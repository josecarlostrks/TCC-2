<?xml version="1.0" encoding="UTF-8"?>
<java-project id="default" name="jext-5.0" revision="jext-5.0">
	<pkg name="/lib/:com.jgoodies.uif_lite.component">
		<class name="/lib/:com.jgoodies.uif_lite.component.Factory" intfc="n" abs="n" inn="n" sloc="21" jdoc="A very light version of the JGoodies &amp;lt;code&amp;gt;UIFactory&amp;lt; code&amp;gt; class. It consists only of static methods to create frequently used components. @author Karsten Lentzsch @version $Revision: 1.2 $">
			<const name="TOOLBAR_BUTTON_MARGIN" access="priv" jdoc="Defines the margin used in toolbar buttons."/>
			<mth name="/lib/:com.jgoodies.uif_lite.component.Factory.createStrippedScrollPane(Component)" access="pub" jdoc="Creates and answers a &amp;lt;code&amp;gt;JScrollPane&amp;lt; code&amp;gt; that has an empty border.">
				<param name="component"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.Factory.createStrippedSplitPane(int, Component, Component, double)" access="pub" jdoc="Creates and returns a &amp;lt;code&amp;gt;JSplitPane&amp;lt; code&amp;gt; that has empty borders. Useful to avoid duplicate decorations, for example if the split pane is contained by other components that already provide a border. @param orientation the split pane&amp;apos;s orientation: horizontal or vertical @param comp1 the top left component @param comp2 the bottom right component @param resizeWeight indicates how to distribute extra space @return a split panes that has an empty border">
				<param name="orientation"/>
				<param name="comp1"/>
				<param name="comp2"/>
				<param name="resizeWeight"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.Factory.createToolBarButton(Action)" access="pub" jdoc="Creates and answers an &amp;lt;code&amp;gt;AbstractButton&amp;lt; code&amp;gt; configured for use in a JToolBar.&amp;lt;p&amp;gt; Superceded by ToolBarButton from the JGoodies UI framework.">
				<comm cntt="button.setHorizontalTextPosition(SwingConstants.CENTER);"/>
				<comm cntt="button.setVerticalTextPosition(SwingConstants.BOTTOM);"/>
				<param name="action"/>
			</mth>
		</class>
		<class name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane" intfc="n" abs="n" inn="n" sloc="63" jdoc="A &amp;lt;code&amp;gt;JSplitPane&amp;lt; code&amp;gt; subclass that can try to remove the divider border. Useful if the splitted components render their own borders. Note that this feature is not supported by all look&amp;amp;feels. Some look&amp;amp;feel implementation will always show a divider border, and conversely, others will never show a divider border. @author Karsten Lentzsch @version $Revision: 1.2 $ @see javax.swing.plaf.basic.BasicSplitPaneUI">
			<comm cntt="Instance Creation"/>
			<comm cntt="Accessing Properties"/>
			<comm cntt="Changing the Divider Border Visibility"/>
			<const name="PROPERTYNAME_DIVIDER_BORDER_VISIBLE" access="pub" jdoc="Holds the name of the bound property that tries to show or hide the split pane&amp;apos;s divider border. @see #isDividerBorderVisible() @see #setDividerBorderVisible(boolean)"/>
			<const name="EMPTY_BORDER" access="priv" jdoc="Holds an empty border that is reused for the split pane itself and the divider."/>
			<field name="dividerBorderVisible" access="priv" jdoc="Determines whether the divider border shall be removed when the UI is updated. @see #isDividerBorderVisible() @see #setDividerBorderVisible(boolean)"/>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.UIFSplitPane()" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;UIFSplitPane&amp;lt; code&amp;gt; configured to arrange the child components side-by-side horizontally with no continuous layout, using two buttons for the components.">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.UIFSplitPane(int)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;UIFSplitPane&amp;lt; code&amp;gt; configured with the specified orientation and no continuous layout. @param newOrientation &amp;lt;code&amp;gt;JSplitPane.HORIZONTAL_SPLIT&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;JSplitPane.VERTICAL_SPLIT&amp;lt; code&amp;gt; @throws IllegalArgumentException if &amp;lt;code&amp;gt;orientation&amp;lt; code&amp;gt; is not one of HORIZONTAL_SPLIT or VERTICAL_SPLIT.">
				<param name="newOrientation"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.UIFSplitPane(int, boolean)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;UIFSplitPane&amp;lt; code&amp;gt; with the specified orientation and redrawing style. @param newOrientation &amp;lt;code&amp;gt;JSplitPane.HORIZONTAL_SPLIT&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;JSplitPane.VERTICAL_SPLIT&amp;lt; code&amp;gt; @param newContinuousLayout a boolean, true for the components to redraw continuously as the divider changes position, false to wait until the divider position stops changing to redraw @throws IllegalArgumentException if &amp;lt;code&amp;gt;orientation&amp;lt; code&amp;gt; is not one of HORIZONTAL_SPLIT or VERTICAL_SPLIT">
				<param name="newOrientation"/>
				<param name="newContinuousLayout"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.UIFSplitPane(int, Component, Component)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;UIFSplitPane&amp;lt; code&amp;gt; with the specified orientation and the given componenents. @param orientation &amp;lt;code&amp;gt;JSplitPane.HORIZONTAL_SPLIT&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;JSplitPane.VERTICAL_SPLIT&amp;lt; code&amp;gt; @param leftComponent the &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; that will appear on the left of a horizontally-split pane, or at the top of a vertically-split pane @param rightComponent the &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; that will appear on the right of a horizontally-split pane, or at the bottom of a vertically-split pane @throws IllegalArgumentException if &amp;lt;code&amp;gt;orientation&amp;lt; code&amp;gt; is not one of: HORIZONTAL_SPLIT or VERTICAL_SPLIT">
				<param name="orientation"/>
				<param name="leftComponent"/>
				<param name="rightComponent"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.UIFSplitPane(int, boolean, Component, Component)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;UIFSplitPane&amp;lt; code&amp;gt; with the specified orientation, redrawing style, and given components. @param orientation &amp;lt;code&amp;gt;JSplitPane.HORIZONTAL_SPLIT&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;JSplitPane.VERTICAL_SPLIT&amp;lt; code&amp;gt; @param continuousLayout a boolean, true for the components to redraw continuously as the divider changes position, false to wait until the divider position stops changing to redraw @param leftComponent the &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; that will appear on the left of a horizontally-split pane, or at the top of a vertically-split pane @param rightComponent the &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; that will appear on the right of a horizontally-split pane, or at the bottom of a vertically-split pane @throws IllegalArgumentException if &amp;lt;code&amp;gt;orientation&amp;lt; code&amp;gt; is not one of HORIZONTAL_SPLIT or VERTICAL_SPLIT">
				<param name="orientation"/>
				<param name="continuousLayout"/>
				<param name="leftComponent"/>
				<param name="rightComponent"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.createStrippedSplitPane(int, Component, Component)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;UIFSplitPane&amp;lt; code&amp;gt;, i.e. a &amp;lt;code&amp;gt;JSplitPane&amp;lt; code&amp;gt; that has no borders. Also disabled the one touch exandable property. @param orientation &amp;lt;code&amp;gt;JSplitPane.HORIZONTAL_SPLIT&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;JSplitPane.VERTICAL_SPLIT&amp;lt; code&amp;gt; @param leftComponent the &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; that will appear on the left of a horizontally-split pane, or at the top of a vertically-split pane @param rightComponent the &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; that will appear on the right of a horizontally-split pane, or at the bottom of a vertically-split pane @throws IllegalArgumentException if &amp;lt;code&amp;gt;orientation&amp;lt; code&amp;gt; is not one of: HORIZONTAL_SPLIT or VERTICAL_SPLIT">
				<param name="orientation"/>
				<param name="leftComponent"/>
				<param name="rightComponent"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.isDividerBorderVisible()" access="pub" jdoc="Checks and answers whether the divider border shall be visible or invisible. Note that this feature is not supported by all look&amp;amp;feels. Some look&amp;amp;feel implementation will always show a divider border, and conversely, others will never show a divider border. @return the desired (but potentially inaccurate) divider border visiblity">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.setDividerBorderVisible(boolean)" access="pub" jdoc="Makes the divider border visible or invisible. Note that this feature is not supported by all look&amp;amp;feels. Some look&amp;amp;feel implementation will always show a divider border, and conversely, others will never show a divider border. @param newVisibility true for visible, false for invisible">
				<param name="newVisibility"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.updateUI()" access="pub" jdoc="Updates the UI and sets an empty divider border. The divider border may be restored by a L&amp;F at UI installation time. And so, we try to reset it each time the UI is changed.">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.component.UIFSplitPane.setEmptyDividerBorder()" access="priv" jdoc="Sets an empty divider border if and only if the UI is an instance of &amp;lt;code&amp;gt;BasicSplitPaneUI&amp;lt; code&amp;gt;.">
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:com.jgoodies.uif_lite.panel">
		<class name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame" intfc="n" abs="n" inn="n" sloc="147" jdoc="A &amp;lt;code&amp;gt;JPanel&amp;lt; code&amp;gt; subclass that has a drop shadow border and that provides a header with icon, title and tool bar.&amp;lt;p&amp;gt; This class can be used to replace the &amp;lt;code&amp;gt;JInternalFrame&amp;lt; code&amp;gt;, for use outside of a &amp;lt;code&amp;gt;JDesktopPane&amp;lt; code&amp;gt;. The &amp;lt;code&amp;gt;SimpleInternalFrame&amp;lt; code&amp;gt; is less flexible but often more usable; it avoids overlapping windows and scales well up to IDE size. Several customers have reported that they and their clients feel much better with both the appearance and the UI feel.&amp;lt;p&amp;gt; The SimpleInternalFrame provides the following bound properties: &amp;lt;i&amp;gt;frameIcon, title, toolBar, content, selected.&amp;lt; i&amp;gt;&amp;lt;p&amp;gt; By default the SimpleInternalFrame is in &amp;lt;i&amp;gt;selected&amp;lt; i&amp;gt; state. If you don&amp;apos;t do anything, multiple simple internal frames will be displayed as selected. @author Karsten Lentzsch @version $Revision: 1.3 $ @see javax.swing.JInternalFrame @see javax.swing.JDesktopPane">
			<comm cntt="Instance Creation"/>
			<comm cntt="Public API"/>
			<comm cntt="public void paintComponent(Graphics g) { super.paintComponent(g); if (!isOpaque()) { return; } Color control = UIManager.getColor(&amp;quot;control&amp;quot;); int width = getWidth(); int height = getHeight(); Graphics2D g2 = (Graphics2D) g; Paint storedPaint = g2.getPaint(); g2.setPaint(new GradientPaint(0, 0, Color.white, width, height, control)); g2.fillRect(0, 0, width, height); g2.setPaint(storedPaint); }"/>
			<comm cntt="Building"/>
			<comm cntt="Helper Code"/>
			<comm cntt="Helper Classes"/>
			<comm cntt="A custom border for the raised header pseudo 3D effect."/>
			<comm cntt="A custom border that has a shadow on the right and lower sides."/>
			<comm cntt="A panel with a horizontal gradient background."/>
			<field name="titleLabel" access="priv" jdoc=""/>
			<field name="gradientPanel" access="priv" jdoc=""/>
			<field name="headerPanel" access="priv" jdoc=""/>
			<field name="isSelected" access="priv" jdoc=""/>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.SimpleInternalFrame(String)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;SimpleInternalFrame&amp;lt; code&amp;gt; with the specified title. @param title the initial title">
				<param name="title"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.SimpleInternalFrame(Icon, String)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;SimpleInternalFrame&amp;lt; code&amp;gt; with the specified icon, and title. @param icon the initial icon @param title the initial title">
				<param name="icon"/>
				<param name="title"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.SimpleInternalFrame(String, JToolBar, JComponent)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;SimpleInternalFrame&amp;lt; code&amp;gt; with the specified title, tool bar, and content panel. @param title the initial title @param bar the initial tool bar @param content the initial content pane">
				<param name="title"/>
				<param name="bar"/>
				<param name="content"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.SimpleInternalFrame(Icon, String, JToolBar, JComponent)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;SimpleInternalFrame&amp;lt; code&amp;gt; with the specified icon, title, tool bar, and content panel. @param icon the initial icon @param title the initial title @param bar the initial tool bar @param content the initial content pane">
				<param name="icon"/>
				<param name="title"/>
				<param name="bar"/>
				<param name="content"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.getFrameIcon()" access="pub" jdoc="Returns the frame&amp;apos;s icon. @return the frame&amp;apos;s icon">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.setFrameIcon(Icon)" access="pub" jdoc="Sets a new frame icon. @param newIcon the icon to be set">
				<param name="newIcon"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.getTitle()" access="pub" jdoc="Returns the frame&amp;apos;s title text. @return String the current title text">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.setTitle(String)" access="pub" jdoc="Sets a new title text. @param newText the title text tp be set">
				<param name="newText"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.getToolBar()" access="pub" jdoc="Returns the current toolbar, null if none has been set before. @return the current toolbar - if any">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.setToolBar(JToolBar)" access="pub" jdoc="Sets a new tool bar in the header. @param newToolBar the tool bar to be set in the header">
				<param name="newToolBar"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.getContent()" access="pub" jdoc="Returns the content - null, if none has been set. @return the current content">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.setContent(Component)" access="pub" jdoc="Sets a new panel content; replaces any existing content, if existing. @param newContent the panel&amp;apos;s new content">
				<param name="newContent"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.isSelected()" access="pub" jdoc="Answers if the panel is currently selected (or in other words active) or not. In the selected state, the header background will be rendered differently. @return boolean a boolean, where true means the frame is selected (currently active) and false means it is not">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.setSelected(boolean)" access="pub" jdoc="This panel draws its title bar differently if it is selected, which may be used to indicate to the user that this panel has the focus, or should get more attention than other simple internal frames. @param newValue a boolean, where true means the frame is selected (currently active) and false means it is not">
				<param name="newValue"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.buildHeader(JLabel, JToolBar)" access="priv" jdoc="Creates and answers the header panel, that consists of: an icon, a title label, a tool bar, and a gradient background. @param label the label to paint the icon and text @param bar the panel&amp;apos;s tool bar @return the panel&amp;apos;s built header area">
				<param name="label"/>
				<param name="bar"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.updateHeader()" access="priv" jdoc="Updates the header.">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.updateUI()" access="pub" jdoc="Updates the UI. In addition to the superclass behavior, we need to update the header component.">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.hasContent()" access="priv" jdoc="Checks and answers if the panel has a content component set. @return true if the panel has a content, false if it&amp;apos;s empty">
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.getTextForeground(boolean)" access="prot" jdoc="Determines and answers the header&amp;apos;s text foreground color. Tries to lookup a special color from the L&amp;amp;F. In case it is absent, it uses the standard internal frame forground. @param selected true to lookup the active color, false for the inactive @return the color of the foreground text">
				<param name="selected"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame.getHeaderBackground()" access="prot" jdoc="Determines and answers the header&amp;apos;s background color. Tries to lookup a special color from the L&amp;amp;F. In case it is absent, it uses the standard internal frame background. @return the color of the header&amp;apos;s background">
			</mth>
		<class name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame$RaisedHeaderBorder" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<const name="INSETS" access="priv" jdoc=""/>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame$RaisedHeaderBorder.getBorderInsets(Component)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame$RaisedHeaderBorder.paintBorder(Component, Graphics, int, int, int, int)" access="pub" jdoc="">
				<param name="c"/>
				<param name="g"/>
				<param name="x"/>
				<param name="y"/>
				<param name="w"/>
				<param name="h"/>
			</mth>
		</class>
		<class name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame$ShadowBorder" intfc="n" abs="n" inn="y" sloc="37" jdoc="">
			<const name="INSETS" access="priv" jdoc=""/>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame$ShadowBorder.getBorderInsets(Component)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame$ShadowBorder.paintBorder(Component, Graphics, int, int, int, int)" access="pub" jdoc="">
				<comm cntt="Shadow line 1"/>
				<comm cntt="Shadow line2"/>
				<param name="c"/>
				<param name="g"/>
				<param name="x"/>
				<param name="y"/>
				<param name="w"/>
				<param name="h"/>
			</mth>
		</class>
		<class name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame$GradientPanel" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame$GradientPanel.GradientPanel(LayoutManager, Color)" access="priv" jdoc="">
				<param name="lm"/>
				<param name="background"/>
			</mth>
			<mth name="/lib/:com.jgoodies.uif_lite.panel.SimpleInternalFrame$GradientPanel.paintComponent(Graphics)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/lib/:com.microstar.xml">
		<class name="/lib/:com.microstar.xml.HandlerBase" intfc="n" abs="n" inn="n" sloc="56" jdoc="Convenience base class for AElfred handlers. &amp;lt;p&amp;gt;This base class implements the XmlHandler interface with (mostly empty) default handlers. You are not required to use this, but if you need to handle only a few events, you might find it convenient to extend this class rather than implementing the entire interface. This example overrides only the &amp;lt;code&amp;gt;charData&amp;lt; code&amp;gt; method, using the defaults for the others: &amp;lt;pre&amp;gt; import com.microstar.xml.HandlerBase; public class MyHandler extends HandlerBase { public void charData (char ch[], int start, int length) { System.out.println(&amp;quot;Data: &amp;quot; + new String (ch, start, length)); } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;This class is optional, but if you use it, you must also include the &amp;lt;code&amp;gt;XmlException&amp;lt; code&amp;gt; class. &amp;lt;p&amp;gt;Do not extend this if you are using SAX; extend &amp;lt;code&amp;gt;org.xml.sax.HandlerBase&amp;lt; code&amp;gt; instead. @author Copyright (c) 1998 by Microstar Software Ltd. @author written by David Megginson &amp;lt;dmeggins@microstar.com&amp;gt; @version 1.1 @see XmlHandler @see XmlException @see org.xml.sax.HandlerBase">
			<mth name="/lib/:com.microstar.xml.HandlerBase.startDocument()" access="pub" jdoc="Handle the start of the document. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#startDocument @exception java.lang.Exception Derived methods may throw exceptions.">
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.endDocument()" access="pub" jdoc="Handle the end of the document. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#endDocument @exception java.lang.Exception Derived methods may throw exceptions.">
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.resolveEntity(String, String)" access="pub" jdoc="Resolve an external entity. &amp;lt;p&amp;gt;The default implementation simply returns the supplied system identifier. @see com.microstar.xml.XmlHandler#resolveEntity @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.startExternalEntity(String)" access="pub" jdoc="Handle the start of an external entity. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#startExternalEntity @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.endExternalEntity(String)" access="pub" jdoc="Handle the end of an external entity. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#endExternalEntity @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.doctypeDecl(String, String, String)" access="pub" jdoc="Handle a document type declaration. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#doctypeDecl @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.attribute(String, String, boolean)" access="pub" jdoc="Handle an attribute assignment. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#attribute @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.startElement(String)" access="pub" jdoc="Handle the start of an element. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#startElement @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="elname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.endElement(String)" access="pub" jdoc="Handle the end of an element. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#endElement @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="elname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.charData(char, int, int)" access="pub" jdoc="Handle character data. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#charData @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.ignorableWhitespace(char, int, int)" access="pub" jdoc="Handle ignorable whitespace. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#ignorableWhitespace @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.processingInstruction(String, String)" access="pub" jdoc="Handle a processing instruction. &amp;lt;p&amp;gt;The default implementation does nothing. @see com.microstar.xml.XmlHandler#processingInstruction @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="target"/>
				<param name="data"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.HandlerBase.error(String, String, int, int)" access="pub" jdoc="Throw an exception for a fatal error. &amp;lt;p&amp;gt;The default implementation throws &amp;lt;code&amp;gt;XmlException&amp;lt; code&amp;gt;. @see com.microstar.xml.XmlHandler#error @exception com.microstar.xml.XmlException A specific parsing error. @exception java.lang.Exception Derived methods may throw exceptions.">
				<param name="message"/>
				<param name="systemId"/>
				<param name="line"/>
				<param name="column"/>
			</mth>
		</class>
		<class name="/lib/:com.microstar.xml.XmlHandler" intfc="y" abs="n" inn="n" sloc="28" jdoc="XML Processing Interface. &amp;lt;p&amp;gt;Whenever you parse an XML document, you must provide an object from a class that implements this interface to receive the parsing events. &amp;lt;p&amp;gt;If you do not want to implement this entire interface, you can extend the &amp;lt;code&amp;gt;HandlerBase&amp;lt; code&amp;gt; convenience class and then implement only what you need. &amp;lt;p&amp;gt;If you are using SAX, you should implement the SAX handler interfaces rather than this one. @author Copyright (c) 1997, 1998 by Microstar Software Ltd. @author written by David Megginson &amp;lt;dmeggins@microstar.com&amp;gt; @version 1.1 @see XmlParser @see HandlerBase @see org.xml.sax.EntityHandler @see org.xml.sax.DocumentHandler @see org.xml.sax.ErrorHandler">
			<mth name="/lib/:com.microstar.xml.XmlHandler.startDocument()" access="pub" jdoc="Start the document. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method just before it attempts to read the first entity (the root of the document). It is guaranteed that this will be the first method called. @exception java.lang.Exception The handler may throw any exception. @see #endDocument">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.endDocument()" access="pub" jdoc="End the document. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method once, when it has finished parsing the XML document. It is guaranteed that this will be the last method called. @exception java.lang.Exception The handler may throw any exception. @see #startDocument">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.resolveEntity(String, String)" access="pub" jdoc="Resolve an External Entity. &amp;lt;p&amp;gt;Give the handler a chance to redirect external entities to different URIs. &amp;AElig;lfred will call this method for the top-level document entity, for external text (XML) entities, and the external DTD subset (if any). @param publicId The public identifier, or null if none was supplied. @param systemId The system identifier. @return The replacement system identifier, or null to use the default. @exception java.lang.Exception The handler may throw any exception. @see #startExternalEntity @see #endExternalEntity">
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.startExternalEntity(String)" access="pub" jdoc="Begin an external entity. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method at the beginning of each external entity, including the top-level document entity and the external DTD subset (if any). &amp;lt;p&amp;gt;If necessary, you can use this method to track the location of the current entity so that you can resolve relative URIs correctly. @param systemId The URI of the external entity that is starting. @exception java.lang.Exception The handler may throw any exception. @see #endExternalEntity @see #resolveEntity">
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.endExternalEntity(String)" access="pub" jdoc="End an external entity. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method at the end of each external entity, including the top-level document entity and the external DTD subset. &amp;lt;p&amp;gt;If necessary, you can use this method to track the location of the current entity so that you can resolve relative URIs correctly. @param systemId The URI of the external entity that is ending. @exception java.lang.Exception The handler may throw any exception. @see #startExternalEntity @see #resolveEntity">
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.doctypeDecl(String, String, String)" access="pub" jdoc="Document type declaration. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method when or if it encounters the document type (DOCTYPE) declaration. &amp;lt;p&amp;gt;Please note that the public and system identifiers will not always be a reliable indication of the DTD in use. @param name The document type name. @param publicId The public identifier, or null if unspecified. @param systemId The system identifier, or null if unspecified. @exception java.lang.Exception The handler may throw any exception.">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.attribute(String, String, boolean)" access="pub" jdoc="Attribute. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method once for each attribute (specified or defaulted) before reporting a startElement event. It is up to your handler to collect the attributes, if necessary. &amp;lt;p&amp;gt;You may use XmlParser.getAttributeType() to find the attribute&amp;apos;s declared type. @param name The name of the attribute. @param type The type of the attribute (see below). @param value The value of the attribute, or null if the attribute is &amp;lt;code&amp;gt;#IMPLIED&amp;lt; code&amp;gt;. @param isSpecified True if the value was specified, false if it was defaulted from the DTD. @exception java.lang.Exception The handler may throw any exception. @see #startElement @see XmlParser#declaredAttributes @see XmlParser#getAttributeType @see XmlParser#getAttributeDefaultValue">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.startElement(String)" access="pub" jdoc="Start an element. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method at the beginning of each element. By the time this is called, all of the attributes for the element will already have been reported using the &amp;lt;code&amp;gt;attribute&amp;lt; code&amp;gt; method. @param elname The element type name. @exception java.lang.Exception The handler may throw any exception. @see #attribute @see #endElement @see XmlParser#declaredElements @see XmlParser#getElementContentType">
				<param name="elname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.endElement(String)" access="pub" jdoc="End an element. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method at the end of each element (including EMPTY elements). @param elname The element type name. @exception java.lang.Exception The handler may throw any exception. @see #startElement @see XmlParser#declaredElements @see XmlParser#getElementContentType">
				<param name="elname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.charData(char, int, int)" access="pub" jdoc="Character data. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method once for each chunk of character data found in the contents of elements. Note that the parser may break up a long sequence of characters into smaller chunks and call this method once for each chunk. &amp;lt;p&amp;gt;Do &amp;lt;em&amp;gt;not&amp;lt; em&amp;gt; attempt to read more than &amp;lt;var&amp;gt;length&amp;lt; var&amp;gt; characters from the array, or to read before the &amp;lt;var&amp;gt;start&amp;lt; var&amp;gt; position. @param ch The character data. @param start The starting position in the array. @param length The number of characters available. @exception java.lang.Exception The handler may throw any exception.">
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.ignorableWhitespace(char, int, int)" access="pub" jdoc="Ignorable whitespace. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method once for each sequence of ignorable whitespace in element content (never in mixed content). &amp;lt;p&amp;gt;For details, see section 2.10 of the XML 1.0 recommendation. &amp;lt;p&amp;gt;Do &amp;lt;em&amp;gt;not&amp;lt; em&amp;gt; attempt to read more than &amp;lt;var&amp;gt;length&amp;lt; var&amp;gt; characters from the array or to read before the &amp;lt;var&amp;gt;start&amp;lt; var&amp;gt; position. @param ch The literal whitespace characters. @param start The starting position in the array. @param length The number of whitespace characters available. @exception java.lang.Exception The handler may throw any exception.">
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.processingInstruction(String, String)" access="pub" jdoc="Processing instruction. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method once for each processing instruction. Note that processing instructions may appear outside of the top-level element. The @param target The target (the name at the start of the PI). @param data The data, if any (the rest of the PI). @exception java.lang.Exception The handler may throw any exception.">
				<param name="target"/>
				<param name="data"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlHandler.error(String, String, int, int)" access="pub" jdoc="Fatal XML parsing error. &amp;lt;p&amp;gt;&amp;AElig;lfred will call this method whenever it encounters a serious error. The parser will attempt to continue past this point so that you can find more possible error points, but if this method is called you should assume that the document is corrupt and you should not try to use its contents. &amp;lt;p&amp;gt;Note that you can use the &amp;lt;code&amp;gt;XmlException&amp;lt; code&amp;gt; class to encapsulate all of the information provided, though the use of the class is not mandatory. @param message The error message. @param systemId The system identifier of the entity that contains the error. @param line The approximate line number of the error. @param column The approximate column number of the error. @exception java.lang.Exception The handler may throw any exception. @see XmlException">
				<param name="message"/>
				<param name="systemId"/>
				<param name="line"/>
				<param name="column"/>
			</mth>
		</class>
		<class name="/lib/:com.microstar.xml.XmlException" intfc="n" abs="n" inn="n" sloc="30" jdoc="Convenience exception class for reporting XML parsing errors. &amp;lt;p&amp;gt;This is an exception class that you can use to encapsulate all of the information from &amp;AElig;lfred&amp;apos;s &amp;lt;code&amp;gt;error&amp;lt; code&amp;gt; callback. This is not necessary for routine use of &amp;AElig;lfred, but it is used by the optional &amp;lt;code&amp;gt;HandlerBase&amp;lt; code&amp;gt; class. &amp;lt;p&amp;gt;Note that the core &amp;AElig;lfred classes do &amp;lt;em&amp;gt;not&amp;lt; em&amp;gt; use this exception. @author Copyright (c) 1998 by Microstar Software Ltd. @author written by David Megginson &amp;lt;dmeggins@microstar.com&amp;gt; @version 1.1 @see XmlHandler#error @see HandlerBase">
			<field name="message" access="priv" jdoc=""/>
			<field name="systemId" access="priv" jdoc=""/>
			<field name="line" access="priv" jdoc=""/>
			<field name="column" access="priv" jdoc=""/>
			<mth name="/lib/:com.microstar.xml.XmlException.XmlException(String, String, int, int)" access="pub" jdoc="Construct a new XML parsing exception. @param message The error message from the parser. @param systemId The URI of the entity containing the error. @param line The line number where the error appeared. @param column The column number where the error appeared.">
				<param name="message"/>
				<param name="systemId"/>
				<param name="line"/>
				<param name="column"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlException.getMessage()" access="pub" jdoc="Get the error message from the parser. @return A string describing the error.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlException.getSystemId()" access="pub" jdoc="Get the URI of the entity containing the error. @return The URI as a string.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlException.getLine()" access="pub" jdoc="Get the line number containing the error. @return The line number as an integer.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlException.getColumn()" access="pub" jdoc="Get the column number containing the error. @return The column number as an integer.">
			</mth>
		</class>
		<class name="/lib/:com.microstar.xml.XmlParser" intfc="n" abs="n" inn="n" sloc="2373" jdoc="Parse XML documents and return parse events through call-backs. &amp;lt;p&amp;gt;You need to define a class implementing the &amp;lt;code&amp;gt;XmlHandler&amp;lt; code&amp;gt; interface: an object belonging to this class will receive the callbacks for the events. (As an alternative to implementing the full XmlHandler interface, you can simply extend the &amp;lt;code&amp;gt;HandlerBase&amp;lt; code&amp;gt; convenience class.) &amp;lt;p&amp;gt;Usage (assuming that &amp;lt;code&amp;gt;MyHandler&amp;lt; code&amp;gt; is your implementation of the &amp;lt;code&amp;gt;XmlHandler&amp;lt; code&amp;gt; interface): &amp;lt;pre&amp;gt; XmlHandler handler = new MyHandler(); XmlParser parser = new XmlParser(); parser.setHandler(handler); try { parser.parse(&amp;quot;http: www.host.com doc.xml&amp;quot;, null); } catch (Exception e) { [do something interesting] } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;Alternatively, you can use the standard SAX interfaces with the &amp;lt;code&amp;gt;SAXDriver&amp;lt; code&amp;gt; class as your entry point. @author Copyright (c) 1997, 1998 by Microstar Software Ltd. @author Written by David Megginson &amp;lt;dmeggins@microstar.com&amp;gt; @version 1.1 @see XmlHandler @see HandlerBase @see SAXDriver">
			<comm cntt=""/>
			<comm cntt="Use special cheats that speed up the code (currently about 50%),"/>
			<comm cntt="but may cause problems with future maintenance and add to the"/>
			<comm cntt="class file size (about 500 bytes)."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Constructors."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Constants."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Constants for element content type."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Constants for the entity type."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Constants for attribute type."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="When the class is loaded, populate the hash table of"/>
			<comm cntt="attribute types."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Constants for supported encodings."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Constants for attribute default value."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Constants for input."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Flags for reading literals."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Flags for parsing context."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Error reporting."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Major syntactic productions."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="High-level reading and scanning methods."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Utility routines."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="XML query routines."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Elements"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Attributes"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Entities"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Notations."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Location."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="High-level I O."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Low-level I O."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Local Variables."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="The current XML handler interface."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="I O information."/>
			<comm cntt=""/>
			<comm cntt="current reader"/>
			<comm cntt="current input stream"/>
			<comm cntt="current line number"/>
			<comm cntt="current column number"/>
			<comm cntt="type of input source"/>
			<comm cntt="stack of input soruces"/>
			<comm cntt="current external entity"/>
			<comm cntt="current character encoding."/>
			<comm cntt="how many bytes read from current source."/>
			<comm cntt=""/>
			<comm cntt="Maintain a count of errors."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Buffers for decoded but unparsed character input."/>
			<comm cntt=""/>
			<comm cntt="overflow character from last data chunk."/>
			<comm cntt=""/>
			<comm cntt="Buffer for undecoded raw byte input."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Buffer for parsed character data."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Buffer for parsed names."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Hashtables for DTD information on elements, entities, and notations."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Element type currently in force."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Base external identifiers for resolution."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Stack of entity names, to help detect recursion."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Are we in a context where PEs are allowed?"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Symbol table, for internalising names."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Hash table of attributes found in current start tag."/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="Utility flag: have we noticed a CR while reading the last"/>
			<comm cntt="data chunk? If so, we will have to go back and normalise"/>
			<comm cntt="CR LF."/>
			<comm cntt=""/>
			<const name="USE_CHEATS" access="priv" jdoc=""/>
			<const name="CONTENT_UNDECLARED" access="pub" jdoc="Constant: an element has not been declared. @see #getElementContentType"/>
			<const name="CONTENT_ANY" access="pub" jdoc="Constant: the element has a content model of ANY. @see #getElementContentType"/>
			<const name="CONTENT_EMPTY" access="pub" jdoc="Constant: the element has declared content of EMPTY. @see #getElementContentType"/>
			<const name="CONTENT_MIXED" access="pub" jdoc="Constant: the element has mixed content. @see #getElementContentType"/>
			<const name="CONTENT_ELEMENTS" access="pub" jdoc="Constant: the element has element content. @see #getElementContentType"/>
			<const name="ENTITY_UNDECLARED" access="pub" jdoc="Constant: the entity has not been declared. @see #getEntityType"/>
			<const name="ENTITY_INTERNAL" access="pub" jdoc="Constant: the entity is internal. @see #getEntityType"/>
			<const name="ENTITY_NDATA" access="pub" jdoc="Constant: the entity is external, non-XML data. @see #getEntityType"/>
			<const name="ENTITY_TEXT" access="pub" jdoc="Constant: the entity is external XML data. @see #getEntityType"/>
			<const name="ATTRIBUTE_UNDECLARED" access="pub" jdoc="Constant: the attribute has not been declared for this element type. @see #getAttributeType"/>
			<const name="ATTRIBUTE_CDATA" access="pub" jdoc="Constant: the attribute value is a string value. @see #getAttributeType"/>
			<const name="ATTRIBUTE_ID" access="pub" jdoc="Constant: the attribute value is a unique identifier. @see #getAttributeType"/>
			<const name="ATTRIBUTE_IDREF" access="pub" jdoc="Constant: the attribute value is a reference to a unique identifier. @see #getAttributeType"/>
			<const name="ATTRIBUTE_IDREFS" access="pub" jdoc="Constant: the attribute value is a list of ID references. @see #getAttributeType"/>
			<const name="ATTRIBUTE_ENTITY" access="pub" jdoc="Constant: the attribute value is the name of an entity. @see #getAttributeType"/>
			<const name="ATTRIBUTE_ENTITIES" access="pub" jdoc="Constant: the attribute value is a list of entity names. @see #getAttributeType"/>
			<const name="ATTRIBUTE_NMTOKEN" access="pub" jdoc="Constant: the attribute value is a name token. @see #getAttributeType"/>
			<const name="ATTRIBUTE_NMTOKENS" access="pub" jdoc="Constant: the attribute value is a list of name tokens. @see #getAttributeType"/>
			<const name="ATTRIBUTE_ENUMERATED" access="pub" jdoc="Constant: the attribute value is a token from an enumeration. @see #getAttributeType"/>
			<const name="ATTRIBUTE_NOTATION" access="pub" jdoc="Constant: the attribute is the name of a notation. @see #getAttributeType"/>
			<field name="attributeTypeHash" access="priv" jdoc="Hash table of attribute types."/>
			<const name="ENCODING_UTF_8" access="priv" jdoc=""/>
			<const name="ENCODING_ISO_8859_1" access="priv" jdoc=""/>
			<const name="ENCODING_UCS_2_12" access="priv" jdoc=""/>
			<const name="ENCODING_UCS_2_21" access="priv" jdoc=""/>
			<const name="ENCODING_UCS_4_1234" access="priv" jdoc=""/>
			<const name="ENCODING_UCS_4_4321" access="priv" jdoc=""/>
			<const name="ENCODING_UCS_4_2143" access="priv" jdoc=""/>
			<const name="ENCODING_UCS_4_3412" access="priv" jdoc=""/>
			<const name="ATTRIBUTE_DEFAULT_UNDECLARED" access="pub" jdoc="Constant: the attribute is not declared. @see #getAttributeDefaultValueType"/>
			<const name="ATTRIBUTE_DEFAULT_SPECIFIED" access="pub" jdoc="Constant: the attribute has a literal default value specified. @see #getAttributeDefaultValueType @see #getAttributeDefaultValue"/>
			<const name="ATTRIBUTE_DEFAULT_IMPLIED" access="pub" jdoc="Constant: the attribute was declared #IMPLIED. @see #getAttributeDefaultValueType"/>
			<const name="ATTRIBUTE_DEFAULT_REQUIRED" access="pub" jdoc="Constant: the attribute was declared #REQUIRED. @see #getAttributeDefaultValueType"/>
			<const name="ATTRIBUTE_DEFAULT_FIXED" access="pub" jdoc="Constant: the attribute was declared #FIXED. @see #getAttributeDefaultValueType @see #getAttributeDefaultValue"/>
			<const name="INPUT_NONE" access="priv" jdoc=""/>
			<const name="INPUT_INTERNAL" access="priv" jdoc=""/>
			<const name="INPUT_EXTERNAL" access="priv" jdoc=""/>
			<const name="INPUT_STREAM" access="priv" jdoc=""/>
			<const name="INPUT_BUFFER" access="priv" jdoc=""/>
			<const name="INPUT_READER" access="priv" jdoc=""/>
			<const name="LIT_CHAR_REF" access="priv" jdoc=""/>
			<const name="LIT_ENTITY_REF" access="priv" jdoc=""/>
			<const name="LIT_PE_REF" access="priv" jdoc=""/>
			<const name="LIT_NORMALIZE" access="priv" jdoc=""/>
			<const name="CONTEXT_NONE" access="priv" jdoc=""/>
			<const name="CONTEXT_DTD" access="priv" jdoc=""/>
			<const name="CONTEXT_ENTITYVALUE" access="priv" jdoc=""/>
			<const name="CONTEXT_ATTRIBUTEVALUE" access="priv" jdoc=""/>
			<field name="handler" access="pub" jdoc=""/>
			<field name="reader" access="priv" jdoc=""/>
			<field name="is" access="priv" jdoc=""/>
			<field name="line" access="priv" jdoc=""/>
			<field name="column" access="priv" jdoc=""/>
			<field name="sourceType" access="priv" jdoc=""/>
			<field name="inputStack" access="priv" jdoc=""/>
			<field name="externalEntity" access="priv" jdoc=""/>
			<field name="encoding" access="priv" jdoc=""/>
			<field name="currentByteCount" access="priv" jdoc=""/>
			<field name="errorCount" access="priv" jdoc=""/>
			<const name="READ_BUFFER_MAX" access="priv" jdoc=""/>
			<field name="readBuffer" access="priv" jdoc=""/>
			<field name="readBufferPos" access="priv" jdoc=""/>
			<field name="readBufferLength" access="priv" jdoc=""/>
			<field name="readBufferOverflow" access="priv" jdoc=""/>
			<field name="rawReadBuffer" access="priv" jdoc=""/>
			<field name="DATA_BUFFER_INITIAL" access="priv" jdoc=""/>
			<field name="dataBuffer" access="priv" jdoc=""/>
			<field name="dataBufferPos" access="priv" jdoc=""/>
			<field name="NAME_BUFFER_INITIAL" access="priv" jdoc=""/>
			<field name="nameBuffer" access="priv" jdoc=""/>
			<field name="nameBufferPos" access="priv" jdoc=""/>
			<field name="elementInfo" access="priv" jdoc=""/>
			<field name="entityInfo" access="priv" jdoc=""/>
			<field name="notationInfo" access="priv" jdoc=""/>
			<field name="currentElement" access="priv" jdoc=""/>
			<field name="currentElementContent" access="priv" jdoc=""/>
			<field name="basePublicId" access="priv" jdoc=""/>
			<field name="baseURI" access="priv" jdoc=""/>
			<field name="baseEncoding" access="priv" jdoc=""/>
			<field name="baseReader" access="priv" jdoc=""/>
			<field name="baseInputStream" access="priv" jdoc=""/>
			<field name="baseInputBuffer" access="priv" jdoc=""/>
			<field name="baseInputBufferStart" access="priv" jdoc=""/>
			<field name="baseInputBufferLength" access="priv" jdoc=""/>
			<field name="entityStack" access="priv" jdoc=""/>
			<field name="context" access="priv" jdoc=""/>
			<field name="symbolTable" access="priv" jdoc=""/>
			<const name="SYMBOL_TABLE_LENGTH" access="priv" jdoc=""/>
			<field name="tagAttributes" access="priv" jdoc=""/>
			<field name="tagAttributePos" access="priv" jdoc=""/>
			<field name="sawCR" access="priv" jdoc=""/>
			<mth name="/lib/:com.microstar.xml.XmlParser.XmlParser()" access="pub" jdoc="Construct a new parser with no associated handler. @see #setHandler @see #parse">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.setHandler(XmlHandler)" access="pub" jdoc="Set the handler that will receive parsing events. @param handler The handler to receive callback events. @see #parse @see XmlHandler">
				<param name="handler"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parse(String, String, String)" access="pub" jdoc="Parse an XML document from a URI. &amp;lt;p&amp;gt;You may parse a document more than once, but only one thread may call this method for an object at one time. @param systemId The URI of the document. @param publicId The public identifier of the document, or null. @param encoding The suggested encoding, or null if unknown. @exception java.lang.Exception Any exception thrown by your own handlers, or any derivation of java.io.IOException thrown by the parser itself.">
				<param name="systemId"/>
				<param name="publicId"/>
				<param name="encoding"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parse(String, String, InputStream, String)" access="pub" jdoc="Parse an XML document from a byte stream. &amp;lt;p&amp;gt;The URI that you supply will become the base URI for resolving relative links, but &amp;AElig;lfred will actually read the document from the supplied input stream. &amp;lt;p&amp;gt;You may parse a document more than once, but only one thread may call this method for an object at one time. @param systemId The base URI of the document, or null if not known. @param publicId The public identifier of the document, or null if not known. @param stream A byte input stream. @param encoding The suggested encoding, or null if unknown. @exception java.lang.Exception Any exception thrown by your own handlers, or any derivation of java.io.IOException thrown by the parser itself.">
				<param name="systemId"/>
				<param name="publicId"/>
				<param name="stream"/>
				<param name="encoding"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parse(String, String, Reader)" access="pub" jdoc="Parse an XML document from a character stream. &amp;lt;p&amp;gt;The URI that you supply will become the base URI for resolving relative links, but &amp;AElig;lfred will actually read the document from the supplied input stream. &amp;lt;p&amp;gt;You may parse a document more than once, but only one thread may call this method for an object at one time. @param systemId The base URI of the document, or null if not known. @param publicId The public identifier of the document, or null if not known. @param reader A character stream. @exception java.lang.Exception Any exception thrown by your own handlers, or any derivation of java.io.IOException thrown by the parser itself.">
				<param name="systemId"/>
				<param name="publicId"/>
				<param name="reader"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.doParse(String, String, Reader, InputStream, String)" access="priv" jdoc="">
				<comm cntt="Set the default entities here."/>
				<param name="systemId"/>
				<param name="publicId"/>
				<param name="reader"/>
				<param name="stream"/>
				<param name="encoding"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.error(String, String, String)" access="pub" jdoc="Report an error. @param message The error message. @param textFound The text that caused the error (or null). @see XmlHandler#error @see #line">
				<param name="message"/>
				<param name="textFound"/>
				<param name="textExpected"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.error(String, char, String)" access="pub" jdoc="Report a serious error. @param message The error message. @param textFound The text that caused the error (or null).">
				<param name="message"/>
				<param name="textFound"/>
				<param name="textExpected"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseDocument()" access="pub" jdoc="Parse an XML document. &amp;lt;pre&amp;gt; [1] document ::= prolog element Misc &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;This is the top-level parsing function for a single XML document. As a minimum, a well-formed document must have a document element, and a valid document must have a prolog as well.">
				<comm cntt="skip all white, PIs, and comments"/>
				<comm cntt="if this doesn&amp;apos;t throw an exception..."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseComment()" access="pub" jdoc="Skip a comment. &amp;lt;pre&amp;gt; [18] Comment ::= &amp;apos;&amp;lt;!--&amp;apos; ((Char - &amp;apos;-&amp;apos;) | (&amp;apos;-&amp;apos; (Char - &amp;apos;-&amp;apos;))) &amp;quot;--&amp;gt;&amp;quot; &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;(The &amp;lt;code&amp;gt;&amp;lt;!--&amp;lt; code&amp;gt; has already been read.)">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parsePI()" access="pub" jdoc="Parse a processing instruction and do a call-back. &amp;lt;pre&amp;gt; [19] PI ::= &amp;apos;&amp;lt;?&amp;apos; Name (S (Char - (Char &amp;apos;?&amp;gt;&amp;apos; Char )))? &amp;apos;?&amp;gt;&amp;apos; &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;(The &amp;lt;code&amp;gt;&amp;lt;?&amp;lt; code&amp;gt; has already been read.) &amp;lt;p&amp;gt;An XML processing instruction &amp;lt;em&amp;gt;must&amp;lt; em&amp;gt; begin with a Name, which is the instruction&amp;apos;s target.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseCDSect()" access="pub" jdoc="Parse a CDATA marked section. &amp;lt;pre&amp;gt; [20] CDSect ::= CDStart CData CDEnd [21] CDStart ::= &amp;apos;&amp;lt;![CDATA[&amp;apos; [22] CData ::= (Char - (Char &amp;apos;]]&amp;gt;&amp;apos; Char )) [23] CDEnd ::= &amp;apos;]]&amp;gt;&amp;apos; &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;(The &amp;apos;&amp;lt;![CDATA[&amp;apos; has already been read.) &amp;lt;p&amp;gt;Note that this just appends characters to the dataBuffer, without actually generating an event.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseProlog()" access="pub" jdoc="Parse the prolog of an XML document. &amp;lt;pre&amp;gt; [24] prolog ::= XMLDecl? Misc (Doctypedecl Misc )? &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;There are a couple of tricks here. First, it is necessary to declare the XML default attributes after the DTD (if present) has been read. Second, it is not possible to expand general references in attribute value literals until after the entire DTD (if present) has been parsed. &amp;lt;p&amp;gt;We do not look for the XML declaration here, because it is handled by pushURL(). @see pushURL">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseXMLDecl(boolean)" access="pub" jdoc="Parse the XML declaration. &amp;lt;pre&amp;gt; [25] XMLDecl ::= &amp;apos;&amp;lt;?xml&amp;apos; VersionInfo EncodingDecl? SDDecl? S? &amp;apos;?&amp;gt;&amp;apos; [26] VersionInfo ::= S &amp;apos;version&amp;apos; Eq (&amp;apos;&amp;quot;1.0&amp;quot;&amp;apos; | &amp;quot;&amp;apos;1.0&amp;apos;&amp;quot;) [33] SDDecl ::= S &amp;apos;standalone&amp;apos; Eq &amp;quot;&amp;apos;&amp;quot; (&amp;apos;yes&amp;apos; | &amp;apos;no&amp;apos;) &amp;quot;&amp;apos;&amp;quot; | S &amp;apos;standalone&amp;apos; Eq &amp;apos;&amp;quot;&amp;apos; (&amp;quot;yes&amp;quot; | &amp;quot;no&amp;quot;) &amp;apos;&amp;quot;&amp;apos; [78] EncodingDecl ::= S &amp;apos;encoding&amp;apos; Eq QEncoding &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;([80] to [82] are also significant.) &amp;lt;p&amp;gt;(The &amp;lt;code&amp;gt;&amp;lt;?xml&amp;lt; code&amp;gt; and whitespace have already been read.) &amp;lt;p&amp;gt;TODO: validate value of standalone. @see #parseTextDecl @see #checkEncoding">
				<comm cntt="Read the version."/>
				<comm cntt="Try reading an encoding declaration."/>
				<comm cntt="Try reading a standalone declaration"/>
				<param name="ignoreEncoding"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseTextDecl(boolean)" access="pub" jdoc="Parse the Encoding PI. &amp;lt;pre&amp;gt; [78] EncodingDecl ::= S &amp;apos;encoding&amp;apos; Eq QEncoding [79] EncodingPI ::= &amp;apos;&amp;lt;?xml&amp;apos; S &amp;apos;encoding&amp;apos; Eq QEncoding S? &amp;apos;?&amp;gt;&amp;apos; [80] QEncoding ::= &amp;apos;&amp;quot;&amp;apos; Encoding &amp;apos;&amp;quot;&amp;apos; | &amp;quot;&amp;apos;&amp;quot; Encoding &amp;quot;&amp;apos;&amp;quot; [81] Encoding ::= LatinName [82] LatinName ::= [A-Za-z] ([A-Za-z0-9._] | &amp;apos;-&amp;apos;) &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;(The &amp;lt;code&amp;gt;&amp;lt;?xml&amp;lt; code&amp;gt;&amp;apos; and whitespace have already been read.) @see #parseXMLDecl @see #checkEncoding">
				<comm cntt="Read an optional version."/>
				<comm cntt="Read the encoding."/>
				<param name="ignoreEncoding"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.checkEncoding(String, boolean)" access="pub" jdoc="Check that the encoding specified makes sense. &amp;lt;p&amp;gt;Compare what the author has specified in the XML declaration or encoding PI with what we have detected. &amp;lt;p&amp;gt;This is also important for distinguishing among the various 7- and 8-bit encodings, such as ISO-LATIN-1 (I cannot autodetect those). @param encodingName The name of the encoding specified by the user. @see #parseXMLDecl @see #parseTextDecl">
				<comm cntt="8-bit encodings"/>
				<comm cntt="16-bit encodings"/>
				<comm cntt="32-bit encodings"/>
				<param name="encodingName"/>
				<param name="ignoreEncoding"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseMisc()" access="pub" jdoc="Parse miscellaneous markup outside the document element and DOCTYPE declaration. &amp;lt;pre&amp;gt; [27] Misc ::= Comment | PI | S &amp;lt; pre&amp;gt;">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseDoctypedecl()" access="pub" jdoc="Parse a document type declaration. &amp;lt;pre&amp;gt; [28] doctypedecl ::= &amp;apos;&amp;lt;!DOCTYPE&amp;apos; S Name (S ExternalID)? S? (&amp;apos;[&amp;apos; %markupdecl &amp;apos;]&amp;apos; S?)? &amp;apos;&amp;gt;&amp;apos; &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;(The &amp;lt;code&amp;gt;&amp;lt;!DOCTYPE&amp;lt; code&amp;gt; has already been read.)">
				<comm cntt="Read the document type name."/>
				<comm cntt="Read the ExternalIDs."/>
				<comm cntt="Look for a declaration subset."/>
				<comm cntt="loop until the subset ends"/>
				<comm cntt="end of subset"/>
				<comm cntt="Read the external subset, if any"/>
				<comm cntt="Loop until we end up back at &amp;apos;&amp;gt;&amp;apos;"/>
				<comm cntt="No external subset."/>
				<comm cntt="Expand general entities in"/>
				<comm cntt="default values of attributes."/>
				<comm cntt="(Do this after the doctypeDecl"/>
				<comm cntt="event!)."/>
				<comm cntt="expandAttributeDefaultValues();"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseMarkupdecl()" access="pub" jdoc="Parse a markup declaration in the internal or external DTD subset. &amp;lt;pre&amp;gt; [29] markupdecl ::= ( %elementdecl | %AttlistDecl | %EntityDecl | %NotationDecl | %PI | %S | %Comment | InternalPERef ) [30] InternalPERef ::= PEReference [31] extSubset ::= (%markupdecl | %conditionalSect) &amp;lt; pre&amp;gt;">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseElement()" access="pub" jdoc="Parse an element, with its tags. &amp;lt;pre&amp;gt; [33] STag ::= &amp;apos;&amp;lt;&amp;apos; Name (S Attribute) S? &amp;apos;&amp;gt;&amp;apos; [WFC: unique Att spec] [38] element ::= EmptyElement | STag content ETag [39] EmptyElement ::= &amp;apos;&amp;lt;&amp;apos; Name (S Attribute) S? &amp;apos; &amp;gt;&amp;apos; [WFC: unique Att spec] &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;(The &amp;apos;&amp;lt;&amp;apos; has already been read.) &amp;lt;p&amp;gt;NOTE: this method actually chains onto parseContent(), if necessary, and parseContent() will take care of calling parseETag().">
				<comm cntt="This is the (global) counter for the"/>
				<comm cntt="array of specified attributes."/>
				<comm cntt="Read the element type name."/>
				<comm cntt="Determine the current content type."/>
				<comm cntt="Read the attributes, if any."/>
				<comm cntt="After this loop, we should be just"/>
				<comm cntt="in front of the closing delimiter."/>
				<comm cntt="Supply any defaulted attributes."/>
				<comm cntt="See if it was specified."/>
				<comm cntt="I guess not..."/>
				<comm cntt="Figure out if this is a start tag"/>
				<comm cntt="or an empty element, and dispatch an"/>
				<comm cntt="event accordingly."/>
				<comm cntt="Restore the previous state."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseAttribute(String)" access="pub" jdoc="Parse an attribute assignment. &amp;lt;pre&amp;gt; [34] Attribute ::= Name Eq AttValue &amp;lt; pre&amp;gt; @param name The name of the attribute&amp;apos;s element. @see XmlHandler#attribute">
				<comm cntt="Read the attribute name."/>
				<comm cntt="Parse &amp;apos;=&amp;apos;"/>
				<comm cntt="Read the value, normalizing whitespace"/>
				<comm cntt="if it is not CDATA."/>
				<comm cntt="Inform the handler about the"/>
				<comm cntt="attribute."/>
				<comm cntt="Note that the attribute has been"/>
				<comm cntt="specified."/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseEq()" access="pub" jdoc="Parse an equals sign surrounded by optional whitespace. [35] Eq ::= S? &amp;apos;=&amp;apos; S?">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseETag()" access="pub" jdoc="Parse an end tag. [36] ETag ::= &amp;apos;&amp;lt; &amp;apos; Name S? &amp;apos;&amp;gt;&amp;apos; NOTE: parseContent() chains to here.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseContent()" access="pub" jdoc="Parse the content of an element. [37] content ::= (element | PCData | Reference | CDSect | PI | Comment) [68] Reference ::= EntityRef | CharRef">
				<comm cntt="Handle delimiters"/>
				<comm cntt="Found &amp;quot;&amp;&amp;quot;"/>
				<comm cntt="Found &amp;quot;&amp;lt;&amp;quot;"/>
				<comm cntt="Found &amp;quot;&amp;lt;!&amp;quot;"/>
				<comm cntt="Found &amp;quot;&amp;lt;!-&amp;quot;"/>
				<comm cntt="Found &amp;quot;&amp;lt;![&amp;quot;"/>
				<comm cntt="Found &amp;quot;&amp;lt;?&amp;quot;"/>
				<comm cntt="Found &amp;quot;&amp;lt; &amp;quot;"/>
				<comm cntt="Found &amp;quot;&amp;lt;&amp;quot; followed by something else"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseElementdecl()" access="pub" jdoc="Parse an element type declaration. [40] elementdecl ::= &amp;apos;&amp;lt;!ELEMENT&amp;apos; S %Name S (%S S)? %contentspec S? &amp;apos;&amp;gt;&amp;apos; [VC: Unique Element Declaration] NOTE: the &amp;apos;&amp;lt;!ELEMENT&amp;apos; has already been read.">
				<comm cntt="Read the element type name."/>
				<comm cntt="Read the content model."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseContentspec(String)" access="pub" jdoc="Content specification. [41] contentspec ::= &amp;apos;EMPTY&amp;apos; | &amp;apos;ANY&amp;apos; | Mixed | elements">
				<param name="name"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseElements()" access="pub" jdoc="Parse an element-content model. [42] elements ::= (choice | seq) (&amp;apos;?&amp;apos; | &amp;apos; &amp;apos; | &amp;apos;+&amp;apos;)? [44] cps ::= S? %cp S? [45] choice ::= &amp;apos;(&amp;apos; S? %ctokplus (S? &amp;apos;|&amp;apos; S? %ctoks) S? &amp;apos;)&amp;apos; [46] ctokplus ::= cps (&amp;apos;|&amp;apos; cps)+ [47] ctoks ::= cps (&amp;apos;|&amp;apos; cps) [48] seq ::= &amp;apos;(&amp;apos; S? %stoks (S? &amp;apos;,&amp;apos; S? %stoks) S? &amp;apos;)&amp;apos; [49] stoks ::= cps (&amp;apos;,&amp;apos; cps) NOTE: the opening &amp;apos;(&amp;apos; and S have already been read. TODO: go over parameter entity boundaries more carefully.">
				<comm cntt="Parse the first content particle"/>
				<comm cntt="Check for end or for a separator."/>
				<comm cntt="Register the separator."/>
				<comm cntt="Parse the rest of the content model."/>
				<comm cntt="Check for the occurrence indicator."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseCp()" access="pub" jdoc="Parse a content particle. [43] cp ::= (Name | choice | seq) (&amp;apos;?&amp;apos; | &amp;apos; &amp;apos; | &amp;apos;+&amp;apos;) NOTE: I actually use a slightly different production here: cp ::= (elements | (Name (&amp;apos;?&amp;apos; | &amp;apos; &amp;apos; | &amp;apos;+&amp;apos;)?))">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseMixed()" access="pub" jdoc="Parse mixed content. [50] Mixed ::= &amp;apos;(&amp;apos; S? %( %&amp;apos;#PCDATA&amp;apos; (S? &amp;apos;|&amp;apos; S? %Mtoks) ) S? &amp;apos;) &amp;apos; | &amp;apos;(&amp;apos; S? %(&amp;apos;#PCDATA&amp;apos;) S? &amp;apos;)&amp;apos; [51] Mtoks ::= %Name (S? &amp;apos;|&amp;apos; S? %Name) NOTE: the S and &amp;apos;#PCDATA&amp;apos; have already been read.">
				<comm cntt="Check for PCDATA alone."/>
				<comm cntt="Parse mixed content."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseAttlistDecl()" access="pub" jdoc="Parse an attribute list declaration. [52] AttlistDecl ::= &amp;apos;&amp;lt;!ATTLIST&amp;apos; S %Name S? %AttDef+ S? &amp;apos;&amp;gt;&amp;apos; NOTE: the &amp;apos;&amp;lt;!ATTLIST&amp;apos; has already been read.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseAttDef(String)" access="pub" jdoc="Parse a single attribute definition. [53] AttDef ::= S %Name S %AttType S %Default">
				<comm cntt="Read the attribute name."/>
				<comm cntt="Read the attribute type."/>
				<comm cntt="Get the string of enumerated values"/>
				<comm cntt="if necessary."/>
				<comm cntt="Read the default value."/>
				<param name="elementName"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.readAttType()" access="pub" jdoc="Parse the attribute type. [54] AttType ::= StringType | TokenizedType | EnumeratedType [55] StringType ::= &amp;apos;CDATA&amp;apos; [56] TokenizedType ::= &amp;apos;ID&amp;apos; | &amp;apos;IDREF&amp;apos; | &amp;apos;IDREFS&amp;apos; | &amp;apos;ENTITY&amp;apos; | &amp;apos;ENTITIES&amp;apos; | &amp;apos;NMTOKEN&amp;apos; | &amp;apos;NMTOKENS&amp;apos; [57] EnumeratedType ::= NotationType | Enumeration TODO: validate the type!!">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseEnumeration()" access="pub" jdoc="Parse an enumeration. [60] Enumeration ::= &amp;apos;(&amp;apos; S? %Etoks (S? &amp;apos;|&amp;apos; S? %Etoks) S? &amp;apos;)&amp;apos; [61] Etoks ::= %Nmtoken (S? &amp;apos;|&amp;apos; S? %Nmtoken) NOTE: the &amp;apos;(&amp;apos; has already been read.">
				<comm cntt="Read the first token."/>
				<comm cntt="Read the remaining tokens."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseNotationType()" access="pub" jdoc="Parse a notation type for an attribute. [58] NotationType ::= %&amp;apos;NOTATION&amp;apos; S &amp;apos;(&amp;apos; S? %Ntoks (S? &amp;apos;|&amp;apos; S? %Ntoks) S? &amp;apos;)&amp;apos; [59] Ntoks ::= %Name (S? &amp;apos;|&amp;apos; S? %Name) NOTE: the &amp;apos;NOTATION&amp;apos; has already been read">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseDefault(String, String, int)" access="pub" jdoc="Parse the default value for an attribute. [62] Default ::= &amp;apos;#REQUIRED&amp;apos; | &amp;apos;#IMPLIED&amp;apos; | ((%&amp;apos;#FIXED&amp;apos; S)? %AttValue">
				<param name="elementName"/>
				<param name="name"/>
				<param name="type"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseConditionalSect()" access="pub" jdoc="Parse a conditional section. [63] conditionalSect ::= includeSect || ignoreSect [64] includeSect ::= &amp;apos;&amp;lt;![&amp;apos; %&amp;apos;INCLUDE&amp;apos; &amp;apos;[&amp;apos; (%markupdecl ) &amp;apos;]]&amp;gt;&amp;apos; [65] ignoreSect ::= &amp;apos;&amp;lt;![&amp;apos; %&amp;apos;IGNORE&amp;apos; &amp;apos;[&amp;apos; ignoreSectContents &amp;apos;]]&amp;gt;&amp;apos; [66] ignoreSectContents ::= ((SkipLit | Comment | PI) -(Char &amp;apos;]]&amp;gt;&amp;apos;)) | (&amp;apos;&amp;lt;![&amp;apos; ignoreSectContents &amp;apos;]]&amp;gt;&amp;apos;) | (Char - (&amp;apos;]&amp;apos; | [&amp;lt;&amp;apos;&amp;quot;])) | (&amp;apos;&amp;lt;!&amp;apos; (Char - (&amp;apos;-&amp;apos; | &amp;apos;[&amp;apos;))) NOTE: the &amp;apos;&amp;lt;![&amp;apos; has already been read. TODO: verify that I am handling ignoreSectContents right.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseCharRef()" access="pub" jdoc="Read a character reference. [67] CharRef ::= &amp;apos;&amp;#&amp;apos; [0-9]+ &amp;apos;;&amp;apos; | &amp;apos;&amp;#x&amp;apos; [0-9a-fA-F]+ &amp;apos;;&amp;apos; NOTE: the &amp;apos;&amp;#&amp;apos; has already been read.">
				<comm cntt="Check for surrogates: 00000000 0000xxxx yyyyyyyy zzzzzzzz"/>
				<comm cntt="(1101|10xx|xxyy|yyyy + 1101|11yy|zzzz|zzzz:"/>
				<comm cntt="no surrogates needed"/>
				<comm cntt="&amp;gt; 16 bits, surrogate needed"/>
				<comm cntt="too big for surrogate"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseEntityRef(boolean)" access="pub" jdoc="Parse a reference. [69] EntityRef ::= &amp;apos;&amp;&amp;apos; Name &amp;apos;;&amp;apos; NOTE: the &amp;apos;&amp;&amp;apos; has already been read. @param externalAllowed External entities are allowed here.">
				<param name="externalAllowed"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parsePEReference(boolean)" access="pub" jdoc="Parse a parameter entity reference. [70] PEReference ::= &amp;apos;%&amp;apos; Name &amp;apos;;&amp;apos; NOTE: the &amp;apos;%&amp;apos; has already been read.">
				<param name="isEntityValue"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseEntityDecl()" access="pub" jdoc="Parse an entity declaration. [71] EntityDecl ::= &amp;apos;&amp;lt;!ENTITY&amp;apos; S %Name S %EntityDef S? &amp;apos;&amp;gt;&amp;apos; | &amp;apos;&amp;lt;!ENTITY&amp;apos; S &amp;apos;%&amp;apos; S %Name S %EntityDef S? &amp;apos;&amp;gt;&amp;apos; [72] EntityDef ::= EntityValue | ExternalDef [73] ExternalDef ::= ExternalID %NDataDecl? [74] ExternalID ::= &amp;apos;SYSTEM&amp;apos; S SystemLiteral | &amp;apos;PUBLIC&amp;apos; S PubidLiteral S SystemLiteral [75] NDataDecl ::= S %&amp;apos;NDATA&amp;apos; S %Name NOTE: the &amp;apos;&amp;lt;!ENTITY&amp;apos; has already been read.">
				<comm cntt="Check for a parameter entity."/>
				<comm cntt="Read the entity name, and prepend"/>
				<comm cntt="&amp;apos;%&amp;apos; if necessary."/>
				<comm cntt="Read the entity value."/>
				<comm cntt="Internal entity."/>
				<comm cntt="Read the external IDs"/>
				<comm cntt="Check for NDATA declaration."/>
				<comm cntt="Finish the declaration."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseNotationDecl()" access="pub" jdoc="Parse a notation declaration. [81] NotationDecl ::= &amp;apos;&amp;lt;!NOTATION&amp;apos; S %Name S %ExternalID S? &amp;apos;&amp;gt;&amp;apos; NOTE: the &amp;apos;&amp;lt;!NOTATION&amp;apos; has already been read.">
				<comm cntt="Read the external identifiers."/>
				<comm cntt="Register the notation."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parsePCData()" access="pub" jdoc="Parse PCDATA. &amp;lt;pre&amp;gt; [16] PCData ::= [^&amp;lt;&amp;amp;] &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;The trick here is that the data stays in the dataBuffer without necessarily being converted to a string right away.">
				<comm cntt="Start with a little cheat -- in most"/>
				<comm cntt="cases, the entire sequence of"/>
				<comm cntt="character data will already be in"/>
				<comm cntt="the readBuffer; if not, fall through to"/>
				<comm cntt="the normal approach."/>
				<comm cntt="OK, the cheat didn&amp;apos;t work; start over"/>
				<comm cntt="and do it by the book."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.requireWhitespace()" access="pub" jdoc="Require whitespace characters. [1] S ::= (#x20 | #x9 | #xd | #xa)+">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseWhitespace()" access="pub" jdoc="Parse whitespace characters, and leave them in the data buffer.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.skipWhitespace()" access="pub" jdoc="Skip whitespace characters. [1] S ::= (#x20 | #x9 | #xd | #xa)+">
				<comm cntt="Start with a little cheat. Most of"/>
				<comm cntt="the time, the white space will fall"/>
				<comm cntt="within the current read buffer; if"/>
				<comm cntt="not, then fall through."/>
				<comm cntt="else fall through..."/>
				<comm cntt="OK, do it by the book."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.readNmtoken(boolean)" access="pub" jdoc="Read a name or name token. [5] Name ::= (Letter | &amp;apos;_&amp;apos; | &amp;apos;:&amp;apos;) (NameChar) [7] Nmtoken ::= (NameChar)+ NOTE: [6] is implemented implicitly where required.">
				<comm cntt="else fall through..."/>
				<comm cntt="Read the first character."/>
				<param name="isName"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.readLiteral(int)" access="pub" jdoc="Read a literal. [10] AttValue ::= &amp;apos;&amp;quot;&amp;apos; ([^&amp;lt;&amp;&amp;quot;] | Reference) &amp;apos;&amp;quot;&amp;apos; | &amp;quot;&amp;apos;&amp;quot; ([^&amp;lt;&amp;&amp;apos;] | Reference) &amp;quot;&amp;apos;&amp;quot; [11] SystemLiteral ::= &amp;apos;&amp;quot;&amp;apos; URLchar &amp;apos;&amp;quot;&amp;apos; | &amp;quot;&amp;apos;&amp;quot; (URLchar - &amp;quot;&amp;apos;&amp;quot;) &amp;quot;&amp;apos;&amp;quot; [13] PubidLiteral ::= &amp;apos;&amp;quot;&amp;apos; PubidChar &amp;apos;&amp;quot;&amp;apos; | &amp;quot;&amp;apos;&amp;quot; (PubidChar - &amp;quot;&amp;apos;&amp;quot;) &amp;quot;&amp;apos;&amp;quot; [9] EntityValue ::= &amp;apos;&amp;quot;&amp;apos; ([^%&amp;&amp;quot;] | PEReference | Reference) &amp;apos;&amp;quot;&amp;apos; | &amp;quot;&amp;apos;&amp;quot; ([^%&amp;&amp;apos;] | PEReference | Reference) &amp;quot;&amp;apos;&amp;quot;">
				<comm cntt="Find the delimiter."/>
				<comm cntt="Read the literal."/>
				<comm cntt="Literals never have line ends"/>
				<comm cntt="References may be allowed"/>
				<comm cntt="check the next character"/>
				<comm cntt="Normalise whitespace if necessary."/>
				<comm cntt="Return the value."/>
				<param name="flags"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.readExternalIds(boolean)" access="pub" jdoc="Try reading external identifiers. &amp;lt;p&amp;gt;The system identifier is not required for notations. @param inNotation Are we in a notation? @return A two-member String array containing the identifiers.">
				<comm cntt="public id"/>
				<comm cntt="system id"/>
				<comm cntt="system id"/>
				<param name="inNotation"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.isWhitespace(char)" access="pub" jdoc="Test if a character is whitespace. &amp;lt;pre&amp;gt; [1] S ::= (#x20 | #x9 | #xd | #xa)+ &amp;lt; pre&amp;gt; @param c The character to test. @return true if the character is whitespace.">
				<param name="c"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.dataBufferAppend(char)" access="pub" jdoc="Add a character to the data buffer.">
				<comm cntt="Expand buffer if necessary."/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.dataBufferAppend(String)" access="pub" jdoc="Add a string to the data buffer.">
				<param name="s"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.dataBufferAppend(char, int, int)" access="pub" jdoc="Append (part of) a character array to the data buffer.">
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.dataBufferNormalize()" access="pub" jdoc="Normalise whitespace in the data buffer.">
				<comm cntt="Skip whitespace at the start."/>
				<comm cntt="Skip whitespace at the end."/>
				<comm cntt="Start copying to the left."/>
				<comm cntt="Normalise all other whitespace to"/>
				<comm cntt="a single space."/>
				<comm cntt="The new length is &amp;lt;= the old one."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.dataBufferToString()" access="pub" jdoc="Convert the data buffer to a string. @param internFlag true if the contents should be interned. @see #intern(char[],int,int)">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.dataBufferFlush()" access="pub" jdoc="Flush the contents of the data buffer to the handler, if appropriate, and reset the buffer for new input.">
				<comm cntt="do nothing"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.require(String)" access="pub" jdoc="Require a string to appear, or throw an exception.">
				<param name="delim"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.require(char)" access="pub" jdoc="Require a character to appear, or throw an exception.">
				<param name="delim"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.intern(String)" access="pub" jdoc="Return an internalised version of a string. &amp;lt;p&amp;gt;&amp;AElig;lfred uses this method to create an internalised version of all names and attribute values, so that it can test equality with &amp;lt;code&amp;gt;==&amp;lt; code&amp;gt; instead of &amp;lt;code&amp;gt;String.equals()&amp;lt; code&amp;gt;. &amp;lt;p&amp;gt;If you want to be able to test for equality in the same way, you can use this method to internalise your own strings first: &amp;lt;pre&amp;gt; String PARA = handler.intern(&amp;quot;PARA&amp;quot;); &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;Note that this will not return the same results as String.intern(). @param s The string to internalise. @return An internalised version of the string. @see #intern(char[],int,int) @see java.lang.String#intern">
				<param name="s"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.intern(char, int, int)" access="pub" jdoc="Create an internalised string from a character array. &amp;lt;p&amp;gt;This is much more efficient than constructing a non-internalised string first, and then internalising it. &amp;lt;p&amp;gt;Note that this will not return the same results as String.intern(). @param ch an array of characters for building the string. @param start the starting position in the array. @param length the number of characters to place in the string. @return an internalised string. @see #intern(String) @see java.lang.String#intern">
				<comm cntt="Generate a hash code."/>
				<comm cntt="Get the bucket."/>
				<comm cntt="Search for a matching tuple, and"/>
				<comm cntt="return the string if we find one."/>
				<comm cntt="Stop when we hit a null index."/>
				<comm cntt="If they&amp;apos;re the same length,"/>
				<comm cntt="check for a match."/>
				<comm cntt="If the loop finishes, &amp;apos;index&amp;apos; will"/>
				<comm cntt="contain the current bucket"/>
				<comm cntt="position."/>
				<comm cntt="Stop if there are no more tuples."/>
				<comm cntt="That&amp;apos;s it, we have a match!"/>
				<comm cntt="Not found -- we&amp;apos;ll have to add it."/>
				<comm cntt="Do we have to grow the bucket?"/>
				<comm cntt="OK, add it to the end of the"/>
				<comm cntt="bucket."/>
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.extendArray(Object, int, int)" access="pub" jdoc="Ensure the capacity of an array, allocating a new one if necessary.">
				<param name="array"/>
				<param name="currentSize"/>
				<param name="requiredSize"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.declaredElements()" access="pub" jdoc="Get the declared elements for an XML document. &amp;lt;p&amp;gt;The results will be valid only after the DTD (if any) has been parsed. @return An enumeration of all element types declared for this document (as Strings). @see #getElementContentType @see #getElementContentModel">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getElementContentType(String)" access="pub" jdoc="Look up the content type of an element. @param name The element type name. @return An integer constant representing the content type. @see #getElementContentModel @see #CONTENT_UNDECLARED @see #CONTENT_ANY @see #CONTENT_EMPTY @see #CONTENT_MIXED @see #CONTENT_ELEMENTS">
				<param name="name"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getElementContentModel(String)" access="pub" jdoc="Look up the content model of an element. &amp;lt;p&amp;gt;The result will always be null unless the content type is CONTENT_ELEMENTS or CONTENT_MIXED. @param name The element type name. @return The normalised content model, as a string. @see #getElementContentType">
				<param name="name"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.setElement(String, int, String, Hashtable)" access="pub" jdoc="Register an element. Array format: element type attribute hash table">
				<comm cntt="Try looking up the element"/>
				<comm cntt="Make a new one if necessary."/>
				<comm cntt="Insert the content type, if any."/>
				<comm cntt="Insert the content model, if any."/>
				<comm cntt="Insert the attributes, if any."/>
				<comm cntt="Save the element info."/>
				<param name="name"/>
				<param name="contentType"/>
				<param name="contentModel"/>
				<param name="attributes"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getElementAttributes(String)" access="pub" jdoc="Look up the attribute hash table for an element. The hash table is the second item in the element array.">
				<param name="name"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.declaredAttributes(String)" access="pub" jdoc="Get the declared attributes for an element type. @param elname The name of the element type. @return An Enumeration of all the attributes declared for a specific element type. The results will be valid only after the DTD (if any) has been parsed. @see #getAttributeType @see #getAttributeEnumeration @see #getAttributeDefaultValueType @see #getAttributeDefaultValue @see #getAttributeExpandedValue">
				<param name="elname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getAttributeType(String, String)" access="pub" jdoc="Retrieve the declared type of an attribute. @param name The name of the associated element. @param aname The name of the attribute. @return An integer constant representing the attribute type. @see #ATTRIBUTE_UNDECLARED @see #ATTRIBUTE_CDATA @see #ATTRIBUTE_ID @see #ATTRIBUTE_IDREF @see #ATTRIBUTE_IDREFS @see #ATTRIBUTE_ENTITY @see #ATTRIBUTE_ENTITIES @see #ATTRIBUTE_NMTOKEN @see #ATTRIBUTE_NMTOKENS @see #ATTRIBUTE_ENUMERATED @see #ATTRIBUTE_NOTATION">
				<param name="name"/>
				<param name="aname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getAttributeEnumeration(String, String)" access="pub" jdoc="Retrieve the allowed values for an enumerated attribute type. @param name The name of the associated element. @param aname The name of the attribute. @return A string containing the token list. @see #ATTRIBUTE_ENUMERATED @see #ATTRIBUTE_NOTATION">
				<param name="name"/>
				<param name="aname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getAttributeDefaultValue(String, String)" access="pub" jdoc="Retrieve the default value of a declared attribute. @param name The name of the associated element. @param aname The name of the attribute. @return The default value, or null if the attribute was #IMPLIED or simply undeclared and unspecified. @see #getAttributeExpandedValue">
				<param name="name"/>
				<param name="aname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getAttributeExpandedValue(String, String)" access="pub" jdoc="Retrieve the expanded value of a declared attribute. &amp;lt;p&amp;gt;All general entities will be expanded. @param name The name of the associated element. @param aname The name of the attribute. @return The expanded default value, or null if the attribute was #IMPLIED or simply undeclared @see #getAttributeDefaultValue">
				<param name="name"/>
				<param name="aname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getAttributeDefaultValueType(String, String)" access="pub" jdoc="Retrieve the default value type of a declared attribute. @see #ATTRIBUTE_DEFAULT_SPECIFIED @see #ATTRIBUTE_DEFAULT_IMPLIED @see #ATTRIBUTE_DEFAULT_REQUIRED @see #ATTRIBUTE_DEFAULT_FIXED">
				<param name="name"/>
				<param name="aname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.setAttribute(String, String, int, String, String, int)" access="pub" jdoc="Register an attribute declaration for later retrieval. Format: - String type - String default value - int value type TODO: do something with attribute types.">
				<comm cntt="Create a new hashtable if necessary."/>
				<comm cntt="Check that the attribute doesn&amp;apos;t"/>
				<comm cntt="already exist!"/>
				<comm cntt="Use CONTENT_UNDECLARED to avoid overwriting"/>
				<comm cntt="existing element declaration."/>
				<param name="elName"/>
				<param name="name"/>
				<param name="type"/>
				<param name="enumeration"/>
				<param name="value"/>
				<param name="valueType"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getAttribute(String, String)" access="pub" jdoc="Retrieve the three-member array representing an attribute declaration.">
				<param name="elName"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.declaredEntities()" access="pub" jdoc="Get declared entities. @return An Enumeration of all the entities declared for this XML document. The results will be valid only after the DTD (if any) has been parsed. @see #getEntityType @see #getEntityPublicId @see #getEntitySystemId @see #getEntityValue @see #getEntityNotationName">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getEntityType(String)" access="pub" jdoc="Find the type of an entity. @returns An integer constant representing the entity type. @see #ENTITY_UNDECLARED @see #ENTITY_INTERNAL @see #ENTITY_NDATA @see #ENTITY_TEXT">
				<param name="ename"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getEntityPublicId(String)" access="pub" jdoc="Return an external entity&amp;apos;s public identifier, if any. @param ename The name of the external entity. @return The entity&amp;apos;s system identifier, or null if the entity was not declared, if it is not an external entity, or if no public identifier was provided. @see #getEntityType">
				<param name="ename"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getEntitySystemId(String)" access="pub" jdoc="Return an external entity&amp;apos;s system identifier. @param ename The name of the external entity. @return The entity&amp;apos;s system identifier, or null if the entity was not declared, or if it is not an external entity. @see #getEntityType">
				<param name="ename"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getEntityValue(String)" access="pub" jdoc="Return the value of an internal entity. @param ename The name of the internal entity. @return The entity&amp;apos;s value, or null if the entity was not declared, or if it is not an internal entity. @see #getEntityType">
				<param name="ename"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getEntityNotationName(String)" access="pub" jdoc="Get the notation name associated with an NDATA entity. @param ename The NDATA entity name. @return The associated notation name, or null if the entity was not declared, or if it is not an NDATA entity. @see #getEntityType">
				<param name="eName"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.setInternalEntity(String, String)" access="pub" jdoc="Register an entity declaration for later retrieval.">
				<param name="eName"/>
				<param name="value"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.setExternalDataEntity(String, String, String, String)" access="pub" jdoc="Register an external data entity.">
				<param name="eName"/>
				<param name="pubid"/>
				<param name="sysid"/>
				<param name="nName"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.setExternalTextEntity(String, String, String)" access="pub" jdoc="Register an external text entity.">
				<param name="eName"/>
				<param name="pubid"/>
				<param name="sysid"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.setEntity(String, int, String, String, String, String)" access="pub" jdoc="Register an entity declaration for later retrieval.">
				<param name="eName"/>
				<param name="eClass"/>
				<param name="pubid"/>
				<param name="sysid"/>
				<param name="value"/>
				<param name="nName"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.declaredNotations()" access="pub" jdoc="Get declared notations. @return An Enumeration of all the notations declared for this XML document. The results will be valid only after the DTD (if any) has been parsed. @see #getNotationPublicId @see #getNotationSystemId">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getNotationPublicId(String)" access="pub" jdoc="Look up the public identifier for a notation. You will normally use this method to look up a notation that was provided as an attribute value or for an NDATA entity. @param nname The name of the notation. @return A string containing the public identifier, or null if none was provided or if no such notation was declared. @see #getNotationSystemId">
				<param name="nname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getNotationSystemId(String)" access="pub" jdoc="Look up the system identifier for a notation. You will normally use this method to look up a notation that was provided as an attribute value or for an NDATA entity. @param nname The name of the notation. @return A string containing the system identifier, or null if no such notation was declared. @see #getNotationPublicId">
				<param name="nname"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.setNotation(String, String, String)" access="pub" jdoc="Register a notation declaration for later retrieval. Format: - public id - system id">
				<param name="nname"/>
				<param name="pubid"/>
				<param name="sysid"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getLineNumber()" access="pub" jdoc="Return the current line number.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getColumnNumber()" access="pub" jdoc="Return the current column number.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.readCh()" access="pub" jdoc="Read a single character from the readBuffer. &amp;lt;p&amp;gt;The readDataChunk() method maintains the buffer. &amp;lt;p&amp;gt;If we hit the end of an entity, try to pop the stack and keep going. &amp;lt;p&amp;gt;(This approach doesn&amp;apos;t really enforce XML&amp;apos;s rules about entity boundaries, but this is not currently a validating parser). &amp;lt;p&amp;gt;This routine also attempts to keep track of the current position in external entities, but it&amp;apos;s not entirely accurate. @return The next available input character. @see #unread(char) @see #unread(String) @see #readDataChunk @see #readBuffer @see #line @return The next character from the current input source.">
				<comm cntt="As long as there&amp;apos;s nothing in the"/>
				<comm cntt="read buffer, try reading more data"/>
				<comm cntt="(for an external entity) or popping"/>
				<comm cntt="the entity stack (for either)."/>
				<comm cntt="This is a particularly nasty bit"/>
				<comm cntt="of code, that checks for a parameter"/>
				<comm cntt="entity reference but peeks ahead to"/>
				<comm cntt="catch the &amp;apos;%&amp;apos; in parameter entity"/>
				<comm cntt="declarations."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.unread(char)" access="pub" jdoc="Push a single character back onto the current input stream. &amp;lt;p&amp;gt;This method usually pushes the character back onto the readBuffer, while the unread(String) method treats the string as a new internal entity. &amp;lt;p&amp;gt;I don&amp;apos;t think that this would ever be called with readBufferPos = 0, because the methods always reads a character before unreading it, but just in case, I&amp;apos;ve added a boundary condition. @param c The character to push back. @see #readCh @see #unread(String) @see #unread(char[]) @see #readBuffer">
				<comm cntt="Normal condition."/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.unread(char, int)" access="pub" jdoc="Push a char array back onto the current input stream. &amp;lt;p&amp;gt;NOTE: you must &amp;lt;em&amp;gt;never&amp;lt; em&amp;gt; push back characters that you haven&amp;apos;t actually read: use pushString() instead. @see #readCh @see #unread(char) @see #unread(String) @see #readBuffer @see #pushString">
				<param name="ch"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.pushURL(String, String, String, Reader, InputStream, String)" access="pub" jdoc="Push a new external input source. &amp;lt;p&amp;gt;The source will be either an external text entity, or the DTD external subset. &amp;lt;p&amp;gt;TO DO: Right now, this method always attempts to autodetect the encoding; in the future, it should allow the caller to request an encoding explicitly, and it should also look at the headers with an HTTP connection. @param url The java.net.URL object for the entity. @see XmlHandler#resolveEntity @see #pushString @see #sourceType @see #pushInput @see #detectEncoding @see #sourceType @see #readBuffer">
				<comm cntt="Push the existing status."/>
				<comm cntt="Create a new read buffer."/>
				<comm cntt="(Note the four-character margin)"/>
				<comm cntt="Flush any remaining data."/>
				<comm cntt="Make the URL absolute."/>
				<comm cntt="See if the application wants to"/>
				<comm cntt="redirect the system ID and or"/>
				<comm cntt="supply its own character stream."/>
				<comm cntt="Start the entity."/>
				<comm cntt="Figure out what we&amp;apos;re reading from."/>
				<comm cntt="There&amp;apos;s an explicit character stream."/>
				<comm cntt="We have to open our own stream"/>
				<comm cntt="to the URL."/>
				<comm cntt="Set the new status"/>
				<comm cntt="If we get to here, there must be"/>
				<comm cntt="an InputStream available."/>
				<comm cntt="Attempt to detect the encoding."/>
				<comm cntt="Read an XML or text declaration."/>
				<param name="ename"/>
				<param name="publicId"/>
				<param name="systemId"/>
				<param name="reader"/>
				<param name="stream"/>
				<param name="encoding"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.tryEncodingDecl(boolean)" access="pub" jdoc="Check for an encoding declaration.">
				<comm cntt="Read the XML Encoding declaration."/>
				<param name="ignoreEncoding"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.detectEncoding()" access="pub" jdoc="Attempt to detect the encoding of an entity. &amp;lt;p&amp;gt;The trick here (as suggested in the XML standard) is that any entity not in UTF-8, or in UCS-2 with a byte-order mark, &amp;lt;b&amp;gt;must&amp;lt; b&amp;gt; begin with an XML declaration or an encoding declaration; we simply have to look for &amp;quot;&amp;lt;?XML&amp;quot; in various encodings. &amp;lt;p&amp;gt;This method has no way to distinguish among 8-bit encodings. Instead, it assumes UTF-8, then (possibly) revises its assumption later in checkEncoding(). Any ASCII-derived 8-bit encoding should work, but most will be rejected later by checkEncoding(). &amp;lt;p&amp;gt;I don&amp;apos;t currently detect EBCDIC, since I&amp;apos;m concerned that it could also be a valid UTF-8 sequence; I&amp;apos;ll have to do more checking later. @see #tryEncoding(byte[],byte,byte,byte,byte) @see #tryEncoding(byte[],byte,byte) @see #checkEncoding @see #read8bitEncodingDeclaration">
				<comm cntt="Read the first four bytes for"/>
				<comm cntt="autodetection."/>
				<comm cntt="Look for a known signature."/>
				<comm cntt="UCS-4 must begin with &amp;quot;&amp;lt;!XML&amp;quot;"/>
				<comm cntt="0x00 0x00 0x00 0x3c: UCS-4, big-endian (1234)"/>
				<comm cntt="UCS-4 must begin with &amp;quot;&amp;lt;!XML&amp;quot;"/>
				<comm cntt="0x3c 0x00 0x00 0x00: UCS-4, little-endian (4321)"/>
				<comm cntt="UCS-4 must begin with &amp;quot;&amp;lt;!XML&amp;quot;"/>
				<comm cntt="0x00 0x00 0x3c 0x00: UCS-4, unusual (2143)"/>
				<comm cntt="UCS-4 must begin with &amp;quot;&amp;lt;!XML&amp;quot;"/>
				<comm cntt="0x00 0x3c 0x00 0x00: UCS-4, unusual (3421)"/>
				<comm cntt="UCS-2 with a byte-order marker."/>
				<comm cntt="0xfe 0xff: UCS-2, big-endian (12)"/>
				<comm cntt="UCS-2 with a byte-order marker."/>
				<comm cntt="0xff 0xfe: UCS-2, little-endian (21)"/>
				<comm cntt="UCS-2 without a BOM must begin with &amp;quot;&amp;lt;?XML&amp;quot;"/>
				<comm cntt="0x00 0x3c 0x00 0x3f: UCS-2, big-endian, no byte-order mark"/>
				<comm cntt="UCS-2 without a BOM must begin with &amp;quot;&amp;lt;?XML&amp;quot;"/>
				<comm cntt="0x3c 0x00 0x3f 0x00: UCS-2, little-endian, no byte-order mark"/>
				<comm cntt="Some kind of 8-bit encoding with &amp;quot;&amp;lt;?XML&amp;quot;"/>
				<comm cntt="0x3c 0x3f 0x78 0x6d: UTF-8 or other 8-bit markup (read ENCODING)"/>
				<comm cntt="Some kind of 8-bit encoding without &amp;quot;&amp;lt;?XML&amp;quot;"/>
				<comm cntt="(otherwise) UTF-8 without encoding XML declaration"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.tryEncoding(byte, byte, byte, byte, byte)" access="pub" jdoc="Check for a four-byte signature. &amp;lt;p&amp;gt;Utility routine for detectEncoding(). &amp;lt;p&amp;gt;Always looks for some part of &amp;quot;&amp;lt;?XML&amp;quot; in a specific encoding. @param sig The first four bytes read. @param b1 The first byte of the signature @param b2 The second byte of the signature @param b3 The third byte of the signature @param b4 The fourth byte of the signature @see #detectEncoding">
				<param name="sig"/>
				<param name="b1"/>
				<param name="b2"/>
				<param name="b3"/>
				<param name="b4"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.tryEncoding(byte, byte, byte)" access="pub" jdoc="Check for a two-byte signature. &amp;lt;p&amp;gt;Looks for a UCS-2 byte-order mark. &amp;lt;p&amp;gt;Utility routine for detectEncoding(). @param sig The first four bytes read. @param b1 The first byte of the signature @param b2 The second byte of the signature @see #detectEncoding">
				<param name="sig"/>
				<param name="b1"/>
				<param name="b2"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.pushString(String, String)" access="pub" jdoc="This method pushes a string back onto input. &amp;lt;p&amp;gt;It is useful either as the expansion of an internal entity, or for backtracking during the parse. &amp;lt;p&amp;gt;Call pushCharArray() to do the actual work. @param s The string to push back onto input. @see #pushCharArray">
				<param name="ename"/>
				<param name="s"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.pushCharArray(String, char, int, int)" access="pub" jdoc="Push a new internal input source. &amp;lt;p&amp;gt;This method is useful for expanding an internal entity, or for unreading a string of characters. It creates a new readBuffer containing the characters in the array, instead of characters converted from an input byte stream. &amp;lt;p&amp;gt;I&amp;apos;ve added a couple of optimisations: don&amp;apos;t push zero- length strings, and just push back a single character for 1-character strings; this should save some time and memory. @param ch The char array to push. @see #pushString @see #pushURL @see #readBuffer @see #sourceType @see #pushInput">
				<comm cntt="Push the existing status"/>
				<param name="ename"/>
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.pushInput(String)" access="pub" jdoc="Save the current input source onto the stack. &amp;lt;p&amp;gt;This method saves all of the global variables associated with the current input source, so that they can be restored when a new input source has finished. It also tests for entity recursion. &amp;lt;p&amp;gt;The method saves the following global variables onto a stack using a fixed-length array: &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;sourceType &amp;lt;li&amp;gt;externalEntity &amp;lt;li&amp;gt;readBuffer &amp;lt;li&amp;gt;readBufferPos &amp;lt;li&amp;gt;readBufferLength &amp;lt;li&amp;gt;line &amp;lt;li&amp;gt;encoding &amp;lt; ol&amp;gt; @param ename The name of the entity (if any) causing the new input. @see #popInput @see #sourceType @see #externalEntity @see #readBuffer @see #readBufferPos @see #readBufferLength @see #line @see #encoding">
				<comm cntt="Check for entity recursion."/>
				<comm cntt="Don&amp;apos;t bother if there is no input."/>
				<comm cntt="Set up a snapshot of the current"/>
				<comm cntt="input source."/>
				<comm cntt="Push it onto the stack."/>
				<param name="ename"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.popInput()" access="pub" jdoc="Restore a previous input source. &amp;lt;p&amp;gt;This method restores all of the global variables associated with the current input source. @exception java.io.EOFExceptionIf there are no more entries on the input stack. @see #pushInput @see #sourceType @see #externalEntity @see #readBuffer @see #readBufferPos @see #readBufferLength @see #line @see #encoding">
				<comm cntt="Throw an EOFException if there"/>
				<comm cntt="is nothing else to pop."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.tryRead(char)" access="pub" jdoc="Return true if we can read the expected character. &amp;lt;p&amp;gt;Note that the character will be removed from the input stream on success, but will be put back on failure. Do not attempt to read the character again if the method succeeds. @param delim The character that should appear next. For a insensitive match, you must supply this in upper-case. @return true if the character was successfully read, or false if it was not. @see #tryRead(String)">
				<comm cntt="Read the character"/>
				<comm cntt="Test for a match, and push the character"/>
				<comm cntt="back if the match fails."/>
				<param name="delim"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.tryRead(String)" access="pub" jdoc="Return true if we can read the expected string. &amp;lt;p&amp;gt;This is simply a convenience method. &amp;lt;p&amp;gt;Note that the string will be removed from the input stream on success, but will be put back on failure. Do not attempt to read the string again if the method succeeds. &amp;lt;p&amp;gt;This method will push back a character rather than an array whenever possible (probably the majority of cases). &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;NOTE:&amp;lt; b&amp;gt; This method currently has a hard-coded limit of 100 characters for the delimiter. @param delim The string that should appear next. @return true if the string was successfully read, or false if it was not. @see #tryRead(char)">
				<comm cntt="Compare the input, character-"/>
				<comm cntt="by character."/>
				<param name="delim"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.tryWhitespace()" access="pub" jdoc="Return true if we can read some whitespace. &amp;lt;p&amp;gt;This is simply a convenience method. &amp;lt;p&amp;gt;This method will push back a character rather than an array whenever possible (probably the majority of cases). @return true if whitespace was found.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.parseUntil(String)" access="pub" jdoc="Read all data until we find the specified string. &amp;lt;p&amp;gt;This is especially useful for scanning marked sections. &amp;lt;p&amp;gt;This is a a little inefficient right now, since it calls tryRead() for every character. @param delim The string delimiter @see #tryRead(String,boolean) @see #readCh">
				<param name="delim"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.skipUntil(String)" access="pub" jdoc="Skip all data until we find the specified string. &amp;lt;p&amp;gt;This is especially useful for scanning comments. &amp;lt;p&amp;gt;This is a a little inefficient right now, since it calls tryRead() for every character. @param delim The string delimiter @see #tryRead(String,boolean) @see #readCh">
				<param name="delim"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.read8bitEncodingDeclaration()" access="pub" jdoc="Read just the encoding declaration (or XML declaration) at the start of an external entity. When this method is called, we know that the declaration is present (or appears to be). We also know that the entity is in some sort of ASCII-derived 8-bit encoding. The idea of this is to let us read what the 8-bit encoding is before we&amp;apos;ve committed to converting any more of the file; the XML or encoding declaration must be in 7-bit ASCII, so we&amp;apos;re safe as long as we don&amp;apos;t go past it.">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.readDataChunk()" access="pub" jdoc="Read a chunk of data from an external input source. &amp;lt;p&amp;gt;This is simply a front-end that fills the rawReadBuffer with bytes, then calls the appropriate encoding handler. @see #encoding @see #rawReadBuffer @see #readBuffer @see #filterCR @see #copyUtf8ReadBuffer @see #copyIso8859_1ReadBuffer @see #copyUcs_2ReadBuffer @see #copyUcs_4ReadBuffer">
				<comm cntt="See if we have any overflow."/>
				<comm cntt="Special situation -- we&amp;apos;re taking"/>
				<comm cntt="input from a character stream."/>
				<comm cntt="Read as many bytes as possible"/>
				<comm cntt="into the read buffer."/>
				<comm cntt="Dispatch to an encoding-specific"/>
				<comm cntt="reader method to populate the"/>
				<comm cntt="readBuffer."/>
				<comm cntt="Filter out all carriage returns"/>
				<comm cntt="if we&amp;apos;ve seen any."/>
				<comm cntt="Reset the position."/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.filterCR()" access="pub" jdoc="Filter carriage returns in the read buffer. &amp;lt;p&amp;gt;CRLF becomes LF; CR becomes LF. @see #readDataChunk @see #readBuffer @see #readBufferOverflow">
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.copyUtf8ReadBuffer(int)" access="pub" jdoc="Convert a buffer of UTF-8-encoded bytes into UTF-16 characters. &amp;lt;p&amp;gt;When readDataChunk() calls this method, the raw bytes are in rawReadBuffer, and the final characters will appear in readBuffer. &amp;lt;p&amp;gt;The tricky part of this is dealing with UTF-8 multi-byte sequences, but it doesn&amp;apos;t seem to slow things down too much. @param count The number of bytes to convert. @see #readDataChunk @see #rawReadBuffer @see #readBuffer @see #getNextUtf8Byte">
				<comm cntt="Determine whether we are dealing"/>
				<comm cntt="with a one-, two-, three-, or four-"/>
				<comm cntt="byte sequence."/>
				<comm cntt="1-byte sequence: 000000000xxxxxxx = 0xxxxxxx"/>
				<comm cntt="2-byte sequence: 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx"/>
				<comm cntt="3-byte sequence: zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx"/>
				<comm cntt="4-byte sequence: 11101110wwwwzzzzyy + 110111yyyyxxxxxx"/>
				<comm cntt="= 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx"/>
				<comm cntt="(uuuuu = wwww + 1)"/>
				<comm cntt="TODO: test that surrogate value is legal."/>
				<comm cntt="Otherwise, the 8th bit may not be set in UTF-8"/>
				<comm cntt="How many characters have we read?"/>
				<param name="count"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.getNextUtf8Byte(int, int)" access="pub" jdoc="Return the next byte value in a UTF-8 sequence. If it is not possible to get a byte from the current entity, throw an exception. @param pos The current position in the rawReadBuffer. @param count The number of bytes in the rawReadBuffer @return The significant six bits of a non-initial byte in a UTF-8 sequence. @exception EOFException If the sequence is incomplete.">
				<comm cntt="Take a character from the buffer"/>
				<comm cntt="or from the actual input stream."/>
				<comm cntt="Check for the correct bits at the"/>
				<comm cntt="start."/>
				<comm cntt="Return the significant bits."/>
				<param name="pos"/>
				<param name="count"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.copyIso8859_1ReadBuffer(int)" access="pub" jdoc="Convert a buffer of ISO-8859-1-encoded bytes into UTF-16 characters. &amp;lt;p&amp;gt;When readDataChunk() calls this method, the raw bytes are in rawReadBuffer, and the final characters will appear in readBuffer. &amp;lt;p&amp;gt;This is a direct conversion, with no tricks. @param count The number of bytes to convert. @see #readDataChunk @see #rawReadBuffer @see #readBuffer">
				<param name="count"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.copyUcs2ReadBuffer(int, int, int)" access="pub" jdoc="Convert a buffer of UCS-2-encoded bytes into UTF-16 characters. &amp;lt;p&amp;gt;When readDataChunk() calls this method, the raw bytes are in rawReadBuffer, and the final characters will appear in readBuffer. @param count The number of bytes to convert. @param shift1 The number of bits to shift byte 1. @param shift2 The number of bits to shift byte 2 @see #readDataChunk @see #rawReadBuffer @see #readBuffer">
				<param name="count"/>
				<param name="shift1"/>
				<param name="shift2"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.copyUcs4ReadBuffer(int, int, int, int, int)" access="pub" jdoc="Convert a buffer of UCS-4-encoded bytes into UTF-16 characters. &amp;lt;p&amp;gt;When readDataChunk() calls this method, the raw bytes are in rawReadBuffer, and the final characters will appear in readBuffer. &amp;lt;p&amp;gt;Java has 16-bit chars, but this routine will attempt to use surrogates to encoding values between 0x00010000 and 0x000fffff. @param count The number of bytes to convert. @param shift1 The number of bits to shift byte 1. @param shift2 The number of bits to shift byte 2 @param shift3 The number of bits to shift byte 2 @param shift4 The number of bits to shift byte 2 @see #readDataChunk @see #rawReadBuffer @see #readBuffer">
				<param name="count"/>
				<param name="shift1"/>
				<param name="shift2"/>
				<param name="shift3"/>
				<param name="shift4"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.encodingError(String, int, int)" access="pub" jdoc="Report a character encoding error.">
				<param name="message"/>
				<param name="value"/>
				<param name="offset"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.initializeVariables()" access="pub" jdoc="Re-initialize the variables for each parse.">
				<comm cntt="No errors; first line"/>
				<comm cntt="Set up the buffers for data and names"/>
				<comm cntt="Set up the DTD hash tables"/>
				<comm cntt="Set up the variables for the current"/>
				<comm cntt="element context."/>
				<comm cntt="Set up the input variables"/>
			</mth>
			<mth name="/lib/:com.microstar.xml.XmlParser.cleanupVariables()" access="pub" jdoc="Clean up after the parse to allow some garbage collection. Leave around anything that might be useful for queries.">
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:gnu.regexp">
		<class name="/lib/:gnu.regexp.REFilterInputStream" intfc="n" abs="n" inn="n" sloc="54" jdoc="Replaces instances of a given RE found within an InputStream with replacement text. The replacements are interpolated into the stream when a match is found. @author &amp;lt;A HREF=&amp;quot;mailto:wes@cacas.org&amp;quot;&amp;gt;Wes Biggs&amp;lt; A&amp;gt; @deprecated This class cannot properly handle all character encodings. For proper handling, use the REFilterReader class instead.">
			<field name="expr" access="priv" jdoc=""/>
			<field name="replace" access="priv" jdoc=""/>
			<field name="buffer" access="priv" jdoc=""/>
			<field name="bufpos" access="priv" jdoc=""/>
			<field name="offset" access="priv" jdoc=""/>
			<field name="stream" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.REFilterInputStream.REFilterInputStream(InputStream, RE, String)" access="pub" jdoc="Creates an REFilterInputStream. When reading from this stream, occurrences of patterns matching the supplied regular expression will be replaced with the supplied replacement text (the metacharacters $0 through $9 may be used to refer to the full match or subexpression matches). @param stream The InputStream to be filtered. @param expr The regular expression to search for. @param replace The text pattern to replace matches with.">
				<param name="stream"/>
				<param name="expr"/>
				<param name="replace"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REFilterInputStream.read()" access="pub" jdoc="Reads the next byte from the stream per the general contract of InputStream.read(). Returns -1 on error or end of stream.">
				<comm cntt="If we have buffered replace data, use it."/>
				<comm cntt="check if input is at a valid position"/>
				<comm cntt="This is prone to infinite loops if replace string turns out empty."/>
			</mth>
			<mth name="/lib/:gnu.regexp.REFilterInputStream.markSupported()" access="pub" jdoc="Returns false. REFilterInputStream does not support mark() and reset() methods.">
			</mth>
			<mth name="/lib/:gnu.regexp.REFilterInputStream.read(byte[], int, int)" access="pub" jdoc="Reads from the stream into the provided array.">
				<param name="b"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REFilterInputStream.read(byte[])" access="pub" jdoc="Reads from the stream into the provided array.">
				<param name="b"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenBackRef" intfc="n" abs="n" inn="n" sloc="25" jdoc="">
			<comm cntt="should implement getMinimumLength() -- any ideas?"/>
			<field name="num" access="priv" jdoc=""/>
			<field name="insens" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.RETokenBackRef.RETokenBackRef(int, int, boolean)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="num"/>
				<param name="insens"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenBackRef.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<comm cntt="this shouldn&amp;apos;t happen, but..."/>
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenBackRef.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.CharIndexedInputStream" intfc="n" abs="n" inn="n" sloc="83" jdoc="">
			<comm cntt="value for end"/>
			<comm cntt="so that we don&amp;apos;t try to reset() right away"/>
			<comm cntt="Big enough for a \r\n pair"/>
			<comm cntt="lookBehind[0] = most recent"/>
			<comm cntt="lookBehind[1] = second most recent"/>
			<const name="BUFFER_INCREMENT" access="priv" jdoc=""/>
			<const name="UNKNOWN" access="priv" jdoc=""/>
			<field name="br" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="bufsize" access="priv" jdoc=""/>
			<field name="end" access="priv" jdoc=""/>
			<field name="cached" access="priv" jdoc=""/>
			<field name="lookBehind" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.CharIndexedInputStream.CharIndexedInputStream(InputStream, int)" access="pub" jdoc="">
				<param name="str"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedInputStream.next()" access="priv" jdoc="">
				<comm cntt="closer to end"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedInputStream.charAt(int)" access="pub" jdoc="">
				<comm cntt="Allocate more space in the buffer."/>
				<comm cntt="this.index is index of next pos relative to charAt(0)"/>
				<comm cntt="set flag that next should fail next time?"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedInputStream.move(int)" access="pub" jdoc="">
				<comm cntt="move read position [index] clicks from &amp;apos;charAt(0)&amp;apos;"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedInputStream.isValid()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenOneOf" intfc="n" abs="n" inn="n" sloc="72" jdoc="">
			<comm cntt="This constructor is used for convenience when we know the set beforehand,"/>
			<comm cntt="e.g. \d --&amp;gt; new RETokenOneOf(&amp;quot;0123456789&amp;quot;,false, ..)"/>
			<comm cntt="\D --&amp;gt; new RETokenOneOf(&amp;quot;0123456789&amp;quot;,true, ..)"/>
			<field name="options" access="priv" jdoc=""/>
			<field name="negative" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.RETokenOneOf.RETokenOneOf(int, String, boolean, boolean)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="optionsStr"/>
				<param name="negative"/>
				<param name="insens"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenOneOf.RETokenOneOf(int, Vector, boolean)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="options"/>
				<param name="negative"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenOneOf.getMinimumLength()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenOneOf.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<comm cntt="match was successful"/>
				<comm cntt="Add tryMatch to list of possibilities."/>
				<comm cntt="next succeeds"/>
				<comm cntt="is a match"/>
				<comm cntt="try next option"/>
				<comm cntt="set contents of mymatch equal to newMatch"/>
				<comm cntt="try each one that matched"/>
				<comm cntt="index+1 works for [^abc] lists, not for generic lookahead (--&amp;gt; index)"/>
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenOneOf.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenChar" intfc="n" abs="n" inn="n" sloc="38" jdoc="">
			<comm cntt="Overrides REToken.chain() to optimize for strings"/>
			<field name="ch" access="priv" jdoc=""/>
			<field name="insens" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.RETokenChar.RETokenChar(int, char, boolean)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="c"/>
				<param name="ins"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenChar.getMinimumLength()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenChar.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenChar.chain(REToken)" access="pub" jdoc="">
				<comm cntt="assume for now that next can only be one character"/>
				<param name="next"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenChar.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenWordBoundary" intfc="n" abs="n" inn="n" sloc="43" jdoc="Represents a combination lookahead lookbehind for POSIX [:alnum:].">
			<field name="negated" access="priv" jdoc=""/>
			<field name="where" access="priv" jdoc=""/>
			<const name="BEGIN" access="pub" jdoc=""/>
			<const name="END" access="pub" jdoc=""/>
			<mth name="/lib/:gnu.regexp.RETokenWordBoundary.RETokenWordBoundary(int, int, boolean)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="where"/>
				<param name="negated"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenWordBoundary.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<comm cntt="Word boundary means input[index-1] was a word character"/>
				<comm cntt="and input[index] is not, or input[index] is a word character"/>
				<comm cntt="and input[index-1] was not"/>
				<comm cntt="In the string &amp;quot;one two three&amp;quot;, these positions match:"/>
				<comm cntt="|o|n|e| |t|w|o| |t|h|r|e|e|"/>
				<comm cntt="^ ^ ^ ^ ^ ^"/>
				<comm cntt="is current character a letter or digit?"/>
				<comm cntt="is previous character a letter or digit?"/>
				<comm cntt="TODO: Also check REG_ANCHORINDEX vs. anchor"/>
				<comm cntt="if (before) and (!after), we&amp;apos;re at end (\&amp;gt;)"/>
				<comm cntt="if (after) and (!before), we&amp;apos;re at beginning (\&amp;lt;)"/>
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenWordBoundary.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenPOSIX" intfc="n" abs="n" inn="n" sloc="91" jdoc="">
			<comm cntt="Array indices correspond to constants defined above."/>
			<comm cntt="The RE constructor uses this to look up the constant for a string"/>
			<field name="type" access="pub" jdoc=""/>
			<field name="insens" access="pub" jdoc=""/>
			<field name="negated" access="pub" jdoc=""/>
			<const name="ALNUM" access="pub" jdoc=""/>
			<const name="ALPHA" access="pub" jdoc=""/>
			<const name="BLANK" access="pub" jdoc=""/>
			<const name="CNTRL" access="pub" jdoc=""/>
			<const name="DIGIT" access="pub" jdoc=""/>
			<const name="GRAPH" access="pub" jdoc=""/>
			<const name="LOWER" access="pub" jdoc=""/>
			<const name="PRINT" access="pub" jdoc=""/>
			<const name="PUNCT" access="pub" jdoc=""/>
			<const name="SPACE" access="pub" jdoc=""/>
			<const name="UPPER" access="pub" jdoc=""/>
			<const name="XDIGIT" access="pub" jdoc=""/>
			<const name="s_nameTable" access="pub" jdoc=""/>
			<mth name="/lib/:gnu.regexp.RETokenPOSIX.intValue(String)" access="pub" jdoc="">
				<param name="key"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenPOSIX.RETokenPOSIX(int, int, boolean, boolean)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="type"/>
				<param name="insens"/>
				<param name="negated"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenPOSIX.getMinimumLength()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenPOSIX.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<comm cntt="Note that there is some debate over whether &amp;apos;_&amp;apos; should be included"/>
				<comm cntt="This feels sloppy, especially for non-U.S. locales."/>
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenPOSIX.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.REToken" intfc="n" abs="y" inn="n" sloc="35" jdoc="">
			<field name="next" access="prot" jdoc=""/>
			<field name="uncle" access="prot" jdoc=""/>
			<field name="subIndex" access="prot" jdoc=""/>
			<mth name="/lib/:gnu.regexp.REToken.REToken(int)" access="prot" jdoc="">
				<param name="subIndex"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REToken.getMinimumLength()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.REToken.setUncle(REToken)" access="pub" jdoc="">
				<param name="anUncle"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REToken.match(CharIndexed, REMatch)" access="pub" jdoc="Returns true if the match succeeded, false if it failed.">
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REToken.next(CharIndexed, REMatch)" access="prot" jdoc="Returns true if the rest of the tokens match, false if they fail.">
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REToken.chain(REToken)" access="pub" jdoc="">
				<comm cntt="Token was accepted"/>
				<param name="token"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REToken.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REToken.dumpAll(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenRange" intfc="n" abs="n" inn="n" sloc="25" jdoc="">
			<field name="lo" access="priv" jdoc=""/>
			<field name="hi" access="priv" jdoc=""/>
			<field name="insens" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.RETokenRange.RETokenRange(int, char, char, boolean)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="lo"/>
				<param name="hi"/>
				<param name="ins"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenRange.getMinimumLength()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenRange.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenRange.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.REFilterReader" intfc="n" abs="n" inn="n" sloc="54" jdoc="Replaces instances of a given RE with replacement text. @author &amp;lt;A HREF=&amp;quot;http: www.csis.hku.hk ~sdlee &amp;quot;&amp;gt;Lee Sau Dan&amp;lt; A&amp;gt; @since gnu.regexp 1.1.0">
			<field name="expr" access="priv" jdoc=""/>
			<field name="replace" access="priv" jdoc=""/>
			<field name="buffer" access="priv" jdoc=""/>
			<field name="bufpos" access="priv" jdoc=""/>
			<field name="offset" access="priv" jdoc=""/>
			<field name="stream" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.REFilterReader.REFilterReader(Reader, RE, String)" access="pub" jdoc="Creates an REFilterReader. When reading from this stream, occurrences of patterns matching the supplied regular expression will be replaced with the supplied replacement text (the metacharacters $0 through $9 may be used to refer to the full match or subexpression matches. @param stream The Reader to be filtered. @param expr The regular expression to search for. @param replace The text pattern to replace matches with.">
				<param name="stream"/>
				<param name="expr"/>
				<param name="replace"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REFilterReader.read()" access="pub" jdoc="Reads the next character from the stream per the general contract of Reader.read(). Returns -1 on error or end of stream.">
				<comm cntt="If we have buffered replace data, use it."/>
				<comm cntt="check if input is at a valid position"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REFilterReader.markSupported()" access="pub" jdoc="Returns false. REFilterReader does not support mark() and reset() methods.">
			</mth>
			<mth name="/lib/:gnu.regexp.REFilterReader.read(char[], int, int)" access="pub" jdoc="Reads from the stream into the provided array.">
				<param name="b"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REFilterReader.read(char[])" access="pub" jdoc="Reads from the stream into the provided array.">
				<param name="b"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenEndSub" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/lib/:gnu.regexp.RETokenEndSub.RETokenEndSub(int)" access="pub" jdoc="">
				<param name="subIndex"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenEndSub.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenEndSub.dump(StringBuffer)" access="pub" jdoc="">
				<comm cntt="handled by RE"/>
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.REException" intfc="n" abs="n" inn="n" sloc="37" jdoc="This is the regular expression exception class. An exception of this type defines the three attributes: &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; A descriptive message of the error. &amp;lt;LI&amp;gt; An integral type code equivalent to one of the statically defined symbols listed below. &amp;lt;LI&amp;gt; The approximate position in the input string where the error occurred. &amp;lt; OL&amp;gt; @author &amp;lt;A HREF=&amp;quot;mailto:wes@cacas.org&amp;quot;&amp;gt;Wes Biggs&amp;lt; A&amp;gt;">
			<comm cntt="Error conditions from GNU regcomp(3) manual"/>
			<field name="type" access="priv" jdoc=""/>
			<field name="pos" access="priv" jdoc=""/>
			<const name="REG_BADRPT" access="pub" jdoc="Error flag. Invalid use of repetition operators such as using ` &amp;apos; as the first character."/>
			<const name="REG_BADBR" access="pub" jdoc="Error flag. Invalid use of back reference operator."/>
			<const name="REG_EBRACE" access="pub" jdoc="Error flag. Un-matched brace interval operators."/>
			<const name="REG_EBRACK" access="pub" jdoc="Error flag. Un-matched bracket list operators."/>
			<const name="REG_ERANGE" access="pub" jdoc="Error flag. Invalid use of the range operator, eg. the ending point of the range occurs prior to the starting point."/>
			<const name="REG_ECTYPE" access="pub" jdoc="Error flag. Unknown character class name. &amp;lt;B&amp;gt;Not implemented&amp;lt; B&amp;gt;."/>
			<const name="REG_EPAREN" access="pub" jdoc="Error flag. Un-matched parenthesis group operators."/>
			<const name="REG_ESUBREG" access="pub" jdoc="Error flag. Invalid back reference to a subexpression."/>
			<const name="REG_EEND" access="pub" jdoc="Error flag. Non specific error. &amp;lt;B&amp;gt;Not implemented&amp;lt; B&amp;gt;."/>
			<const name="REG_ESCAPE" access="pub" jdoc="Error flag. Invalid escape sequence. &amp;lt;B&amp;gt;Not implemented&amp;lt; B&amp;gt;."/>
			<const name="REG_BADPAT" access="pub" jdoc="Error flag. Invalid use of pattern operators such as group or list."/>
			<const name="REG_ESIZE" access="pub" jdoc="Error flag. Compiled regular expression requires a pattern buffer larger than 64Kb. &amp;lt;B&amp;gt;Not implemented&amp;lt; B&amp;gt;."/>
			<const name="REG_ESPACE" access="pub" jdoc="Error flag. The regex routines ran out of memory. &amp;lt;B&amp;gt;Not implemented&amp;lt; B&amp;gt;."/>
			<mth name="/lib/:gnu.regexp.REException.REException(String, int, int)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="type"/>
				<param name="position"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REException.getType()" access="pub" jdoc="Returns the type of the exception, one of the constants listed above.">
			</mth>
			<mth name="/lib/:gnu.regexp.REException.getPosition()" access="pub" jdoc="Returns the position, relative to the string or character array being compiled, where the error occurred. This position is generally the point where the error was detected, not necessarily the starting index of a bad subexpression.">
			</mth>
			<mth name="/lib/:gnu.regexp.REException.getMessage()" access="pub" jdoc="Reports the descriptive message associated with this exception as well as its index position in the string or character array being compiled.">
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.CharIndexed" intfc="y" abs="n" inn="n" sloc="6" jdoc="Defines the interface used internally so that different types of source text can be accessed in the same way. Built-in concrete classes provide support for String, StringBuffer, InputStream and char[] types. A class that is CharIndexed supports the notion of a cursor within a block of text. The cursor must be able to be advanced via the move() method. The charAt() method returns the character at the cursor position plus a given offset. @author &amp;lt;A HREF=&amp;quot;mailto:wes@cacas.org&amp;quot;&amp;gt;Wes Biggs&amp;lt; A&amp;gt;">
			<field name="OUT_OF_BOUNDS" access="pub" jdoc="Defines a constant (0xFFFF was somewhat arbitrarily chosen) that can be returned by the charAt() function indicating that the specified index is out of range."/>
			<mth name="/lib/:gnu.regexp.CharIndexed.charAt(int)" access="pub" jdoc="Returns the character at the given offset past the current cursor position in the input. The index of the current position is zero. It is possible for this method to be called with a negative index. This happens when using the &amp;apos;^&amp;apos; operator in multiline matching mode or the &amp;apos;\b&amp;apos; or &amp;apos;\&amp;lt;&amp;apos; word boundary operators. In any case, the lower bound is currently fixed at -2 (for &amp;apos;^&amp;apos; with a two-character newline). @param index the offset position in the character field to examine @return the character at the specified index, or the OUT_OF_BOUNDS character defined by this interface.">
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexed.move(int)" access="pub" jdoc="Shifts the input buffer by a given number of positions. Returns true if the new cursor position is valid.">
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexed.isValid()" access="pub" jdoc="Returns true if the most recent move() operation placed the cursor position at a valid position in the input.">
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.IntPair" intfc="n" abs="n" inn="n" sloc="3" jdoc="">
			<field name="first" access="pub" jdoc=""/>
			<field name="second" access="pub" jdoc=""/>
		</class>
		<class name="/lib/:gnu.regexp.CharUnit" intfc="n" abs="n" inn="n" sloc="4" jdoc="">
			<field name="ch" access="pub" jdoc=""/>
			<field name="bk" access="pub" jdoc=""/>
		</class>
		<class name="/lib/:gnu.regexp.RE" intfc="n" abs="n" inn="n" sloc="661" jdoc="RE provides the user interface for compiling and matching regular expressions. &amp;lt;P&amp;gt; A regular expression object (class RE) is compiled by constructing it from a String, StringBuffer or character array, with optional compilation flags (below) and an optional syntax specification (see RESyntax; if not specified, &amp;lt;code&amp;gt;RESyntax.RE_SYNTAX_PERL5&amp;lt; code&amp;gt; is used). &amp;lt;P&amp;gt; Various methods attempt to match input text against a compiled regular expression. These methods are: &amp;lt;LI&amp;gt;&amp;lt;code&amp;gt;isMatch&amp;lt; code&amp;gt;: returns true if the input text in its entirety matches the regular expression pattern. &amp;lt;LI&amp;gt;&amp;lt;code&amp;gt;getMatch&amp;lt; code&amp;gt;: returns the first match found in the input text, or null if no match is found. &amp;lt;LI&amp;gt;&amp;lt;code&amp;gt;getAllMatches&amp;lt; code&amp;gt;: returns an array of all non-overlapping matches found in the input text. If no matches are found, the array is zero-length. &amp;lt;LI&amp;gt;&amp;lt;code&amp;gt;substitute&amp;lt; code&amp;gt;: substitute the first occurence of the pattern in the input text with a replacement string (which may include metacharacters $0-$9, see REMatch.substituteInto). &amp;lt;LI&amp;gt;&amp;lt;code&amp;gt;substituteAll&amp;lt; code&amp;gt;: same as above, but repeat for each match before returning. &amp;lt;LI&amp;gt;&amp;lt;code&amp;gt;getMatchEnumeration&amp;lt; code&amp;gt;: returns an REMatchEnumeration object that allows iteration over the matches (see REMatchEnumeration for some reasons why you may want to do this instead of using &amp;lt;code&amp;gt;getAllMatches&amp;lt; code&amp;gt;. &amp;lt;P&amp;gt; These methods all have similar argument lists. The input can be a String, a character array, a StringBuffer, a Reader or an InputStream of some sort. Note that when using a Reader or InputStream, the stream read position cannot be guaranteed after attempting a match (this is not a bug, but a consequence of the way regular expressions work). Using an REMatchEnumeration can eliminate most positioning problems. &amp;lt;P&amp;gt; The optional index argument specifies the offset from the beginning of the text at which the search should start (see the descriptions of some of the execution flags for how this can affect positional pattern operators). For a Reader or InputStream, this means an offset from the current read position, so subsequent calls with the same index argument on a Reader or an InputStream will not necessarily access the same position on the stream, whereas repeated searches at a given index in a fixed string will return consistent results. &amp;lt;P&amp;gt; You can optionally affect the execution environment by using a combination of execution flags (constants listed below). &amp;lt;P&amp;gt; All operations on a regular expression are performed in a thread-safe manner. @author &amp;lt;A HREF=&amp;quot;mailto:wes@cacas.org&amp;quot;&amp;gt;Wes Biggs&amp;lt; A&amp;gt; @version 1.1.4-dev, to be released">
			<comm cntt="This String will be returned by getVersion()"/>
			<comm cntt="The localized strings are kept in a separate file"/>
			<comm cntt="These are, respectively, the first and last tokens in our linked list"/>
			<comm cntt="If there is only one token, firstToken == lastToken"/>
			<comm cntt="This is the number of subexpressions in this regular expression,"/>
			<comm cntt="with a minimum value of zero. Returned by getNumSubs()"/>
			<comm cntt="Retrieves a message from the ResourceBundle"/>
			<comm cntt="internal constructor used for alternation"/>
			<comm cntt="For use by subclasses"/>
			<comm cntt="The meat of construction"/>
			<comm cntt="Overrides REToken.setUncle"/>
			<comm cntt="Overrides REToken.chain"/>
			<comm cntt="this has been changed since 1.03 to be non-overlapping matches"/>
			<comm cntt="Implements abstract method REToken.match()"/>
			<comm cntt="Helper function for constructor"/>
			<comm cntt="Cast input appropriately or throw exception"/>
			<const name="VERSION" access="priv" jdoc=""/>
			<field name="messages" access="priv" jdoc=""/>
			<field name="firstToken" access="priv" jdoc=""/>
			<field name="lastToken" access="priv" jdoc=""/>
			<field name="numSubs" access="priv" jdoc=""/>
			<field name="minimumLength" access="priv" jdoc="Minimum length, in characters, of any possible match."/>
			<const name="REG_ICASE" access="pub" jdoc="Compilation flag. Do not differentiate case. Subsequent searches using this RE will be case insensitive."/>
			<const name="REG_DOT_NEWLINE" access="pub" jdoc="Compilation flag. The match-any-character operator (dot) will match a newline character. When set this overrides the syntax bit RE_DOT_NEWLINE (see RESyntax for details). This is equivalent to the &amp;quot; s&amp;quot; operator in Perl."/>
			<const name="REG_MULTILINE" access="pub" jdoc="Compilation flag. Use multiline mode. In this mode, the ^ and $ anchors will match based on newlines within the input. This is equivalent to the &amp;quot; m&amp;quot; operator in Perl."/>
			<const name="REG_NOTBOL" access="pub" jdoc="Execution flag. The match-beginning operator (^) will not match at the beginning of the input string. Useful for matching on a substring when you know the context of the input is such that position zero of the input to the match test is not actually position zero of the text. &amp;lt;P&amp;gt; This example demonstrates the results of various ways of matching on a substring. &amp;lt;P&amp;gt; &amp;lt;CODE&amp;gt; String s = &amp;quot;food bar fool&amp;quot;;&amp;lt;BR&amp;gt; RE exp = new RE(&amp;quot;^foo.&amp;quot;);&amp;lt;BR&amp;gt; REMatch m0 = exp.getMatch(s);&amp;lt;BR&amp;gt; REMatch m1 = exp.getMatch(s.substring(8));&amp;lt;BR&amp;gt; REMatch m2 = exp.getMatch(s.substring(8),0,RE.REG_NOTBOL); &amp;lt;BR&amp;gt; REMatch m3 = exp.getMatch(s,8); &amp;lt;BR&amp;gt; REMatch m4 = exp.getMatch(s,8,RE.REG_ANCHORINDEX); &amp;lt;BR&amp;gt; &amp;lt;P&amp;gt; Results:&amp;lt;BR&amp;gt; m0 = &amp;quot;food&amp;quot;&amp;lt;BR&amp;gt; m1 = &amp;quot;fool&amp;quot;&amp;lt;BR&amp;gt; m2 = null&amp;lt;BR&amp;gt; m3 = null&amp;lt;BR&amp;gt; m4 = &amp;quot;fool&amp;quot;&amp;lt;BR&amp;gt; &amp;lt; CODE&amp;gt;"/>
			<const name="REG_NOTEOL" access="pub" jdoc="Execution flag. The match-end operator ($) does not match at the end of the input string. Useful for matching on substrings."/>
			<const name="REG_ANCHORINDEX" access="pub" jdoc="Execution flag. When a match method is invoked that starts matching at a non-zero index into the input, treat the input as if it begins at the index given. The effect of this flag is that the engine does not &amp;quot;see&amp;quot; any text in the input before the given index. This is useful so that the match-beginning operator (^) matches not at position 0 in the input string, but at the position the search started at (based on the index input given to the getMatch function). See the example under REG_NOTBOL. It also affects the use of the \&amp;lt; and \b operators."/>
			<const name="REG_NO_INTERPOLATE" access="pub" jdoc="Execution flag. The substitute and substituteAll methods will not attempt to interpolate occurrences of $1-$9 in the replacement text with the corresponding subexpressions. For example, you may want to replace all matches of &amp;quot;one dollar&amp;quot; with &amp;quot;$1&amp;quot;."/>
			<mth name="/lib/:gnu.regexp.RE.version()" access="pub" jdoc="Returns a string representing the version of the gnu.regexp package.">
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getLocalizedMessage(String)" access="pub" jdoc="">
				<param name="key"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.RE(Object)" access="pub" jdoc="Constructs a regular expression pattern buffer without any compilation flags set, and using the default syntax (RESyntax.RE_SYNTAX_PERL5). @param pattern A regular expression pattern, in the form of a String, StringBuffer or char[]. Other input types will be converted to strings using the toString() method. @exception REException The input pattern could not be parsed. @exception NullPointerException The pattern was null.">
				<param name="pattern"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.RE(Object, int)" access="pub" jdoc="Constructs a regular expression pattern buffer using the specified compilation flags and the default syntax (RESyntax.RE_SYNTAX_PERL5). @param pattern A regular expression pattern, in the form of a String, StringBuffer, or char[]. Other input types will be converted to strings using the toString() method. @param cflags The logical OR of any combination of the compilation flags listed above. @exception REException The input pattern could not be parsed. @exception NullPointerException The pattern was null.">
				<param name="pattern"/>
				<param name="cflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.RE(Object, int, RESyntax)" access="pub" jdoc="Constructs a regular expression pattern buffer using the specified compilation flags and regular expression syntax. @param pattern A regular expression pattern, in the form of a String, StringBuffer, or char[]. Other input types will be converted to strings using the toString() method. @param cflags The logical OR of any combination of the compilation flags listed above. @param syntax The type of regular expression syntax to use. @exception REException The input pattern could not be parsed. @exception NullPointerException The pattern was null.">
				<param name="pattern"/>
				<param name="cflags"/>
				<param name="syntax"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.RE(REToken, REToken, int, int, int)" access="priv" jdoc="">
				<param name="first"/>
				<param name="last"/>
				<param name="subs"/>
				<param name="subIndex"/>
				<param name="minLength"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.RE(Object, int, RESyntax, int, int)" access="priv" jdoc="">
				<comm cntt="Subexpression index of this token."/>
				<param name="patternObj"/>
				<param name="cflags"/>
				<param name="syntax"/>
				<param name="myIndex"/>
				<param name="nextSub"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.RE()" access="prot" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.RE.initialize(Object, int, RESyntax, int, int)" access="prot" jdoc="">
				<comm cntt="Number of subexpressions in this token."/>
				<comm cntt="linked list of tokens (sort of -- some closed loops can exist)"/>
				<comm cntt="Precalculate these so we don&amp;apos;t pay for the math every time we"/>
				<comm cntt="need to access them."/>
				<comm cntt="Parse pattern into tokens. Does anyone know if it&amp;apos;s more efficient"/>
				<comm cntt="to use char[] than a String.charAt()? I&amp;apos;m assuming so."/>
				<comm cntt="index tracks the position in the char array"/>
				<comm cntt="this will be the current parse character (pattern[index])"/>
				<comm cntt="This is used for {x,y} calculations"/>
				<comm cntt="Buffer a token so we can create a TokenRepeated, etc."/>
				<comm cntt="read the next character unit (including backslash escapes)"/>
				<comm cntt="ALTERNATION OPERATOR"/>
				<comm cntt="\| or | (if RE_NO_BK_VBAR) or newline (if RE_NEWLINE_ALT)"/>
				<comm cntt="not available if RE_LIMITED_OPS is set"/>
				<comm cntt="TODO: the &amp;apos;\n&amp;apos; literal here should be a test against REToken.newline,"/>
				<comm cntt="which unfortunately may be more than a single character."/>
				<comm cntt="make everything up to here be a branch. create vector if nec."/>
				<comm cntt="INTERVAL OPERATOR:"/>
				<comm cntt="{x} | {x,} | {x,y} (RE_INTERVALS &amp;&amp; RE_NO_BK_BRACES)"/>
				<comm cntt="\{x\} | \{x,\} | \{x,y\} (RE_INTERVALS &amp;&amp; !RE_NO_BK_BRACES)"/>
				<comm cntt=""/>
				<comm cntt="OPEN QUESTION:"/>
				<comm cntt="what is proper interpretation of &amp;apos;{&amp;apos; at start of string?"/>
				<comm cntt="LIST OPERATOR:"/>
				<comm cntt="[...] | [^...]"/>
				<comm cntt="Check for initial caret, negation"/>
				<comm cntt="Check for leading right bracket literal"/>
				<comm cntt="while in list"/>
				<comm cntt="Out of list, index is one past &amp;apos;]&amp;apos;"/>
				<comm cntt="Create a new RETokenOneOf"/>
				<comm cntt="SUBEXPRESSIONS"/>
				<comm cntt="(...) | \(...\) depending on RE_NO_BK_PARENS"/>
				<comm cntt="find end of subexpression"/>
				<comm cntt="endIndex is now position at a &amp;apos;)&amp;apos;,&amp;apos;\)&amp;apos;"/>
				<comm cntt="nextIndex is end of string or position after &amp;apos;)&amp;apos; or &amp;apos;\)&amp;apos;"/>
				<comm cntt="not a comment"/>
				<comm cntt="create RE subexpression as token."/>
				<comm cntt="not a comment"/>
				<comm cntt="subexpression"/>
				<comm cntt="UNMATCHED RIGHT PAREN"/>
				<comm cntt=") or \) throw exception if"/>
				<comm cntt="!syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD)"/>
				<comm cntt="START OF LINE OPERATOR"/>
				<comm cntt="^"/>
				<comm cntt="END OF LINE OPERATOR"/>
				<comm cntt="$"/>
				<comm cntt="MATCH-ANY-CHARACTER OPERATOR (except possibly newline and null)"/>
				<comm cntt="."/>
				<comm cntt="ZERO-OR-MORE REPEAT OPERATOR"/>
				<comm cntt=""/>
				<comm cntt="ONE-OR-MORE REPEAT OPERATOR"/>
				<comm cntt="+ | \+ depending on RE_BK_PLUS_QM"/>
				<comm cntt="not available if RE_LIMITED_OPS is set"/>
				<comm cntt="ZERO-OR-ONE REPEAT OPERATOR STINGY MATCHING OPERATOR"/>
				<comm cntt="? | \? depending on RE_BK_PLUS_QM"/>
				<comm cntt="not available if RE_LIMITED_OPS is set"/>
				<comm cntt="stingy matching if RE_STINGY_OPS is set and it follows a quantifier"/>
				<comm cntt="Check for stingy matching on RETokenRepeated"/>
				<comm cntt="BACKREFERENCE OPERATOR"/>
				<comm cntt="\1 \2 ... \9"/>
				<comm cntt="not available if RE_NO_BK_REFS is set"/>
				<comm cntt="START OF STRING OPERATOR"/>
				<comm cntt="\A if RE_STRING_ANCHORS is set"/>
				<comm cntt="WORD BREAK OPERATOR"/>
				<comm cntt="\b if ????"/>
				<comm cntt="WORD BEGIN OPERATOR"/>
				<comm cntt="\&amp;lt; if ????"/>
				<comm cntt="WORD END OPERATOR"/>
				<comm cntt="\&amp;gt; if ????"/>
				<comm cntt="NON-WORD BREAK OPERATOR"/>
				<comm cntt="\B if ????"/>
				<comm cntt="DIGIT OPERATOR"/>
				<comm cntt="\d if RE_CHAR_CLASS_ESCAPES is set"/>
				<comm cntt="NON-DIGIT OPERATOR"/>
				<comm cntt="\D"/>
				<comm cntt="NEWLINE ESCAPE"/>
				<comm cntt="\n"/>
				<comm cntt="RETURN ESCAPE"/>
				<comm cntt="\r"/>
				<comm cntt="WHITESPACE OPERATOR"/>
				<comm cntt="\s if RE_CHAR_CLASS_ESCAPES is set"/>
				<comm cntt="NON-WHITESPACE OPERATOR"/>
				<comm cntt="\S"/>
				<comm cntt="TAB ESCAPE"/>
				<comm cntt="\t"/>
				<comm cntt="ALPHANUMERIC OPERATOR"/>
				<comm cntt="\w"/>
				<comm cntt="NON-ALPHANUMERIC OPERATOR"/>
				<comm cntt="\W"/>
				<comm cntt="END OF STRING OPERATOR"/>
				<comm cntt="\Z"/>
				<comm cntt="NON-SPECIAL CHARACTER (or escape to make literal)"/>
				<comm cntt="c | \ for example"/>
				<comm cntt="not a special character"/>
				<comm cntt="end while"/>
				<comm cntt="Add final buffered token and an EndSub marker"/>
				<comm cntt="compact the Vector"/>
				<param name="patternObj"/>
				<param name="cflags"/>
				<param name="syntax"/>
				<param name="myIndex"/>
				<param name="nextSub"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getCharUnit(char[], int, CharUnit)" access="priv" jdoc="">
				<param name="input"/>
				<param name="index"/>
				<param name="unit"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.isMatch(Object)" access="pub" jdoc="Checks if the regular expression matches the input in its entirety. @param input The input text.">
				<param name="input"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.isMatch(Object, int)" access="pub" jdoc="Checks if the input string, starting from index, is an exact match of this regular expression. @param input The input text. @param index The offset index at which the search should be begin.">
				<param name="input"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.isMatch(Object, int, int)" access="pub" jdoc="Checks if the input, starting from index and using the specified execution flags, is an exact match of this regular expression. @param input The input text. @param index The offset index at which the search should be begin. @param eflags The logical OR of any execution flags above.">
				<param name="input"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.isMatchImpl(CharIndexed, int, int)" access="priv" jdoc="">
				<comm cntt="Trivial case"/>
				<param name="input"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getNumSubs()" access="pub" jdoc="Returns the maximum number of subexpressions in this regular expression. If the expression contains branches, the value returned will be the maximum subexpressions in any of the branches.">
			</mth>
			<mth name="/lib/:gnu.regexp.RE.setUncle(REToken)" access="pub" jdoc="">
				<comm cntt="to deal with empty subexpressions"/>
				<param name="uncle"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.chain(REToken)" access="pub" jdoc="">
				<param name="next"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMinimumLength()" access="pub" jdoc="Returns the minimum number of characters that could possibly constitute a match of this regular expression.">
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getAllMatches(Object)" access="pub" jdoc="Returns an array of all matches found in the input. If the regular expression allows the empty string to match, it will substitute matches at all positions except the end of the input. @param input The input text. @return a non-null (but possibly zero-length) array of matches">
				<param name="input"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getAllMatches(Object, int)" access="pub" jdoc="Returns an array of all matches found in the input, beginning at the specified index position. If the regular expression allows the empty string to match, it will substitute matches at all positions except the end of the input. @param input The input text. @param index The offset index at which the search should be begin. @return a non-null (but possibly zero-length) array of matches">
				<param name="input"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getAllMatches(Object, int, int)" access="pub" jdoc="Returns an array of all matches found in the input string, beginning at the specified index position and using the specified execution flags. If the regular expression allows the empty string to match, it will substitute matches at all positions except the end of the input. @param input The input text. @param index The offset index at which the search should be begin. @param eflags The logical OR of any execution flags above. @return a non-null (but possibly zero-length) array of matches">
				<param name="input"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getAllMatchesImpl(CharIndexed, int, int)" access="priv" jdoc="">
				<comm cntt="handle pathological case of zero-length match"/>
				<param name="input"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<comm cntt="Note the start of this subexpression"/>
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMatch(Object)" access="pub" jdoc="Returns the first match found in the input. If no match is found, null is returned. @param input The input text. @return An REMatch instance referencing the match, or null if none.">
				<param name="input"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMatch(Object, int)" access="pub" jdoc="Returns the first match found in the input, beginning the search at the specified index. If no match is found, returns null. @param input The input text. @param index The offset within the text to begin looking for a match. @return An REMatch instance referencing the match, or null if none.">
				<param name="input"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMatch(Object, int, int)" access="pub" jdoc="Returns the first match found in the input, beginning the search at the specified index, and using the specified execution flags. If no match is found, returns null. @param input The input text. @param index The offset index at which the search should be begin. @param eflags The logical OR of any execution flags above. @return An REMatch instance referencing the match, or null if none.">
				<param name="input"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMatch(Object, int, int, StringBuffer)" access="pub" jdoc="Returns the first match found in the input, beginning the search at the specified index, and using the specified execution flags. If no match is found, returns null. If a StringBuffer is provided and is non-null, the contents of the input text from the index to the beginning of the match (or to the end of the input, if there is no match) are appended to the StringBuffer. @param input The input text. @param index The offset index at which the search should be begin. @param eflags The logical OR of any execution flags above. @param buffer The StringBuffer to save pre-match text in. @return An REMatch instance referencing the match, or null if none.">
				<param name="input"/>
				<param name="index"/>
				<param name="eflags"/>
				<param name="buffer"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMatchImpl(CharIndexed, int, int, StringBuffer)" access="pub" jdoc="">
				<comm cntt="Create a new REMatch to hold results"/>
				<comm cntt="Optimization: check if anchor + minimumLength &amp;gt; length"/>
				<comm cntt="Find longest match of them all to observe leftmost longest"/>
				<comm cntt="Append character to buffer if needed"/>
				<param name="input"/>
				<param name="anchor"/>
				<param name="eflags"/>
				<param name="buffer"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMatchEnumeration(Object)" access="pub" jdoc="Returns an REMatchEnumeration that can be used to iterate over the matches found in the input text. @param input The input text. @return A non-null REMatchEnumeration instance.">
				<param name="input"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMatchEnumeration(Object, int)" access="pub" jdoc="Returns an REMatchEnumeration that can be used to iterate over the matches found in the input text. @param input The input text. @param index The offset index at which the search should be begin. @return A non-null REMatchEnumeration instance, with its input cursor set to the index position specified.">
				<param name="input"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMatchEnumeration(Object, int, int)" access="pub" jdoc="Returns an REMatchEnumeration that can be used to iterate over the matches found in the input text. @param input The input text. @param index The offset index at which the search should be begin. @param eflags The logical OR of any execution flags above. @return A non-null REMatchEnumeration instance, with its input cursor set to the index position specified.">
				<param name="input"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.substitute(Object, String)" access="pub" jdoc="Substitutes the replacement text for the first match found in the input. @param input The input text. @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto). @return A String interpolating the substituted text. @see REMatch#substituteInto">
				<param name="input"/>
				<param name="replace"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.substitute(Object, String, int)" access="pub" jdoc="Substitutes the replacement text for the first match found in the input beginning at the specified index position. Specifying an index effectively causes the regular expression engine to throw away the specified number of characters. @param input The input text. @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto). @param index The offset index at which the search should be begin. @return A String containing the substring of the input, starting at the index position, and interpolating the substituted text. @see REMatch#substituteInto">
				<param name="input"/>
				<param name="replace"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.substitute(Object, String, int, int)" access="pub" jdoc="Substitutes the replacement text for the first match found in the input string, beginning at the specified index position and using the specified execution flags. @param input The input text. @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto). @param index The offset index at which the search should be begin. @param eflags The logical OR of any execution flags above. @return A String containing the substring of the input, starting at the index position, and interpolating the substituted text. @see REMatch#substituteInto">
				<param name="input"/>
				<param name="replace"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.substituteImpl(CharIndexed, String, int, int)" access="priv" jdoc="">
				<param name="input"/>
				<param name="replace"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.substituteAll(Object, String)" access="pub" jdoc="Substitutes the replacement text for each non-overlapping match found in the input text. @param input The input text. @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto). @return A String interpolating the substituted text. @see REMatch#substituteInto">
				<param name="input"/>
				<param name="replace"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.substituteAll(Object, String, int)" access="pub" jdoc="Substitutes the replacement text for each non-overlapping match found in the input text, starting at the specified index. If the regular expression allows the empty string to match, it will substitute matches at all positions except the end of the input. @param input The input text. @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto). @param index The offset index at which the search should be begin. @return A String containing the substring of the input, starting at the index position, and interpolating the substituted text. @see REMatch#substituteInto">
				<param name="input"/>
				<param name="replace"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.substituteAll(Object, String, int, int)" access="pub" jdoc="Substitutes the replacement text for each non-overlapping match found in the input text, starting at the specified index and using the specified execution flags. @param input The input text. @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto). @param index The offset index at which the search should be begin. @param eflags The logical OR of any execution flags above. @return A String containing the substring of the input, starting at the index position, and interpolating the substituted text. @see REMatch#substituteInto">
				<param name="input"/>
				<param name="replace"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.substituteAllImpl(CharIndexed, String, int, int)" access="priv" jdoc="">
				<param name="input"/>
				<param name="replace"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.addToken(REToken)" access="priv" jdoc="">
				<comm cntt="if chain returns false, it &amp;quot;rejected&amp;quot; the token due to"/>
				<comm cntt="an optimization, and next was combined with lastToken"/>
				<param name="next"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.setRepeated(REToken, int, int, int)" access="priv" jdoc="">
				<param name="current"/>
				<param name="min"/>
				<param name="max"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getPosixSet(char[], int, StringBuffer)" access="priv" jdoc="">
				<comm cntt="Precondition: pattern[index-1] == &amp;apos;:&amp;apos;"/>
				<comm cntt="we will return pos of closing &amp;apos;]&amp;apos;."/>
				<comm cntt="didn&amp;apos;t match up"/>
				<param name="pattern"/>
				<param name="index"/>
				<param name="buf"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.getMinMax(char[], int, IntPair, RESyntax)" access="priv" jdoc="">
				<comm cntt="Precondition: input[index-1] == &amp;apos;{&amp;apos;, minMax != null"/>
				<comm cntt="Read string of digits"/>
				<comm cntt="Check for {} tomfoolery"/>
				<comm cntt="Read string of digits"/>
				<comm cntt="This is the case of {x,}"/>
				<comm cntt="We know min and max now, and they are valid."/>
				<comm cntt="return the index following the &amp;apos;}&amp;apos;"/>
				<param name="input"/>
				<param name="index"/>
				<param name="minMax"/>
				<param name="syntax"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.toString()" access="pub" jdoc="Return a human readable form of the compiled regular expression, useful for debugging.">
			</mth>
			<mth name="/lib/:gnu.regexp.RE.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RE.makeCharIndexed(Object, int)" access="priv" jdoc="">
				<comm cntt="We could let a String fall through to final input, but since"/>
				<comm cntt="it&amp;apos;s the most likely input type, we check it first."/>
				<comm cntt="do we lose index info?"/>
				<param name="input"/>
				<param name="index"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.CharIndexedStringBuffer" intfc="n" abs="n" inn="n" sloc="18" jdoc="">
			<field name="s" access="priv" jdoc=""/>
			<field name="anchor" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.CharIndexedStringBuffer.CharIndexedStringBuffer(StringBuffer, int)" access="pub" jdoc="">
				<param name="str"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedStringBuffer.charAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedStringBuffer.isValid()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedStringBuffer.move(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.REMatchEnumeration" intfc="n" abs="n" inn="n" sloc="45" jdoc="An REMatchEnumeration enumerates regular expression matches over a given input text. You obtain a reference to an enumeration using the &amp;lt;code&amp;gt;getMatchEnumeration()&amp;lt; code&amp;gt; methods on an instance of RE. &amp;lt;P&amp;gt; REMatchEnumeration does lazy computation; that is, it will not search for a match until it needs to. If you&amp;apos;d rather just get all the matches at once in a big array, use the &amp;lt;code&amp;gt;getAllMatches()&amp;lt; code&amp;gt; methods on RE. However, using an enumeration can help speed performance when the entire text does not need to be searched immediately. &amp;lt;P&amp;gt; The enumerated type is especially useful when searching on a Reader or InputStream, because the InputStream read position cannot be guaranteed after calling &amp;lt;code&amp;gt;getMatch()&amp;lt; code&amp;gt; (see the description of that method for an explanation of why). Enumeration also saves a lot of overhead required when calling &amp;lt;code&amp;gt;getMatch()&amp;lt; code&amp;gt; multiple times. @author &amp;lt;A HREF=&amp;quot;mailto:wes@cacas.org&amp;quot;&amp;gt;Wes Biggs&amp;lt; A&amp;gt;">
			<comm cntt="Package scope constructor is used by RE.getMatchEnumeration()"/>
			<const name="YES" access="priv" jdoc=""/>
			<const name="MAYBE" access="priv" jdoc=""/>
			<const name="NO" access="priv" jdoc=""/>
			<field name="more" access="priv" jdoc=""/>
			<field name="match" access="priv" jdoc=""/>
			<field name="expr" access="priv" jdoc=""/>
			<field name="input" access="priv" jdoc=""/>
			<field name="eflags" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.REMatchEnumeration.REMatchEnumeration(RE, CharIndexed, int, int)" access="pub" jdoc="">
				<param name="expr"/>
				<param name="input"/>
				<param name="index"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatchEnumeration.hasMoreElements()" access="pub" jdoc="Returns true if there are more matches in the input text.">
			</mth>
			<mth name="/lib/:gnu.regexp.REMatchEnumeration.hasMoreMatches()" access="pub" jdoc="Returns true if there are more matches in the input text.">
			</mth>
			<mth name="/lib/:gnu.regexp.REMatchEnumeration.hasMoreMatches(StringBuffer)" access="pub" jdoc="Returns true if there are more matches in the input text. Saves the text leading up to the match (or to the end of the input) in the specified buffer.">
				<param name="buffer"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatchEnumeration.nextElement()" access="pub" jdoc="Returns the next match in the input text.">
			</mth>
			<mth name="/lib/:gnu.regexp.REMatchEnumeration.nextMatch()" access="pub" jdoc="Returns the next match in the input text. This method is provided for convenience to avoid having to explicitly cast the return value to class REMatch.">
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenStart" intfc="n" abs="n" inn="n" sloc="38" jdoc="">
			<comm cntt="matches after a newline"/>
			<field name="newline" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.RETokenStart.RETokenStart(int, String)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="newline"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenStart.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<comm cntt="charAt(index-n) may be unknown on a Reader InputStream. FIXME"/>
				<comm cntt="Match after a newline if in multiline mode"/>
				<comm cntt="position in REToken.newline"/>
				<comm cntt="Don&amp;apos;t match at all if REG_NOTBOL is set."/>
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenStart.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenRepeated" intfc="n" abs="n" inn="n" sloc="123" jdoc="">
			<comm cntt="We do need to save every possible point, but the number of clone()"/>
			<comm cntt="invocations here is really a killer for performance on non-stingy"/>
			<comm cntt="repeat operators. I&amp;apos;m open to suggestions..."/>
			<comm cntt="Hypothetical question: can you have a RE that matches 1 times,"/>
			<comm cntt="3 times, 5 times, but not 2 times or 4 times? Does having"/>
			<comm cntt="the subexpression back-reference operator allow that?"/>
			<field name="token" access="priv" jdoc=""/>
			<field name="min" access="priv" jdoc=""/>
			<field name="max" access="priv" jdoc=""/>
			<field name="stingy" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.RETokenRepeated.RETokenRepeated(int, REToken, int, int)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="token"/>
				<param name="min"/>
				<param name="max"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenRepeated.makeStingy()" access="pub" jdoc="Sets the minimal matching mode to true.">
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenRepeated.isStingy()" access="pub" jdoc="Queries if this token has minimal matching enabled.">
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenRepeated.getMinimumLength()" access="pub" jdoc="The minimum length of a repeated token is the minimum length of the token multiplied by the minimum number of times it must match.">
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenRepeated.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<comm cntt="number of times we&amp;apos;ve matched so far"/>
				<comm cntt="Possible positions for the next repeat to match at"/>
				<comm cntt="Add the &amp;apos;0-repeats&amp;apos; index"/>
				<comm cntt="positions.elementAt(z) == position [] in input after &amp;lt;&amp;lt;z&amp;gt;&amp;gt; matches"/>
				<comm cntt="Declare variables used in loop"/>
				<comm cntt="Check for stingy match for each possibility."/>
				<comm cntt="try next repeat at all possible positions"/>
				<comm cntt="add all items in current to doables array"/>
				<comm cntt="Order these from longest to shortest"/>
				<comm cntt="Start by assuming longest (more repeats)"/>
				<comm cntt="Find new doablesLast"/>
				<comm cntt="if none of the possibilities worked out, break out of do while"/>
				<comm cntt="reassign where the next repeat can match"/>
				<comm cntt="increment how many repeats we&amp;apos;ve successfully found"/>
				<comm cntt="If there aren&amp;apos;t enough repeats, then fail"/>
				<comm cntt="We&amp;apos;re greedy, but ease off until a true match is found"/>
				<comm cntt="At this point we&amp;apos;ve either got too many or just the right amount."/>
				<comm cntt="See if this numRepeats works with the rest of the regexp."/>
				<comm cntt="Order these from longest to shortest"/>
				<comm cntt="Start by assuming longest (more repeats)"/>
				<comm cntt="Find new doablesLast"/>
				<comm cntt="else did not match rest of the tokens, try again on smaller sample"/>
				<comm cntt="does this get all?"/>
				<comm cntt="If we fall out, no matches."/>
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenRepeated.matchRest(CharIndexed, REMatch)" access="priv" jdoc="">
				<comm cntt="Test all possible matches for this number of repeats"/>
				<comm cntt="clone() separates a single match from the chain"/>
				<comm cntt="chain results to doneIndex"/>
				<comm cntt="Find new doneIndexLast"/>
				<param name="input"/>
				<param name="newMatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenRepeated.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.CharIndexedReader" intfc="n" abs="n" inn="n" sloc="91" jdoc="">
			<comm cntt="value for end"/>
			<comm cntt="so that we don&amp;apos;t try to reset() right away"/>
			<comm cntt="Big enough for a \r\n pair"/>
			<comm cntt="lookBehind[0] = most recent"/>
			<comm cntt="lookBehind[1] = second most recent"/>
			<const name="BUFFER_INCREMENT" access="priv" jdoc=""/>
			<const name="UNKNOWN" access="priv" jdoc=""/>
			<const name="br" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="bufsize" access="priv" jdoc=""/>
			<field name="end" access="priv" jdoc=""/>
			<field name="cached" access="priv" jdoc=""/>
			<field name="lookBehind" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.CharIndexedReader.CharIndexedReader(Reader, int)" access="pub" jdoc="">
				<param name="reader"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedReader.next()" access="priv" jdoc="">
				<comm cntt="closer to end"/>
				<comm cntt="convert the byte read into a char"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedReader.charAt(int)" access="pub" jdoc="">
				<comm cntt="Allocate more space in the buffer."/>
				<comm cntt="this.index is index of next pos relative to charAt(0)"/>
				<comm cntt="set flag that next should fail next time?"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedReader.move(int)" access="pub" jdoc="">
				<comm cntt="move read position [index] clicks from &amp;apos;charAt(0)&amp;apos;"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedReader.isValid()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RESyntax" intfc="n" abs="n" inn="n" sloc="174" jdoc="An RESyntax specifies the way a regular expression will be compiled. This class provides a number of predefined useful constants for emulating popular regular expression syntaxes. Additionally the user may construct his or her own syntax, using any combination of the syntax bit constants. The syntax is an optional argument to any of the matching methods on class RE. @author &amp;lt;A HREF=&amp;quot;mailto:wes@cacas.org&amp;quot;&amp;gt;Wes Biggs&amp;lt; A&amp;gt;">
			<comm cntt="true for the constant defined syntaxes"/>
			<comm cntt="Values for constants are bit indexes"/>
			<comm cntt="impl."/>
			<comm cntt="single line mode ( s)"/>
			<comm cntt="Define syntaxes"/>
			<comm cntt="P1003.2 D11.2, section 4.20.7.1, lines 5078ff."/>
			<comm cntt="Differs from RE_SYNTAX_POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added."/>
			<comm cntt="There is no official Perl spec, but here&amp;apos;s a &amp;quot;best guess&amp;quot;"/>
			<comm cntt="except for &amp;apos;{&amp;apos;, apparently"/>
			<comm cntt="\d,\D,\w,\W,\s,\S"/>
			<comm cntt="(?:)"/>
			<comm cntt="?,??,+?,{}?"/>
			<comm cntt="(?=)(?!)"/>
			<comm cntt="\A,\Z"/>
			<comm cntt="\d,\D,\w,\W,\s,\S within []"/>
			<comm cntt="(?#)"/>
			<const name="DEFAULT_LINE_SEPARATOR" access="pub" jdoc=""/>
			<const name="SYNTAX_IS_FINAL" access="priv" jdoc=""/>
			<field name="bits" access="priv" jdoc=""/>
			<field name="isFinal" access="priv" jdoc=""/>
			<field name="lineSeparator" access="priv" jdoc=""/>
			<const name="RE_BACKSLASH_ESCAPE_IN_LISTS" access="pub" jdoc="Syntax bit. Backslash is an escape character in lists."/>
			<const name="RE_BK_PLUS_QM" access="pub" jdoc="Syntax bit. Use \? instead of ? and \+ instead of +."/>
			<const name="RE_CHAR_CLASSES" access="pub" jdoc="Syntax bit. POSIX character classes ([:...:]) in lists are allowed."/>
			<const name="RE_CONTEXT_INDEP_ANCHORS" access="pub" jdoc="Syntax bit. ^ and $ are special everywhere. &amp;lt;B&amp;gt;Not implemented.&amp;lt; B&amp;gt;"/>
			<const name="RE_CONTEXT_INDEP_OPS" access="pub" jdoc="Syntax bit. Repetition operators are only special in valid positions. &amp;lt;B&amp;gt;Not implemented.&amp;lt; B&amp;gt;"/>
			<const name="RE_CONTEXT_INVALID_OPS" access="pub" jdoc="Syntax bit. Repetition and alternation operators are invalid at start and end of pattern and other places. &amp;lt;B&amp;gt;Not implemented&amp;lt; B&amp;gt;."/>
			<const name="RE_DOT_NEWLINE" access="pub" jdoc="Syntax bit. Match-any-character operator (.) matches a newline."/>
			<const name="RE_DOT_NOT_NULL" access="pub" jdoc="Syntax bit. Match-any-character operator (.) does not match a null."/>
			<const name="RE_INTERVALS" access="pub" jdoc="Syntax bit. Intervals ({x}, {x,}, {x,y}) are allowed."/>
			<const name="RE_LIMITED_OPS" access="pub" jdoc="Syntax bit. No alternation (|), match one-or-more (+), or match zero-or-one (?) operators."/>
			<const name="RE_NEWLINE_ALT" access="pub" jdoc="Syntax bit. Newline is an alternation operator."/>
			<const name="RE_NO_BK_BRACES" access="pub" jdoc="Syntax bit. Intervals use { } instead of \{ \}"/>
			<const name="RE_NO_BK_PARENS" access="pub" jdoc="Syntax bit. Grouping uses ( ) instead of \( \)."/>
			<const name="RE_NO_BK_REFS" access="pub" jdoc="Syntax bit. Backreferences not allowed."/>
			<const name="RE_NO_BK_VBAR" access="pub" jdoc="Syntax bit. Alternation uses | instead of \|"/>
			<const name="RE_NO_EMPTY_RANGES" access="pub" jdoc="Syntax bit. &amp;lt;B&amp;gt;Not implemented&amp;lt; B&amp;gt;."/>
			<const name="RE_UNMATCHED_RIGHT_PAREN_ORD" access="pub" jdoc="Syntax bit. An unmatched right parenthesis (&amp;apos;)&amp;apos; or &amp;apos;\)&amp;apos;, depending on RE_NO_BK_PARENS) will throw an exception when compiling."/>
			<const name="RE_HAT_LISTS_NOT_NEWLINE" access="pub" jdoc="Syntax bit. &amp;lt;B&amp;gt;Not implemented.&amp;lt; B&amp;gt;"/>
			<const name="RE_STINGY_OPS" access="pub" jdoc="Syntax bit. Stingy matching is allowed (+?, ?, ??, {x,y}?)."/>
			<const name="RE_CHAR_CLASS_ESCAPES" access="pub" jdoc="Syntax bit. Allow character class escapes (\d, \D, \s, \S, \w, \W)."/>
			<const name="RE_PURE_GROUPING" access="pub" jdoc="Syntax bit. Allow use of (?:xxx) grouping (subexpression is not saved)."/>
			<const name="RE_LOOKAHEAD" access="pub" jdoc="Syntax bit. Allow use of (?=xxx) and (?!xxx) apply the subexpression to the text following the current position without consuming that text."/>
			<const name="RE_STRING_ANCHORS" access="pub" jdoc="Syntax bit. Allow beginning- and end-of-string anchors (\A, \Z)."/>
			<const name="RE_COMMENTS" access="pub" jdoc="Syntax bit. Allow embedded comments, (?#comment), as in Perl5."/>
			<const name="RE_CHAR_CLASS_ESC_IN_LISTS" access="pub" jdoc="Syntax bit. Allow character class escapes within lists, as in Perl5."/>
			<const name="BIT_TOTAL" access="priv" jdoc=""/>
			<const name="RE_SYNTAX_AWK" access="pub" jdoc="Predefined syntax. Emulates regular expression support in the awk utility."/>
			<const name="RE_SYNTAX_ED" access="pub" jdoc="Predefined syntax. Emulates regular expression support in the ed utility."/>
			<const name="RE_SYNTAX_EGREP" access="pub" jdoc="Predefined syntax. Emulates regular expression support in the egrep utility."/>
			<const name="RE_SYNTAX_EMACS" access="pub" jdoc="Predefined syntax. Emulates regular expression support in the GNU Emacs editor."/>
			<const name="RE_SYNTAX_GREP" access="pub" jdoc="Predefined syntax. Emulates regular expression support in the grep utility."/>
			<const name="RE_SYNTAX_POSIX_AWK" access="pub" jdoc="Predefined syntax. Emulates regular expression support in the POSIX awk specification."/>
			<const name="RE_SYNTAX_POSIX_BASIC" access="pub" jdoc="Predefined syntax. Emulates POSIX basic regular expression support."/>
			<const name="RE_SYNTAX_POSIX_EGREP" access="pub" jdoc="Predefined syntax. Emulates regular expression support in the POSIX egrep specification."/>
			<const name="RE_SYNTAX_POSIX_EXTENDED" access="pub" jdoc="Predefined syntax. Emulates POSIX extended regular expression support."/>
			<const name="RE_SYNTAX_POSIX_MINIMAL_BASIC" access="pub" jdoc="Predefined syntax. Emulates POSIX basic minimal regular expressions."/>
			<const name="RE_SYNTAX_POSIX_MINIMAL_EXTENDED" access="pub" jdoc="Predefined syntax. Emulates POSIX extended minimal regular expressions."/>
			<const name="RE_SYNTAX_SED" access="pub" jdoc="Predefined syntax. Emulates regular expression support in the sed utility."/>
			<const name="RE_SYNTAX_PERL4" access="pub" jdoc="Predefined syntax. Emulates regular expression support in Larry Wall&amp;apos;s perl, version 4,"/>
			<const name="RE_SYNTAX_PERL4_S" access="pub" jdoc="Predefined syntax. Emulates regular expression support in Larry Wall&amp;apos;s perl, version 4, using single line mode ( s modifier)."/>
			<const name="RE_SYNTAX_PERL5" access="pub" jdoc="Predefined syntax. Emulates regular expression support in Larry Wall&amp;apos;s perl, version 5."/>
			<const name="RE_SYNTAX_PERL5_S" access="pub" jdoc="Predefined syntax. Emulates regular expression support in Larry Wall&amp;apos;s perl, version 5, using single line mode ( s modifier)."/>
			<mth name="/lib/:gnu.regexp.RESyntax.RESyntax()" access="pub" jdoc="Construct a new syntax object with all bits turned off. This is equivalent to RE_SYNTAX_EMACS.">
			</mth>
			<mth name="/lib/:gnu.regexp.RESyntax.makeFinal()" access="pub" jdoc="Called internally when constructing predefined syntaxes so their interpretation cannot vary. Conceivably useful for your syntaxes as well. Causes IllegalAccessError to be thrown if any attempt to modify the syntax is made. @return this object for convenient chaining">
			</mth>
			<mth name="/lib/:gnu.regexp.RESyntax.RESyntax(RESyntax)" access="pub" jdoc="Construct a new syntax object with all bits set the same as the other syntax.">
				<param name="other"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RESyntax.get(int)" access="pub" jdoc="Check if a given bit is set in this syntax.">
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RESyntax.set(int)" access="pub" jdoc="Set a given bit in this syntax. @param index the constant (RESyntax.RE_xxx) bit to set. @return a reference to this object for easy chaining.">
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RESyntax.clear(int)" access="pub" jdoc="Clear a given bit in this syntax. @param index the constant (RESyntax.RE_xxx) bit to clear. @return a reference to this object for easy chaining.">
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RESyntax.setLineSeparator(String)" access="pub" jdoc="Changes the line separator string for regular expressions created using this RESyntax. The default separator is the value returned by the system property &amp;quot;line.separator&amp;quot;, which should be correct when reading platform-specific files from a filesystem. However, many programs may collect input from sources where the line separator is differently specified (for example, in the applet environment, the text box widget interprets line breaks as single-character newlines, regardless of the host platform. Note that setting the line separator to a character or characters that have specific meaning within the current syntax can cause unexpected chronosynclastic infundibula. @return this object for convenient chaining">
				<param name="aSeparator"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RESyntax.getLineSeparator()" access="pub" jdoc="Returns the currently active line separator string. The default is the platform-dependent system property &amp;quot;line.separator&amp;quot;.">
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.REMatch" intfc="n" abs="n" inn="n" sloc="104" jdoc="An instance of this class represents a match completed by a gnu.regexp matching function. It can be used to obtain relevant information about the location of a match or submatch. @author &amp;lt;A HREF=&amp;quot;mailto:wes@cacas.org&amp;quot;&amp;gt;Wes Biggs&amp;lt; A&amp;gt;">
			<comm cntt="These variables are package scope for fast access within the engine"/>
			<comm cntt="execution flags this match was made using"/>
			<comm cntt="Offset in source text where match was tried. This is zero-based;"/>
			<comm cntt="the actual position in the source text is given by (offset + anchor)."/>
			<comm cntt="Anchor position refers to the index into the source input"/>
			<comm cntt="at which the matching operation began."/>
			<comm cntt="This is also useful for the ANCHORINDEX option."/>
			<comm cntt="Package scope; used by RE."/>
			<comm cntt="used while matching to mark current match position in input"/>
			<comm cntt="start positions (relative to offset) for each (sub)exp."/>
			<comm cntt="end positions for the same"/>
			<comm cntt="other possibility (to avoid having to use arrays)"/>
			<field name="matchedText" access="priv" jdoc=""/>
			<field name="eflags" access="pub" jdoc=""/>
			<field name="offset" access="pub" jdoc=""/>
			<field name="anchor" access="pub" jdoc=""/>
			<field name="index" access="pub" jdoc=""/>
			<field name="start" access="pub" jdoc=""/>
			<field name="end" access="pub" jdoc=""/>
			<field name="next" access="pub" jdoc=""/>
			<mth name="/lib/:gnu.regexp.REMatch.clone()" access="pub" jdoc="">
				<comm cntt="doesn&amp;apos;t happen"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.assignFrom(REMatch)" access="pub" jdoc="">
				<comm cntt="need to deep clone?"/>
				<param name="other"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.REMatch(int, int, int)" access="pub" jdoc="">
				<param name="subs"/>
				<param name="anchor"/>
				<param name="eflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.finish(CharIndexed)" access="pub" jdoc="">
				<comm cntt="If any subexpressions didn&amp;apos;t terminate, they don&amp;apos;t count"/>
				<comm cntt="TODO check if this code ever gets hit"/>
				<comm cntt="cut off alternates"/>
				<param name="text"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.clear(int)" access="pub" jdoc="Clears the current match and moves the offset to the new index.">
				<comm cntt="cut off alternates"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.toString()" access="pub" jdoc="Returns the string matching the pattern. This makes it convenient to write code like the following: &amp;lt;P&amp;gt; &amp;lt;code&amp;gt; REMatch myMatch = myExpression.getMatch(myString);&amp;lt;br&amp;gt; if (myMatch != null) System.out.println(&amp;quot;Regexp found: &amp;quot;+myMatch); &amp;lt; code&amp;gt;">
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.getStartIndex()" access="pub" jdoc="Returns the index within the input text where the match in its entirety began.">
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.getEndIndex()" access="pub" jdoc="Returns the index within the input string where the match in its entirety ends. The return value is the next position after the end of the string; therefore, a match created by the following call: &amp;lt;P&amp;gt; &amp;lt;code&amp;gt;REMatch myMatch = myExpression.getMatch(myString);&amp;lt; code&amp;gt; &amp;lt;P&amp;gt; can be viewed (given that myMatch is not null) by creating &amp;lt;P&amp;gt; &amp;lt;code&amp;gt;String theMatch = myString.substring(myMatch.getStartIndex(), myMatch.getEndIndex());&amp;lt; code&amp;gt; &amp;lt;P&amp;gt; But you can save yourself that work, since the &amp;lt;code&amp;gt;toString()&amp;lt; code&amp;gt; method (above) does exactly that for you.">
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.toString(int)" access="pub" jdoc="Returns the string matching the given subexpression. The subexpressions are indexed starting with one, not zero. That is, the subexpression identified by the first set of parentheses in a regular expression could be retrieved from an REMatch by calling match.toString(1). @param sub Index of the subexpression.">
				<param name="sub"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.getSubStartIndex(int)" access="pub" jdoc="Returns the index within the input string used to generate this match where subexpression number &amp;lt;i&amp;gt;sub&amp;lt; i&amp;gt; begins, or &amp;lt;code&amp;gt;-1&amp;lt; code&amp;gt; if the subexpression does not exist. The initial position is zero. @param sub Subexpression index @deprecated Use getStartIndex(int) instead.">
				<param name="sub"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.getStartIndex(int)" access="pub" jdoc="Returns the index within the input string used to generate this match where subexpression number &amp;lt;i&amp;gt;sub&amp;lt; i&amp;gt; begins, or &amp;lt;code&amp;gt;-1&amp;lt; code&amp;gt; if the subexpression does not exist. The initial position is zero. @param sub Subexpression index @since gnu.regexp 1.1.0">
				<param name="sub"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.getSubEndIndex(int)" access="pub" jdoc="Returns the index within the input string used to generate this match where subexpression number &amp;lt;i&amp;gt;sub&amp;lt; i&amp;gt; ends, or &amp;lt;code&amp;gt;-1&amp;lt; code&amp;gt; if the subexpression does not exist. The initial position is zero. @param sub Subexpression index @deprecated Use getEndIndex(int) instead">
				<param name="sub"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.getEndIndex(int)" access="pub" jdoc="Returns the index within the input string used to generate this match where subexpression number &amp;lt;i&amp;gt;sub&amp;lt; i&amp;gt; ends, or &amp;lt;code&amp;gt;-1&amp;lt; code&amp;gt; if the subexpression does not exist. The initial position is zero. @param sub Subexpression index">
				<param name="sub"/>
			</mth>
			<mth name="/lib/:gnu.regexp.REMatch.substituteInto(String)" access="pub" jdoc="Substitute the results of this match to create a new string. This is patterned after PERL, so the tokens to watch out for are &amp;lt;code&amp;gt;$0&amp;lt; code&amp;gt; through &amp;lt;code&amp;gt;$9&amp;lt; code&amp;gt;. &amp;lt;code&amp;gt;$0&amp;lt; code&amp;gt; matches the full substring matched; &amp;lt;code&amp;gt;$&amp;lt;i&amp;gt;n&amp;lt; i&amp;gt;&amp;lt; code&amp;gt; matches subexpression number &amp;lt;i&amp;gt;n&amp;lt; i&amp;gt;. @param input A string consisting of literals and &amp;lt;code&amp;gt;$&amp;lt;i&amp;gt;n&amp;lt; i&amp;gt;&amp;lt; code&amp;gt; tokens.">
				<comm cntt="a la Perl, $0 is whole thing, $1 - $9 are subexpressions"/>
				<param name="input"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenEnd" intfc="n" abs="n" inn="n" sloc="28" jdoc="">
			<field name="newline" access="priv" jdoc="Indicates whether this token should match on a line break."/>
			<mth name="/lib/:gnu.regexp.RETokenEnd.RETokenEnd(int, String)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="newline"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenEnd.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<comm cntt="position in newline"/>
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenEnd.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenAny" intfc="n" abs="n" inn="n" sloc="25" jdoc="">
			<field name="newline" access="priv" jdoc="True if &amp;apos;.&amp;apos; can match a newline (RE_DOT_NEWLINE)"/>
			<field name="matchNull" access="priv" jdoc="True if &amp;apos;.&amp;apos; can&amp;apos;t match a null (RE_DOT_NOT_NULL)"/>
			<mth name="/lib/:gnu.regexp.RETokenAny.RETokenAny(int, boolean, boolean)" access="pub" jdoc="">
				<param name="subIndex"/>
				<param name="newline"/>
				<param name="matchNull"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenAny.getMinimumLength()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenAny.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenAny.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.RETokenLookAhead" intfc="n" abs="n" inn="n" sloc="37" jdoc="@since gnu.regexp 1.1.3 @author Shashank Bapat">
			<field name="re" access="pub" jdoc=""/>
			<field name="negative" access="pub" jdoc=""/>
			<mth name="/lib/:gnu.regexp.RETokenLookAhead.RETokenLookAhead(REToken, boolean)" access="pub" jdoc="">
				<param name="re"/>
				<param name="negative"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenLookAhead.match(CharIndexed, REMatch)" access="pub" jdoc="">
				<comm cntt="else"/>
				<comm cntt="no match"/>
				<comm cntt="else"/>
				<param name="input"/>
				<param name="mymatch"/>
			</mth>
			<mth name="/lib/:gnu.regexp.RETokenLookAhead.dump(StringBuffer)" access="pub" jdoc="">
				<param name="os"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.CharIndexedString" intfc="n" abs="n" inn="n" sloc="20" jdoc="">
			<field name="s" access="priv" jdoc=""/>
			<field name="anchor" access="priv" jdoc=""/>
			<field name="len" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.CharIndexedString.CharIndexedString(String, int)" access="pub" jdoc="">
				<param name="str"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedString.charAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedString.isValid()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedString.move(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.CharIndexedCharArray" intfc="n" abs="n" inn="n" sloc="18" jdoc="">
			<field name="s" access="priv" jdoc=""/>
			<field name="anchor" access="priv" jdoc=""/>
			<mth name="/lib/:gnu.regexp.CharIndexedCharArray.CharIndexedCharArray(char[], int)" access="pub" jdoc="">
				<param name="str"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedCharArray.charAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedCharArray.isValid()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:gnu.regexp.CharIndexedCharArray.move(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
		</class>
		<class name="/lib/:gnu.regexp.UncheckedRE" intfc="n" abs="n" inn="n" sloc="15" jdoc="UncheckedRE is a subclass of RE that allows programmers an easier means of programmatically precompiling regular expressions. It is constructed and used in exactly the same manner as an instance of the RE class; the only difference is that its constructors do not throw REException. Instead, if a syntax error is encountered during construction, a RuntimeException will be thrown. &amp;lt;P&amp;gt; Note that this makes UncheckedRE dangerous if constructed with dynamic data. Do not use UncheckedRE unless you are completely sure that all input being passed to it contains valid, well-formed regular expressions for the syntax specified. @author &amp;lt;A HREF=&amp;quot;mailto:wes@cacas.org&amp;quot;&amp;gt;Wes Biggs&amp;lt; A&amp;gt; @see gnu.regexp.RE @since gnu.regexp 1.1.4">
			<mth name="/lib/:gnu.regexp.UncheckedRE.UncheckedRE(Object)" access="pub" jdoc="Constructs a regular expression pattern buffer without any compilation flags set, and using the default syntax (RESyntax.RE_SYNTAX_PERL5). @param pattern A regular expression pattern, in the form of a String, StringBuffer or char[]. Other input types will be converted to strings using the toString() method. @exception RuntimeException The input pattern could not be parsed. @exception NullPointerException The pattern was null.">
				<param name="pattern"/>
			</mth>
			<mth name="/lib/:gnu.regexp.UncheckedRE.UncheckedRE(Object, int)" access="pub" jdoc="Constructs a regular expression pattern buffer using the specified compilation flags and the default syntax (RESyntax.RE_SYNTAX_PERL5). @param pattern A regular expression pattern, in the form of a String, StringBuffer, or char[]. Other input types will be converted to strings using the toString() method. @param cflags The logical OR of any combination of the compilation flags in the RE class. @exception RuntimeException The input pattern could not be parsed. @exception NullPointerException The pattern was null.">
				<param name="pattern"/>
				<param name="cflags"/>
			</mth>
			<mth name="/lib/:gnu.regexp.UncheckedRE.UncheckedRE(Object, int, RESyntax)" access="pub" jdoc="Constructs a regular expression pattern buffer using the specified compilation flags and regular expression syntax. @param pattern A regular expression pattern, in the form of a String, StringBuffer, or char[]. Other input types will be converted to strings using the toString() method. @param cflags The logical OR of any combination of the compilation flags in the RE class. @param syntax The type of regular expression syntax to use. @exception RuntimeException The input pattern could not be parsed. @exception NullPointerException The pattern was null.">
				<param name="pattern"/>
				<param name="cflags"/>
				<param name="syntax"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.gjt.sp.jedit">
		<class name="/lib/:org.gjt.sp.jedit.OperatingSystem" intfc="n" abs="n" inn="n" sloc="81" jdoc="Contains operating system detection routines. @author Slava Pestov @version $Id: OperatingSystem.java,v 1.1 2002 08 11 01:18:37 gfx Exp $ @since jEdit 4.0pre4">
			<comm cntt="{{{ isDOSDerived() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ isWindows() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ isWindows9x() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ isWindowsNT() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ isOS2() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ isUnix() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ isMacOS() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ isMacOSLF() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ isJava14() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ Private members"/>
			<comm cntt="{{{ Class initializer"/>
			<comm cntt="}}}"/>
			<comm cntt="}}}"/>
			<const name="UNIX" access="priv" jdoc=""/>
			<const name="WINDOWS_9x" access="priv" jdoc=""/>
			<const name="WINDOWS_NT" access="priv" jdoc=""/>
			<const name="OS2" access="priv" jdoc=""/>
			<const name="MAC_OS_X" access="priv" jdoc=""/>
			<const name="UNKNOWN" access="priv" jdoc=""/>
			<field name="os" access="priv" jdoc=""/>
			<field name="java14" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.OperatingSystem.isDOSDerived()" access="pub" jdoc="Returns if we&amp;apos;re running Windows 95 98 ME NT 2000 XP, or OS 2.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.OperatingSystem.isWindows()" access="pub" jdoc="Returns if we&amp;apos;re running Windows 95 98 ME NT 2000 XP.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.OperatingSystem.isWindows9x()" access="pub" jdoc="Returns if we&amp;apos;re running Windows 95 98 ME.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.OperatingSystem.isWindowsNT()" access="pub" jdoc="Returns if we&amp;apos;re running Windows NT 2000 XP.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.OperatingSystem.isOS2()" access="pub" jdoc="Returns if we&amp;apos;re running OS 2.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.OperatingSystem.isUnix()" access="pub" jdoc="Returns if we&amp;apos;re running Unix (this includes MacOS X).">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.OperatingSystem.isMacOS()" access="pub" jdoc="Returns if we&amp;apos;re running MacOS X.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.OperatingSystem.isMacOSLF()" access="pub" jdoc="Returns if we&amp;apos;re running MacOS X and using the native L&amp;F.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.OperatingSystem.hasJava14()" access="pub" jdoc="Returns if Java 2 version 1.4 is in use.">
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.gjt.sp.jedit.gui">
		<class name="/lib/:org.gjt.sp.jedit.gui.KeyEventWorkaround" intfc="n" abs="n" inn="n" sloc="140" jdoc="This class contains various hacks to get keyboard event handling to behave in a consistent manner across Java implementations, many of which are hopelessly broken in this regard. @author Slava Pestov @version $Id: KeyEventWorkaround.java,v 1.3 2002 10 25 17:29:57 gfx Exp $">
			<comm cntt="{{{ processKeyEvent() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ numericKeypadKey() method"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ Private members"/>
			<comm cntt="{{{ Static variables"/>
			<comm cntt="}}}"/>
			<comm cntt="{{{ handleBrokenKeys() method"/>
			<comm cntt="}}}"/>
			<comm cntt="}}}"/>
			<field name="lastKeyTime" access="priv" jdoc=""/>
			<field name="last" access="priv" jdoc=""/>
			<const name="LAST_NOTHING" access="priv" jdoc=""/>
			<const name="LAST_ALT" access="priv" jdoc=""/>
			<const name="LAST_BROKEN" access="priv" jdoc=""/>
			<const name="LAST_NUMKEYPAD" access="priv" jdoc=""/>
			<const name="LAST_MOD" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.gui.KeyEventWorkaround.processKeyEvent(KeyEvent)" access="pub" jdoc="">
				<comm cntt="{{{ KEY_PRESSED..."/>
				<comm cntt="get rid of keys we never need to handle"/>
				<comm cntt="}}}"/>
				<comm cntt="{{{ KEY_TYPED..."/>
				<comm cntt="need to let \b through so that backspace will work"/>
				<comm cntt="in HistoryTextFields"/>
				<comm cntt="&amp;quot;Alt&amp;quot; is the option key on MacOS, and it can generate"/>
				<comm cntt="user input"/>
				<comm cntt="On JDK 1.4 with Windows, some Alt-key sequences send"/>
				<comm cntt="bullshit in a KEY_TYPED afterwards. We filter it out"/>
				<comm cntt="here"/>
				<comm cntt="if the last key was a broken key, filter"/>
				<comm cntt="out all except &amp;apos;a&amp;apos;-&amp;apos;z&amp;apos; that occur 750 ms after."/>
				<comm cntt="otherwise, if it was ALT, filter out everything."/>
				<comm cntt="}}}"/>
				<comm cntt="{{{ KEY_RELEASED..."/>
				<comm cntt="bad workaround... on Windows JDK 1.4, some"/>
				<comm cntt="Alt-sequences generate random crap afterwards"/>
				<comm cntt="}}}"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.gui.KeyEventWorkaround.numericKeypadKey()" access="pub" jdoc="A workaround for non-working NumLock status in some Java versions. @since jEdit 4.0pre8">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.gui.KeyEventWorkaround.handleBrokenKeys(KeyEvent, int)" access="priv" jdoc="">
				<param name="evt"/>
				<param name="keyCode"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.gjt.sp.jedit.syntax">
		<class name="/lib/:org.gjt.sp.jedit.syntax.Token" intfc="n" abs="n" inn="n" sloc="37" jdoc="A linked list of tokens. Each token has three fields - a token identifier, which is a byte value that can be looked up in the array returned by &amp;lt;code&amp;gt;SyntaxDocument.getColors()&amp;lt; code&amp;gt; to get a color value, a length value which is the length of the token in the text, and a pointer to the next token in the list. @author Slava Pestov @version $Id: Token.java,v 1.4 2003 06 30 17:31:10 blaisorblade Exp $">
			<const name="NULL" access="pub" jdoc="Normal text token id. This should be used to mark normal text."/>
			<const name="COMMENT1" access="pub" jdoc="Comment 1 token id. This can be used to mark a comment."/>
			<const name="COMMENT2" access="pub" jdoc="Comment 2 token id. This can be used to mark a comment."/>
			<const name="LITERAL1" access="pub" jdoc="Literal 1 token id. This can be used to mark a string literal (eg, C mode uses this to mark &amp;quot;...&amp;quot; literals)"/>
			<const name="LITERAL2" access="pub" jdoc="Literal 2 token id. This can be used to mark an object literal (eg, Java mode uses this to mark true, false, etc)"/>
			<const name="LABEL" access="pub" jdoc="Label token id. This can be used to mark labels (eg, C mode uses this to mark ...: sequences)"/>
			<const name="KEYWORD1" access="pub" jdoc="Keyword 1 token id. This can be used to mark a keyword. This should be used for general language constructs."/>
			<const name="KEYWORD2" access="pub" jdoc="Keyword 2 token id. This can be used to mark a keyword. This should be used for preprocessor commands, or variables."/>
			<const name="KEYWORD3" access="pub" jdoc="Keyword 3 token id. This can be used to mark a keyword. This should be used for data types."/>
			<const name="OPERATOR" access="pub" jdoc="Operator token id. This can be used to mark an operator. (eg, SQL mode marks +, -, etc with this token type)"/>
			<const name="INVALID" access="pub" jdoc="Invalid token id. This can be used to mark invalid or incomplete tokens, so the user can easily spot syntax errors."/>
			<const name="METHOD" access="pub" jdoc="Methods calls."/>
			<const name="ID_COUNT" access="pub" jdoc="The total number of defined token ids."/>
			<const name="INTERNAL_FIRST" access="pub" jdoc="The first id that can be used for internal state in a token marker."/>
			<const name="INTERNAL_LAST" access="pub" jdoc="The last id that can be used for internal state in a token marker."/>
			<const name="END" access="pub" jdoc="The token type, that along with a length of 0 marks the end of the token list."/>
			<field name="length" access="pub" jdoc="The length of this token."/>
			<field name="id" access="pub" jdoc="The id of this token."/>
			<field name="next" access="pub" jdoc="The next token in the linked list."/>
			<field name="highlightBackground" access="pub" jdoc="If we need to highlight behind the token."/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.Token.Token(int, byte)" access="pub" jdoc="Creates a new token. @param length The length of the token @param id The id of the token">
				<param name="length"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.Token.Token(int, byte, boolean)" access="pub" jdoc="">
				<param name="length"/>
				<param name="id"/>
				<param name="highlightBackground"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.Token.toString()" access="pub" jdoc="Returns a string representation of this token.">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.EiffelTokenMarker" intfc="n" abs="n" inn="n" sloc="235" jdoc="Eiffel token Marker. @author Artur Biesiadowski">
			<comm cntt="private members"/>
			<field name="eiffelKeywords" access="priv" jdoc=""/>
			<field name="cpp" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.EiffelTokenMarker.EiffelTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.EiffelTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.EiffelTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.EiffelTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.MakefileTokenMarker" intfc="n" abs="n" inn="n" sloc="138" jdoc="Makefile token marker. @author Slava Pestov @version $Id: MakefileTokenMarker.java,v 1.1.1.1 2001 08 20 22:32:07 gfx Exp $">
			<comm cntt="public members"/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.MakefileTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.JavaScriptTokenMarker" intfc="n" abs="n" inn="n" sloc="33" jdoc="JavaScript token marker. @author Slava Pestov @version $Id: JavaScriptTokenMarker.java,v 1.1.1.1 2001 08 20 22:32:06 gfx Exp $">
			<comm cntt="private members"/>
			<field name="javaScriptKeywords" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JavaScriptTokenMarker.JavaScriptTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JavaScriptTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.ShellScriptTokenMarker" intfc="n" abs="n" inn="n" sloc="242" jdoc="Shell script token marker. @author Slava Pestov @version $Id: ShellScriptTokenMarker.java,v 1.2 2001 11 28 21:25:29 gfx Exp $">
			<comm cntt="public members"/>
			<const name="LVARIABLE" access="pub" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ShellScriptTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="0 = space before command, 1 = inside"/>
				<comm cntt="command, 2 = after command"/>
				<comm cntt="insideCmd"/>
				<comm cntt="afterCmd"/>
				<comm cntt="insideCmd"/>
				<comm cntt="afterCmd"/>
				<comm cntt="beforeCmd"/>
				<comm cntt="afterCmd"/>
				<comm cntt="afterCmd"/>
				<comm cntt="afterCmd"/>
				<comm cntt="beforeCmd"/>
				<comm cntt="insideCmd"/>
				<comm cntt="afterCmd"/>
				<comm cntt="afterCmd"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerWithAddToken" intfc="y" abs="n" inn="n" sloc="4" jdoc="@author Andre Kaplan @version 0.5">
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerWithAddToken.addToken(int, byte)" access="pub" jdoc="">
				<param name="length"/>
				<param name="id"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.CTokenMarker" intfc="n" abs="n" inn="n" sloc="272" jdoc="C token marker. @author Slava Pestov @version $Id: CTokenMarker.java,v 1.9 2003 06 30 17:31:09 blaisorblade Exp $">
			<comm cntt="private members"/>
			<const name="METHOD_DELIMITERS" access="pub" jdoc=""/>
			<field name="cKeywords" access="priv" jdoc=""/>
			<field name="cpp" access="prot" jdoc=""/>
			<field name="javadoc" access="prot" jdoc=""/>
			<field name="keywords" access="prot" jdoc=""/>
			<field name="lastOffset" access="prot" jdoc=""/>
			<field name="lastKeyword" access="prot" jdoc=""/>
			<field name="lastWhitespace" access="prot" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CTokenMarker.CTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CTokenMarker.CTokenMarker(boolean, boolean, KeywordMap)" access="pub" jdoc="">
				<param name="cpp"/>
				<param name="javadoc"/>
				<param name="keywords"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CTokenMarker.doKeyword(Segment, int, char)" access="prot" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.BeanShellTokenMarker" intfc="n" abs="n" inn="n" sloc="47" jdoc="BeanShell (www.beanshell.org) token marker. @author Slava Pestov @version $Id: BeanShellTokenMarker.java,v 1.1.1.1 2001 08 20 22:32:04 gfx Exp $">
			<comm cntt="private members"/>
			<field name="bshKeywords" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.BeanShellTokenMarker.BeanShellTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.BeanShellTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.LATTokenMarker" intfc="n" abs="n" inn="n" sloc="177" jdoc="">
			<comm cntt="private members"/>
			<field name="latKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.LATTokenMarker.LATTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.LATTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.LATTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.LATTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.ASPVBScriptTokenMarker" intfc="n" abs="n" inn="n" sloc="416" jdoc="ASP VBScript token marker @author Andre Kaplan @version 0.6">
			<comm cntt=""/>
			<comm cntt="markTokensImpl"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="markTokensImpl"/>
			<comm cntt=""/>
			<comm cntt="Static members"/>
			<comm cntt="private members"/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="standalone" access="priv" jdoc=""/>
			<field name="vbScriptKeywords" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPVBScriptTokenMarker.ASPVBScriptTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPVBScriptTokenMarker.ASPVBScriptTokenMarker(boolean)" access="pub" jdoc="">
				<param name="standalone"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPVBScriptTokenMarker.addToken(int, byte)" access="pub" jdoc="">
				<param name="length"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPVBScriptTokenMarker.markTokensImpl(byte, Segment, int)" access="prot" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPVBScriptTokenMarker.markTokensImpl(MultiModeToken, TokenMarkerContext)" access="pub" jdoc="">
				<comm cntt="NULL Token"/>
				<comm cntt="Just return, let parent mode decide what to do next"/>
				<comm cntt="Just return, let parent mode decide what to do next"/>
				<comm cntt="Just return, let parent mode decide what to do next"/>
				<comm cntt="Comments"/>
				<comm cntt="Literals"/>
				<comm cntt="Single character operators"/>
				<comm cntt="Integer division"/>
				<comm cntt="Exponentiation"/>
				<comm cntt="String Concatenation"/>
				<comm cntt="Comment (Rem)"/>
				<comm cntt="END LOOP"/>
				<param name="token"/>
				<param name="tokenContext"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPVBScriptTokenMarker.doKeywordToPos(MultiModeToken, TokenMarkerContext)" access="priv" jdoc="">
				<param name="mmt"/>
				<param name="tokenContext"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPVBScriptTokenMarker.getKeywords()" access="pub" jdoc="">
				<comm cntt="Conditional Statements"/>
				<comm cntt="Loop Statements"/>
				<comm cntt="For..Next"/>
				<comm cntt="For Each..Next"/>
				<comm cntt="Do..Loop"/>
				<comm cntt="While..Wend"/>
				<comm cntt="Closing, Exit Statements"/>
				<comm cntt="Methods, Functions, Class, Properties, Variables"/>
				<comm cntt="property set: vbScriptKeywords.add(&amp;quot;set&amp;quot;, Token.KEYWORD1);"/>
				<comm cntt="Parameters passing"/>
				<comm cntt="Declaration"/>
				<comm cntt="Object Assignement Instantiation"/>
				<comm cntt="Visibility"/>
				<comm cntt="Comments"/>
				<comm cntt="Function Call - Dynamic Evaluation"/>
				<comm cntt="Miscellaneous"/>
				<comm cntt="Operators"/>
				<comm cntt="Comparison Operators"/>
				<comm cntt="Arihtmetic Operators"/>
				<comm cntt="Logical Operators"/>
				<comm cntt="Datatypes Constants Literals"/>
				<comm cntt="String Constants"/>
				<comm cntt="VarType Constants"/>
				<comm cntt="Built-in Functions"/>
				<comm cntt="Array Handling"/>
				<comm cntt="Conversion Functions (Variant)"/>
				<comm cntt="Conversion Functions (Radix)"/>
				<comm cntt="Date Time Functions"/>
				<comm cntt="Formatting Strings"/>
				<comm cntt="Input Output"/>
				<comm cntt="Math Functions"/>
				<comm cntt="Miscellaneous"/>
				<comm cntt="COM Objects"/>
				<comm cntt="Rounding"/>
				<comm cntt="Script Engine ID"/>
				<comm cntt="Strings"/>
				<comm cntt="Variants"/>
				<comm cntt="Uncomment your favorite keywords if you like"/>
				<comm cntt="ADO Constants"/>
				<comm cntt="---- CursorTypeEnum Values ----"/>
				<comm cntt="---- CursorOptionEnum Values ----"/>
				<comm cntt="---- LockTypeEnum Values ----"/>
				<comm cntt="---- ExecuteOptionEnum Values ----"/>
				<comm cntt="---- ConnectOptionEnum Values ----"/>
				<comm cntt="---- ObjectStateEnum Values ----"/>
				<comm cntt="---- CursorLocationEnum Values ----"/>
				<comm cntt="---- DataTypeEnum Values ----"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.CobolTokenMarker" intfc="n" abs="n" inn="n" sloc="760" jdoc="">
			<comm cntt="private members"/>
			<field name="cobolKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CobolTokenMarker.CobolTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CobolTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="case Token.LITERAL1:"/>
				<comm cntt="case Token.LITERAL2:"/>
				<comm cntt="addToken(length - lastOffset, Token.INVALID);"/>
				<comm cntt="token = Token.NULL;"/>
				<comm cntt="break;"/>
				<comm cntt="case Token.KEYWORD2:"/>
				<comm cntt="addToken(length - lastOffset, token);"/>
				<comm cntt="token = Token.NULL;"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CobolTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CobolTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.MultiModeToken" intfc="n" abs="n" inn="n" sloc="41" jdoc="This class is useful to handle multiple modes. @author Andre Kaplan @version 0.6">
			<field name="mode" access="pub" jdoc=""/>
			<field name="token" access="pub" jdoc=""/>
			<field name="obj" access="pub" jdoc=""/>
			<const name="NULL" access="pub" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.MultiModeToken.MultiModeToken()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.MultiModeToken.MultiModeToken(byte, byte)" access="priv" jdoc="">
				<param name="mode"/>
				<param name="token"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.MultiModeToken.MultiModeToken(byte, byte, Object)" access="pub" jdoc="">
				<param name="mode"/>
				<param name="token"/>
				<param name="obj"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.MultiModeToken.MultiModeToken(MultiModeToken)" access="pub" jdoc="">
				<param name="other"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.MultiModeToken.reset()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.MultiModeToken.assign(MultiModeToken)" access="pub" jdoc="">
				<param name="other"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker" intfc="n" abs="n" inn="n" sloc="731" jdoc="Original Perl token marker by Slava Pestov Perlscript Token Marker @author Andre Kaplan @version 0.6">
			<comm cntt="public members"/>
			<comm cntt=""/>
			<comm cntt="markTokensImpl"/>
			<comm cntt=""/>
			<comm cntt="private members"/>
			<comm cntt=""/>
			<comm cntt="doKeywordToEnd"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="doKeywordToPos"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="doKeyword"/>
			<comm cntt=""/>
			<comm cntt="Converts &amp;lt; EOF &amp;gt;, &amp;lt; &amp;apos;EOF&amp;apos; &amp;gt;, etc to &amp;lt;EOF&amp;gt;"/>
			<const name="S_ONE" access="pub" jdoc=""/>
			<const name="S_TWO" access="pub" jdoc=""/>
			<const name="S_END" access="pub" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="standalone" access="priv" jdoc=""/>
			<field name="matchChar" access="priv" jdoc=""/>
			<field name="matchCharBracket" access="priv" jdoc=""/>
			<field name="matchSpacesAllowed" access="priv" jdoc=""/>
			<field name="debug" access="priv" jdoc=""/>
			<field name="perlKeywords" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.ASPPerlscriptTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.ASPPerlscriptTokenMarker(boolean)" access="pub" jdoc="">
				<param name="standalone"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.ASPPerlscriptTokenMarker(KeywordMap)" access="pub" jdoc="">
				<param name="keywords"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.ASPPerlscriptTokenMarker(KeywordMap, boolean)" access="pub" jdoc="">
				<param name="keywords"/>
				<param name="standalone"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.addToken(int, byte)" access="pub" jdoc="">
				<param name="length"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.markTokensImpl(byte, Segment, int)" access="prot" jdoc="">
				<param name="_token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.markTokensImpl(MultiModeToken, TokenMarkerContext)" access="pub" jdoc="">
				<comm cntt="Following is a way to detect whether tokenContext.pos is not"/>
				<comm cntt="correctly incremented. This is for debugging purposes"/>
				<comm cntt="We got stuck here at some point"/>
				<comm cntt="Log this and increment tokenContext.pos to escape this"/>
				<comm cntt="Just return, let parent mode decide what to do next"/>
				<comm cntt="Just return, let parent mode decide what to do next"/>
				<comm cntt="Just return, let parent mode decide what to do next"/>
				<comm cntt="Log.log(Log.DEBUG, this, &amp;quot;Readin: [&amp;quot; + readin + &amp;quot;]&amp;quot;);"/>
				<comm cntt="Doesn&amp;apos;t pick up all labels,"/>
				<comm cntt="but at least doesn&amp;apos;t mess up"/>
				<comm cntt="XXX::YYY"/>
				<comm cntt="This test checks for an end-of-variable"/>
				<comm cntt="condition"/>
				<comm cntt="If this is the first character"/>
				<comm cntt="of the variable name ($&amp;apos;aaa)"/>
				<comm cntt="ignore it"/>
				<comm cntt="Otherwise, end of variable..."/>
				<comm cntt="Wind back so that stuff"/>
				<comm cntt="like $hello$fred is picked"/>
				<comm cntt="up"/>
				<comm cntt="Change the token KEYWORD2 -&amp;gt; NULL"/>
				<comm cntt="And continue at the same position"/>
				<comm cntt="else if(c == &amp;apos;$&amp;apos;) backslash = true;"/>
				<comm cntt="else if(c == &amp;apos;$&amp;apos;) backslash = true;"/>
				<comm cntt="XXX"/>
				<param name="token"/>
				<param name="tokenContext"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.doKeywordToEnd(MultiModeToken, TokenMarkerContext, char)" access="priv" jdoc="">
				<param name="token"/>
				<param name="tokenContext"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.doKeywordToPos(MultiModeToken, TokenMarkerContext, char)" access="priv" jdoc="">
				<param name="token"/>
				<param name="tokenContext"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.doKeyword(MultiModeToken, TokenMarkerContext, int, char)" access="priv" jdoc="">
				<param name="token"/>
				<param name="tokenContext"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.createReadinString(char[], int, int)" access="priv" jdoc="">
				<param name="array"/>
				<param name="start"/>
				<param name="len"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPPerlscriptTokenMarker.getKeywords()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.MultiModeTokenMarkerWithContext" intfc="y" abs="n" inn="n" sloc="7" jdoc="@author Andre Kaplan @version 0.5">
			<mth name="/lib/:org.gjt.sp.jedit.syntax.MultiModeTokenMarkerWithContext.markTokensImpl(MultiModeToken, TokenMarkerContext)" access="pub" jdoc="">
				<param name="token"/>
				<param name="tokenContext"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.CCTokenMarker" intfc="n" abs="n" inn="n" sloc="91" jdoc="C++ token marker. @author Slava Pestov @version $Id: CCTokenMarker.java,v 1.1.1.1 2001 08 20 22:32:04 gfx Exp $">
			<comm cntt="private members"/>
			<field name="ccKeywords" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CCTokenMarker.CCTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CCTokenMarker.getKeywords()" access="pub" jdoc="">
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt="non ANSI keywords"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.ASPJavascriptTokenMarker" intfc="n" abs="n" inn="n" sloc="369" jdoc="ASP Javascript token marker @author Andre Kaplan @version 0.6">
			<comm cntt=""/>
			<comm cntt="markTokensImpl"/>
			<comm cntt=""/>
			<comm cntt="private members"/>
			<comm cntt="private members"/>
			<field name="javaScriptKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="standalone" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPJavascriptTokenMarker.ASPJavascriptTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPJavascriptTokenMarker.ASPJavascriptTokenMarker(boolean)" access="pub" jdoc="">
				<param name="standalone"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPJavascriptTokenMarker.ASPJavascriptTokenMarker(KeywordMap)" access="pub" jdoc="">
				<param name="keywords"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPJavascriptTokenMarker.ASPJavascriptTokenMarker(KeywordMap, boolean)" access="pub" jdoc="">
				<param name="keywords"/>
				<param name="standalone"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPJavascriptTokenMarker.addToken(int, byte)" access="pub" jdoc="">
				<param name="length"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPJavascriptTokenMarker.markTokensImpl(byte, Segment, int)" access="prot" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPJavascriptTokenMarker.markTokensImpl(MultiModeToken, TokenMarkerContext)" access="pub" jdoc="">
				<comm cntt="Just return, let parent mode decide what to do next"/>
				<comm cntt="Just return, let parent mode decide what to do next"/>
				<comm cntt="Just return, let parent mode decide what to do next"/>
				<comm cntt="Operators"/>
				<comm cntt="Unary: ~ ++ --"/>
				<comm cntt="Arithmetic: + - %"/>
				<comm cntt="Comparison: == != &amp;lt; &amp;gt; &amp;lt;= &amp;gt;="/>
				<comm cntt="Boolean: | &amp; ^"/>
				<comm cntt="Bit Shift: &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt;"/>
				<comm cntt="Logical: ! || &amp;&amp;"/>
				<comm cntt="Assignment: = += -= = = %= |= &amp;= ^= &amp;lt;&amp;lt;= &amp;gt;&amp;gt;= &amp;gt;&amp;gt;&amp;gt;="/>
				<comm cntt="Conditional: ?:"/>
				<comm cntt="END LOOP"/>
				<param name="token"/>
				<param name="tokenContext"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPJavascriptTokenMarker.getKeywords()" access="pub" jdoc="">
				<comm cntt="ECMAScript keywords"/>
				<comm cntt="ECMAScript keywords"/>
				<comm cntt="Reserved for future use (some are already used in some Javascripts Engines)"/>
				<comm cntt="Intrinsic Objects (Good idea not to use these names!!)"/>
				<comm cntt="NON-ECMA"/>
				<comm cntt="Literals"/>
				<comm cntt="Global functions"/>
				<comm cntt="Comment Uncomment your favorite ADO Constants"/>
				<comm cntt="ADO Constants"/>
				<comm cntt="---- CursorTypeEnum Values ----"/>
				<comm cntt="---- CursorOptionEnum Values ----"/>
				<comm cntt="---- LockTypeEnum Values ----"/>
				<comm cntt="---- ExecuteOptionEnum Values ----"/>
				<comm cntt="---- ConnectOptionEnum Values ----"/>
				<comm cntt="---- ObjectStateEnum Values ----"/>
				<comm cntt="---- CursorLocationEnum Values ----"/>
				<comm cntt="---- DataTypeEnum Values ----"/>
				<comm cntt="---- FieldAttributeEnum Values ---- javaScriptKeywords.add(&amp;quot;adFldMayDefer&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldUpdatable&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldUnknownUpdatable&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldFixed&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldIsNullable&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldMayBeNull&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldLong&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldRowID&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldRowVersion&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldCacheDeferred&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFldKeyColumn&amp;quot;, Token.LITERAL2); ---- EditModeEnum Values ---- javaScriptKeywords.add(&amp;quot;adEditNone&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adEditInProgress&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adEditAdd&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adEditDelete&amp;quot;, Token.LITERAL2); ---- RecordStatusEnum Values ---- javaScriptKeywords.add(&amp;quot;adRecOK&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecNew&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecModified&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecDeleted&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecUnmodified&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecInvalid&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecMultipleChanges&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecPendingChanges&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecCanceled&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecCantRelease&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecConcurrencyViolation&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecIntegrityViolation&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecMaxChangesExceeded&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecObjectOpen&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecOutOfMemory&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecPermissionDenied&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecSchemaViolation&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecDBDeleted&amp;quot;, Token.LITERAL2); ---- GetRowsOptionEnum Values ---- javaScriptKeywords.add(&amp;quot;adGetRowsRest&amp;quot;, Token.LITERAL2); ---- PositionEnum Values ---- javaScriptKeywords.add(&amp;quot;adPosUnknown&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPosBOF&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPosEOF&amp;quot;, Token.LITERAL2); ---- enum Values ---- javaScriptKeywords.add(&amp;quot;adBookmarkCurrent&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adBookmarkFirst&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adBookmarkLast&amp;quot;, Token.LITERAL2); ---- MarshalOptionsEnum Values ---- javaScriptKeywords.add(&amp;quot;adMarshalAll&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adMarshalModifiedOnly&amp;quot;, Token.LITERAL2); ---- AffectEnum Values ---- javaScriptKeywords.add(&amp;quot;adAffectCurrent&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adAffectGroup&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adAffectAll&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adAffectAllChapters&amp;quot;, Token.LITERAL2); ---- ResyncEnum Values ---- javaScriptKeywords.add(&amp;quot;adResyncUnderlyingValues&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adResyncAllValues&amp;quot;, Token.LITERAL2); ---- CompareEnum Values ---- javaScriptKeywords.add(&amp;quot;adCompareLessThan&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCompareEqual&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCompareGreaterThan&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCompareNotEqual&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCompareNotComparable&amp;quot;, Token.LITERAL2); ---- FilterGroupEnum Values ---- javaScriptKeywords.add(&amp;quot;adFilterNone&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFilterPendingRecords&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFilterAffectedRecords&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFilterFetchedRecords&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFilterPredicate&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adFilterConflictingRecords&amp;quot;, Token.LITERAL2); ---- SearchDirectionEnum Values ---- javaScriptKeywords.add(&amp;quot;adSearchForward&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSearchBackward&amp;quot;, Token.LITERAL2); ---- PersistFormatEnum Values ---- javaScriptKeywords.add(&amp;quot;adPersistADTG&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPersistXML&amp;quot;, Token.LITERAL2); ---- StringFormatEnum Values ---- javaScriptKeywords.add(&amp;quot;adStringXML&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adStringHTML&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adClipString&amp;quot;, Token.LITERAL2); ---- ConnectPromptEnum Values ---- javaScriptKeywords.add(&amp;quot;adPromptAlways&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPromptComplete&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPromptCompleteRequired&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPromptNever&amp;quot;, Token.LITERAL2); ---- ConnectModeEnum Values ---- javaScriptKeywords.add(&amp;quot;adModeUnknown&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adModeRead&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adModeWrite&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adModeReadWrite&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adModeShareDenyRead&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adModeShareDenyWrite&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adModeShareExclusive&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adModeShareDenyNone&amp;quot;, Token.LITERAL2); ---- IsolationLevelEnum Values ---- javaScriptKeywords.add(&amp;quot;adXactUnspecified&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adXactChaos&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adXactReadUncommitted&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adXactBrowse&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adXactCursorStability&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adXactReadCommitted&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adXactRepeatableRead&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adXactSerializable&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adXactIsolated&amp;quot;, Token.LITERAL2); ---- XactAttributeEnum Values ---- javaScriptKeywords.add(&amp;quot;adXactCommitRetaining&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adXactAbortRetaining&amp;quot;, Token.LITERAL2); ---- PropertyAttributesEnum Values ---- javaScriptKeywords.add(&amp;quot;adPropNotSupported&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPropRequired&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPropOptional&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPropRead&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPropWrite&amp;quot;, Token.LITERAL2); ---- ErrorValueEnum Values ---- javaScriptKeywords.add(&amp;quot;adErrInvalidArgument&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrNoCurrentRecord&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrIllegalOperation&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrInTransaction&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrFeatureNotAvailable&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrItemNotFound&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrObjectInCollection&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrObjectNotSet&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrDataConversion&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrObjectClosed&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrObjectOpen&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrProviderNotFound&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrBoundToCommand&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrInvalidParamInfo&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrInvalidConnection&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrNotReentrant&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrStillExecuting&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrOperationCancelled&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrStillConnecting&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrNotExecuting&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adErrUnsafeOperation&amp;quot;, Token.LITERAL2); ---- ParameterAttributesEnum Values ---- javaScriptKeywords.add(&amp;quot;adParamSigned&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adParamNullable&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adParamLong&amp;quot;, Token.LITERAL2); ---- ParameterDirectionEnum Values ---- javaScriptKeywords.add(&amp;quot;adParamUnknown&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adParamInput&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adParamOutput&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adParamInputOutput&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adParamReturnValue&amp;quot;, Token.LITERAL2); ---- CommandTypeEnum Values ---- javaScriptKeywords.add(&amp;quot;adCmdUnknown&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCmdText&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCmdTable&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCmdStoredProc&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCmdFile&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCmdTableDirect&amp;quot;, Token.LITERAL2); ---- EventStatusEnum Values ---- javaScriptKeywords.add(&amp;quot;adStatusOK&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adStatusErrorsOccurred&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adStatusCantDeny&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adStatusCancel&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adStatusUnwantedEvent&amp;quot;, Token.LITERAL2); ---- EventReasonEnum Values ---- javaScriptKeywords.add(&amp;quot;adRsnAddNew&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnDelete&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnUpdate&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnUndoUpdate&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnUndoAddNew&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnUndoDelete&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnRequery&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnResynch&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnClose&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnMove&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnFirstChange&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnMoveFirst&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnMoveNext&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnMovePrevious&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRsnMoveLast&amp;quot;, Token.LITERAL2); ---- SchemaEnum Values ---- javaScriptKeywords.add(&amp;quot;adSchemaProviderSpecific&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaAsserts&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaCatalogs&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaCharacterSets&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaCollations&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaColumns&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaCheckConstraints&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaConstraintColumnUsage&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaConstraintTableUsage&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaKeyColumnUsage&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaReferentialConstraints&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaTableConstraints&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaColumnsDomainUsage&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaIndexes&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaColumnPrivileges&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaTablePrivileges&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaUsagePrivileges&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaProcedures&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaSchemata&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaSQLLanguages&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaStatistics&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaTables&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaTranslations&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaProviderTypes&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaViews&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaViewColumnUsage&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaViewTableUsage&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaProcedureParameters&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaForeignKeys&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaPrimaryKeys&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaProcedureColumns&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaDBInfoKeywords&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaDBInfoLiterals&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaCubes&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaDimensions&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaHierarchies&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaLevels&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaMeasures&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaProperties&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSchemaMembers&amp;quot;, Token.LITERAL2); ---- SeekEnum Values ---- javaScriptKeywords.add(&amp;quot;adSeekFirstEQ&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSeekLastEQ&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSeekAfterEQ&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSeekAfter&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSeekBeforeEQ&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adSeekBefore&amp;quot;, Token.LITERAL2); ---- ADCPROP_UPDATECRITERIA_ENUM Values ---- javaScriptKeywords.add(&amp;quot;adCriteriaKey&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCriteriaAllCols&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCriteriaUpdCols&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adCriteriaTimeStamp&amp;quot;, Token.LITERAL2); ---- ADCPROP_ASYNCTHREADPRIORITY_ENUM Values ---- javaScriptKeywords.add(&amp;quot;adPriorityLowest&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPriorityBelowNormal&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPriorityNormal&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPriorityAboveNormal&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adPriorityHighest&amp;quot;, Token.LITERAL2); ---- CEResyncEnum Values ---- javaScriptKeywords.add(&amp;quot;adResyncNone&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adResyncAutoIncrement&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adResyncConflicts&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adResyncUpdates&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adResyncInserts&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adResyncAll&amp;quot;, Token.LITERAL2); ---- ADCPROP_AUTORECALC_ENUM Values ---- javaScriptKeywords.add(&amp;quot;adRecalcUpFront&amp;quot;, Token.LITERAL2); javaScriptKeywords.add(&amp;quot;adRecalcAlways&amp;quot;, Token.LITERAL2);"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.PropsTokenMarker" intfc="n" abs="n" inn="n" sloc="64" jdoc="Java properties DOS INI token marker. @author Slava Pestov @version $Id: PropsTokenMarker.java,v 1.1.1.1 2001 08 20 22:31:41 gfx Exp $">
			<const name="VALUE" access="pub" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PropsTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PropsTokenMarker.supportsMultilineTokens()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.ASPStateInfo" intfc="n" abs="n" inn="n" sloc="53" jdoc="An utility class to save some relevant infos (language and client server side) found in SCRIPT Tags or &amp;lt;%@ like Tags @author Andre Kaplan @version 0.6">
			<field name="client" access="pub" jdoc=""/>
			<field name="language" access="pub" jdoc=""/>
			<field name="modes" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPStateInfo.ASPStateInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPStateInfo.ASPStateInfo(boolean, String)" access="pub" jdoc="">
				<param name="client"/>
				<param name="language"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPStateInfo.init(boolean, String)" access="pub" jdoc="">
				<param name="client"/>
				<param name="language"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPStateInfo.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPStateInfo.toASPMode()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPStateInfo.display(java.io.PrintStream)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.ASPTokenMarker" intfc="n" abs="n" inn="n" sloc="389" jdoc="ASP Token Marker. TO DO: CSS support, HTML Entities, HTML Attributes &amp; Values colorizing @author Andre Kaplan @version 0.6">
			<comm cntt="Token to request next line parsing when the mode has changed"/>
			<comm cntt=""/>
			<comm cntt="markTokensImpl"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="markTokensImpl"/>
			<comm cntt=""/>
			<comm cntt="private members"/>
			<const name="MODE_CHANGE" access="pub" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="stateInfo" access="priv" jdoc=""/>
			<field name="defaultASPMode" access="priv" jdoc=""/>
			<field name="debug" access="priv" jdoc=""/>
			<field name="vbs" access="priv" jdoc=""/>
			<field name="js" access="priv" jdoc=""/>
			<field name="ps" access="priv" jdoc=""/>
			<field name="modes" access="priv" jdoc=""/>
			<field name="language" access="priv" jdoc=""/>
			<field name="runat" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPTokenMarker.ASPTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPTokenMarker.addToken(int, byte)" access="pub" jdoc="">
				<param name="length"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPTokenMarker.markTokensImpl(byte, Segment, int)" access="prot" jdoc="">
				<comm cntt="We store the old defaultASPMode"/>
				<comm cntt="We check if mode has changed"/>
				<comm cntt="We inform markTokens that the mode has changed"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPTokenMarker.markTokensImpl(MultiModeToken, TokenMarkerContext)" access="pub" jdoc="">
				<comm cntt="We got stuck here at some point"/>
				<comm cntt="Log this and increment tokenContext.pos to escape this"/>
				<comm cntt="Switch to ASP Mode if &amp;lt;% found at pos"/>
				<comm cntt="Except if already in a server-side mode"/>
				<comm cntt="Switch to HTML_SCRIPT Mode if &amp;lt;script found at pos"/>
				<comm cntt="Except if already in a server-side mode"/>
				<comm cntt="or in a client-side script"/>
				<comm cntt="HTML Text"/>
				<comm cntt="Server-Side Include comment"/>
				<comm cntt="break; Not reached was already continued"/>
				<comm cntt=""/>
				<comm cntt="Inside a tag"/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt="Inside an ASP CFG tag (&amp;lt;%@)"/>
				<comm cntt=""/>
				<comm cntt="System.out.println(&amp;quot;ASP CFG&amp;quot;);"/>
				<comm cntt="this.stateInfo.display(System.out);"/>
				<comm cntt="the language was not recognized, default to html"/>
				<comm cntt=""/>
				<comm cntt="Inside a script tag"/>
				<comm cntt=""/>
				<comm cntt="this.stateInfo.display(System.out);"/>
				<comm cntt="If this is a client script tag"/>
				<comm cntt="we test if are inside an HTML COMMENT"/>
				<comm cntt="and if it is, we just ignore the script tag and go"/>
				<comm cntt="back to normal"/>
				<comm cntt="the language was not recognized, default to html"/>
				<comm cntt=""/>
				<comm cntt="Inside an entity"/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt="Inside an HTML comment or SSI"/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt="Inside an ASP script"/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt="Inside a SCRIPT"/>
				<comm cntt=""/>
				<comm cntt="END LOOP"/>
				<param name="token"/>
				<param name="tokenContext"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPTokenMarker.doASP(MultiModeToken, TokenMarkerContext)" access="priv" jdoc="Checks if ASP mode is entered at pos then updates Token and Context">
				<comm cntt="We save the current mode"/>
				<param name="mmt"/>
				<param name="tokenContext"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPTokenMarker.doScript(MultiModeToken, TokenMarkerContext)" access="priv" jdoc="">
				<comm cntt="We save the current mode"/>
				<comm cntt="If we are in a HTML Comment we can not decide if we tokenize"/>
				<comm cntt="until we know that the script executes on the server"/>
				<comm cntt="mmt.token = Token.KEYWORD1;"/>
				<param name="mmt"/>
				<param name="tokenContext"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASPTokenMarker.doScriptClose(MultiModeToken, TokenMarkerContext)" access="priv" jdoc="">
				<param name="mmt"/>
				<param name="tokenContext"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerDebugger" intfc="n" abs="n" inn="n" sloc="27" jdoc="@author Andre Kaplan @version 0.6">
			<comm cntt="Following is a way to detect whether tokenContext.pos is not"/>
			<comm cntt="correctly incremented. This is for debugging purposes"/>
			<const name="MAX_COUNT" access="pub" jdoc=""/>
			<field name="pos" access="priv" jdoc=""/>
			<field name="count" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerDebugger.TokenMarkerDebugger()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerDebugger.isOK(TokenMarkerContext)" access="pub" jdoc="">
				<comm cntt="Seems that we got stuck somewhere"/>
				<param name="tokenContext"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerDebugger.reset()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.PHPTokenMarker" intfc="n" abs="n" inn="n" sloc="490" jdoc="PHP token marker. @author Clancy Malcolm @version $Id: PHPTokenMarker.java,v 1.11 2003 06 30 17:31:10 blaisorblade Exp $">
			<comm cntt="private members"/>
			<const name="SCRIPT" access="pub" jdoc=""/>
			<const name="HTML_LITERAL_QUOTE" access="pub" jdoc=""/>
			<const name="HTML_LITERAL_NO_QUOTE" access="pub" jdoc=""/>
			<const name="INSIDE_TAG" access="pub" jdoc=""/>
			<const name="PHP_VARIABLE" access="pub" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<field name="lastWhitespace" access="priv" jdoc=""/>
			<field name="script" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PHPTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="HTML text"/>
				<comm cntt="addToken(1, Token.KEYWORD1);"/>
				<comm cntt="addToken(6, Token.LABEL);"/>
				<comm cntt="addToken(1, Token.KEYWORD1);"/>
				<comm cntt="lastOffset = lastKeyword = (i += 7) + 1;"/>
				<comm cntt="token = SCRIPT;"/>
				<comm cntt="SCRIPT;"/>
				<comm cntt="Inside a tag"/>
				<comm cntt="Token.KEYWORD3;"/>
				<comm cntt="if (c != &amp;apos; &amp;apos; &amp;&amp; c != &amp;apos;\t&amp;apos;) {"/>
				<comm cntt="Inside an entity"/>
				<comm cntt="Inside an attribute"/>
				<comm cntt="token = INSIDE_TAG;"/>
				<comm cntt="Inside a comment"/>
				<comm cntt="Inside a JavaScript or PHP"/>
				<comm cntt="addToken(9, Token.LABEL);"/>
				<comm cntt="Ending the script"/>
				<comm cntt="? operator"/>
				<comm cntt="This is the same as if(length &amp;gt; i + 1)"/>
				<comm cntt="operator"/>
				<comm cntt="operator"/>
				<comm cntt="&amp;&amp; c != &amp;apos;$&amp;apos;)"/>
				<comm cntt="Script &amp;quot;...&amp;quot;"/>
				<comm cntt="Script &amp;apos;...&amp;apos;"/>
				<comm cntt="Inside a Script comment"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PHPTokenMarker.addToken(int, byte)" access="prot" jdoc="">
				<param name="i"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PHPTokenMarker.addToken(int, byte, boolean)" access="prot" jdoc="">
				<param name="i"/>
				<param name="id"/>
				<param name="highlighBackground"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PHPTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.PlainTokenMarker" intfc="n" abs="n" inn="n" sloc="9" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PlainTokenMarker.PlainTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PlainTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext" intfc="n" abs="n" inn="n" sloc="156" jdoc="This class contains the Context of a Token Marker that can be passed along nested Token Markers through a method like markTokensImpl(MyToken token, TokenMarkerContext ctx) : MyToken where MyToken represents the token state at the end of the marked line. It contains useful infos such as last offset and last keyword and the pos in the marked line It also provides utility functions that are often used in TokenMarkers such as addTokenToPos, addTokenToEnd doKeywordToPos, doKeywordToEnd @author Andre Kaplan @version 0.6">
			<comm cntt=""/>
			<comm cntt="addTokenToEnd"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="doKeywordToPos"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="doKeywordToPos"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="doKeywordToEnd"/>
			<comm cntt=""/>
			<field name="line" access="pub" jdoc=""/>
			<field name="lineIndex" access="pub" jdoc=""/>
			<field name="array" access="pub" jdoc=""/>
			<field name="offset" access="pub" jdoc=""/>
			<field name="lastOffset" access="pub" jdoc=""/>
			<field name="lastKeyword" access="pub" jdoc=""/>
			<field name="length" access="pub" jdoc=""/>
			<field name="pos" access="pub" jdoc=""/>
			<field name="marker" access="priv" jdoc=""/>
			<field name="prevLineInfo" access="pub" jdoc=""/>
			<field name="currLineInfo" access="pub" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.TokenMarkerContext(Segment, int, TokenMarkerWithAddToken, TokenMarker.LineInfo[])" access="pub" jdoc="">
				<param name="line"/>
				<param name="lineIndex"/>
				<param name="marker"/>
				<param name="lineInfo"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.TokenMarkerContext(Segment, int, TokenMarkerWithAddToken)" access="pub" jdoc="">
				<param name="line"/>
				<param name="lineIndex"/>
				<param name="marker"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.atFirst()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.hasMoreChars()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.remainingChars()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.getChar()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.getChar(int)" access="pub" jdoc="">
				<param name="inc"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.lastChar()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.addToken(int, byte)" access="pub" jdoc="">
				<param name="length"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.addTokenToPos(byte)" access="pub" jdoc="Adds a token to the position specified (position exclusive) The character at pos index is excluded">
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.addTokenToPos(int, byte)" access="pub" jdoc="">
				<param name="pos"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.addTokenToEnd(byte)" access="pub" jdoc="">
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.doKeywordToPos(int, KeywordMap)" access="pub" jdoc="">
				<param name="pos"/>
				<param name="keywords"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.doKeywordToPos(KeywordMap)" access="pub" jdoc="">
				<param name="keywords"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.doKeywordToEnd(KeywordMap)" access="pub" jdoc="">
				<param name="keywords"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.regionMatches(boolean, String)" access="pub" jdoc="">
				<param name="ignoreCase"/>
				<param name="match"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.RERegionMatches(RE)" access="pub" jdoc="">
				<param name="match"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.RERegionMatches(Segment, int, RE)" access="priv" jdoc="Checks if a subregion of a &amp;lt;code&amp;gt;Segment&amp;lt; code&amp;gt; matches a regular expression. The match-beginning operator (^) in the regular expression matches segment at position offset This function is intended to be part of SyntaxUtilities @param text The segment @param offset The offset into the segment @param match The regular expression to match">
				<comm cntt="BUG: The following may throw exceptions"/>
				<comm cntt="I guess it&amp;apos;s a thread safety issue since text.array may point to nowhere before getMatch has completed"/>
				<comm cntt="If anyone knows about it..."/>
				<comm cntt="char[] textArray = text.array;"/>
				<comm cntt="return match.getMatch(textArray, offset, RE.REG_ANCHORINDEX);"/>
				<param name="text"/>
				<param name="offset"/>
				<param name="match"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarkerContext.toString()" access="pub" jdoc="">
				<comm cntt="Line numbers start from 1"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.PikeTokenMarker" intfc="n" abs="n" inn="n" sloc="53" jdoc="Pike token marker. @author Romain Guy">
			<comm cntt="private members"/>
			<field name="pikeKeywords" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PikeTokenMarker.PikeTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PikeTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.HTMLTokenMarker" intfc="n" abs="n" inn="n" sloc="363" jdoc="HTML token marker. @author Slava Pestov @version $Id: HTMLTokenMarker.java,v 1.3 2001 12 01 18:54:31 gfx Exp $">
			<comm cntt="private members"/>
			<const name="JAVASCRIPT" access="pub" jdoc=""/>
			<const name="HTML_LITERAL_QUOTE" access="pub" jdoc=""/>
			<const name="HTML_LITERAL_NO_QUOTE" access="pub" jdoc=""/>
			<const name="INSIDE_TAG" access="pub" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="js" access="priv" jdoc=""/>
			<field name="javascript" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<field name="lastWhitespace" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.HTMLTokenMarker.HTMLTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.HTMLTokenMarker.HTMLTokenMarker(boolean)" access="pub" jdoc="">
				<param name="js"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.HTMLTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="HTML text"/>
				<comm cntt="addToken(6, Token.METHOD);"/>
				<comm cntt="lastOffset = lastKeyword = (i += 7);"/>
				<comm cntt="JAVASCRIPT;"/>
				<comm cntt="Inside a tag"/>
				<comm cntt="if (c != &amp;apos; &amp;apos; &amp;&amp; c != &amp;apos;\t&amp;apos;) {"/>
				<comm cntt="Inside an entity"/>
				<comm cntt="Inside an attribute"/>
				<comm cntt="token = INSIDE_TAG;"/>
				<comm cntt="Inside a comment"/>
				<comm cntt="Inside a JavaScript"/>
				<comm cntt="JavaScript &amp;quot;...&amp;quot;"/>
				<comm cntt="JavaScript &amp;apos;...&amp;apos;"/>
				<comm cntt="Inside a JavaScript comment"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.HTMLTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.PascalTokenMarker" intfc="n" abs="n" inn="n" sloc="239" jdoc="Pascal token marker.">
			<comm cntt="private members"/>
			<const name="METHOD_DELIMITERS" access="pub" jdoc=""/>
			<field name="pascalKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<field name="lastWhitespace" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PascalTokenMarker.PascalTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PascalTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PascalTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PascalTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle" intfc="n" abs="n" inn="n" sloc="73" jdoc="A simple text style class. It can specify the color, italic flag, and bold flag of a run of text. @author Slava Pestov @version $Id: SyntaxStyle.java,v 1.1.1.1 2001 08 20 22:31:42 gfx Exp $">
			<comm cntt="private members"/>
			<field name="color" access="priv" jdoc=""/>
			<field name="italic" access="priv" jdoc=""/>
			<field name="bold" access="priv" jdoc=""/>
			<field name="lastFont" access="priv" jdoc=""/>
			<field name="lastStyledFont" access="priv" jdoc=""/>
			<field name="fontMetrics" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle.SyntaxStyle(Color, boolean, boolean)" access="pub" jdoc="Creates a new SyntaxStyle. @param color The text color @param italic True if the text should be italics @param bold True if the text should be bold">
				<param name="color"/>
				<param name="italic"/>
				<param name="bold"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle.getColor()" access="pub" jdoc="Returns the color specified in this style.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle.isPlain()" access="pub" jdoc="Returns true if no font styles are enabled.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle.isItalic()" access="pub" jdoc="Returns true if italics is enabled for this style.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle.isBold()" access="pub" jdoc="Returns true if boldface is enabled for this style.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle.getStyledFont(Font)" access="pub" jdoc="Returns the specified font, but with the style&amp;apos;s bold and italic flags applied.">
				<param name="font"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle.getFontMetrics(Font)" access="pub" jdoc="Returns the font metrics for the styled font.">
				<param name="font"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle.setGraphicsFlags(Graphics, Font)" access="pub" jdoc="Sets the foreground color and font of the specified graphics context to that specified in this style. @param gfx The graphics context @param font The font to add the styles to">
				<param name="gfx"/>
				<param name="font"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxStyle.toString()" access="pub" jdoc="Returns a string representation of this object.">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.IDLTokenMarker" intfc="n" abs="n" inn="n" sloc="53" jdoc="IDL token marker. @author Slava Pestov @author Juha Lindfors @version $Id: IDLTokenMarker.java,v 1.1.1.1 2001 08 20 22:32:06 gfx Exp $">
			<comm cntt="private members"/>
			<field name="idlKeywords" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.IDLTokenMarker.IDLTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.IDLTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap" intfc="n" abs="n" inn="n" sloc="61" jdoc="A &amp;lt;code&amp;gt;KeywordMap&amp;lt; code&amp;gt; is similar to a hashtable in that it maps keys to values. However, the `keys&amp;apos; are Swing segments. This allows lookups of text substrings without the overhead of creating a new string object. &amp;lt;p&amp;gt; This class is used by &amp;lt;code&amp;gt;CTokenMarker&amp;lt; code&amp;gt; to map keywords to ids. @author Slava Pestov, Mike Dillon @version $Id: KeywordMap.java,v 1.1.1.1 2001 08 20 22:32:06 gfx Exp $">
			<comm cntt="protected members"/>
			<comm cntt="private members"/>
			<field name="mapLength" access="prot" jdoc=""/>
			<field name="map" access="priv" jdoc=""/>
			<field name="ignoreCase" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap.KeywordMap(boolean)" access="pub" jdoc="Creates a new &amp;lt;code&amp;gt;KeywordMap&amp;lt; code&amp;gt;. @param ignoreCase True if keys are case insensitive">
				<param name="ignoreCase"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap.KeywordMap(boolean, int)" access="pub" jdoc="Creates a new &amp;lt;code&amp;gt;KeywordMap&amp;lt; code&amp;gt;. @param ignoreCase True if the keys are case insensitive @param mapLength The number of `buckets&amp;apos; to create. A value of 52 will give good performance for most maps.">
				<param name="ignoreCase"/>
				<param name="mapLength"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap.lookup(Segment, int, int)" access="pub" jdoc="Looks up a key. @param text The text segment @param offset The offset of the substring within the text segment @param length The length of the substring">
				<param name="text"/>
				<param name="offset"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap.add(String, byte)" access="pub" jdoc="Adds a key-value mapping. @param keyword The key @Param id The value">
				<param name="keyword"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap.getIgnoreCase()" access="pub" jdoc="Returns true if the keyword map is set to be case insensitive, false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap.setIgnoreCase(boolean)" access="pub" jdoc="Sets if the keyword map should be case insensitive. @param ignoreCase True if the keyword map should be case insensitive, false otherwise">
				<param name="ignoreCase"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap.getStringMapKey(String)" access="prot" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap.getSegmentMapKey(Segment, int, int)" access="prot" jdoc="">
				<param name="s"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
		<class name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap$Keyword" intfc="n" abs="n" inn="y" sloc="12" jdoc="">
			<field name="keyword" access="pub" jdoc=""/>
			<field name="id" access="pub" jdoc=""/>
			<field name="next" access="pub" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.KeywordMap$Keyword.Keyword(char[], byte, Keyword)" access="pub" jdoc="">
				<param name="keyword"/>
				<param name="id"/>
				<param name="next"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.TextTokenMarker" intfc="n" abs="n" inn="n" sloc="82" jdoc="Text token marker.">
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TextTokenMarker.TextTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TextTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.PythonTokenMarker" intfc="n" abs="n" inn="n" sloc="260" jdoc="Python token marker. @author Jonathan Revusky, Romain Guy @version $Id: PythonTokenMarker.java,v 1.5 2001 12 01 18:54:31 gfx Exp $">
			<comm cntt="private members"/>
			<const name="TRIPLEQUOTE1" access="priv" jdoc=""/>
			<const name="TRIPLEQUOTE2" access="priv" jdoc=""/>
			<field name="pyKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<field name="lastWhitespace" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PythonTokenMarker.PythonTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PythonTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PythonTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PythonTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.ASMTokenMarker" intfc="n" abs="n" inn="n" sloc="896" jdoc="">
			<comm cntt="private members"/>
			<field name="asmKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASMTokenMarker.ASMTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASMTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASMTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.ASMTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.FortranTokenMarker" intfc="n" abs="n" inn="n" sloc="250" jdoc="Custom TokenMarker for UNISYS&amp;apos;s &amp;lt;cite&amp;gt;ASCII FORTRAN 77&amp;lt; cite&amp;gt;. Characteristics of this dialect are:&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;Fixed column format, with&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;comment character ( &amp;apos;C&amp;apos;|&amp;apos;c&amp;apos;|&amp;apos; &amp;apos; ) in column 1,&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;labels (numeric) in column 1-5,&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;continuation character ( any nonblank ) in column 6,&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;logical end of line after column 72.&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt;&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;Nonstandard block comment character ( &amp;apos;@&amp;apos; ) in any column,&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;Some nonstandard functions: &amp;lt;code&amp;gt;BITS&amp;lt; code&amp;gt;, &amp;lt;code&amp;gt;BOOL&amp;lt; code&amp;gt;, &amp;lt;code&amp;gt;INDEX&amp;lt; code&amp;gt;, &amp;lt;code&amp;gt;TRMLEN&amp;lt; code&amp;gt;&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; It should be easy enough to adapt this class for minor variations in the dialect so long as the format is the classic fixed column format. As this scanner is highly optimized for the fixed column format, it is probably not readily adaptable for freeform FORTRAN code.">
			<comm cntt="private members"/>
			<const name="MAYBE_KEYWORD_FIRST" access="priv" jdoc=""/>
			<const name="MAYBE_KEYWORD_MORE" access="priv" jdoc=""/>
			<const name="S_E_P" access="priv" jdoc=""/>
			<field name="fortranKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.FortranTokenMarker.FortranTokenMarker()" access="pub" jdoc="Constructor, with a wee bit of initialization.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.FortranTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="Implementation of code to mark tokens.">
				<comm cntt="--- Very quick check for empty line"/>
				<comm cntt="EXIT METHOD!"/>
				<comm cntt="--- Very quick check for &amp;apos;C&amp;apos; comment line"/>
				<comm cntt="EXIT METHOD!"/>
				<comm cntt="context usually ends on line boundary"/>
				<comm cntt="--- Check for a label"/>
				<comm cntt="comment to end of line"/>
				<comm cntt="EXIT METHOD!"/>
				<comm cntt="numerics: Label."/>
				<comm cntt="--- End of line?"/>
				<comm cntt="EXIT METHOD!"/>
				<comm cntt="--- Check for line continuation"/>
				<comm cntt="comment to end of line"/>
				<comm cntt="EXIT METHOD!"/>
				<comm cntt="just a plain old blank"/>
				<comm cntt="line continuation: mark it as a label to make it stand out"/>
				<comm cntt="--- End of line?"/>
				<comm cntt="EXIT METHOD!"/>
				<comm cntt="--- Check for &amp;quot;START EDIT PAGE&amp;quot;"/>
				<comm cntt="EXIT METHOD!"/>
				<comm cntt="--- &amp;apos;normal&amp;apos; real, honest coding now"/>
				<comm cntt="ignore anything but the end of literal"/>
				<comm cntt="comment to end of line"/>
				<comm cntt="EXIT METHOD!"/>
				<comm cntt="unknown special char - maintain state"/>
				<comm cntt="end for"/>
				<comm cntt="--- Finish up the coding part of the line"/>
				<comm cntt="--- End of line?"/>
				<comm cntt="EXIT METHOD!"/>
				<comm cntt="--- Anything beyond column 72 is comment"/>
				<comm cntt=""/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.FortranTokenMarker.checkStartEditPage(Segment)" access="priv" jdoc="">
				<param name="line"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.FortranTokenMarker.doKeyword(Segment, int)" access="priv" jdoc="Add the latest token to the current list. Process &amp;apos;START&amp;apos; as a special case.">
				<param name="line"/>
				<param name="keywordEnd"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.FortranTokenMarker.guardedAddToken(int, byte)" access="priv" jdoc="Call addToken only if the length of the token is not 0.">
				<param name="len"/>
				<param name="token"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.FortranTokenMarker.getKeywords()" access="pub" jdoc="Return the keyword map. It&amp;apos;s lazily initialized on the first call.">
				<comm cntt="=== Commands ==="/>
				<comm cntt="=== Compiler directives ==="/>
				<comm cntt="=== Data types (etc.) ==="/>
				<comm cntt="=== Operators ==="/>
				<comm cntt="=== Literals ==="/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.TSQLTokenMarker" intfc="n" abs="n" inn="n" sloc="1069" jdoc="SQL token marker.">
			<comm cntt="private members"/>
			<field name="bracket" access="pub" jdoc=""/>
			<field name="sqlKeywords" access="prot" jdoc=""/>
			<field name="cpp" access="priv" jdoc=""/>
			<field name="javadoc" access="priv" jdoc=""/>
			<field name="keywords" access="prot" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TSQLTokenMarker.TSQLTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TSQLTokenMarker.TSQLTokenMarker(KeywordMap)" access="pub" jdoc="">
				<param name="keywords"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TSQLTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TSQLTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TSQLTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.VHDLTokenMarker" intfc="n" abs="n" inn="n" sloc="274" jdoc="VHDL token marker. @author Bogdan Mitu @version $Id: VHDLTokenMarker.java,v 1.1.1.1 2001 08 20 22:31:49 gfx Exp $">
			<comm cntt="private members"/>
			<comm cntt="to be used by a future plugin"/>
			<comm cntt="to be used by a future plugin"/>
			<comm cntt="to be used by a future plugin"/>
			<comm cntt="to be used by a future plugin"/>
			<comm cntt="to be used by a future plugin"/>
			<const name="AS_IS" access="pub" jdoc=""/>
			<const name="LOWER_CASE" access="pub" jdoc=""/>
			<const name="UPPER_CASE" access="pub" jdoc=""/>
			<field name="vhdlKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<field name="keywordCase" access="priv" jdoc=""/>
			<field name="allLowerCase" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VHDLTokenMarker.VHDLTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VHDLTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VHDLTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VHDLTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VHDLTokenMarker.setKeywordCase(int)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VHDLTokenMarker.getKeywordCase()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VHDLTokenMarker.setAllLowerCase(boolean)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VHDLTokenMarker.getAllLowerCase()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.CSharpTokenMarker" intfc="n" abs="n" inn="n" sloc="324" jdoc="">
			<comm cntt="private members"/>
			<const name="VERBATIM_STRING" access="pub" jdoc=""/>
			<field name="cKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<field name="lastWhitespace" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CSharpTokenMarker.CSharpTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CSharpTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="Token.LITERAL1;"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CSharpTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.CSharpTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.SAP2000TokenMarker" intfc="n" abs="n" inn="n" sloc="191" jdoc="">
			<comm cntt="private members"/>
			<field name="sapKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SAP2000TokenMarker.SAP2000TokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SAP2000TokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="case Token.LITERAL1:"/>
				<comm cntt="case Token.LITERAL2:"/>
				<comm cntt="addToken(length - lastOffset, Token.INVALID);"/>
				<comm cntt="token = Token.NULL;"/>
				<comm cntt="break;"/>
				<comm cntt="case Token.KEYWORD2:"/>
				<comm cntt="addToken(length - lastOffset, token);"/>
				<comm cntt="token = Token.NULL;"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SAP2000TokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SAP2000TokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.JavaTokenMarker" intfc="n" abs="n" inn="n" sloc="264" jdoc="Java token marker. @author Slava Pestov @version $Id: JavaTokenMarker.java,v 1.6 2003 06 30 17:31:10 blaisorblade Exp $">
			<comm cntt="private members"/>
			<const name="META_DATA" access="pub" jdoc=""/>
			<field name="javaKeywords" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JavaTokenMarker.JavaTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JavaTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JavaTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.TeXTokenMarker" intfc="n" abs="n" inn="n" sloc="108" jdoc="TeX token marker. @author Slava Pestov @version $Id: TeXTokenMarker.java,v 1.1.1.1 2001 08 20 22:31:47 gfx Exp $">
			<comm cntt="public members"/>
			<const name="BDFORMULA" access="pub" jdoc=""/>
			<const name="EDFORMULA" access="pub" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TeXTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="if a backslash is followed immediately"/>
				<comm cntt="by a non-alpha character, the command at"/>
				<comm cntt="the non-alpha char. If we have a backslash,"/>
				<comm cntt="some text, and then a non-alpha char,"/>
				<comm cntt="the command ends before the non-alpha char."/>
				<comm cntt="\&amp;lt;non alpha&amp;gt;"/>
				<comm cntt="we skip over this character,"/>
				<comm cntt="hence the `continue&amp;apos;"/>
				<comm cntt="\blah&amp;lt;non alpha&amp;gt;"/>
				<comm cntt="we leave the character in"/>
				<comm cntt="the stream, and it&amp;apos;s not"/>
				<comm cntt="part of the command token"/>
				<comm cntt="singe $"/>
				<comm cntt="\...$"/>
				<comm cntt="$$aaa"/>
				<comm cntt="$$aaa$"/>
				<comm cntt="$$aaa$$"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.DawnTokenMarker" intfc="n" abs="n" inn="n" sloc="145" jdoc="">
			<comm cntt="private members"/>
			<field name="dawnKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.DawnTokenMarker.DawnTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.DawnTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="case Token.KEYWORD2:"/>
				<comm cntt="addToken(length - lastOffset, token);"/>
				<comm cntt="token = Token.NULL;"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.DawnTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.DawnTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.PovrayTokenMarker" intfc="n" abs="n" inn="n" sloc="188" jdoc="Povray token marker. @author Romain Guy">
			<comm cntt="private members"/>
			<field name="povrayKeywords" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PovrayTokenMarker.PovrayTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PovrayTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.JSPTokenMarker" intfc="n" abs="n" inn="n" sloc="591" jdoc="JSP token marker. @author Romain Guy">
			<comm cntt="private members"/>
			<const name="JAVASCRIPT" access="pub" jdoc=""/>
			<const name="HTML_LITERAL_QUOTE" access="pub" jdoc=""/>
			<const name="HTML_LITERAL_NO_QUOTE" access="pub" jdoc=""/>
			<const name="INSIDE_TAG" access="pub" jdoc=""/>
			<const name="JSP_NULL" access="pub" jdoc=""/>
			<const name="JSP_KEYWORD1" access="pub" jdoc=""/>
			<const name="JSP_KEYWORD2" access="pub" jdoc=""/>
			<const name="JSP_KEYWORD3" access="pub" jdoc=""/>
			<const name="JSP_COMMENT1" access="pub" jdoc=""/>
			<const name="JSP_COMMENT2" access="pub" jdoc=""/>
			<const name="JSP_METHOD" access="pub" jdoc=""/>
			<const name="JSP_LITERAL1" access="pub" jdoc=""/>
			<const name="JSP_LITERAL2" access="pub" jdoc=""/>
			<const name="JSP_LABEL" access="pub" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="javaKeywords" access="priv" jdoc=""/>
			<field name="js" access="priv" jdoc=""/>
			<field name="javascript" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<field name="lastWhitespace" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JSPTokenMarker.JSPTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JSPTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="HTML text"/>
				<comm cntt="addToken(6, Token.METHOD);"/>
				<comm cntt="lastOffset = lastKeyword = (i += 7);"/>
				<comm cntt="JAVASCRIPT;"/>
				<comm cntt="Inside a tag"/>
				<comm cntt="if (c != &amp;apos; &amp;apos; &amp;&amp; c != &amp;apos;\t&amp;apos;) {"/>
				<comm cntt="Inside an entity"/>
				<comm cntt="Inside an attribute"/>
				<comm cntt="token = INSIDE_TAG;"/>
				<comm cntt="Inside a comment"/>
				<comm cntt="Inside a JavaScript"/>
				<comm cntt="JavaScript &amp;quot;...&amp;quot;"/>
				<comm cntt="JavaScript &amp;apos;...&amp;apos;"/>
				<comm cntt="Inside a JavaScript comment"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JSPTokenMarker.doJSKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JSPTokenMarker.doJavaKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.JSPTokenMarker.doKeyword(Segment, int, char, boolean)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
				<param name="javaScript"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument" intfc="n" abs="n" inn="n" sloc="77" jdoc="A document implementation that can be tokenized by the syntax highlighting system. @author Slava Pestov @version $Id: SyntaxDocument.java,v 1.1.1.1 2001 08 20 22:31:42 gfx Exp $">
			<comm cntt="protected members"/>
			<field name="tokenMarker" access="prot" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument.getTokenMarker()" access="pub" jdoc="Returns the token marker that is to be used to split lines of this document up into tokens. May return null if this document is not to be colorized.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument.setTokenMarker(TokenMarker)" access="pub" jdoc="Sets the token marker that is to be used to split lines of this document up into tokens. May throw an exception if this is not supported for this type of document. @param tm The new token marker">
				<param name="tm"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument.tokenizeLines()" access="pub" jdoc="Reparses the document, by passing all lines to the token marker. This should be called after the document is first loaded.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument.tokenizeLines(int, int)" access="pub" jdoc="Reparses the document, by passing the specified lines to the token marker. This should be called after a large quantity of text is first inserted. @param start The first line to parse @param len The number of lines, after the first one to parse">
				<param name="start"/>
				<param name="len"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument.beginCompoundEdit()" access="pub" jdoc="Starts a compound edit that can be undone in one operation. Subclasses that implement undo should override this method; this class has no undo functionality so this method is empty.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument.endCompoundEdit()" access="pub" jdoc="Ends a compound edit that can be undone in one operation. Subclasses that implement undo should override this method; this class has no undo functionality so this method is empty.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument.addUndoableEdit(UndoableEdit)" access="pub" jdoc="Adds an undoable edit to this document&amp;apos;s undo list. The edit should be ignored if something is currently being undone. @param edit The undoable edit @since jEdit 2.2pre1">
				<param name="edit"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument.fireInsertUpdate(DocumentEvent)" access="prot" jdoc="We overwrite this method to update the token marker state immediately so that any event listeners get a consistent token marker.">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxDocument.fireRemoveUpdate(DocumentEvent)" access="prot" jdoc="We overwrite this method to update the token marker state immediately so that any event listeners get a consistent token marker.">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.PatchTokenMarker" intfc="n" abs="n" inn="n" sloc="28" jdoc="Patch diff token marker. @author Slava Pestov @version $Id: PatchTokenMarker.java,v 1.1 2002 12 27 18:50:37 blaisorblade Exp $">
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PatchTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PatchTokenMarker.supportsMultilineTokens()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.VerilogTokenMarker" intfc="n" abs="n" inn="n" sloc="325" jdoc="Verilog token marker. @author Bogdan Mitu @version $Id: VerilogTokenMarker.java,v 1.1.1.1 2001 08 20 22:31:50 gfx Exp $">
			<comm cntt="private members"/>
			<const name="NORMAL" access="pub" jdoc=""/>
			<const name="SIMPLE_QUOTE" access="pub" jdoc=""/>
			<const name="BACK_ACCENT" access="pub" jdoc=""/>
			<const name="DOLLAR" access="pub" jdoc=""/>
			<field name="env" access="pub" jdoc=""/>
			<field name="vKeywords" access="priv" jdoc=""/>
			<field name="cpp" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VerilogTokenMarker.VerilogTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VerilogTokenMarker.VerilogTokenMarker(KeywordMap)" access="pub" jdoc="">
				<param name="keywords"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VerilogTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VerilogTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.VerilogTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.PLSQLTokenMarker" intfc="n" abs="n" inn="n" sloc="337" jdoc="SQL token marker.">
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PLSQLTokenMarker.PLSQLTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.PLSQLTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.RubyTokenMarker" intfc="n" abs="n" inn="n" sloc="203" jdoc="Python token marker. @author Jonathan Revusky, Romain Guy @version $Id: RubyTokenMarker.java,v 1.2 2001 11 16 21:00:46 gfx Exp $">
			<comm cntt="private members"/>
			<field name="rubyKeywords" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<field name="lastWhitespace" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.RubyTokenMarker.RubyTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.RubyTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.RubyTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.RubyTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker" intfc="n" abs="y" inn="n" sloc="138" jdoc="A token marker that splits lines of text into tokens. Each token carries a length field and an indentification tag that can be mapped to a color for painting that token.&amp;lt;p&amp;gt; For performance reasons, the linked list of tokens is reused after each line is tokenized. Therefore, the return value of &amp;lt;code&amp;gt;markTokens&amp;lt; code&amp;gt; should only be used for immediate painting. Notably, it cannot be cached. @author Slava Pestov @version $Id: TokenMarker.java,v 1.5 2003 06 30 17:31:10 blaisorblade Exp $ @see org.gjt.sp.jedit.syntax.Token">
			<comm cntt="protected members"/>
			<field name="firstToken" access="prot" jdoc="The first token in the list. This should be used as the return value from &amp;lt;code&amp;gt;markTokens()&amp;lt; code&amp;gt;."/>
			<field name="lastToken" access="prot" jdoc="The last token in the list. New tokens are added here. This should be set to null before a new line is to be tokenized."/>
			<field name="lineInfo" access="prot" jdoc="An array for storing information about lines. It is enlarged and shrunk automatically by the &amp;lt;code&amp;gt;insertLines()&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;deleteLines()&amp;lt; code&amp;gt; methods."/>
			<field name="length" access="prot" jdoc="The number of lines in the model being tokenized. This can be less than the length of the &amp;lt;code&amp;gt;lineInfo&amp;lt; code&amp;gt; array."/>
			<field name="lastLine" access="prot" jdoc="The last tokenized line."/>
			<field name="nextLineRequested" access="prot" jdoc="True if the next line should be painted."/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.markTokens(Segment, int)" access="pub" jdoc="A wrapper for the lower-level &amp;lt;code&amp;gt;markTokensImpl&amp;lt; code&amp;gt; method that is called to split a line up into tokens. @param line The line @param lineIndex The line number">
				<comm cntt="This is a foul hack. It stops nextLineRequested from being cleared if the same line is marked twice. Why is this necessary? It&amp;apos;s all JEditTextArea&amp;apos;s fault. When something is inserted into the text, firing a document event, the insertUpdate() method shifts the caret (if necessary) by the amount inserted. All caret movement is handled by the select() method, which eventually pipes the new position to scrollTo() and calls repaint(). Note that at this point in time, the new line hasn&amp;apos;t yet been painted; the caret is moved first. scrollTo() calls offsetToX(), which tokenizes the line unless it is being called on the last line painted (in which case it uses the text area&amp;apos;s painter cached token list). What scrollTo() does next is irrelevant. After scrollTo() has done it&amp;apos;s job, repaint() is called, and eventually we end up in paintLine(), whose job is to paint the changed line. It, too, calls markTokens(). The problem was that if the line started a multiline token, the first markTokens() (done in offsetToX()) would set nextLineRequested (because the line end token had changed) but the second would clear it (because the line was the same that time) and therefore paintLine() would never know that it needed to repaint subsequent lines. This bug took me ages to track down, that&amp;apos;s why I wrote all the relevant info down so that others wouldn&amp;apos;t duplicate it."/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.markTokensImpl(byte, Segment, int)" access="prot" jdoc="An abstract method that splits a line up into tokens. It should parse the line, and call &amp;lt;code&amp;gt;addToken()&amp;lt; code&amp;gt; to add syntax tokens to the token list. Then, it should return the initial token type for the next line.&amp;lt;p&amp;gt; For example if the current line contains the start of a multiline comment that doesn&amp;apos;t end on that line, this method should return the comment token type so that it continues on the next line. @param token The initial token type for this line @param line The line to be tokenized @param lineIndex The index of the line in the document, starting at 0 @return The initial token type for the next line">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.supportsMultilineTokens()" access="pub" jdoc="Returns if the token marker supports tokens that span multiple lines. If this is true, the object using this token marker is required to pass all lines in the document to the &amp;lt;code&amp;gt;markTokens()&amp;lt; code&amp;gt; method (in turn).&amp;lt;p&amp;gt; The default implementation returns true; it should be overridden to return false on simpler token markers for increased speed.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.insertLines(int, int)" access="pub" jdoc="Informs the token marker that lines have been inserted into the document. This inserts a gap in the &amp;lt;code&amp;gt;lineInfo&amp;lt; code&amp;gt; array. @param index The first line number @param lines The number of lines">
				<param name="index"/>
				<param name="lines"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.deleteLines(int, int)" access="pub" jdoc="Informs the token marker that line have been deleted from the document. This removes the lines in question from the &amp;lt;code&amp;gt;lineInfo&amp;lt; code&amp;gt; array. @param index The first line number @param lines The number of lines">
				<param name="index"/>
				<param name="lines"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.getLineCount()" access="pub" jdoc="Returns the number of lines in this token marker.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.isNextLineRequested()" access="pub" jdoc="Returns true if the next line should be repainted. This will return true after a line has been tokenized that starts a multiline token that continues onto the next line.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.TokenMarker()" access="prot" jdoc="Creates a new &amp;lt;code&amp;gt;TokenMarker&amp;lt; code&amp;gt;. This DOES NOT create a lineInfo array; an initial call to &amp;lt;code&amp;gt;insertLines()&amp;lt; code&amp;gt; does that.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.ensureCapacity(int)" access="prot" jdoc="Ensures that the &amp;lt;code&amp;gt;lineInfo&amp;lt; code&amp;gt; array can contain the specified index. This enlarges it if necessary. No action is taken if the array is large enough already.&amp;lt;p&amp;gt; It should be unnecessary to call this under normal circumstances; &amp;lt;code&amp;gt;insertLine()&amp;lt; code&amp;gt; should take care of enlarging the line info array automatically. @param index The array index">
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.getMaxLineWidth(int, int)" access="pub" jdoc="Returns the maximum line width in the specified line range. @param start The first line @param len The number of lines">
				<param name="start"/>
				<param name="len"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.addToken(int, byte)" access="prot" jdoc="Adds a token to the token list. @param length The length of the token @param id The id of the token">
				<param name="length"/>
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.addToken(int, byte, boolean)" access="prot" jdoc="">
				<param name="length"/>
				<param name="id"/>
				<param name="highlightBackground"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker.setLineWidth(int, int)" access="pub" jdoc="Store the width of a line, in pixels. @param lineIndex The line number @param width The width">
				<param name="lineIndex"/>
				<param name="width"/>
			</mth>
		<class name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker$LineInfo" intfc="n" abs="n" inn="y" sloc="14" jdoc="Inner class for storing information about tokenized lines.">
			<field name="width" access="pub" jdoc=""/>
			<field name="token" access="pub" jdoc="The id of the last token of the line."/>
			<field name="obj" access="pub" jdoc="This is for use by the token marker implementations themselves. It can be used to store anything that is an object and that needs to exist on a per-line basis."/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker$LineInfo.LineInfo()" access="pub" jdoc="Creates a new LineInfo object with token = Token.NULL and obj = null.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.TokenMarker$LineInfo.LineInfo(byte, Object)" access="pub" jdoc="Creates a new LineInfo object with the specified parameters.">
				<param name="token"/>
				<param name="obj"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.ASPMode" intfc="n" abs="n" inn="n" sloc="17" jdoc="ASP Mode constants @author Andre Kaplan @version 0.6">
			<const name="HTML" access="pub" jdoc=""/>
			<const name="HTML_COMMENT" access="pub" jdoc=""/>
			<const name="HTML_ENTITY" access="pub" jdoc=""/>
			<const name="HTML_TAG" access="pub" jdoc=""/>
			<const name="HTML_SCRIPT" access="pub" jdoc=""/>
			<const name="SSI" access="pub" jdoc=""/>
			<const name="ASP" access="pub" jdoc=""/>
			<const name="ASP_CFG" access="pub" jdoc=""/>
			<const name="SSVB" access="pub" jdoc=""/>
			<const name="CSVB" access="pub" jdoc=""/>
			<const name="SSJS" access="pub" jdoc=""/>
			<const name="CSJS" access="pub" jdoc=""/>
			<const name="SSPS" access="pub" jdoc=""/>
			<const name="CSPS" access="pub" jdoc=""/>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.SyntaxUtilities" intfc="n" abs="n" inn="n" sloc="92" jdoc="Class with several utility functions used by jEdit&amp;apos;s syntax colorizing subsystem. @author Slava Pestov @version $Id: SyntaxUtilities.java,v 1.4 2003 06 30 17:31:10 blaisorblade Exp $">
			<comm cntt="private members"/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxUtilities.regionMatches(boolean, Segment, int, String)" access="pub" jdoc="Checks if a subregion of a &amp;lt;code&amp;gt;Segment&amp;lt; code&amp;gt; is equal to a string. @param ignoreCase True if case should be ignored, false otherwise @param text The segment @param offset The offset into the segment @param match The string to match">
				<param name="ignoreCase"/>
				<param name="text"/>
				<param name="offset"/>
				<param name="match"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxUtilities.regionMatches(boolean, Segment, int, char[])" access="pub" jdoc="Checks if a subregion of a &amp;lt;code&amp;gt;Segment&amp;lt; code&amp;gt; is equal to a character array. @param ignoreCase True if case should be ignored, false otherwise @param text The segment @param offset The offset into the segment @param match The character array to match">
				<param name="ignoreCase"/>
				<param name="text"/>
				<param name="offset"/>
				<param name="match"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxUtilities.getDefaultSyntaxStyles()" access="pub" jdoc="Returns the default style table. This can be passed to the &amp;lt;code&amp;gt;setStyles()&amp;lt; code&amp;gt; method of &amp;lt;code&amp;gt;SyntaxDocument&amp;lt; code&amp;gt; to use the default syntax styles.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxUtilities.paintSyntaxLine(Segment, Token, SyntaxStyle[], TabExpander, Graphics, int, int)" access="pub" jdoc="Paints the specified line onto the graphics context. Note that this method munges the offset and count values of the segment. @param line The line segment @param tokens The token list for the line @param styles The syntax style list @param expander The tab expander used to determine tab stops. May be null @param gfx The graphics context @param x The x co-ordinate @param y The y co-ordinate @return The x co-ordinate, plus the width of the painted string">
				<param name="line"/>
				<param name="tokens"/>
				<param name="styles"/>
				<param name="expander"/>
				<param name="gfx"/>
				<param name="x"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SyntaxUtilities.SyntaxUtilities()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.BatchFileTokenMarker" intfc="n" abs="n" inn="n" sloc="90" jdoc="Batch file token marker. @author Slava Pestov @version $Id: BatchFileTokenMarker.java,v 1.1.1.1 2001 08 20 22:32:04 gfx Exp $">
			<mth name="/lib/:org.gjt.sp.jedit.syntax.BatchFileTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.BatchFileTokenMarker.supportsMultilineTokens()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.syntax.SQRTokenMarker" intfc="n" abs="n" inn="n" sloc="259" jdoc="sqr token marker.">
			<comm cntt="private members"/>
			<field name="bracket" access="pub" jdoc=""/>
			<field name="sqrKeywords" access="priv" jdoc=""/>
			<field name="cpp" access="priv" jdoc=""/>
			<field name="javadoc" access="priv" jdoc=""/>
			<field name="keywords" access="priv" jdoc=""/>
			<field name="lastOffset" access="priv" jdoc=""/>
			<field name="lastKeyword" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SQRTokenMarker.SQRTokenMarker()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SQRTokenMarker.markTokensImpl(byte, Segment, int)" access="pub" jdoc="">
				<comm cntt="THIS IS SQR&amp;apos;s Line Comment Indicator"/>
				<comm cntt="SQR Allows some weird Characters in Keywords"/>
				<param name="token"/>
				<param name="line"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SQRTokenMarker.getKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.syntax.SQRTokenMarker.doKeyword(Segment, int, char)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
				<param name="c"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.gjt.sp.jedit.textarea">
		<class name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter" intfc="n" abs="n" inn="n" sloc="556" jdoc="The text area repaint manager. It performs double buffering and paints lines of text. @author Slava Pestov @version $Id: TextAreaPainter.java,v 1.9 2003 06 30 17:31:08 blaisorblade Exp $">
			<comm cntt=""/>
			<comm cntt="ANTI ALIASING"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="WRAP GUIDE"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="INTERVAL HIGHLIGHTING"/>
			<comm cntt=""/>
			<comm cntt="protected members"/>
			<field name="ANTI_ALIASED_RENDERING" access="pub" jdoc=""/>
			<field name="DEFAULT_RENDERING" access="pub" jdoc=""/>
			<field name="antiAliasing" access="priv" jdoc=""/>
			<field name="wasAntiAliasing" access="priv" jdoc=""/>
			<field name="wrapGuide" access="priv" jdoc=""/>
			<field name="wrapGuideColor" access="priv" jdoc=""/>
			<field name="wrapGuideOffset" access="priv" jdoc=""/>
			<field name="linesIntervalHighlight" access="priv" jdoc=""/>
			<field name="linesIntervalColor" access="priv" jdoc=""/>
			<field name="linesInterval" access="priv" jdoc=""/>
			<field name="textArea" access="prot" jdoc=""/>
			<field name="styles" access="prot" jdoc=""/>
			<field name="caretColor" access="prot" jdoc=""/>
			<field name="selectionColor" access="prot" jdoc=""/>
			<field name="lineHighlightColor" access="prot" jdoc=""/>
			<field name="highlightColor" access="prot" jdoc=""/>
			<field name="bracketHighlightColor" access="prot" jdoc=""/>
			<field name="eolMarkerColor" access="prot" jdoc=""/>
			<field name="blockCaret" access="prot" jdoc=""/>
			<field name="lineHighlight" access="prot" jdoc=""/>
			<field name="bracketHighlight" access="prot" jdoc=""/>
			<field name="paintInvalid" access="prot" jdoc=""/>
			<field name="eolMarkers" access="prot" jdoc=""/>
			<field name="cols" access="prot" jdoc=""/>
			<field name="rows" access="prot" jdoc=""/>
			<field name="tabSize" access="prot" jdoc=""/>
			<field name="fm" access="prot" jdoc=""/>
			<field name="highlights" access="prot" jdoc=""/>
			<field name="firstPriorityHighlights" access="prot" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.initRenderingings()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.TextAreaPainter(JEditTextArea, TextAreaDefaults)" access="pub" jdoc="Creates a new repaint manager. This should be not be called directly.">
				<param name="textArea"/>
				<param name="defaults"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.isAntiAliasingEnabled()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setAntiAliasingEnabled(boolean)" access="pub" jdoc="">
				<comm cntt="TEMP FIX"/>
				<comm cntt=""/>
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setAntiAliasing(Graphics)" access="priv" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setWrapGuideEnabled(boolean)" access="pub" jdoc="">
				<param name="enabled"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setWrapGuideOffset(int)" access="pub" jdoc="">
				<param name="offset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setWrapGuideColor(Color)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setLinesIntervalHighlightEnabled(boolean)" access="pub" jdoc="">
				<param name="enabled"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setLinesInterval(int)" access="pub" jdoc="">
				<param name="offset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setLinesIntervalHighlightColor(Color)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.isManagingFocus()" access="pub" jdoc="Returns if this component can be traversed by pressing the Tab key. This returns false.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getStyles()" access="pub" jdoc="Returns the syntax styles used to paint colorized text. Entry &amp;lt;i&amp;gt;n&amp;lt; i&amp;gt; will be used to paint tokens with id = &amp;lt;i&amp;gt;n&amp;lt; i&amp;gt;. @see org.gjt.sp.jedit.syntax.Token">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setStyles(SyntaxStyle[])" access="pub" jdoc="Sets the syntax styles used to paint colorized text. Entry &amp;lt;i&amp;gt;n&amp;lt; i&amp;gt; will be used to paint tokens with id = &amp;lt;i&amp;gt;n&amp;lt; i&amp;gt;. @param styles The syntax styles @see org.gjt.sp.jedit.syntax.Token">
				<param name="styles"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getCaretColor()" access="pub" jdoc="Returns the caret color.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setCaretColor(Color)" access="pub" jdoc="Sets the caret color. @param caretColor The caret color">
				<param name="caretColor"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getSelectionColor()" access="pub" jdoc="Returns the selection color.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setSelectionColor(Color)" access="pub" jdoc="Sets the selection color. @param selectionColor The selection color">
				<param name="selectionColor"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getHighlightColor()" access="pub" jdoc="Returns the highlight color.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setHighlightColor(Color)" access="pub" jdoc="Sets the highlight color. @param highlightColor The highlight color">
				<param name="highlightColor"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getLineHighlightColor()" access="pub" jdoc="Returns the line highlight color.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setLineHighlightColor(Color)" access="pub" jdoc="Sets the line highlight color. @param lineHighlightColor The line highlight color">
				<param name="lineHighlightColor"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.isLineHighlightEnabled()" access="pub" jdoc="Returns true if line highlight is enabled, false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setLineHighlightEnabled(boolean)" access="pub" jdoc="Enables or disables current line highlighting. @param lineHighlight True if current line highlight should be enabled, false otherwise">
				<param name="lineHighlight"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getBracketHighlightColor()" access="pub" jdoc="Returns the bracket highlight color.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setBracketHighlightColor(Color)" access="pub" jdoc="Sets the bracket highlight color. @param bracketHighlightColor The bracket highlight color">
				<param name="bracketHighlightColor"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.isBracketHighlightEnabled()" access="pub" jdoc="Returns true if bracket highlighting is enabled, false otherwise. When bracket highlighting is enabled, the bracket matching the one before the caret (if any) is highlighted.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setBracketHighlightEnabled(boolean)" access="pub" jdoc="Enables or disables bracket highlighting. When bracket highlighting is enabled, the bracket matching the one before the caret (if any) is highlighted. @param bracketHighlight True if bracket highlighting should be enabled, false otherwise">
				<param name="bracketHighlight"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.isBlockCaretEnabled()" access="pub" jdoc="Returns true if the caret should be drawn as a block, false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setBlockCaretEnabled(boolean)" access="pub" jdoc="Sets if the caret should be drawn as a block, false otherwise. @param blockCaret True if the caret should be drawn as a block, false otherwise.">
				<param name="blockCaret"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getEOLMarkerColor()" access="pub" jdoc="Returns the EOL marker color.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setEOLMarkerColor(Color)" access="pub" jdoc="Sets the EOL marker color. @param eolMarkerColor The EOL marker color">
				<param name="eolMarkerColor"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getEOLMarkersPainted()" access="pub" jdoc="Returns true if EOL markers are drawn, false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setEOLMarkersPainted(boolean)" access="pub" jdoc="Sets if EOL markers are to be drawn. @param eolMarkers True if EOL markers should be drawn, false otherwise">
				<param name="eolMarkers"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getInvalidLinesPainted()" access="pub" jdoc="Returns true if invalid lines are painted as red tildes (~), false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setInvalidLinesPainted(boolean)" access="pub" jdoc="Sets if invalid lines are to be painted as red tildes. @param paintInvalid True if invalid lines should be drawn, false otherwise">
				<param name="paintInvalid"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.addCustomHighlight(TextAreaHighlight)" access="pub" jdoc="Adds a custom highlight painter. @param highlight The highlight">
				<param name="highlight"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.addCustomFirstPriorityHighlight(TextAreaHighlight)" access="pub" jdoc="Adds a custom first priority highlight painter. @param highlight The highlight">
				<param name="highlight"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getToolTipText(MouseEvent)" access="pub" jdoc="Returns the tool tip to display at the specified location. @param evt The mouse event">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getFontMetrics()" access="pub" jdoc="Returns the font metrics used by this component.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.setFont(Font)" access="pub" jdoc="Sets the font for this component. This is overridden to update the cached font metrics and to recalculate which lines are visible. @param font The font">
				<param name="font"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paint(Graphics)" access="pub" jdoc="Repaints the text. @param g The graphics context">
				<comm cntt="TEMP FIX"/>
				<comm cntt="setAntiAliasing(gfx);"/>
				<comm cntt="We don&amp;apos;t use yToLine() here because that method doesn&amp;apos;t"/>
				<comm cntt="return lines past the end of the document"/>
				<comm cntt="Because the clipRect&amp;apos;s height is usually an even multiple"/>
				<comm cntt="of the font height, we subtract 1 from it, otherwise one"/>
				<comm cntt="too many lines will always be painted."/>
				<comm cntt="Yay"/>
				<param name="gfx"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.invalidateLine(int)" access="pub" jdoc="Marks a line as needing a repaint. @param line The line to invalidate">
				<param name="line"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.invalidateLineRange(int, int)" access="pub" jdoc="Marks a range of lines as needing a repaint. @param firstLine The first line to invalidate @param lastLine The last line to invalidate">
				<param name="firstLine"/>
				<param name="lastLine"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.invalidateSelectedLines()" access="pub" jdoc="Repaints the lines containing the selection.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.nextTabStop(float, int)" access="pub" jdoc="Implementation of TabExpander interface. Returns next tab stop after a specified point. @param x The x co-ordinate @param tabOffset Ignored @return The next tab stop after &amp;lt;i&amp;gt;x&amp;lt; i&amp;gt;">
				<param name="x"/>
				<param name="tabOffset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getPreferredSize()" access="pub" jdoc="Returns the painter&amp;apos;s preferred size.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.getMinimumSize()" access="pub" jdoc="Returns the painter&amp;apos;s minimum size.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paintLine(Graphics, TokenMarker, boolean, int, int)" access="prot" jdoc="">
				<param name="gfx"/>
				<param name="tokenMarker"/>
				<param name="valid"/>
				<param name="line"/>
				<param name="x"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paintSyntaxLine(Graphics, TokenMarker, int, Font, Color, int, int)" access="prot" jdoc="">
				<comm cntt="priority highlights first"/>
				<param name="gfx"/>
				<param name="tokenMarker"/>
				<param name="line"/>
				<param name="defaultFont"/>
				<param name="defaultColor"/>
				<param name="x"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paintHighlight(Graphics, int, int)" access="prot" jdoc="">
				<param name="gfx"/>
				<param name="line"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paintWrapGuide(Graphics, int, int)" access="prot" jdoc="">
				<param name="gfx"/>
				<param name="line"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paintLinesInterval(Graphics, int, int)" access="prot" jdoc="">
				<param name="gfx"/>
				<param name="line"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paintLineHighlight(Graphics, int, int)" access="prot" jdoc="">
				<comm cntt="x2 = getWidth();"/>
				<comm cntt="x2 = getWidth();"/>
				<comm cntt="&amp;quot;inlined&amp;quot; min max()"/>
				<param name="gfx"/>
				<param name="line"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paintBracketHighlight(Graphics, int, int)" access="prot" jdoc="">
				<comm cntt="Hack!!! Since there is no fast way to get the character"/>
				<comm cntt="from the bracket matching routine, we use ( since all"/>
				<comm cntt="brackets probably have the same width anyway"/>
				<param name="gfx"/>
				<param name="line"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paintCaret(Graphics, int, int)" access="prot" jdoc="">
				<param name="gfx"/>
				<param name="line"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaPainter.paintShadowCaret(Graphics, int, int)" access="prot" jdoc="">
				<param name="gfx"/>
				<param name="line"/>
				<param name="y"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.TextAreaDefaults" intfc="n" abs="n" inn="n" sloc="84" jdoc="Encapsulates default settings for a text area. This can be passed to the constructor once the necessary fields have been filled out. The advantage of doing this over calling lots of set() methods after creating the text area is that this method is faster.">
			<field name="DEFAULTS" access="priv" jdoc=""/>
			<field name="inputHandler" access="pub" jdoc=""/>
			<field name="editable" access="pub" jdoc=""/>
			<field name="caretVisible" access="pub" jdoc=""/>
			<field name="caretBlinks" access="pub" jdoc=""/>
			<field name="blockCaret" access="pub" jdoc=""/>
			<field name="electricScroll" access="pub" jdoc=""/>
			<field name="gutterCollapsed" access="pub" jdoc=""/>
			<field name="gutterWidth" access="pub" jdoc=""/>
			<field name="gutterBgColor" access="pub" jdoc=""/>
			<field name="gutterFgColor" access="pub" jdoc=""/>
			<field name="gutterHighlightColor" access="pub" jdoc=""/>
			<field name="gutterBorderColor" access="pub" jdoc=""/>
			<field name="caretMarkColor" access="pub" jdoc=""/>
			<field name="anchorMarkColor" access="pub" jdoc=""/>
			<field name="selectionMarkColor" access="pub" jdoc=""/>
			<field name="gutterBorderWidth" access="pub" jdoc=""/>
			<field name="gutterNumberAlignment" access="pub" jdoc=""/>
			<field name="gutterFont" access="pub" jdoc=""/>
			<field name="cols" access="pub" jdoc=""/>
			<field name="rows" access="pub" jdoc=""/>
			<field name="styles" access="pub" jdoc=""/>
			<field name="caretColor" access="pub" jdoc=""/>
			<field name="selectionColor" access="pub" jdoc=""/>
			<field name="lineHighlightColor" access="pub" jdoc=""/>
			<field name="lineHighlight" access="pub" jdoc=""/>
			<field name="bracketHighlightColor" access="pub" jdoc=""/>
			<field name="bracketHighlight" access="pub" jdoc=""/>
			<field name="eolMarkerColor" access="pub" jdoc=""/>
			<field name="eolMarkers" access="pub" jdoc=""/>
			<field name="paintInvalid" access="pub" jdoc=""/>
			<field name="wrapGuide" access="pub" jdoc=""/>
			<field name="wrapGuideColor" access="pub" jdoc=""/>
			<field name="wrapGuideOffset" access="pub" jdoc=""/>
			<field name="linesIntervalHighlight" access="pub" jdoc=""/>
			<field name="linesIntervalColor" access="pub" jdoc=""/>
			<field name="linesInterval" access="pub" jdoc=""/>
			<field name="antiAliasing" access="pub" jdoc=""/>
			<field name="popup" access="pub" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaDefaults.getDefaults()" access="pub" jdoc="Returns a new TextAreaDefaults object with the default values filled in.">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.Gutter" intfc="n" abs="n" inn="n" sloc="269" jdoc="">
			<comm cntt=""/>
			<comm cntt="ANTI ALIASING"/>
			<comm cntt=""/>
			<comm cntt="JComponent.setBorder(Border) is overridden here to cache the left inset of the border (if any) to avoid having to fetch it during every repaint."/>
			<comm cntt="JComponent.setFont(Font) is overridden here to cache the baseline for the font. This avoids having to get the font metrics during every repaint."/>
			<comm cntt="Component.getPreferredSize() is overridden here to support the collapsing behavior."/>
			<comm cntt="private members"/>
			<comm cntt="the JEditTextArea this gutter is attached to"/>
			<field name="antiAliasing" access="priv" jdoc=""/>
			<field name="wasAntiAliasing" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<field name="context" access="priv" jdoc=""/>
			<field name="highlights" access="priv" jdoc=""/>
			<field name="baseline" access="priv" jdoc=""/>
			<field name="ileft" access="priv" jdoc=""/>
			<field name="gutterSize" access="priv" jdoc=""/>
			<field name="collapsedSize" access="priv" jdoc=""/>
			<field name="intervalHighlight" access="priv" jdoc=""/>
			<field name="caretMark" access="priv" jdoc=""/>
			<field name="anchorMark" access="priv" jdoc=""/>
			<field name="selectionMark" access="priv" jdoc=""/>
			<field name="fm" access="priv" jdoc=""/>
			<field name="alignment" access="priv" jdoc=""/>
			<field name="interval" access="priv" jdoc=""/>
			<field name="lineNumberingEnabled" access="priv" jdoc=""/>
			<field name="collapsed" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.Gutter(JEditTextArea, TextAreaDefaults)" access="pub" jdoc="">
				<param name="textArea"/>
				<param name="defaults"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setAntiAliasingEnabled(boolean)" access="pub" jdoc="">
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setAntiAliasing(Graphics)" access="priv" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.paintComponent(Graphics)" access="pub" jdoc="">
				<comm cntt="fill the background"/>
				<comm cntt="paint custom highlights, if there are any"/>
				<comm cntt="paint line numbers, if they are enabled"/>
				<param name="gfx"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.paintLineNumbers(Graphics)" access="prot" jdoc="">
				<comm cntt="only print numbers for valid lines"/>
				<param name="gfx"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.paintCustomHighlights(Graphics)" access="prot" jdoc="">
				<param name="gfx"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.addCustomHighlight(TextAreaHighlight)" access="pub" jdoc="Adds a custom highlight painter. @param highlight The highlight">
				<param name="highlight"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setBorder(int, Color)" access="pub" jdoc="Convenience method for setting a default matte border on the right with the specified border width and color @param width The border width (in pixels) @param color The border color">
				<param name="width"/>
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setBorder(Border)" access="pub" jdoc="">
				<param name="border"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setFont(Font)" access="pub" jdoc="">
				<param name="font"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setHighlightedForeground(Color)" access="pub" jdoc="Set the foreground color for highlighted line numbers @param highlight The highlight color">
				<param name="highlight"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.getHighlightedForeground()" access="pub" jdoc="Get the foreground color for highlighted line numbers @return The highlight color">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setCaretMark(Color)" access="pub" jdoc="">
				<param name="mark"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setAnchorMark(Color)" access="pub" jdoc="">
				<param name="mark"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setSelectionMark(Color)" access="pub" jdoc="">
				<param name="mark"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setGutterWidth(int)" access="pub" jdoc="Set the width of the expanded gutter @param width The gutter width">
				<comm cntt="if the gutter is expanded, ask the text area to revalidate"/>
				<comm cntt="the layout to resize the gutter"/>
				<param name="width"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.getGutterWidth()" access="pub" jdoc="Get the width of the expanded gutter @return The gutter width">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.getPreferredSize()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.getMinimumSize()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.getToolTipText(MouseEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.isLineNumberingEnabled()" access="pub" jdoc="Identifies whether or not the line numbers are drawn in the gutter @return true if the line numbers are drawn, false otherwise">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setLineNumberingEnabled(boolean)" access="pub" jdoc="Turns the line numbering on or off and causes the gutter to be repainted. @param enabled true if line numbers are drawn, false otherwise">
				<param name="enabled"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.getLineNumberAlignment()" access="pub" jdoc="Identifies whether the horizontal alignment of the line numbers. @return Gutter.RIGHT, Gutter.CENTER, Gutter.LEFT">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setLineNumberAlignment(int)" access="pub" jdoc="Sets the horizontal alignment of the line numbers. @param alignment Gutter.RIGHT, Gutter.CENTER, Gutter.LEFT">
				<param name="alignment"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.isCollapsed()" access="pub" jdoc="Identifies whether the gutter is collapsed or expanded. @return true if the gutter is collapsed, false if it is expanded">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setCollapsed(boolean)" access="pub" jdoc="Sets whether the gutter is collapsed or expanded and force the text area to update its layout if there is a change. @param collapsed true if the gutter is collapsed, false if it is expanded">
				<param name="collapsed"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.toggleCollapsed()" access="pub" jdoc="Toggles whether the gutter is collapsed or expanded.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.getHighlightInterval()" access="pub" jdoc="Sets the number of lines between highlighted line numbers. @return The number of lines between highlighted line numbers or zero if highlighting is disabled">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setHighlightInterval(int)" access="pub" jdoc="Sets the number of lines between highlighted line numbers. Any value less than or equal to one will result in highlighting being disabled. @param interval The number of lines between highlighted line numbers">
				<param name="interval"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.getContextMenu()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter.setContextMenu(JPopupMenu)" access="pub" jdoc="">
				<param name="context"/>
			</mth>
		<class name="/lib/:org.gjt.sp.jedit.textarea.Gutter$GutterMouseListener" intfc="n" abs="n" inn="y" sloc="63" jdoc="">
			<field name="dragStart" access="priv" jdoc=""/>
			<field name="startWidth" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter$GutterMouseListener.mouseClicked(MouseEvent)" access="pub" jdoc="">
				<comm cntt="XXX this is a hack to make sure the"/>
				<comm cntt="XXX actions get the right text area"/>
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter$GutterMouseListener.mousePressed(MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter$GutterMouseListener.mouseDragged(MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter$GutterMouseListener.mouseExited(MouseEvent)" access="pub" jdoc="">
				<comm cntt="dragStart = null;"/>
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter$GutterMouseListener.mouseMoved(MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.Gutter$GutterMouseListener.mouseReleased(MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.TextUtilities" intfc="n" abs="n" inn="n" sloc="231" jdoc="Class with several utility functions used by the text area component. This is a special version based on v 1.8 adapted by Matt Benson for Jext. @author Slava Pestov @author Matt Benson @version $Id: TextUtilities.java,v 1.1.1.1 2001 08 20 22:32:16 gfx Exp $">
			<const name="BRACKETS" access="pub" jdoc=""/>
			<const name="FORWARD" access="pub" jdoc=""/>
			<const name="BACKWARD" access="pub" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextUtilities.getTokenList(Token, int)" access="priv" jdoc="Returns an &amp;lt;CODE&amp;gt;ArrayList&amp;lt; CODE&amp;gt; filled with &amp;lt;CODE&amp;gt;Token&amp;lt; CODE&amp;gt;s linked to the argument token, in the order specified. @param token The initial &amp;lt;CODE&amp;gt;Token&amp;lt; CODE&amp;gt; that links to the others. @param dir The &amp;lt;CODE&amp;gt;int&amp;lt; CODE&amp;gt; representation of the ordering to be used when filling the &amp;lt;CODE&amp;gt;ArrayList&amp;lt; CODE&amp;gt;.">
				<comm cntt="end if token.id == Token.END"/>
				<comm cntt="The following is just a trick--size 1 &amp;gt;= 0 but size -1 &amp;lt;= 0"/>
				<comm cntt="end else"/>
				<comm cntt="end while token != null"/>
				<param name="token"/>
				<param name="dir"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextUtilities.findMatchingBracket(SyntaxDocument, int)" access="pub" jdoc="Returns the offset of the bracket matching the one at the specified offset of the document, or -1 if the bracket is unmatched (or if the character is not a bracket). @param doc The document @param offset The offset @exception BadLocationException If an out-of-bounds access was attempted on the document text @since jEdit 3.0pre1">
				<comm cntt="the character"/>
				<comm cntt="end try"/>
				<comm cntt="for when cursor is positioned at offset 0."/>
				<comm cntt="end catch ArrayIndexOutOfBoundsException"/>
				<comm cntt="end if whichBracket == -1"/>
				<comm cntt="corresponding character"/>
				<comm cntt="I didn&amp;apos;t like the old switch statement. Also I changed direction to an int which should be pos neg 1 for ease in counting with merged search logic as compared to SP versions which search bkwd &amp; fwd separately. Actually the merged search is pretty sloppy but Slava included the comment in an earlier version that he was leaving the merge as an exercise to the reader, so I took him up on it."/>
				<comm cntt="end if tokenMarker == null"/>
				<comm cntt="Get the syntax token at &amp;apos;offset&amp;apos;"/>
				<comm cntt="only tokens with the same type will be checked for"/>
				<comm cntt="the corresponding bracket"/>
				<comm cntt="default to invalid"/>
				<comm cntt="end try"/>
				<comm cntt="end catch IndexOutOfBoundsException"/>
				<comm cntt="end if FORWARD"/>
				<comm cntt="end if this Token"/>
				<comm cntt="end else"/>
				<comm cntt="end do while loop"/>
				<comm cntt="end if idOfBracket == Token.INVALID"/>
				<comm cntt="get text"/>
				<comm cntt="end if direction == FORWARD"/>
				<comm cntt="end else"/>
				<comm cntt="end if not original line"/>
				<comm cntt="end else"/>
				<comm cntt="only check tokens with id &amp;apos;idOfBracket&amp;apos;"/>
				<comm cntt="end for thru word"/>
				<comm cntt="set it 1 different than what we really want b c we increment in the beginning of the loop"/>
				<comm cntt="end if ch == c"/>
				<comm cntt="end else"/>
				<comm cntt="end if id == idOfBracket"/>
				<comm cntt="the following skips to the next token offset by adding len of curr. token"/>
				<comm cntt="end if"/>
				<comm cntt="end for tok..."/>
				<comm cntt="end for i"/>
				<comm cntt="Nothing found"/>
				<param name="doc"/>
				<param name="offset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextUtilities.findWordStart(String, int, String)" access="pub" jdoc="Locates the start of the word at the specified position. @param line The text @param pos The position @param noWordSep Characters that are non-alphanumeric, but should be treated as word characters anyway">
				<comm cntt="end if"/>
				<comm cntt="end for i"/>
				<param name="line"/>
				<param name="pos"/>
				<param name="noWordSep"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextUtilities.findWordEnd(String, int, String)" access="pub" jdoc="Locates the end of the word at the specified position. @param line The text @param pos The position @param noWordSep Characters that are non-alphanumeric, but should be treated as word characters anyway">
				<comm cntt="end if pos != 0"/>
				<comm cntt="end if noWordSep == null"/>
				<comm cntt="end if"/>
				<comm cntt="end for i"/>
				<param name="line"/>
				<param name="pos"/>
				<param name="noWordSep"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextUtilities.findTypeChange(String, int, int)" access="pub" jdoc="Locates the next character type change searching in the specified direction. Included for use with Jext&amp;apos;s CsWord Action. @param line The text. @param pos The position. @param direction The direction in which the search should be made.">
				<comm cntt="end if"/>
				<comm cntt="end try"/>
				<comm cntt="end catch"/>
				<comm cntt="end for i"/>
				<param name="line"/>
				<param name="pos"/>
				<param name="direction"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea" intfc="n" abs="n" inn="n" sloc="1082" jdoc="jEdit&amp;apos;s text area component. It is more suited for editing program source code than JEditorPane, because it drops the unnecessary features (images, variable-width lines, and so on) and adds a whole bunch of useful goodies such as: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;More flexible key binding scheme &amp;lt;li&amp;gt;Supports macro recorders &amp;lt;li&amp;gt;Rectangular selection &amp;lt;li&amp;gt;Bracket highlighting &amp;lt;li&amp;gt;Syntax highlighting &amp;lt;li&amp;gt;Command repetition &amp;lt;li&amp;gt;Block caret can be enabled &amp;lt; ul&amp;gt; It is also faster and doesn&amp;apos;t have as many problems. It can be used in other applications; the only other part of jEdit it depends on is the syntax package.&amp;lt;p&amp;gt; To use it in your app, treat it like any other component, for example: &amp;lt;pre&amp;gt;JEditTextArea ta = new JEditTextArea(); ta.setTokenMarker(new JavaTokenMarker()); ta.setText(&amp;quot;public class Test {\n&amp;quot; + &amp;quot; public static void main(String[] args) {\n&amp;quot; + &amp;quot; System.out.println(\&amp;quot;Hello World\&amp;quot;);\n&amp;quot; + &amp;quot; }\n&amp;quot; + &amp;quot;}&amp;quot;);&amp;lt; pre&amp;gt; @author Slava Pestov @version $Id: JEditTextArea.java,v 1.10 2003 06 30 17:31:08 blaisorblade Exp $">
			<comm cntt="package-private members"/>
			<comm cntt="protected members"/>
			<comm cntt="private members"/>
			<comm cntt="for event handlers only"/>
			<comm cntt=""/>
			<comm cntt="ONE CLICK HACK"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="END OF ONE CLICK HACK"/>
			<comm cntt=""/>
			<field name="view" access="priv" jdoc=""/>
			<field name="LEFT_OF_SCROLLBAR" access="pub" jdoc="Adding components with this name to the text area will place them left of the horizontal scroll bar. In jEdit, the status bar is added this way."/>
			<field name="lineSegment" access="pub" jdoc=""/>
			<field name="CENTER" access="prot" jdoc=""/>
			<field name="RIGHT" access="prot" jdoc=""/>
			<field name="LEFT" access="prot" jdoc=""/>
			<field name="BOTTOM" access="prot" jdoc=""/>
			<field name="focusedComponent" access="prot" jdoc=""/>
			<field name="caretTimer" access="prot" jdoc=""/>
			<field name="painter" access="prot" jdoc=""/>
			<field name="gutter" access="prot" jdoc=""/>
			<field name="popup" access="prot" jdoc=""/>
			<field name="listenerList" access="prot" jdoc=""/>
			<field name="caretEvent" access="prot" jdoc=""/>
			<field name="caretBlinks" access="prot" jdoc=""/>
			<field name="caretVisible" access="prot" jdoc=""/>
			<field name="blink" access="prot" jdoc=""/>
			<field name="editable" access="prot" jdoc=""/>
			<field name="maxHorizontalScrollWidth" access="prot" jdoc=""/>
			<field name="firstLine" access="prot" jdoc=""/>
			<field name="visibleLines" access="prot" jdoc=""/>
			<field name="electricScroll" access="prot" jdoc=""/>
			<field name="horizontalOffset" access="prot" jdoc=""/>
			<field name="vertical" access="prot" jdoc=""/>
			<field name="horizontal" access="prot" jdoc=""/>
			<field name="scrollBarsInitialized" access="prot" jdoc=""/>
			<field name="inputHandler" access="prot" jdoc=""/>
			<field name="document" access="prot" jdoc=""/>
			<field name="documentHandler" access="prot" jdoc=""/>
			<field name="documentHandlerInstalled" access="prot" jdoc=""/>
			<field name="selectionStart" access="prot" jdoc=""/>
			<field name="selectionStartLine" access="prot" jdoc=""/>
			<field name="selectionEnd" access="prot" jdoc=""/>
			<field name="selectionEndLine" access="prot" jdoc=""/>
			<field name="biasLeft" access="prot" jdoc=""/>
			<field name="bracketPosition" access="prot" jdoc=""/>
			<field name="bracketLine" access="prot" jdoc=""/>
			<field name="magicCaret" access="prot" jdoc=""/>
			<field name="overwrite" access="prot" jdoc=""/>
			<field name="rectSelect" access="prot" jdoc=""/>
			<field name="clickCount" access="priv" jdoc=""/>
			<field name="oneClickEvent" access="prot" jdoc=""/>
			<field name="oneClick" access="pub" jdoc=""/>
			<field name="dragText" access="priv" jdoc=""/>
			<field name="dragCursor" access="priv" jdoc=""/>
			<field name="dragControlDown" access="priv" jdoc=""/>
			<field name="shadowCaretLine" access="priv" jdoc=""/>
			<field name="shadowCaretOffset" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.JEditTextArea(JextFrame)" access="pub" jdoc="Creates a new JEditTextArea with the default settings.">
				<param name="view"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.JEditTextArea(JextFrame, TextAreaDefaults)" access="pub" jdoc="Creates a new JEditTextArea with the specified settings. @param defaults The default settings">
				<comm cntt="Enable the necessary events"/>
				<comm cntt="Initialize some misc. stuff"/>
				<comm cntt="Initialize the GUI"/>
				<comm cntt="Add some event listeners"/>
				<comm cntt="Load the defaults"/>
				<comm cntt="We don&amp;apos;t seem to get the initial focus event?"/>
				<param name="view"/>
				<param name="defaults"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getFocusTraversalKeysEnabled()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getInputHandler()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.isManagingFocus()" access="pub" jdoc="Returns if this component can be traversed by pressing the Tab key. This returns false.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getMinimumSize()" access="pub" jdoc="Returns 0,0 for split pane compatibility.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getPainter()" access="pub" jdoc="Returns the object responsible for painting this text area.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getGutter()" access="pub" jdoc="Returns the gutter to the left of the text area or null if the gutter is disabled">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.isCaretBlinkEnabled()" access="pub" jdoc="Returns true if the caret is blinking, false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setCaretBlinkEnabled(boolean)" access="pub" jdoc="Toggles caret blinking. @param caretBlinks True if the caret should blink, false otherwise">
				<param name="caretBlinks"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.isCaretVisible()" access="pub" jdoc="Returns true if the caret is visible, false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setCaretVisible(boolean)" access="pub" jdoc="Sets if the caret should be visible. @param caretVisible True if the caret should be visible, false otherwise">
				<param name="caretVisible"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.blinkCaret()" access="pub" jdoc="Blinks the caret.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getElectricScroll()" access="pub" jdoc="Returns the number of lines from the top and button of the text area that are always visible.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setElectricScroll(int)" access="pub" jdoc="Sets the number of lines from the top and bottom of the text area that are always visible @param electricScroll The number of lines always visible from the top or bottom">
				<param name="electricScroll"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.updateScrollBars()" access="pub" jdoc="Updates the state of the scroll bars. This should be called if the number of lines in the document changes, or when the size of the text are changes.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getFirstLine()" access="pub" jdoc="Returns the line displayed at the text area&amp;apos;s origin.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setFirstLine(int)" access="pub" jdoc="Sets the line displayed at the text area&amp;apos;s origin without updating the scroll bars.">
				<param name="firstLine"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getVisibleLines()" access="pub" jdoc="Returns the number of lines visible in this text area.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.recalculateVisibleLines()" access="pub" jdoc="Recalculates the number of visible lines. This should not be called directly.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.updateMaxHorizontalScrollWidth()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getHorizontalOffset()" access="pub" jdoc="Returns the horizontal offset of drawn lines.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setHorizontalOffset(int)" access="pub" jdoc="Sets the horizontal offset of drawn lines. This can be used to implement horizontal scrolling. @param horizontalOffset offset The new horizontal offset">
				<param name="horizontalOffset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setOrigin(int, int)" access="pub" jdoc="A fast way of changing both the first line and horizontal offset. @param firstLine The new first line @param horizontalOffset The new horizontal offset @return True if any of the values were changed, false otherwise">
				<param name="firstLine"/>
				<param name="horizontalOffset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.scrollToCaret()" access="pub" jdoc="Ensures that the caret is visible by scrolling the text area if necessary. @return True if scrolling was actually performed, false if the caret was already visible">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.scrollTo(int, int)" access="pub" jdoc="Ensures that the specified line and offset is visible by scrolling the text area if necessary. @param line The line to scroll to @param offset The offset in the line to scroll to @return True if scrolling was actually performed, false if the line and offset was already visible">
				<comm cntt="visibleLines == 0 before the component is realized"/>
				<comm cntt="we can&amp;apos;t do any proper scrolling then, so we have"/>
				<comm cntt="this hack..."/>
				<param name="line"/>
				<param name="offset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.lineToY(int)" access="pub" jdoc="Converts a line index to a y co-ordinate. @param line The line">
				<param name="line"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.yToLine(int)" access="pub" jdoc="Converts a y co-ordinate to a line index. @param y The y co-ordinate">
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.offsetToX(int, int)" access="pub" jdoc="Converts an offset in a line into an x co-ordinate. @param line The line @param offset The offset, from the start of the line">
				<comm cntt="Use painter&amp;apos;s cached info for speed"/>
				<comm cntt="If syntax coloring is disabled, do simple translation"/>
				<comm cntt="If syntax coloring is enabled, we have to do this because tokens can vary in width"/>
				<param name="line"/>
				<param name="offset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.xToOffset(int, int)" access="pub" jdoc="Converts an x co-ordinate to an offset within a line. @param line The line @param x The x co-ordinate">
				<comm cntt="Use painter&amp;apos;s cached info for speed"/>
				<param name="line"/>
				<param name="x"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.xyToOffset(int, int)" access="pub" jdoc="Converts a point to an offset, from the start of the text. @param x The x co-ordinate of the point @param y The y co-ordinate of the point">
				<param name="x"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getDocument()" access="pub" jdoc="Returns the document this text area is editing.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setDocument(SyntaxDocument)" access="pub" jdoc="Sets the document this text area is editing. @param document The document">
				<param name="document"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getTokenMarker()" access="pub" jdoc="Returns the document&amp;apos;s token marker. Equivalent to calling &amp;lt;code&amp;gt;getDocument().getTokenMarker()&amp;lt; code&amp;gt;.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setTokenMarker(TokenMarker)" access="pub" jdoc="Sets the document&amp;apos;s token marker. Equivalent to caling &amp;lt;code&amp;gt;getDocument().setTokenMarker()&amp;lt; code&amp;gt;. @param tokenMarker The token marker">
				<param name="tokenMarker"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getDocumentLength()" access="pub" jdoc="Returns the length of the document. Equivalent to calling &amp;lt;code&amp;gt;getDocument().getLength()&amp;lt; code&amp;gt;.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getLineCount()" access="pub" jdoc="Returns the number of lines in the document.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getLineOfOffset(int)" access="pub" jdoc="Returns the line containing the specified offset. @param offset The offset">
				<param name="offset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getLineStartOffset(int)" access="pub" jdoc="Returns the start offset of the specified line. @param line The line @return The start offset of the specified line, or -1 if the line is invalid">
				<param name="line"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getLineEndOffset(int)" access="pub" jdoc="Returns the end offset of the specified line. @param line The line @return The end offset of the specified line, or -1 if the line is invalid.">
				<param name="line"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getLineLength(int)" access="pub" jdoc="Returns the length of the specified line. @param line The line">
				<param name="line"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getText()" access="pub" jdoc="Returns the entire text of this text area.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setText(String)" access="pub" jdoc="Sets the entire text of this text area.">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getText(int, int)" access="pub" jdoc="Returns the specified substring of the document. @param start The start offset @param len The length of the substring @return The substring, or null if the offsets are invalid">
				<param name="start"/>
				<param name="len"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getText(int, int, Segment)" access="pub" jdoc="Copies the specified substring of the document into a segment. If the offsets are invalid, the segment will contain a null string. @param start The start offset @param len The length of the substring @param segment The segment">
				<param name="start"/>
				<param name="len"/>
				<param name="segment"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getLineText(int)" access="pub" jdoc="Returns the text on the specified line. @param lineIndex The line @return The text, or null if the line is invalid">
				<param name="lineIndex"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getLineText(int, Segment)" access="pub" jdoc="Copies the text on the specified line into a segment. If the line is invalid, the segment will contain a null string. @param lineIndex The line">
				<param name="lineIndex"/>
				<param name="segment"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getSelectionStart()" access="pub" jdoc="Returns the selection start offset.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getSelectionStart(int)" access="pub" jdoc="Returns the offset where the selection starts on the specified line.">
				<param name="line"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getSelectionStartLine()" access="pub" jdoc="Returns the selection start line.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setSelectionStart(int)" access="pub" jdoc="Sets the selection start. The new selection will be the new selection start and the old selection end. @param selectionStart The selection start @see #select(int,int)">
				<param name="selectionStart"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getSelectionEnd()" access="pub" jdoc="Returns the selection end offset.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getSelectionEnd(int)" access="pub" jdoc="Returns the offset where the selection ends on the specified line.">
				<param name="line"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getSelectionEndLine()" access="pub" jdoc="Returns the selection end line.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setSelectionEnd(int)" access="pub" jdoc="Sets the selection end. The new selection will be the old selection start and the bew selection end. @param selectionEnd The selection end @see #select(int,int)">
				<param name="selectionEnd"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getCaretPosition()" access="pub" jdoc="Returns the caret position. This will either be the selection start or the selection end, depending on which direction the selection was made in.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getCaretLine()" access="pub" jdoc="Returns the caret line.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getMarkPosition()" access="pub" jdoc="Returns the mark position. This will be the opposite selection bound to the caret position. @see #getCaretPosition()">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getMarkLine()" access="pub" jdoc="Returns the mark line.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setCaretPosition(int)" access="pub" jdoc="Sets the caret position. The new selection will consist of the caret position only (hence no text will be selected) @param caret The caret position @see #select(int,int)">
				<param name="caret"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.selectAll()" access="pub" jdoc="Selects all text in the document.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.selectNone()" access="pub" jdoc="Moves the mark to the caret position.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.select(int, int)" access="pub" jdoc="Selects from the start offset to the end offset. This is the general selection method used by all other selecting methods. The caret position will be start if start &amp;lt; end, and end if end &amp;gt; start. @param start The start offset @param end The end offset">
				<comm cntt="If the new position is the same as the old, we don&amp;apos;t"/>
				<comm cntt="do all this crap, however we still do the stuff at"/>
				<comm cntt="the end (clearing magic position, scrolling)"/>
				<comm cntt="When the user is typing, etc, we don&amp;apos;t want the caret"/>
				<comm cntt="to blink"/>
				<comm cntt="Disable rectangle select if selection start = selection end"/>
				<comm cntt="Clear the `magic&amp;apos; caret position used by up down"/>
				<param name="start"/>
				<param name="end"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getSelectedText()" access="pub" jdoc="Returns the selected text, or null if no selection is active.">
				<comm cntt="Return each row of the selection on a new line"/>
				<comm cntt="Certain rectangles satisfy this condition..."/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setSelectedText(String)" access="pub" jdoc="Replaces the selection with the specified text. @param selectedText The replacement text for the selection">
				<comm cntt="Certain rectangles satisfy this condition..."/>
				<param name="selectedText"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.isEditable()" access="pub" jdoc="Returns true if this text area is editable, false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setEditable(boolean)" access="pub" jdoc="Sets if this component is editable. @param editable True if this text area should be editable, false otherwise">
				<param name="editable"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getRightClickPopup()" access="pub" jdoc="Returns the right click popup menu.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setRightClickPopup(JPopupMenu)" access="pub" jdoc="Sets the right click popup menu. @param popup The popup">
				<param name="popup"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getMagicCaretPosition()" access="pub" jdoc="Returns the `magic&amp;apos; caret position. This can be used to preserve the column position when moving up and down lines.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setMagicCaretPosition(int)" access="pub" jdoc="Sets the `magic&amp;apos; caret position. This can be used to preserve the column position when moving up and down lines. @param magicCaret The magic caret position">
				<param name="magicCaret"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.overwriteSetSelectedText(String)" access="pub" jdoc="Similar to &amp;lt;code&amp;gt;setSelectedText()&amp;lt; code&amp;gt;, but overstrikes the appropriate number of characters if overwrite mode is enabled. @param str The string @see #setSelectedText(String) @see #isOverwriteEnabled()">
				<comm cntt="Don&amp;apos;t overstrike if there is a selection"/>
				<comm cntt="Don&amp;apos;t overstrike if we&amp;apos;re on the end of"/>
				<comm cntt="the line"/>
				<param name="str"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.isOverwriteEnabled()" access="pub" jdoc="Returns true if overwrite mode is enabled, false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setOverwriteEnabled(boolean)" access="pub" jdoc="Sets if overwrite mode should be enabled. @param overwrite True if overwrite mode should be enabled, false otherwise.">
				<param name="overwrite"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.isSelectionRectangular()" access="pub" jdoc="Returns true if the selection is rectangular, false otherwise.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setSelectionRectangular(boolean)" access="pub" jdoc="Sets if the selection should be rectangular. @param overwrite True if the selection should be rectangular, false otherwise.">
				<param name="rectSelect"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getBracketPosition()" access="pub" jdoc="Returns the position of the highlighted bracket (the bracket matching the one before the caret)">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getBracketLine()" access="pub" jdoc="Returns the line of the highlighted bracket (the bracket matching the one before the caret)">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.addCaretListener(CaretListener)" access="pub" jdoc="Adds a caret change listener to this text area. @param listener The listener">
				<param name="listener"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.removeCaretListener(CaretListener)" access="pub" jdoc="Removes a caret change listener from this text area. @param listener The listener">
				<param name="listener"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.appendCut()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.cut()" access="pub" jdoc="Deletes the selected text from the text area and places it into the clipboard.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.appendCopy()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.copy()" access="pub" jdoc="Places the selected text into the clipboard.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.paste()" access="pub" jdoc="Inserts the clipboard contents into the text.">
				<comm cntt="The MacOS MRJ doesn&amp;apos;t convert \r to \n,"/>
				<comm cntt="so do it here"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getStatus()" access="pub" jdoc="Returns the status bar component (which was added with a name of LEFT_OF_SCROLLBAR).">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.addNotify()" access="pub" jdoc="Called by the AWT when this component is added to a parent. Adds document listener.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.removeNotify()" access="pub" jdoc="Called by the AWT when this component is removed from it&amp;apos;s parent. This clears the pointer to the currently focused component. Also removes document listener.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.processKeyEvent(KeyEvent)" access="prot" jdoc="">
				<comm cntt="JextFrame view = MenuAction.getJextParent(evt);"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.fireCaretEvent()" access="prot" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.updateBracketHighlight(int)" access="prot" jdoc="">
				<param name="newCaretPosition"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.documentChanged(DocumentEvent)" access="prot" jdoc="">
				<comm cntt="do magic stuff"/>
				<comm cntt="end of magic stuff"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setOneClick(org.jext.OneClickAction)" access="pub" jdoc="">
				<param name="oneClick"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setOneClick(org.jext.OneClickAction, ActionEvent)" access="pub" jdoc="">
				<param name="oneClick"/>
				<param name="oneClickEvent"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.setShadowCaretPosition(int)" access="pub" jdoc="">
				<param name="offset"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getShadowCaretLine()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea.getShadowCaretPosition()" access="pub" jdoc="">
			</mth>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$ScrollLayout" intfc="n" abs="n" inn="y" sloc="92" jdoc="">
			<field name="center" access="pub" jdoc=""/>
			<field name="left" access="pub" jdoc=""/>
			<field name="right" access="pub" jdoc=""/>
			<field name="bottom" access="pub" jdoc=""/>
			<field name="leftOfScrollBar" access="pub" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$ScrollLayout.addLayoutComponent(String, Component)" access="pub" jdoc="">
				<param name="name"/>
				<param name="comp"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$ScrollLayout.removeLayoutComponent(Component)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$ScrollLayout.preferredLayoutSize(Container)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$ScrollLayout.minimumLayoutSize(Container)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$ScrollLayout.layoutContainer(Container)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$CaretBlinker" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$CaretBlinker.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MutableCaretEvent" intfc="n" abs="n" inn="y" sloc="15" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MutableCaretEvent.MutableCaretEvent()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MutableCaretEvent.getDot()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MutableCaretEvent.getMark()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$AdjustHandler" intfc="n" abs="n" inn="y" sloc="19" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$AdjustHandler.adjustmentValueChanged(AdjustmentEvent)" access="pub" jdoc="">
				<comm cntt="If this is not done, mousePressed events accumilate"/>
				<comm cntt="and the result is that scrolling doesn&amp;apos;t stop after"/>
				<comm cntt="the mouse is released"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$ComponentHandler" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$ComponentHandler.componentResized(ComponentEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DocumentHandler" intfc="n" abs="n" inn="y" sloc="66" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DocumentHandler.insertUpdate(DocumentEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DocumentHandler.removeUpdate(DocumentEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DocumentHandler.changedUpdate(DocumentEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DragHandler" intfc="n" abs="n" inn="y" sloc="105" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DragHandler.mouseDragged(MouseEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DragHandler.mouseMoved(MouseEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DragHandler.doSingleDrag(MouseEvent)" access="priv" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DragHandler.doDoubleDrag(MouseEvent)" access="priv" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$DragHandler.doTripleDrag(MouseEvent)" access="priv" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$FocusHandler" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$FocusHandler.focusGained(FocusEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$FocusHandler.focusLost(FocusEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MouseHandler" intfc="n" abs="n" inn="y" sloc="138" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MouseHandler.mouseReleased(MouseEvent)" access="pub" jdoc="">
				<comm cntt="moves text"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MouseHandler.mousePressed(MouseEvent)" access="pub" jdoc="">
				<comm cntt="Focus events not fired sometimes?"/>
				<comm cntt="It uses the bracket matching stuff, so"/>
				<comm cntt="it can throw a BLE"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MouseHandler.doSingleClick(MouseEvent, int, int, int)" access="priv" jdoc="">
				<param name="evt"/>
				<param name="line"/>
				<param name="offset"/>
				<param name="dot"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MouseHandler.doDoubleClick(MouseEvent, int, int, int)" access="priv" jdoc="">
				<comm cntt="Ignore empty lines"/>
				<comm cntt="Hack"/>
				<comm cntt="Ok, it&amp;apos;s not a bracket... select the word"/>
				<param name="evt"/>
				<param name="line"/>
				<param name="offset"/>
				<param name="dot"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MouseHandler.doTripleClick(MouseEvent, int, int, int)" access="priv" jdoc="">
				<param name="evt"/>
				<param name="line"/>
				<param name="offset"/>
				<param name="dot"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$MouseHandler.doRightClick(MouseEvent)" access="priv" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$CaretUndo" intfc="n" abs="n" inn="y" sloc="41" jdoc="">
			<field name="start" access="priv" jdoc=""/>
			<field name="end" access="priv" jdoc=""/>
			<field name="newStart" access="priv" jdoc=""/>
			<field name="newEnd" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$CaretUndo.CaretUndo(int, int, int, int)" access="pub" jdoc="">
				<param name="start"/>
				<param name="end"/>
				<param name="newStart"/>
				<param name="newEnd"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$CaretUndo.isSignificant()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$CaretUndo.getPresentationName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$CaretUndo.undo()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$CaretUndo.addEdit(UndoableEdit)" access="pub" jdoc="">
				<param name="edit"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.JEditTextArea$CaretUndo.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler" intfc="n" abs="y" inn="n" sloc="229" jdoc="An input handler converts the user&amp;apos;s key strokes into concrete actions. It also takes care of macro recording and action repetition.&amp;lt;p&amp;gt; This class provides all the necessary support code for an input handler, but doesn&amp;apos;t actually do any key binding logic. It is up to the implementations of this class to do so. @author Slava Pestov @version $Id: InputHandler.java,v 1.4 2003 07 08 18:55:50 blaisorblade Exp $ @see org.gjt.sp.jedit.textarea.DefaultInputHandler">
			<comm cntt="Default action"/>
			<comm cntt="protected members"/>
			<const name="SMART_HOME_END_PROPERTY" access="pub" jdoc="If this client property is set to Boolean.TRUE on the text area, the home end keys will support &amp;apos;smart&amp;apos; BRIEF-like behaviour (one press = start end of line, two presses = start end of viewscreen, three presses = start end of document). By default, this property is not set."/>
			<const name="BACKSPACE" access="pub" jdoc=""/>
			<const name="BACKSPACE_WORD" access="pub" jdoc=""/>
			<const name="DELETE" access="pub" jdoc=""/>
			<const name="DELETE_WORD" access="pub" jdoc=""/>
			<const name="END" access="pub" jdoc=""/>
			<const name="DOCUMENT_END" access="pub" jdoc=""/>
			<const name="SELECT_END" access="pub" jdoc=""/>
			<const name="SELECT_DOC_END" access="pub" jdoc=""/>
			<const name="INSERT_BREAK" access="pub" jdoc=""/>
			<const name="INSERT_TAB" access="pub" jdoc=""/>
			<const name="HOME" access="pub" jdoc=""/>
			<const name="DOCUMENT_HOME" access="pub" jdoc=""/>
			<const name="SELECT_HOME" access="pub" jdoc=""/>
			<const name="SELECT_DOC_HOME" access="pub" jdoc=""/>
			<const name="NEXT_CHAR" access="pub" jdoc=""/>
			<const name="NEXT_LINE" access="pub" jdoc=""/>
			<const name="NEXT_PAGE" access="pub" jdoc=""/>
			<const name="NEXT_WORD" access="pub" jdoc=""/>
			<const name="SELECT_NEXT_CHAR" access="pub" jdoc=""/>
			<const name="SELECT_NEXT_LINE" access="pub" jdoc=""/>
			<const name="SELECT_NEXT_PAGE" access="pub" jdoc=""/>
			<const name="SELECT_NEXT_WORD" access="pub" jdoc=""/>
			<const name="OVERWRITE" access="pub" jdoc=""/>
			<const name="PREV_CHAR" access="pub" jdoc=""/>
			<const name="PREV_LINE" access="pub" jdoc=""/>
			<const name="PREV_PAGE" access="pub" jdoc=""/>
			<const name="PREV_WORD" access="pub" jdoc=""/>
			<const name="SELECT_PREV_CHAR" access="pub" jdoc=""/>
			<const name="SELECT_PREV_LINE" access="pub" jdoc=""/>
			<const name="SELECT_PREV_PAGE" access="pub" jdoc=""/>
			<const name="SELECT_PREV_WORD" access="pub" jdoc=""/>
			<const name="REPEAT" access="pub" jdoc=""/>
			<const name="INSERT_CHAR" access="pub" jdoc=""/>
			<field name="actions" access="priv" jdoc=""/>
			<field name="inputAction" access="prot" jdoc=""/>
			<field name="grabAction" access="prot" jdoc=""/>
			<field name="repeat" access="prot" jdoc=""/>
			<field name="repeatCount" access="prot" jdoc=""/>
			<field name="recorder" access="prot" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.getAction(String)" access="pub" jdoc="Returns a named text area action. @param name The action name">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.getActionName(ActionListener)" access="pub" jdoc="Returns the name of the specified text area action. @param listener The action">
				<param name="listener"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.getActions()" access="pub" jdoc="Returns an enumeration of all available actions.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.addDefaultKeyBindings()" access="pub" jdoc="Adds the default key bindings to this input handler. This should not be called in the constructor of this input handler, because applications might load the key bindings from a file, etc.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.addKeyBinding(String, ActionListener)" access="pub" jdoc="Adds a key binding to this input handler. @param keyBinding The key binding (the format of this is input-handler specific) @param action The action">
				<param name="keyBinding"/>
				<param name="action"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.removeKeyBinding(String)" access="pub" jdoc="Removes a key binding from this input handler. @param keyBinding The key binding">
				<param name="keyBinding"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.removeAllKeyBindings()" access="pub" jdoc="Removes all key bindings from this input handler.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.grabNextKeyStroke(ActionListener)" access="pub" jdoc="Grabs the next key typed event and invokes the specified action with the key as a the action command. @param action The action">
				<param name="listener"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.isRepeatEnabled()" access="pub" jdoc="Returns if repeating is enabled. When repeating is enabled, actions will be executed multiple times. This is usually invoked with a special key stroke in the input handler.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.setRepeatEnabled(boolean)" access="pub" jdoc="Enables repeating. When repeating is enabled, actions will be executed multiple times. Once repeating is enabled, the input handler should read a number from the keyboard.">
				<param name="repeat"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.getRepeatCount()" access="pub" jdoc="Returns the number of times the next action will be repeated.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.setRepeatCount(int)" access="pub" jdoc="Sets the number of times the next action will be repeated. @param repeatCount The repeat count">
				<param name="repeatCount"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.getInputAction()" access="pub" jdoc="Returns the action used to handle text input.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.setInputAction(ActionListener)" access="pub" jdoc="Sets the action used to handle text input. @param inputAction The new input action">
				<param name="inputAction"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.getMacroRecorder()" access="pub" jdoc="Returns the macro recorder. If this is non-null, all executed actions should be forwarded to the recorder.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.setMacroRecorder(InputHandler.MacroRecorder)" access="pub" jdoc="Sets the macro recorder. If this is non-null, all executed actions should be forwarded to the recorder. @param recorder The macro recorder">
				<param name="recorder"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.executeOneClickAction(org.jext.OneClickAction, Object, String)" access="pub" jdoc="">
				<comm cntt="create event"/>
				<param name="listener"/>
				<param name="source"/>
				<param name="actionCommand"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.executeAction(ActionListener, Object, String)" access="pub" jdoc="Executes the specified action, repeating and recording it as necessary. @param listener The action listener @param source The event source @param actionCommand The action command">
				<comm cntt="create event"/>
				<comm cntt="don&amp;apos;t do anything if the action is a wrapper"/>
				<comm cntt="(like EditAction.Wrapper)"/>
				<comm cntt="remember old values, in case action changes them"/>
				<comm cntt="execute the action"/>
				<comm cntt="do recording. Notice that we do no recording whatsoever"/>
				<comm cntt="for actions that grab keys"/>
				<comm cntt="If repeat was true originally, clear it"/>
				<comm cntt="Otherwise it might have been set by the action, etc"/>
				<param name="listener"/>
				<param name="source"/>
				<param name="actionCommand"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.getTextArea(EventObject)" access="pub" jdoc="Returns the text area that fired the specified event. @param evt The event">
				<comm cntt="find the parent text area"/>
				<comm cntt="this shouldn&amp;apos;t happen"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler.handleGrabAction(KeyEvent)" access="prot" jdoc="If a key is being grabbed, this method should be called with the appropriate key event. It executes the grab action with the typed character as the parameter.">
				<comm cntt="Clear it before it is executed so that executeAction()"/>
				<comm cntt="resets the repeat count"/>
				<param name="evt"/>
			</mth>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$NonRepeatable" intfc="y" abs="n" inn="y" sloc="1" jdoc="If an action implements this interface, it should not be repeated. Instead, it will handle the repetition itself.">
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$NonRecordable" intfc="y" abs="n" inn="y" sloc="1" jdoc="If an action implements this interface, it should not be recorded by the macro recorder. Instead, it will do its own recording.">
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$Wrapper" intfc="y" abs="n" inn="y" sloc="1" jdoc="For use by EditAction.Wrapper only. @since jEdit 2.2final">
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$MacroRecorder" intfc="y" abs="n" inn="y" sloc="5" jdoc="Macro recorder.">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$MacroRecorder.actionPerformed(ActionListener, String)" access="pub" jdoc="">
				<param name="listener"/>
				<param name="actionCommand"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$backspace" intfc="n" abs="n" inn="y" sloc="34" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$backspace.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$backspace_word" intfc="n" abs="n" inn="y" sloc="43" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$backspace_word.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$delete" intfc="n" abs="n" inn="y" sloc="34" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$delete.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$delete_word" intfc="n" abs="n" inn="y" sloc="42" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$delete_word.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$end" intfc="n" abs="n" inn="y" sloc="44" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$end.end(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$end.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$document_end" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$document_end.document_end(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$document_end.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$home" intfc="n" abs="n" inn="y" sloc="45" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$home.home(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$home.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$document_home" intfc="n" abs="n" inn="y" sloc="16" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$document_home.document_home(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$document_home.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$insert_break" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$insert_break.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$insert_tab" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$insert_tab.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_char" intfc="n" abs="n" inn="y" sloc="23" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_char.next_char(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_char.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_line" intfc="n" abs="n" inn="y" sloc="32" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_line.next_line(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_line.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_page" intfc="n" abs="n" inn="y" sloc="27" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_page.next_page(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_page.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_word" intfc="n" abs="n" inn="y" sloc="44" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_word.next_word(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$next_word.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="boolean skipSpacesAfter = WordMove.isSpaceAfter(), this one is always == enabled! enabled = WordMove.isEnabled();"/>
				<comm cntt="MODIFIED by Blaisorblade, Paolo Giarrusso"/>
				<comm cntt="We must always skip spaces before jumping over a word, if the patch is enabled"/>
				<comm cntt="MODIFIED"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$overwrite" intfc="n" abs="n" inn="y" sloc="9" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$overwrite.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_char" intfc="n" abs="n" inn="y" sloc="23" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_char.prev_char(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_char.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_line" intfc="n" abs="n" inn="y" sloc="32" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_line.prev_line(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_line.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_page" intfc="n" abs="n" inn="y" sloc="24" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_page.prev_page(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_page.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_word" intfc="n" abs="n" inn="y" sloc="42" jdoc="">
			<field name="select" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_word.prev_word(boolean)" access="pub" jdoc="">
				<param name="select"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$prev_word.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="boolean skipSpacesBefore = WordMove.isSpaceBefore(), this one is always FALSE !"/>
				<comm cntt="enabled = WordMove.isEnabled();"/>
				<comm cntt="MODIFIED by Blaisorblade, Paolo Giarrusso"/>
				<comm cntt="We must always skip spaces before jumping over a word, if the patch is enabled"/>
				<comm cntt="if (skipSpacesBefore) while (caret &amp;gt; 0 &amp;&amp; lineText.charAt(caret - 1) == &amp;apos; &amp;apos;) caret--;"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$repeat" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$repeat.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$insert_char" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.InputHandler$insert_char.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.TextAreaHighlight" intfc="y" abs="n" inn="n" sloc="6" jdoc="Highlight interface. Create implementations of this interface and add them to the text area with &amp;lt;code&amp;gt;TextAreaPainter.addCustomHighlight()&amp;lt; code&amp;gt; to paint custom highlights. @author Slava Pestov @version $Id: TextAreaHighlight.java,v 1.4 2003 06 30 17:31:08 blaisorblade Exp $">
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaHighlight.init(JEditTextArea, TextAreaHighlight)" access="pub" jdoc="Called after the highlight painter has been added. @param textArea The text area @param next The painter this one should delegate to">
				<param name="textArea"/>
				<param name="next"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaHighlight.paintHighlight(Graphics, int, int)" access="pub" jdoc="This should paint the highlight and delgate to the next highlight painter. @param gfx The graphics context @param line The line number @param y The y co-ordinate of the line">
				<param name="gfx"/>
				<param name="line"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.TextAreaHighlight.getToolTipText(MouseEvent)" access="pub" jdoc="Returns the tool tip to display at the specified location. If this highlighter doesn&amp;apos;t know what to display, it should delegate to the next highlight painter. @param evt The mouse event">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler" intfc="n" abs="n" inn="n" sloc="253" jdoc="The default input handler. It maps sequences of keystrokes into actions and inserts key typed events into the text area. @author Slava Pestov @version $Id: DefaultInputHandler.java,v 1.6 2002 08 09 14:16:38 orangeherbert Exp $">
			<comm cntt="private members"/>
			<field name="bindings" access="priv" jdoc=""/>
			<field name="currentBindings" access="priv" jdoc=""/>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler.DefaultInputHandler()" access="pub" jdoc="Creates a new input handler with no key bindings defined.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler.DefaultInputHandler(DefaultInputHandler)" access="pub" jdoc="Creates a new input handler with the same set of key bindings as the one specified. Note that both input handlers share a pointer to exactly the same key binding table; so adding a key binding in one will also add it to the other. @param copy The input handler to copy key bindings from">
				<param name="copy"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler.addDefaultKeyBindings()" access="pub" jdoc="Sets up the default key bindings.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler.addKeyBinding(String, ActionListener)" access="pub" jdoc="Adds a key binding to this input handler. The key binding is a list of white space separated key strokes of the form &amp;lt;i&amp;gt;[modifiers+]key&amp;lt; i&amp;gt; where modifier is C for Control, A for Alt, or S for Shift, and key is either a character (a-z) or a field name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE) @param keyBinding The key binding @param action The action">
				<param name="keyBinding"/>
				<param name="action"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler.removeKeyBinding(String)" access="pub" jdoc="Removes a key binding from this input handler. This is not yet implemented. @param keyBinding The key binding">
				<param name="keyBinding"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler.removeAllKeyBindings()" access="pub" jdoc="Removes all key bindings from this input handler.">
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler.keyPressed(KeyEvent)" access="pub" jdoc="Handle a key pressed event. This will look up the binding for the key stroke and execute it.">
				<comm cntt="Don&amp;apos;t beep if the user presses some"/>
				<comm cntt="key we don&amp;apos;t know about unless a"/>
				<comm cntt="prefix is active. Otherwise it will"/>
				<comm cntt="beep when caps lock is pressed, etc."/>
				<comm cntt="F10 should be passed on, but C+e F10"/>
				<comm cntt="shouldn&amp;apos;t"/>
				<comm cntt="Don&amp;apos;t beep if the user presses some"/>
				<comm cntt="key we don&amp;apos;t know about unless a"/>
				<comm cntt="prefix is active. Otherwise it will"/>
				<comm cntt="beep when caps lock is pressed, etc."/>
				<comm cntt="F10 should be passed on, but C+e F10"/>
				<comm cntt="shouldn&amp;apos;t"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler.keyTyped(KeyEvent)" access="pub" jdoc="Handle a key typed event. This inserts the key into the text area.">
				<comm cntt="0-9 adds another &amp;apos;digit&amp;apos; to the repeat number"/>
				<comm cntt="if (!evt.isControlDown())"/>
				<comm cntt="System.out.println(evt.isControlDown());"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.gjt.sp.jedit.textarea.DefaultInputHandler.parseKeyStroke(String)" access="pub" jdoc="Converts a string to a keystroke. The string should be of the form &amp;lt;i&amp;gt;modifiers&amp;lt; i&amp;gt;+&amp;lt;i&amp;gt;shortcut&amp;lt; i&amp;gt; where &amp;lt;i&amp;gt;modifiers&amp;lt; i&amp;gt; is any combination of A for Alt, C for Control, S for Shift or M for Meta, and &amp;lt;i&amp;gt;shortcut&amp;lt; i&amp;gt; is either a single character, or a keycode name from the &amp;lt;code&amp;gt;KeyEvent&amp;lt; code&amp;gt; class, without the &amp;lt;code&amp;gt;VK_&amp;lt; code&amp;gt; prefix. @param keyStroke A string description of the key stroke">
				<comm cntt="InputEvent.CTRL_MASK;"/>
				<param name="keyStroke"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext">
		<class name="/lib/:org.jext.ModeFileFilter" intfc="n" abs="n" inn="n" sloc="55" jdoc="&amp;lt;code&amp;gt;ModeFileFilter&amp;lt; code&amp;gt; is a file filter specific to a given syntax colorizing mode.">
			<field name="regexp" access="priv" jdoc=""/>
			<field name="modeName" access="priv" jdoc=""/>
			<field name="description" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.ModeFileFilter.ModeFileFilter(Mode)" access="pub" jdoc="Creates a new file filter for given syntax colorizing mode. @param mode The syntax colorizing mode which gives file filters infos">
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.ModeFileFilter.rebuildRegexp()" access="pub" jdoc="Reload the filter; use this when the user changes it. Called from a JextFrame inner class by a JextListener when properties change.">
				<comm cntt="friendly"/>
			</mth>
			<mth name="/lib/:org.jext.ModeFileFilter.getModeName()" access="pub" jdoc="Returns Jext internal mode name of the mode used to build this file filter.">
			</mth>
			<mth name="/lib/:org.jext.ModeFileFilter.accept(File)" access="pub" jdoc="If given file is correctly named, it is accepted by the file filter.">
				<comm cntt="Lazy building of regexp is also needed because custom properties are loaded after building these filters."/>
				<param name="file"/>
			</mth>
			<mth name="/lib/:org.jext.ModeFileFilter.getDescription()" access="pub" jdoc="Returns a simple description of the file filter.">
			</mth>
		</class>
		<class name="/lib/:org.jext.Jext" intfc="n" abs="n" inn="n" sloc="900" jdoc="Jext is a fully featured, 100% Pure Java, text editor. It has been mainly designed for programmers, and provides also very useful functions for them (syntax colorization, auto indentation...). @author Romain Guy @version 5.0">
			<comm cntt=""/>
			<comm cntt="PUBLIC CONSTANTS"/>
			<comm cntt=""/>
			<comm cntt="If you change any of the final values here, you&amp;apos;ll need to recompile every class that uses them. So some lost their &amp;quot;final&amp;quot; at some point, but mustn&amp;apos;t be modified anyway."/>
			<comm cntt=""/>
			<comm cntt="BEGINNING OF STATIC PART"/>
			<comm cntt=""/>
			<comm cntt="STATIC FIELDS"/>
			<comm cntt=""/>
			<comm cntt="modes"/>
			<comm cntt="selected language"/>
			<comm cntt="GUI option to have, or not flat menus"/>
			<comm cntt="GUI option to have non highlighted buttons"/>
			<comm cntt="server socket"/>
			<comm cntt="plugins specific variables"/>
			<comm cntt="user properties filename"/>
			<comm cntt="the splash screen"/>
			<comm cntt="the properties files"/>
			<comm cntt="contains all the instances of Jext"/>
			<comm cntt="this is an object we synchronize on to avoid window being created concurrently or when is not ready"/>
			<comm cntt="enough(for instance by JextLoader when we didn&amp;apos;t call initProperties() yet)."/>
			<comm cntt="contains all the actions"/>
			<comm cntt="contains all the python actions"/>
			<comm cntt="auto check"/>
			<comm cntt="input handler"/>
			<comm cntt="user properties file name"/>
			<comm cntt="this property(set by loadInSingleJVMInstance), if true, says we must not show"/>
			<comm cntt="the default value found during loading must be stored for the option dialog"/>
			<comm cntt="when the user runs jext -kill, we store this here and go to kill the server(see"/>
			<comm cntt="loadInSingleJVMInstance)"/>
			<comm cntt="the text area we pre-build if running in background, that will be shown when Jext is started"/>
			<comm cntt="by the user(so it will be very fast!)"/>
			<comm cntt=""/>
			<comm cntt="STATIC METHODS"/>
			<comm cntt=""/>
			<comm cntt="returns a non-null ZipEntry object if current language pack"/>
			<comm cntt="contains requested file"/>
			<comm cntt="sort modes alphabetically"/>
			<comm cntt="changes some default UI settings such as trees leaf icons or font size and style..."/>
			<comm cntt="For JextLoader when it&amp;apos;s killing Jext"/>
			<comm cntt="friendly"/>
			<comm cntt="check the command line arguments"/>
			<comm cntt=""/>
			<comm cntt="END OF STATIC PART"/>
			<comm cntt=""/>
			<comm cntt="MAIN ENTRY POINT"/>
			<comm cntt=""/>
			<field name="RELEASE" access="pub" jdoc="Current Jext&amp;apos;s release."/>
			<field name="BUILD" access="pub" jdoc="Last Jext&amp;apos;s build number. It&amp;apos;s used actually only for plugin dependencies, so don&amp;apos;t change it for simple bug-fix which don&amp;apos;t bump the release number."/>
			<field name="DELETE_OLD_SETTINGS" access="pub" jdoc="If true, Jext will delete user settings if this release is newer"/>
			<field name="DEBUG" access="pub" jdoc="Debug mode(not final to avoid it being included in other .class files)"/>
			<const name="NEW_LINE" access="pub" jdoc="Available new lines characters"/>
			<const name="SETTINGS_DIRECTORY" access="pub" jdoc="Settings directory."/>
			<const name="JEXT_HOME" access="pub" jdoc="Jext home directory."/>
			<const name="JEXT_SERVER_PORT" access="pub" jdoc="Jext server base port number. Used to load all Jext instances with only one JVM."/>
			<field name="modes" access="pub" jdoc=""/>
			<field name="modesFileFilters" access="pub" jdoc=""/>
			<field name="language" access="priv" jdoc=""/>
			<field name="languagePack" access="priv" jdoc=""/>
			<field name="languageEntries" access="priv" jdoc=""/>
			<field name="flatMenus" access="priv" jdoc=""/>
			<field name="buttonsHighlight" access="priv" jdoc=""/>
			<field name="jextLoader" access="priv" jdoc=""/>
			<field name="isServerEnabled" access="priv" jdoc=""/>
			<field name="plugins" access="priv" jdoc=""/>
			<field name="usrProps" access="pub" jdoc=""/>
			<field name="splash" access="priv" jdoc=""/>
			<field name="props" access="priv" jdoc=""/>
			<field name="defaultProps" access="priv" jdoc=""/>
			<field name="instances" access="priv" jdoc=""/>
			<field name="actionHash" access="priv" jdoc=""/>
			<field name="pythonActionHash" access="priv" jdoc=""/>
			<field name="check" access="priv" jdoc=""/>
			<field name="inputHandler" access="priv" jdoc=""/>
			<const name="USER_PROPS" access="priv" jdoc=""/>
			<field name="runInBg" access="priv" jdoc=""/>
			<field name="keepInMemory" access="priv" jdoc=""/>
			<field name="defaultKeepInMemory" access="priv" jdoc=""/>
			<field name="goingToKill" access="priv" jdoc=""/>
			<field name="builtTextArea" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.Jext.getButtonsHighlight()" access="pub" jdoc="Returns true if highlight buttons should not be highlighted on mouse over.">
			</mth>
			<mth name="/lib/:org.jext.Jext.getFlatMenus()" access="pub" jdoc="Returns true if menu should be flatened.">
			</mth>
			<mth name="/lib/:org.jext.Jext.stopAutoCheck()" access="pub" jdoc="Stop the auto check function. We just interrupt the &amp;lt;code&amp;gt;Thread&amp;lt; code&amp;gt; and then &amp;apos;kill&amp;apos; it.">
			</mth>
			<mth name="/lib/:org.jext.Jext.getInputHandler()" access="pub" jdoc="Returns the input handler.">
			</mth>
			<mth name="/lib/:org.jext.Jext.addAction(MenuAction)" access="pub" jdoc="Add an action listener to the list. @param action The action listener">
				<param name="action"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.addPythonAction(String, String, boolean)" access="pub" jdoc="Add a python action listener to the list. @param name Internal action name @param script The python source script @param editAction True if this is an edit action">
				<param name="name"/>
				<param name="script"/>
				<param name="editAction"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getAction(String)" access="pub" jdoc="Returns a named action. @param action The action">
				<param name="action"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.initActions()" access="priv" jdoc="Load the action listeners.">
				<comm cntt="Python written actions"/>
				<comm cntt="native Java actions"/>
				<comm cntt="addAction(new RemoveSpaces());"/>
				<comm cntt="init OneClick! actions"/>
				<comm cntt="One Click !"/>
				<comm cntt="addAction(new OneClickAction(&amp;quot;one_paste&amp;quot;, &amp;quot;paste&amp;quot;));"/>
				<comm cntt="addAction(new OneClickAction(&amp;quot;one_reverse_paste&amp;quot;, &amp;quot;reverse_paste&amp;quot;));"/>
				<comm cntt="addAction(new OneClickAction(&amp;quot;one_delete_line&amp;quot;, &amp;quot;delete_line&amp;quot;));"/>
				<comm cntt="addAction(new OneClickAction(&amp;quot;one_join_lines&amp;quot;, &amp;quot;join_lines&amp;quot;));"/>
				<comm cntt="addAction(new OneClickAction(&amp;quot;one_right_indent&amp;quot;, &amp;quot;right_indent&amp;quot;));"/>
				<comm cntt="addAction(new OneClickAction(&amp;quot;one_left_indent&amp;quot;, &amp;quot;left_indent&amp;quot;));"/>
				<comm cntt="addAction(new OneClickAction(&amp;quot;one_simple_comment&amp;quot;, &amp;quot;simple_comment&amp;quot;));"/>
				<comm cntt="addAction(new OneClickAction(&amp;quot;one_simple_uncomment&amp;quot;, &amp;quot;simple_uncomment&amp;quot;));"/>
				<comm cntt="addAction(new OneClickAction(&amp;quot;one_complete_word&amp;quot;, &amp;quot;complete_word&amp;quot;));"/>
				<comm cntt="key bindings"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.addJextKeyBindings()" access="priv" jdoc="Adds Jext internal key bindings.">
				<comm cntt="end if JRE 1.4 or above"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.initPlugins()" access="priv" jdoc="Loads plugins.">
			</mth>
			<mth name="/lib/:org.jext.Jext.assocPluginsToModes()" access="pub" jdoc="Makes each mode know what plugins to start when it is selected.">
			</mth>
			<mth name="/lib/:org.jext.Jext.loadPlugins(String)" access="pub" jdoc="Loads all plugins in a directory. @param directory The directory">
				<param name="directory"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.addPlugin(Plugin)" access="pub" jdoc="Registers a plugin with the editor. This will also call the &amp;lt;code&amp;gt;start()&amp;lt; code&amp;gt; method of the plugin.">
				<comm cntt="System.out.println(&amp;quot;Added a SkinPlugin named: &amp;quot; + plugin.getClass().getName());"/>
				<param name="plugin"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getPlugin(String)" access="pub" jdoc="Returns a plugin by it&amp;apos;s class name. @param name The plugin to return">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getPlugins()" access="pub" jdoc="Returns an array of installed plugins.">
				<comm cntt="Object[] o = plugins.toArray(); Plugin[] p = new Plugin[o.length]; for (int i = 0; i &amp;lt; o.length; i++) p[i] = (Plugin) o[i];"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.newWindow(String)" access="pub" jdoc="Opens a new window. @param args Parameters from command line">
				<param name="args"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.newWindow()" access="pub" jdoc="Opens a new window.">
			</mth>
			<mth name="/lib/:org.jext.Jext.newWindow(String, boolean)" access="pub" jdoc="Opens a new window, but eventually does not show it. @param args The command line arguments @param toShow When true the frame is shown">
				<comm cntt="Note: until code doesn&amp;apos;t need it, better leaving it only for the package."/>
				<comm cntt="friendly"/>
				<comm cntt="if (toShow)"/>
				<param name="args"/>
				<param name="toShow"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getWindowsCount()" access="pub" jdoc="Returns amount of opened Jext">
			</mth>
			<mth name="/lib/:org.jext.Jext.propertiesChanged()" access="pub" jdoc="Notify all instances of Jext and all properties listeners to reload properties.">
				<comm cntt="we send the event to all the listeners available"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.recentChanged(JextFrame)" access="pub" jdoc="Notify all instances of Jext but the one which saved the file to reload recent menu @param The instance which saved a file">
				<comm cntt="we send the event to all the listeners available"/>
				<param name="instance"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getInstances()" access="pub" jdoc="Some external classes may need to notify each instance of Jext. XTree does. @return A &amp;lt;code&amp;gt;ArrayList&amp;lt; code&amp;gt; containing all instances of Jext">
			</mth>
			<mth name="/lib/:org.jext.Jext.getMyToolkit()" access="pub" jdoc="Many methods will need to use a &amp;lt;code&amp;gt;Toolkit&amp;lt; code&amp;gt;. This method simply avoid to write too many lines of code. @return The default &amp;lt;code&amp;gt;Toolkit&amp;lt; code&amp;gt;">
			</mth>
			<mth name="/lib/:org.jext.Jext.getHomeDirectory()" access="pub" jdoc="Jext startup directory is saved during execution. @return Jext&amp;apos;s startup directory">
			</mth>
			<mth name="/lib/:org.jext.Jext.saveProps()" access="pub" jdoc="Store the properties on the HD. After having set up the properties, we need to store&amp;apos;em in a file. @deprecated Use &amp;lt;code&amp;gt;saveXMLProps()&amp;lt; code&amp;gt; instead">
			</mth>
			<mth name="/lib/:org.jext.Jext.saveXMLProps(String)" access="pub" jdoc="Saves the user&amp;apos;s properties to a file using the XML specifications. @param description is a &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; containing a little description of the properties file. This String is stored on topmost of the user&amp;apos;s properties file. Can be set to &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;.">
				<param name="description"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.saveXMLProps(String, String)" access="pub" jdoc="Saves the user&amp;apos;s properties to a file using the XML specifications. @param userProps is the path to the file in which properties will be stored. If it is set to &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;, properties are not saved at all. @param description is a &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; containing a little description of the properties file. This String is stored on topmost of the user&amp;apos;s properties file. Can be set to &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;.">
				<comm cntt="for (int i = 0; i &amp;lt; buf.length(); i++)"/>
				<comm cntt="out.write(buf.charAt(i));"/>
				<comm cntt="JARClassLoader.saveDisabledList();"/>
				<param name="userProps"/>
				<param name="description"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getProperties()" access="pub" jdoc="The &amp;lt;code&amp;gt;XPropertiesHandler&amp;lt; code&amp;gt; needs to get Jext&amp;apos;s &amp;lt;code&amp;gt;Properties&amp;lt; code&amp;gt; object to achieve its purpose. @return The current &amp;lt;code&amp;gt;Properties&amp;lt; code&amp;gt; object">
			</mth>
			<mth name="/lib/:org.jext.Jext.loadXMLProps(InputStream, String)" access="pub" jdoc="Load a set of properties from an XML file. This method, and not the caller, will search for the translated version of the XML. @param in An &amp;lt;code&amp;gt;InputStream&amp;lt; code&amp;gt; is specified to load properties from a JAR file @param fileName The XML filename">
				<param name="in"/>
				<param name="fileName"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.loadXMLProps(InputStream, String, boolean)" access="pub" jdoc="Load a set of properties from an XML file. It is provided for when the caller already provides the translated file(for instance for the plugin translation); in this case toTranslate must be true, otherwise it will be translated the default way. @param in An &amp;lt;code&amp;gt;InputStream&amp;lt; code&amp;gt; is specified to load properties from a JAR file @param fileName The XML filename @since Jext3.2pre1">
				<param name="in"/>
				<param name="fileName"/>
				<param name="toTranslate"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.loadXMLActions(InputStream, String)" access="pub" jdoc="Load a set of actions from an XML file. @param in An &amp;lt;code&amp;gt;InputStream&amp;lt; code&amp;gt; is specified to load properties from a JAR file @param fileName The XML filename">
				<param name="in"/>
				<param name="fileName"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.loadXMLOneClickActions(InputStream, String)" access="pub" jdoc="Load a set of actions from an XML file. @param in An &amp;lt;code&amp;gt;InputStream&amp;lt; code&amp;gt; is specified to load properties from a JAR file @param fileName The XML filename">
				<param name="in"/>
				<param name="fileName"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getLanguageStream(InputStream, String)" access="pub" jdoc="Returns an input stream corresponding to selected language. @param in The default stream @param fileName The requested file">
				<param name="in"/>
				<param name="fileName"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.languagePackContains(String)" access="pub" jdoc="">
				<param name="fileName"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.loadProps(InputStream)" access="pub" jdoc="Load a set of properties. @param in An &amp;lt;code&amp;gt;InputStream&amp;lt; code&amp;gt; is specified to load properties from a JAR file @deprecated Maintained only for plugins compliance. Use &amp;lt;code&amp;gt;loadXMLProps()&amp;lt; code&amp;gt; instead of this method.">
				<param name="in"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.initDirectories()" access="pub" jdoc="Creates the necessary directories.">
			</mth>
			<mth name="/lib/:org.jext.Jext.initProperties()" access="pub" jdoc="Init the properties.">
				<comm cntt=""/>
				<comm cntt="DEPRECATED BY THE METHOD loadXMLProps()"/>
				<comm cntt=""/>
				<comm cntt="loadProps(Jext.class.getResourceAsStream(&amp;quot;jext-gui.keys&amp;quot;));"/>
				<comm cntt="loadProps(Jext.class.getResourceAsStream(&amp;quot;jext-gui.text&amp;quot;));"/>
				<comm cntt="loadProps(Jext.class.getResourceAsStream(&amp;quot;jext.props&amp;quot;));"/>
				<comm cntt="loadProps(Jext.class.getResourceAsStream(&amp;quot;jext.tips&amp;quot;));"/>
				<comm cntt=""/>
				<comm cntt="loads specified language pack"/>
				<comm cntt="loadXMLProps(Jext.class.getResourceAsStream(&amp;quot;jext.props.xml&amp;quot;), &amp;quot;jext.props.xml&amp;quot;);"/>
				<comm cntt="loadXMLProps(Jext.class.getResourceAsStream(&amp;quot;jext.props.xml&amp;quot;), &amp;quot;jext.props.xml&amp;quot;);"/>
				<comm cntt="must be here since the user can change the mode filters."/>
				<comm cntt="Add our protocols to java.net.URL&amp;apos;s list"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.setLanguage(String)" access="pub" jdoc="Sets the current selected language. @param lang The label of the language">
				<param name="lang"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getLanguage()" access="pub" jdoc="Returns current selected language.">
			</mth>
			<mth name="/lib/:org.jext.Jext.executeScripts(JextFrame)" access="pub" jdoc="Execute scripts found in user home directory.">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.sortModes()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.Jext.initUI()" access="priv" jdoc="">
				<comm cntt="if (getBooleanProperty(&amp;quot;useJextTheme&amp;quot;)) MetalLookAndFeel.setCurrentTheme(new JextMetalTheme());"/>
				<comm cntt="check if menus are flat or not"/>
				<comm cntt="check if buttons are highlighted or not"/>
				<comm cntt="rollover"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.initModes()" access="priv" jdoc="Initialize syntax colorizing modes.">
			</mth>
			<mth name="/lib/:org.jext.Jext.getMode(String)" access="pub" jdoc="Returns the mode according to its name.">
				<param name="modeName"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getModes()" access="pub" jdoc="Returns modes list.">
			</mth>
			<mth name="/lib/:org.jext.Jext.addMode(Mode)" access="pub" jdoc="Adds a mode to Jext&amp;apos;s syntax colorizing modes list">
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.setProperty(String, String)" access="pub" jdoc="Set a property. @param name Property&amp;apos;s name @param value The value to store as &amp;lt;code&amp;gt;name&amp;lt; code&amp;gt;">
				<param name="name"/>
				<param name="value"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getBooleanProperty(String)" access="pub" jdoc="Returns true if the property value equals to &amp;quot;on&amp;quot; or &amp;quot;true&amp;quot; @param name The name of the property to read">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getBooleanProperty(String, String)" access="pub" jdoc="Returns true if the property value equals to &amp;quot;on&amp;quot; or &amp;quot;true&amp;quot; @param name The name of the property to read">
				<param name="name"/>
				<param name="def"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getProperty(String)" access="pub" jdoc="If we store properties, we need to read them, too ! @param name The name of the property to read @return The value of the specified property">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getProperty(String, String)" access="pub" jdoc="Fetches a property, returning the default value if it&amp;apos;s not defined. @param name The property @param def The default value">
				<param name="name"/>
				<param name="def"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getProperty(String, Object[])" access="pub" jdoc="Returns the property with the specified name, formatting it with the &amp;lt;code&amp;gt;java.text.MessageFormat.format()&amp;lt; code&amp;gt; method. @param name The property @param args The positional parameters">
				<param name="name"/>
				<param name="args"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.unsetProperty(String)" access="pub" jdoc="Unsets (clears) a property. @param name The property">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.exit()" access="pub" jdoc="Exits Jext by closing all the windows. If backgrounding, it doesn&amp;apos;t kill the jext server. This is synchronized because creating two windows at a time can be problematic.">
				<comm cntt="if (i == 0) { instance.fireJextEvent(JextEvent.KILLING_JEXT); if (!isRunningBg()) stopPlugins(); } else instance.fireJextEvent(JextEvent.CLOSE_WINDOW);"/>
				<comm cntt="if (isRunningBg()) { builtTextArea = newWindow(null, false); instances.add(builtTextArea); } else finalCleanupBeforeExit();"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.finalCleanupAndExit()" access="pub" jdoc="Do the final cleanup that must be done at the real end of the session(when closing the server if running background server, or after killing the last window if no server is running).">
				<comm cntt="friendly"/>
				<comm cntt="currently it does almost nothing, but it&amp;apos;s used."/>
			</mth>
			<mth name="/lib/:org.jext.Jext.stopPlugins()" access="pub" jdoc="Stop plugins.">
				<comm cntt="friendly"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.closeToQuit(JextFrame)" access="pub" jdoc="Close a {@link JextFrame} by calling {@link JextFrame#closeToQuit()} and if it it the last window and we are not keeping the server open we close Jext completely.">
				<param name="frame"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.closeToQuit(JextFrame, boolean)" access="pub" jdoc="">
				<comm cntt="so when calling closeWindow(frame), which will happen, it will close completely Jext"/>
				<comm cntt="and stop plugins."/>
				<param name="frame"/>
				<param name="isKillingServer"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.closeWindow(JextFrame)" access="pub" jdoc="">
				<comm cntt="&amp;&amp; !isRunningBg()"/>
				<comm cntt="frame.cleanMemory();"/>
				<comm cntt="this way, the garbage collector should do its work, without any NullPointerEx at all."/>
				<param name="frame"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.getSplashScreen()" access="pub" jdoc="Returns splash screen">
			</mth>
			<mth name="/lib/:org.jext.Jext.setSplashProgress(int)" access="pub" jdoc="Set the splash screen progress value after having checked if it isn&amp;apos;t null (in case of a new window). @param val The new value">
				<param name="val"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.setSplashText(String)" access="pub" jdoc="Set the splash screen text value after having checked if it isn&amp;apos;t null (in case of a new window). @param text The new text">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.killSplashScreen()" access="pub" jdoc="Kills splash screen">
			</mth>
			<mth name="/lib/:org.jext.Jext.stopServer()" access="pub" jdoc="Stops the Jext server which loads every Jext instance in the same JVM.">
			</mth>
			<mth name="/lib/:org.jext.Jext.isServerEnabled()" access="pub" jdoc="Returns true if the server is enabled.">
			</mth>
			<mth name="/lib/:org.jext.Jext.isDefaultKeepInMemory()" access="pub" jdoc="Returns true if the backgrounding is enabled.">
			</mth>
			<mth name="/lib/:org.jext.Jext.setDefaultKeepInMemory(boolean)" access="pub" jdoc="">
				<comm cntt="TODO:hack to active it from this session onwards"/>
				<param name="val"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.setServerEnabled(boolean)" access="pub" jdoc="Used by security options panel to remember of the server status. @param on If true, the server will be runned at next start">
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.loadInSingleJVMInstance(String[])" access="pub" jdoc="Attempts to load Jext in a single JVM instance only. If this instance of Jext is the very first to be loaded, then a ServerSocket is opened. Otherwise, this instance attemps to connect on to a specific socket port to tell other Jext instance to create a new window. This avoids to load on JVM for each launch of Jext. Opened port is securised so that no security hole is created. @param args The arguments of the new Jext window">
				<comm cntt="if the authorization key exists, another Jext instance may"/>
				<comm cntt="be running"/>
				<comm cntt="we attempt to log onto the other instance of Jext(but only if we are not backgrounding; no"/>
				<comm cntt="more than one bg instance is started, and if we are bg we don&amp;apos;t pass anything to the other instance."/>
				<comm cntt="now that we made sure that the other instance exists, if backgrounding we do"/>
				<comm cntt="nothing"/>
				<comm cntt="no other jext instance is running, we delete the auth. file"/>
				<param name="args"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.isRunningBg()" access="pub" jdoc="As Jext can be runned in background mode, some operations may need to know wether or not current instance is &amp;quot;up&amp;quot; or &amp;quot;crouched&amp;quot;. This is the purpose of this method. @return A true boolean value is returned whenever Jext is running in background mode">
			</mth>
			<mth name="/lib/:org.jext.Jext.parseOptions(String[])" access="priv" jdoc="">
				<comm cntt="Trap bg flag"/>
				<comm cntt="First, it checks defaults: if the user actived -showbg by default, read this setting."/>
				<comm cntt="Then, let&amp;apos;s read options."/>
				<comm cntt="Whenever it encounter an option it resets all contrary ones."/>
				<comm cntt="This option is unrelated."/>
				<param name="args"/>
			</mth>
			<mth name="/lib/:org.jext.Jext.main(String)" access="pub" jdoc="Start method. Load the property file, set the look and feel, create a new GUI, load the options. If a file name is specified as first argument, we pass it to the window contructor which will construct its full path (because you can specify, for example, ..\..\test.java or ~\jext.props or ..... hello.cpp - both and \ can be used -)">
				<comm cntt="DEBUG"/>
				<comm cntt="FIXME:maybe it should ignore arguments when backgrounding."/>
				<param name="args"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JextLoader" intfc="n" abs="n" inn="n" sloc="125" jdoc="This class creates a new socket connection which listens to client requests. Whenever a client logs onto the socket, we check its IP address.&amp;lt;br&amp;gt; Security implementation:&amp;lt;p&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;If this address isn&amp;apos;t 127.0.0.1 (aka localhost), the connection is rejected.&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;The socket also needs to get the good message which must contain a give authorization key. If the given key or message is wrong, the connection is rejected.&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;If the server rejects a connection, it also closes itself to avoid Denial Of Service attacks or brutal ones (trying for instance random keys).&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; @author Romain Guy @version 1.1.1">
			<comm cntt="warn the user that someone is attempting to break into his system"/>
			<field name="port" access="priv" jdoc=""/>
			<field name="auth" access="priv" jdoc=""/>
			<field name="key" access="priv" jdoc=""/>
			<field name="tServer" access="priv" jdoc=""/>
			<field name="server" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.JextLoader.JextLoader()" access="pub" jdoc="">
				<comm cntt="creates the authorization key"/>
				<comm cntt="16 383 = unreserved range of ports"/>
				<comm cntt="creates the server"/>
				<comm cntt="server is necessarily threaded"/>
			</mth>
			<mth name="/lib/:org.jext.JextLoader.stop()" access="pub" jdoc="Stops the server by inerrupting the thread, killing it and then closing the server itself. Finally, it erases the authorization key.">
			</mth>
			<mth name="/lib/:org.jext.JextLoader.run()" access="pub" jdoc="Waits for a connexion request and handle it. The client should provide a special line containing a message, the arguments for the loading and the authorization key. This key is used to avoid security holes in your system.">
				<comm cntt="when backgrounding connects to check existance of server but sends"/>
				<comm cntt="nothing."/>
				<comm cntt="can be 0 when backgrounding.??? No more!"/>
				<comm cntt="parent.setVisible(true); this code is not good when running background server,"/>
				<comm cntt="since Jext keeps builtTextArea set(and doesn&amp;apos;t open a new one until it isn&amp;apos;t unset)."/>
				<comm cntt="And so setVisible is not needed."/>
				<comm cntt="when Jext.isRunningBg()"/>
				<comm cntt="&amp;&amp; Jext.getWindowsCount() &amp;lt;= 1 )"/>
				<comm cntt="normally at least one window is always open, even if hidden, but in some moments"/>
				<comm cntt="this isn&amp;apos;t true(when the user exits jext and it has not still started a new window)."/>
				<comm cntt="If one window is open, we must check it is not shown."/>
				<comm cntt="since the window has not been shown this could be useless, but maybe not, especially to"/>
				<comm cntt="dispatch JextEvent&amp;apos;s."/>
				<comm cntt="I&amp;apos;ve commented out the above code since it causes bugs with the ProjectManagement,"/>
				<comm cntt="that is NullPointerEx. I&amp;apos;m trying if this doesn&amp;apos;t happen without cleanMemory."/>
				<comm cntt="check well this! TODO"/>
			</mth>
			<mth name="/lib/:org.jext.JextLoader.intrusion()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.Mode" intfc="n" abs="n" inn="n" sloc="48" jdoc="&amp;lt;code&amp;gt;Mode&amp;lt; code&amp;gt; represents a syntax colorizing mode. This class holds the mode name and its correpsonding syntax colorizing toke marker. @author Romain Guy">
			<comm cntt="protected to let plugins have an acces to these"/>
			<comm cntt="fields. the text mode plugin is a good example"/>
			<field name="modeName" access="prot" jdoc=""/>
			<field name="userModeName" access="prot" jdoc=""/>
			<field name="className" access="prot" jdoc=""/>
			<field name="plugins" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.Mode.Mode(String)" access="pub" jdoc="Creates a new syntax colorizing mode defined by its name. The name is internal to Jext. For instance, plain text colorizing mode internal name is &amp;quot;plain&amp;quot; whereas its user name is &amp;quot;Plain Text&amp;quot;. @param modeName The internal mode name">
				<param name="modeName"/>
			</mth>
			<mth name="/lib/:org.jext.Mode.getModeName()" access="pub" jdoc="Returns the internal mode name.">
			</mth>
			<mth name="/lib/:org.jext.Mode.getUserModeName()" access="pub" jdoc="Returns the user mode name.">
			</mth>
			<mth name="/lib/:org.jext.Mode.getTokenMarker()" access="pub" jdoc="Returns the associated toke marker which is used to colorize the text.">
			</mth>
			<mth name="/lib/:org.jext.Mode.addPlugin(Plugin)" access="pub" jdoc="Registers a plugin with this mode. @param plugin The &amp;lt;code&amp;gt;Plugin&amp;lt; code&amp;gt; to register">
				<param name="plugin"/>
			</mth>
			<mth name="/lib/:org.jext.Mode.getPlugins()" access="pub" jdoc="Returns all the plugins associated to this mode.">
			</mth>
			<mth name="/lib/:org.jext.Mode.setPlugins(ArrayList)" access="pub" jdoc="Sets associated plugins. @param newPlugins The associated &amp;lt;code&amp;gt;Plugin&amp;lt; code&amp;gt;s">
				<param name="newPlugins"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.Utilities" intfc="n" abs="n" inn="n" sloc="521" jdoc="This class contains a bunch of methods, useful for the programmer. @author Romain Guy, Slava Pestov, James Gosling, Paolo Giarrusso @version 2.3.0 @see Jext">
			<comm cntt="The below code is left here, even if it is useless, because maybe there are"/>
			<comm cntt="plugins which need it. sortStrings is needed by jftp, so it&amp;apos;s there."/>
			<comm cntt="Remember that sortStrings is listed in the docs, so you can&amp;apos;t remove it."/>
			<comm cntt="Quick sort an array of Strings. @param a Strings to be sorted @param lo0 Lower bound @param hi0 Higher bound"/>
			<comm cntt="public static void sortStrings(String a[], int lo0, int hi0) { int lo = lo0; int hi = hi0; String mid; if (hi0 &amp;gt; lo0) { mid = a[(lo0 + hi0) 2]; while (lo &amp;lt;= hi) { while (lo &amp;lt; hi0 &amp;&amp; a[lo].compareTo(mid) &amp;lt; 0) ++lo; while (hi &amp;gt; lo0 &amp;&amp; a[hi].compareTo(mid) &amp;gt; 0) --hi; if (lo &amp;lt;= hi) { swap(a, lo, hi); ++lo; --hi; } } if (lo0 &amp;lt; hi) sortStrings(a, lo0, hi); if (lo &amp;lt; hi0) sortStrings(a, lo, hi0); } }"/>
			<comm cntt="Swaps two Strings. @param a The array to be swapped @param i First String index @param j Second String index"/>
			<comm cntt="public static void swap(String a[], int i, int j) { String T; T = a[i]; a[i] = a[j]; a[j] = T; }"/>
			<comm cntt="public static void downloadFile(URL source, String outPath, boolean threaded, HandlingRunnable notify) throws IOException { try { String tempPath = outPath + &amp;quot;__FRAG__&amp;quot;; final File outFile = new File(outPath), tempFile = new File(tempPath); FIXME: think about the case below. The caller must avoid that we download the file 2 times. Not us! if (tempFile.exists()) tempFile.renameTo(new File(tempPath + &amp;quot;.bak&amp;quot;)); Could fail and return false!"/>
			<comm cntt="HandlingRunnable renamer = new HandlingRunnable() { public void run() { if (expectedLen != -1 &amp;&amp; expectedLen != tempFile.length()) { exceptional condition: if (excep == null &amp;&amp; notify != null) notify.setException(new IOException(&amp;quot;The download was not completed&amp;quot;)); } if (outFile.exists()) { outFile.renameTo(new File(outPath + &amp;quot;.bak&amp;quot;)); Could fail and return false! outFile.delete(); } tempFile.renameTo(outFile); if (notify != null) { notify.setException(excep); we won&amp;apos;t handle it: this will be done by notify. notify.run(); } } run method end }; copy(threaded, renamer); } catch (IOException ioe) { try { if (in != null) in.close(); if things go well, copy() closes the streams! } catch (IOException ioe2) {} throw ioe; } }"/>
			<comm cntt="public static void downloadFile(URL source, String outPath, boolean threaded) throws IOException { downloadFile(source, outPath, threaded, null); }"/>
			<comm cntt="public static void copy(final InputStream in, final OutputStream out, boolean threaded) throws IOException { copy(in, out, threaded, null); }"/>
			<const name="OPEN" access="pub" jdoc="This constant defines an open dialog box."/>
			<const name="SAVE" access="pub" jdoc="This constant defines a save dialog box."/>
			<const name="SCRIPT" access="pub" jdoc="This constant defines an open dialog box."/>
			<const name="JDK_VERSION" access="pub" jdoc="JDK release version."/>
			<mth name="/lib/:org.jext.Utilities.showMessage(String)" access="pub" jdoc="Display a sample message in a dialog box. @param message The message to display">
				<param name="message"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.showError(String)" access="pub" jdoc="Display an error message in a dialog box. @param message The message to display">
				<param name="message"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.showMessage(String, String)" access="pub" jdoc="Display a sample message in a dialog box. @param message The message to display">
				<param name="title"/>
				<param name="message"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getScreenDimension()" access="pub" jdoc="This methods is used to determine screen&amp;apos;s dimensions. @return A &amp;lt;code&amp;gt;Dimension&amp;lt; code&amp;gt; object containing screen&amp;apos;s resolution">
			</mth>
			<mth name="/lib/:org.jext.Utilities.centerComponent(Component)" access="pub" jdoc="A very nice trick is to center windows on screen, this method helps you to to that. @param compo The &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; to center">
				<param name="compo"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.centerComponentChild(Component, Component)" access="pub" jdoc="A very nice trick is to center dialog with their parent. @param parent The parent &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; @param child The &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; to center">
				<param name="parent"/>
				<param name="child"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.classToFile(String)" access="pub" jdoc="Converts a clas name to a file name. All periods are replaced with slashes and the &amp;apos;.class&amp;apos; extension is added. @param name The class name">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.fileToClass(String)" access="pub" jdoc="Converts a file name to a class name. All slash characters are replaced with periods and the trailing &amp;apos;.class&amp;apos; is removed. @param name The file name">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.beep()" access="pub" jdoc="Used to &amp;apos;beep&amp;apos; the user.">
			</mth>
			<mth name="/lib/:org.jext.Utilities.setCursorOnWait(Component, boolean)" access="pub" jdoc="Long operations need to display an hourglass. @param comp The &amp;lt;code&amp;gt;JComponent&amp;lt; code&amp;gt; on which to apply the hour glass cursor @param on If true, we set the cursor on the hourglass">
				<param name="comp"/>
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getIcon(String, Class)" access="pub" jdoc="We may need to load and display images. @param picture The path to the image @param source The class &amp;apos;root&amp;apos; @return An &amp;lt;code&amp;gt;ImageIcon&amp;lt; code&amp;gt;">
				<param name="picture"/>
				<param name="source"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getImage(String, Class)" access="pub" jdoc="We may need to load and display images. @param picture The path to the image @param source The class &amp;apos;root&amp;apos; @return An &amp;lt;code&amp;gt;Image&amp;lt; code&amp;gt;">
				<param name="picture"/>
				<param name="source"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.chooseFiles(Component, int)" access="pub" jdoc="Display a file chooser dialog box and returns selected files. @param owner &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; which &amp;apos;owns&amp;apos; the dialog @param mode Can be either &amp;lt;code&amp;gt;OPEN&amp;lt; code&amp;gt;, &amp;lt;code&amp;gt;SCRIPT&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;SAVE&amp;lt; code&amp;gt; @return The path to selected file, null otherwise">
				<param name="owner"/>
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.chooseFile(Component, int)" access="pub" jdoc="Display a file chooser dialog box. @param owner &amp;lt;code&amp;gt;Component&amp;lt; code&amp;gt; which &amp;apos;owns&amp;apos; the dialog @param mode Can be either &amp;lt;code&amp;gt;OPEN&amp;lt; code&amp;gt;, &amp;lt;code&amp;gt;SCRIPT&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;SAVE&amp;lt; code&amp;gt; @return The path to selected file, null otherwise">
				<param name="owner"/>
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getFileChooser(Component, int)" access="priv" jdoc="">
				<param name="owner"/>
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.createWhiteSpace(int)" access="pub" jdoc="Create a blank String made of spaces. @param len Amount of spaces contained in the String @return A blank &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt;">
				<param name="len"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.createWhiteSpace(int, int)" access="pub" jdoc="Create a blank String made of tabs. @param len Amount of spaces contained in the String @param tabSize Tabulation size @return A blank &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt;">
				<param name="len"/>
				<param name="tabSize"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getLeadingWhiteSpace(String)" access="pub" jdoc="Returns the number of leading white space characters in the specified string. @param str The string">
				<param name="str"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getLeadingWhiteSpaceWidth(String, int)" access="pub" jdoc="Returns the width of the leading white space in the specified string. @param str The string @param tabSize The tab size">
				<param name="str"/>
				<param name="tabSize"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getRealLength(String, int)" access="pub" jdoc="">
				<param name="str"/>
				<param name="tabSize"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getShortStringOf(String, int)" access="pub" jdoc="Some String can be too long to be correctly displayed on the screen. Mainly when it is a path to a file. This method truncate a String. @param longString The &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to be truncated @param maxLength The maximum length of the &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; @return The truncated string">
				<comm cntt="return longString.substring(0, maxLength 2) + &amp;quot;...&amp;quot; +"/>
				<comm cntt="longString.substring(len - (maxLength 2));"/>
				<param name="longString"/>
				<param name="maxLength"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.constructPath(String)" access="pub" jdoc="Constructs a new path from current user path. This is an easy way to get a path if the user specified, for example, &amp;quot;..\Java&amp;quot; as new path. This method will return the argument if this one is a path to a root (i.e, if &amp;lt;code&amp;gt;change&amp;lt; code&amp;gt; is equal to C:\Jdk, constructPath will return C:\Jdk). @param change The modification to apply to the path">
				<param name="change"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.beginsWithRoot(String)" access="pub" jdoc="It can be necessary to check if a path specified by the user is an absolute path (i.e C:\Gfx\3d\Utils is absolute whereas ..\Jext is relative). @param path The path to check @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if &amp;lt;code&amp;gt;path&amp;lt; code&amp;gt; begins with a root name">
				<param name="path"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getUserDirectory()" access="pub" jdoc="Returns user directory.">
			</mth>
			<mth name="/lib/:org.jext.Utilities.getHomeDirectory()" access="pub" jdoc="Returns user&amp;apos;s home directory.">
			</mth>
			<mth name="/lib/:org.jext.Utilities.getRoot(String)" access="pub" jdoc="It can be necessary to determine which is the root of a path. For example, the root of D:\Projects\Java is D:\. @param path The path used to get a root @return The root which contais the specified path">
				<param name="path"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getWildCardMatches(String, boolean)" access="pub" jdoc="When the user has to specify file names, he can use wildcards ( , ?). This methods handles the usage of these wildcards. @param s Wilcards @param sort Set to true will sort file names @return An array of String which contains all files matching &amp;lt;code&amp;gt;s&amp;lt; code&amp;gt; in current directory.">
				<param name="s"/>
				<param name="sort"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.getWildCardMatches(String, String, boolean)" access="pub" jdoc="When the user has to specify file names, he can use wildcards ( , ?). This methods handles the usage of these wildcards. @param path The path were to search @param s Wilcards @param sort Set to true will sort file names @return An array of String which contains all file names matching &amp;lt;code&amp;gt;s&amp;lt; code&amp;gt; in &amp;lt;code&amp;gt;path&amp;lt; code&amp;gt; directory.">
				<comm cntt="File temp = new File(getUserDirectory(), files[i]);"/>
				<param name="path"/>
				<param name="s"/>
				<param name="sort"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.match(String, String)" access="pub" jdoc="This method can determine if a String matches a pattern of wildcards @param pattern The pattern used for comparison @param string The String to be checked @return true if &amp;lt;code&amp;gt;string&amp;lt; code&amp;gt; matches &amp;lt;code&amp;gt;pattern&amp;lt; code&amp;gt;">
				<param name="pattern"/>
				<param name="string"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.sortStrings(String[])" access="pub" jdoc="Quick sort an array of Strings. @param string Strings to be sorted @deprecated Use the standard Java java.util.Array.sort instead.">
				<param name="strings"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.listFiles(String[], boolean)" access="pub" jdoc="Lists content of a directory. @param names Names of the files @param construct Set it to true if names does not contain full paths @return An array of Files">
				<param name="names"/>
				<param name="construct"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.listFiles(String[], String, boolean)" access="pub" jdoc="Lists content of a directory. @param names Names of the files @param path Base path for files @param construct Set it to true if names do not contain full paths @return An array of Files">
				<param name="names"/>
				<param name="path"/>
				<param name="construct"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.globToRE(String)" access="pub" jdoc="Turns a Un x glob filter to regexp one @param glob Globbed filter">
				<param name="glob"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.downloadFile(URL, String, boolean, HandlingRunnable)" access="pub" jdoc="Downloads the file specified in the URL to the File with the &amp;lt;code&amp;gt;outPath&amp;lt; code&amp;gt; path using copy() (so see copy() for infos about notify and threaded). @since Jext 3.2pre4">
				<comm cntt="throws IOException"/>
				<comm cntt="try { if (threaded) downloader.start(); else downloader.run(); } catch (Throwable t) { throw (IOException) t; }"/>
				<param name="source"/>
				<param name="outPath"/>
				<param name="threaded"/>
				<param name="notify"/>
			</mth>
			<mth name="/lib/:org.jext.Utilities.copy(InputStream, OutputStream, boolean, HandlingRunnable)" access="pub" jdoc="This method copy the content of the InputStream in to the OutputStream out, in the calling thread or in a new one. If threaded is true, a new thread is created, and notify will be called at the end, and will have passed the exception eventually thrown while doing the copy. Otherwise, the copy is done synchronously; if an exception is thrown during the copy it is dispatched to the calling method, otherwise the notify is called. @since Jext 3.2pre4">
				<comm cntt="try { if (threaded) copier.start(); else copier.run(); } catch (Throwable t) { throw (IOException) t; }"/>
				<param name="in"/>
				<param name="out"/>
				<param name="threaded"/>
				<param name="notify"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.MenuAction" intfc="n" abs="y" inn="n" sloc="68" jdoc="This class implements an &amp;lt;code&amp;gt;ActionListener&amp;lt; code&amp;gt; and handles action events fired by &amp;lt;codeJMenuItem&amp;lt; code&amp;gt;. This class also provides two new methods which can be used to get the window which has fired the event and the associated text area.">
			<field name="name" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.MenuAction.MenuAction(String)" access="pub" jdoc="Creates a new menu action designed by its name. This name is internally used by Jext to handles scripts, correctly build menu bar and tool bar. @param name Internal action name">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.MenuAction.getName()" access="pub" jdoc="Returns the associated action name.">
			</mth>
			<mth name="/lib/:org.jext.MenuAction.getTextArea(EventObject)" access="pub" jdoc="This methods returns the selected text area in the window which fired the event. @param evt The source event">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.MenuAction.getNSTextArea(EventObject)" access="pub" jdoc="This methods returns the selected text area in the window which fired the event, excluding the splitted one. @param evt The source event">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.MenuAction.getJextParent(EventObject)" access="pub" jdoc="Returns the window which fired the event. @param evt The source event">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.MenuAction.getTextArea(Component)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.MenuAction.getNSTextArea(Component)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.MenuAction.getJextParent(Component)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JextTextArea" intfc="n" abs="n" inn="n" sloc="985" jdoc="Extending JEditTextArea allow us to support syntax colorization. We also implement some listeners: for the caret, for the undos and redos, for the keys (indent) and for the modifications which can occures in the text. This component provides its own methods to read and save files (even to zip them). @author Romain Guy @see Jext">
			<comm cntt="static fields"/>
			<comm cntt="private fields"/>
			<comm cntt="misc properties"/>
			<comm cntt="friendly"/>
			<comm cntt="undo"/>
			<comm cntt="newf says whether this is a new file or not"/>
			<comm cntt="highlighters"/>
			<comm cntt="let&amp;apos;s remember the line end of the original file(as of Jext3.2pre3)"/>
			<comm cntt="this will be checked probably by internal JextTextArea methods; I think that JextTextArea will call"/>
			<comm cntt="something as parent.setChanged, only a bit different."/>
			<comm cntt="friendly"/>
			<comm cntt="friendly"/>
			<comm cntt="friendly"/>
			<comm cntt="get the name of a file from its absolute path name"/>
			<comm cntt=""/>
			<comm cntt="INTERNAL CLASSES"/>
			<comm cntt=""/>
			<field name="popupMenu" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="mode" access="priv" jdoc=""/>
			<field name="modTime" access="priv" jdoc=""/>
			<field name="anchor" access="priv" jdoc=""/>
			<field name="fontSize" access="priv" jdoc=""/>
			<field name="fontStyle" access="priv" jdoc=""/>
			<field name="fontName" access="priv" jdoc=""/>
			<field name="currentFile" access="priv" jdoc=""/>
			<field name="lineTermSelector" access="pub" jdoc=""/>
			<field name="undoing" access="priv" jdoc=""/>
			<field name="undo" access="priv" jdoc=""/>
			<field name="compoundEdit" access="priv" jdoc=""/>
			<field name="currentEdit" access="priv" jdoc=""/>
			<field name="dirty" access="priv" jdoc=""/>
			<field name="newf" access="priv" jdoc=""/>
			<field name="operation" access="priv" jdoc=""/>
			<field name="protectedCompoundEdit" access="priv" jdoc=""/>
			<field name="searchHighlight" access="priv" jdoc=""/>
			<const name="BUFFER_SIZE" access="pub" jdoc="This constant defines the size of the buffer used to read files"/>
			<const name="DOS_LINE_END" access="pub" jdoc=""/>
			<const name="MACOS_LINE_END" access="pub" jdoc=""/>
			<const name="UNIX_LINE_END" access="pub" jdoc=""/>
			<field name="myLineTerm" access="priv" jdoc=""/>
			<field name="origLineTerm" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.JextTextArea.JextTextArea(JextFrame)" access="pub" jdoc="The constructor add the necessary listeners, set some stuffs (caret color, borers, fonts...). @param parent &amp;lt;code&amp;gt;JextTextArea&amp;lt; code&amp;gt; needs a &amp;lt;code&amp;gt;Jext&amp;lt; code&amp;gt; parent because it provides a lot of &amp;apos;vital&amp;apos; methods">
				<comm cntt="this updates the other TextArea if"/>
				<comm cntt="the JextFrame is splitted"/>
				<comm cntt="Jext.getProperty(&amp;quot;editor.colorize.mode&amp;quot;);"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setLineTerm(String)" access="priv" jdoc="">
				<comm cntt="for now it&amp;apos;s private so nothing changes."/>
				<param name="newLineTerm"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getLineTerm()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.resetLineTerm()" access="priv" jdoc="">
				<comm cntt="happens on first run."/>
				<comm cntt="And made 3.2pre3 crash the day before official release, while trying built version."/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.storeOrigLineTerm()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.isLineTermChanged()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setLineTerm(int)" access="pub" jdoc="">
				<param name="lineTermConst"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getLineTermName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.rotateLineTerm()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setMouseWheel()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.initSearchHighlight()" access="pub" jdoc="Adds a search highlighter if none exists.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getSearchHighlight()" access="pub" jdoc="Returns the associated search highlighter.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getPopupMenu()" access="pub" jdoc="Returns text area popup menu.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getProperty(String)" access="pub" jdoc="Get property inherent to current syntax colorizing mode.">
				<param name="key"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setDocument(org.gjt.sp.jedit.syntax.SyntaxDocument)" access="pub" jdoc="Set a new document">
				<param name="document"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getFontName()" access="pub" jdoc="Return current font&amp;apos;s name">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getFontSize()" access="pub" jdoc="Return current font&amp;apos;s size">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getFontStyle()" access="pub" jdoc="Return current font&amp;apos;s style (bold, italic...)">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setFontName(String)" access="pub" jdoc="Set the font which has to be used. @param name The name of the font">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setFontSize(int)" access="pub" jdoc="Set the size of the font. @param size The new font&amp;apos;s size">
				<param name="size"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setFontStyle(int)" access="pub" jdoc="Set the style of the font. @param style The new style to apply">
				<param name="style"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.changeFont()" access="priv" jdoc="Set the new font.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.waitingCursor(boolean)" access="pub" jdoc="Show hide waiting cursor">
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getTabIndent()" access="pub" jdoc="This is necessary to determine if we have to indent on tab key press or not.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getEnterIndent()" access="pub" jdoc="This is necessary to determine if we have to indent on enter key press or not.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getSoftTab()" access="pub" jdoc="Return the state of the softtab check menu item. This is necessary to know if tabs have to be replaced by whitespaces.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.beginOperation()" access="pub" jdoc="When an operation has began, setChanged() cannot be called. This is very important when we need to insert or remove some parts of the text without turning on the &amp;apos;to_be_saved&amp;apos; flag.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.endOperation()" access="pub" jdoc="Calling this will allow the DocumentListener to use setChanged().">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getJextParent()" access="pub" jdoc="Return the parent of this component. Note that a LOT of external functions need to call methods contained in the parent.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getOperation()" access="pub" jdoc="Return true if we can use the setChanged() method, false otherwise.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getFile()" access="pub" jdoc="Return current opened file as a &amp;lt;code&amp;gt;File&amp;lt; code&amp;gt; object.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getCurrentFile()" access="pub" jdoc="Return the full path of the opened file.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setCurrentFile(String)" access="pub" jdoc="Set path of current opened file.">
				<param name="path"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.filteredPaste()" access="pub" jdoc="Performs a &amp;apos;filtered&amp;apos; paste. A filtered paste is a paste action performed after having made some search and replace operations over the clipboard text.">
				<comm cntt="The MacOS MRJ doesn&amp;apos;t convert \r to \n,"/>
				<comm cntt="so do it here"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.newFile()" access="pub" jdoc="Set a new file. We first ask the user if he&amp;apos;d like to save its changes (if some have been made).">
				<comm cntt="we don&amp;apos;t want to see a &amp;apos;modified&amp;apos; message"/>
				<comm cntt="we have to create a new document, so we remove"/>
				<comm cntt="old listeners and create new ones below"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.autoSave()" access="pub" jdoc="This is called by the AutoSave thread.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.insert(String, int)" access="pub" jdoc="This overrides standard insert method. Indeed, we need to update the label containing caret&amp;apos;s position. @param insert The string to insert @param pos The offset of the text where to insert the string">
				<param name="insert"/>
				<param name="pos"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.userInput(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getTabSize()" access="pub" jdoc="Because JEditorPane doesn&amp;apos;t have any getTabSize() method, we implement our own one. @return Current tab size (in amount of spaces)">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setTabSize(int)" access="pub" jdoc="See getTabSize(). @param size The new tab size (in amount of spaces)">
				<comm cntt="Jext.setProperty(&amp;quot;editor.tabSize&amp;quot;, String.valueOf(size));"/>
				<param name="size"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setParentTitle()" access="pub" jdoc="Set parent title according to the fullfilename flag in the user properties.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getFileName(String)" access="priv" jdoc="">
				<param name="file"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getName()" access="pub" jdoc="Get name of this text area. This name is made of the current opened file name.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setColorizing(String)" access="pub" jdoc="Turn syntax colorization on or off. @param mode Colorization mode">
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setColorizing(Mode)" access="pub" jdoc="">
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.enableColorizing(String, TokenMarker)" access="priv" jdoc="">
				<param name="mode"/>
				<param name="token"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setColorizingMode(String)" access="pub" jdoc="Sets current colorizing mode. @param mode The colorizing mode name">
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getColorizingMode()" access="pub" jdoc="Returns current syntax colorizing mode.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.checkLastModificationTime()" access="pub" jdoc="Checks if holded file has been changed by an external program.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.zipContent()" access="pub" jdoc="Called to save current content in specified zip file. Call zip(String file) but asks user for overwriting if file already exists.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.zip(String)" access="pub" jdoc="Zip text area content into specified file. @param zipFile The file name where to zip the text">
				<comm cntt="we ensured we use system&amp;apos;s carriage return char, as in save():"/>
				<comm cntt="String newline = Jext.getProperty(&amp;quot;editor.newLine&amp;quot;); System.getProperty(&amp;quot;line.separator&amp;quot;);"/>
				<comm cntt="but now, as in save(), we use document&amp;apos;s one."/>
				<comm cntt="we zip the text line by line"/>
				<param name="zipFile"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.saveContent()" access="pub" jdoc="Called to save this component&amp;apos;s content. Call save(String file) but let the user choosing a file name if the isNew() flag is true (int the case the user choosed an existing file, we ask him if he really wants to overwrite it).">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.save(String)" access="pub" jdoc="Store the text in a specified file. @param file The file in which we&amp;apos;ll write the text">
				<comm cntt="String newline = Jext.getProperty(&amp;quot;editor.newLine&amp;quot;);"/>
				<comm cntt="we save the text line by line"/>
				<comm cntt="avoids extra line feed at the end of the file"/>
				<comm cntt="so we can see if it has been changed."/>
				<comm cntt="reset the dirty flag"/>
				<param name="file"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.open(String)" access="pub" jdoc="Called to load a new file in the text area. Determines which line separator (\n, \r\n...) are used in the file to open. Convert&amp;apos;em into Swing line separator (\n). @param path The path of the file to be loaded">
				<param name="path"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.open(String, boolean)" access="pub" jdoc="Called to load a new file in the text area. Determines which line separator (\n, \r\n...) are used in the file to open. Convert&amp;apos;em into Swing line separator (\n). @param path The path of the file to be loaded @param addToRecentList If false, the file name is not added to recent list">
				<param name="path"/>
				<param name="addToRecentList"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.open(String, InputStreamReader, int)" access="pub" jdoc="Called to load a new file in the text area. Determines which line separator (\n, \r\n...) are used in the file to open. Convert&amp;apos;em into Swing line separator (\n). @param path The path of the file to be loaded @param _in You can specify an InputStreamReader (see ZipExplorer) @param bufferSize Size of the StringBuffer, useful if _in != null">
				<param name="path"/>
				<param name="_in"/>
				<param name="bufferSize"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.open(String, InputStreamReader, int, boolean, boolean)" access="pub" jdoc="Called to load a new file in the text area. Determines which line separator (\n, \r\n...) are used in the file to open. Convert&amp;apos;em into Swing line separator (\n). @param path The path of the file to be loaded @param _in You can specify an InputStreamReader (see ZipExplorer); if you do this the TextArea is marked as &amp;apos;dirty&amp;apos; @param bufferSize Size of the StringBuffer, useful if _in != null @param web True if open an url @param addToRecentList If false, the file name is not added to recent list">
				<comm cntt="we do the same thing as in newFile() for the listeners"/>
				<comm cntt="we check if the file is read only or not"/>
				<comm cntt="we read the file till its end (amazing, hu ?)"/>
				<comm cntt="and we convert system&amp;apos;s carriage return char into \n"/>
				<comm cntt="handle line end choice"/>
				<comm cntt="then CRLF is true"/>
				<comm cntt="so we can see if it has been changed."/>
				<comm cntt="this updates the other TextArea if"/>
				<comm cntt="the JextFrame is splitted"/>
				<comm cntt="we clear the area"/>
				<comm cntt="we put the text in it"/>
				<comm cntt="we add the file into the recent menu"/>
				<comm cntt="and we choose the most appropriate syntax colorization mode"/>
				<param name="path"/>
				<param name="_in"/>
				<param name="bufferSize"/>
				<param name="web"/>
				<param name="addToRecentList"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setNewFlag(boolean)" access="pub" jdoc="Set the new flag and resets the default line end separator.">
				<comm cntt="TODO: check if this is good."/>
				<param name="newFlag"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.isNew()" access="pub" jdoc="Return true if current text is new, false otherwise.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.isEmpty()" access="pub" jdoc="Return true if area is empty, false otherwise.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.isDirty()" access="pub" jdoc="Return true if area content has changed, false otherwise.">
				<comm cntt="this is to mark changed a file when"/>
				<comm cntt="its line end has been changed. But it&amp;apos;s probably a bug - if you clean() a TextArea"/>
				<comm cntt="it can be still dirty."/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setDirty()" access="priv" jdoc="Called when the content of the area has changed.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.clean()" access="pub" jdoc="Called after having saved or created a new document to ensure the content isn&amp;apos;t &amp;apos;dirty&amp;apos;.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.discard()" access="pub" jdoc="Discard all edits contained in the UndoManager. Update the corresponding menu items.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setAnchor()" access="pub" jdoc="Set the anchor postion.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.gotoAnchor()" access="pub" jdoc="Go to anchor position">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getAnchorOffset()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getUndo()" access="pub" jdoc="Used by Jext to update its menu items.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.beginCompoundEdit()" access="pub" jdoc="Used for ReplaceAll. This merges all text changes made between the beginCompoundEdit() and the endCompoundEdit() calls into only one undo event.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.beginCompoundEdit(boolean)" access="pub" jdoc="">
				<param name="cursorHandle"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.beginProtectedCompoundEdit()" access="pub" jdoc="A protected compound edit is a compound edit which cannot be ended by a normal call to endCompoundEdit().">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.endCompoundEdit()" access="pub" jdoc="See beginCompoundEdit().">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.endCompoundEdit(boolean)" access="pub" jdoc="">
				<param name="cursorHandle"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.endProtectedCompoundEdit()" access="pub" jdoc="This terminates a protected compound edit.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.getLength()" access="pub" jdoc="Return the lentgh of the text in the area.">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.undoableEditHappened(UndoableEditEvent)" access="pub" jdoc="When an undoable event is fired, we add it to the undo redo list.">
				<comm cntt="undo.addEdit(e.getEdit());"/>
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.endCurrentEdit()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.setUndoing(boolean)" access="pub" jdoc="">
				<param name="action"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.changedUpdate(DocumentEvent)" access="pub" jdoc="When a modification is made in the text, we turn the &amp;apos;to_be_saved&amp;apos; flag to true.">
				<comm cntt="it needs that the area is &amp;quot;dirty&amp;quot;, so we have to call setDirty() before"/>
				<comm cntt="isDirty can be true if the line end is changed or if dirty is true;"/>
				<comm cntt="setCaretPosition(e.getOffset() + e.getLength());"/>
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.insertUpdate(DocumentEvent)" access="pub" jdoc="When a modification is made in the text, we turn the &amp;apos;to_be_saved&amp;apos; flag to true.">
				<comm cntt="it needs that the area is &amp;quot;dirty&amp;quot;, so we have to call setDirty() before"/>
				<comm cntt="isDirty can be true if the line end is changed or if dirty is true;"/>
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.removeUpdate(DocumentEvent)" access="pub" jdoc="When a modification is made in the text, we turn the &amp;apos;to_be_saved&amp;apos; flag to true.">
				<comm cntt="it needs that the area is &amp;quot;dirty&amp;quot;, so we have to call setDirty() before"/>
				<comm cntt="isDirty can be true if the line end is changed or if dirty is true;"/>
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea.toString()" access="pub" jdoc="Return a String representation of this object.">
			</mth>
		<class name="/lib/:org.jext.JextTextArea$FocusHandler" intfc="n" abs="n" inn="y" sloc="16" jdoc="">
			<mth name="/lib/:org.jext.JextTextArea$FocusHandler.focusGained(FocusEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JextTextArea$CaretHandler" intfc="n" abs="n" inn="y" sloc="7" jdoc="">
			<mth name="/lib/:org.jext.JextTextArea$CaretHandler.caretUpdate(CaretEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JextTextArea$JextTextAreaPopupMenu" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<field name="area" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.JextTextArea$JextTextAreaPopupMenu.JextTextAreaPopupMenu(JextTextArea)" access="pub" jdoc="">
				<param name="area"/>
			</mth>
			<mth name="/lib/:org.jext.JextTextArea$JextTextAreaPopupMenu.run()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.PythonEditAction" intfc="n" abs="n" inn="n" sloc="7" jdoc="This class implements an &amp;lt;code&amp;gt;ActionListener&amp;lt; code&amp;gt; and handles action events fired by &amp;lt;codeJMenuItem&amp;lt; code&amp;gt;. The action is performed by executing a Python script.">
			<mth name="/lib/:org.jext.PythonEditAction.PythonEditAction(String, String)" access="pub" jdoc="Creates a new menu action designed by its name and the pyhon execution script. @param name Internal action name @param script Python script">
				<param name="name"/>
				<param name="script"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JavaSupport" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<mth name="/lib/:org.jext.JavaSupport.initJavaSupport()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JavaSupport.setMouseWheel(JextTextArea)" access="pub" jdoc="">
				<param name="area"/>
			</mth>
		<class name="/lib/:org.jext.JavaSupport$JextKeyboardFocusManager" intfc="n" abs="n" inn="y" sloc="28" jdoc="">
			<mth name="/lib/:org.jext.JavaSupport$JextKeyboardFocusManager.JextKeyboardFocusManager()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JavaSupport$JextKeyboardFocusManager.postProcessKeyEvent(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.JARClassLoader" intfc="n" abs="n" inn="n" sloc="350" jdoc="A class loader implementation that loads classes from JAR files. @author Slava Pestov">
			<comm cntt="public static ArrayList pluginsRealNames = new ArrayList();"/>
			<comm cntt="This is the prefix for entries inside .jar&amp;apos;s containing only translations. I.e., .xml files for translations must be inside trans &amp;lt;languagecode&amp;gt; folder. Note that any file which name starts with &amp;quot;trans&amp;quot; will be ignored. The prefix here was &amp;quot;trans&amp;quot; + File.separator, but entries were always read with forward slashes(I don&amp;apos;t know why, it&amp;apos;s a characteristic of ZIP file, it seems)"/>
			<comm cntt="Now I&amp;apos;ve added the parameter isPlugin(which defaults to true) to use the code"/>
			<comm cntt="for the plugin downloader, which hot-loads a JAR."/>
			<comm cntt="private final static String DISABLED_LIST_PATH = Jext.SETTINGS_DIRECTORY + &amp;quot;.disabledPlugins&amp;quot;; static { try { File f = new File(DISABLED_LIST_PATH); if (f.exists()) { BufferedReader in = new BufferedReader(new FileReader(f)); String line; while ( (line = in.readLine()) != null) disabledPlugins.add(line); in.close(); } } catch (IOException ioe) {ioe.printStackTrace();} } static void saveDisabledList() { try { PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(DISABLED_LIST_PATH))); for (Iterator i = disabledPlugins.iterator(); i.hasNext(); ) { out.println((String) i.next()); } out.close(); } catch (IOException ioe) {} }"/>
			<comm cntt="private members"/>
			<comm cntt="Loading of plugin classes is deferred until all JARs are loaded - this is necessary because a plugin might depend on classes stored in other JARs."/>
			<comm cntt="replaced fileName attribute with URL as fileName was not used, and URL is now used for package sealing."/>
			<field name="pluginsNames" access="pub" jdoc=""/>
			<const name="langsPrefix" access="priv" jdoc=""/>
			<field name="disabledPlugins" access="priv" jdoc=""/>
			<field name="classLoaders" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="pluginClasses" access="priv" jdoc=""/>
			<field name="url" access="priv" jdoc=""/>
			<field name="zipFile" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.JARClassLoader.JARClassLoader(String)" access="pub" jdoc="">
				<param name="path"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.JARClassLoader(String, boolean, ClassLoader)" access="pub" jdoc="">
				<comm cntt="the files in trans dirs must be loaded only as translations;"/>
				<comm cntt="this loop over entries elements must not iterate over them."/>
				<comm cntt="This could be removed(no plugin using it)."/>
				<comm cntt="We load first the untranslated one, then the translated which contains"/>
				<comm cntt="only some properties!"/>
				<comm cntt="not to translate."/>
				<comm cntt="First search translation inside the plugin&amp;apos;s jar"/>
				<comm cntt="fall back to old search method."/>
				<comm cntt="already translated."/>
				<comm cntt="pluginsRealNames.add(baseName);"/>
				<comm cntt="If this is done before the above while() statement"/>
				<comm cntt="and an exception is thrown while the ZIP file is"/>
				<comm cntt="being loaded, weird things happen..."/>
				<param name="path"/>
				<param name="isPlugin"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.setEnabled(String, boolean)" access="pub" jdoc="">
				<comm cntt="int i = disabledPlugins.indexOf(name); if (toEnable) { if (i != -1) disabledPlugins.remove(i); } else { if (i == -1) disabledPlugins.add(name); }"/>
				<param name="name"/>
				<param name="toEnable"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.isEnabled(String)" access="pub" jdoc="">
				<comm cntt="return disabledPlugins.indexOf(name) == -1;"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.loadClass(String, boolean)" access="pub" jdoc="@exception ClassNotFoundException if the class could not be found">
				<param name="clazz"/>
				<param name="resolveIt"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.getResourceAsStream(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.getResource(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.getResourceAsPath(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.getPath()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.initPlugins()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.getClassLoader(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.getClassLoaderCount()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.reloadPluginsProperties()" access="pub" jdoc="">
				<comm cntt="the files in trans dirs must be loaded only as translations;"/>
				<comm cntt="this loop over entries elements must not iterate over them."/>
				<comm cntt="We load first the untranslated one, then the translated which contains"/>
				<comm cntt="only some properties!"/>
				<comm cntt="not to translate."/>
				<comm cntt="First search translation inside the plugin&amp;apos;s jar"/>
				<comm cntt="fall back to old search method."/>
				<comm cntt="already translated."/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.executeScripts(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.getZipFile()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.loadAllPlugins()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.loadPluginClass(String)" access="priv" jdoc="">
				<comm cntt="if (&amp;quot;yes&amp;quot;.equals(Jext.getProperty(&amp;quot;plugin.&amp;quot; + name + &amp;quot;.disabled&amp;quot;)))"/>
				<comm cntt="Check dependencies"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.checkDependencies(String)" access="priv" jdoc="">
				<comm cntt="Utilities.buildToVersion(arg);"/>
				<comm cntt="Jext.setProperty(&amp;quot;plugin.&amp;quot; + name + &amp;quot;.disabled&amp;quot;, response == 0 ? &amp;quot;yes&amp;quot; : &amp;quot;no&amp;quot;);"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.findOtherClass(String, boolean)" access="priv" jdoc="">
				<comm cntt="Defer to whoever loaded us (such as JShell, Echidna, etc)"/>
				<comm cntt="Doesn&amp;apos;t exist in any other plugin, look in system classes"/>
				<param name="clazz"/>
				<param name="resolveIt"/>
			</mth>
			<mth name="/lib/:org.jext.JARClassLoader.loadClassFromZip(String, boolean, boolean)" access="priv" jdoc="">
				<comm cntt="end if there is a Package but it has not yet been defined"/>
				<param name="clazz"/>
				<param name="resolveIt"/>
				<param name="doDepencies"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JextTabbedPane" intfc="n" abs="n" inn="n" sloc="141" jdoc="A tabbed pane which can display indexed titles. As a matter of fact, if a tab is added with a name which already exists, &amp;lt;code&amp;gt;JextTabbedPane&amp;lt; code&amp;gt; will add an index under the form &amp;apos;(x)&amp;apos; at the end of the name. When all tabs of the same name are closed, indexes are counted over from 0. @author Romain Guy">
			<comm cntt="static fields"/>
			<comm cntt="private"/>
			<comm cntt="hold indexes"/>
			<comm cntt="mouse listener"/>
			<comm cntt="icon of a &amp;apos;clean&amp;apos; text area"/>
			<comm cntt="icon of a &amp;apos;dirty&amp;apos; text area"/>
			<comm cntt="handles mouse right clicks to display a popup"/>
			<comm cntt="if specified title is title of another tab, we keep it in the list,"/>
			<comm cntt="otherwise, it is removed"/>
			<comm cntt="register a title in the list. If it hasn&amp;apos;t been registered"/>
			<comm cntt="yet, it is added to list, otherwise, the corresponding index"/>
			<comm cntt="is increased by one."/>
			<comm cntt="get a title from the indexed titles list. If the title is found in"/>
			<comm cntt="the list, and if the index is != 0, we add &amp;quot;(index)&amp;quot; at the end of"/>
			<comm cntt="the title."/>
			<field name="popupMenu" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="fileNames" access="priv" jdoc=""/>
			<field name="_mouseListener" access="priv" jdoc=""/>
			<const name="CLEAN_ICON" access="priv" jdoc=""/>
			<const name="DIRTY_ICON" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.JextTabbedPane.JextTabbedPane(JextFrame)" access="pub" jdoc="Creates a new tabbed pane and register a change listener which will be used to update Jext infos concerning text areas. @param parent The parent window">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.getPopupMenu()" access="pub" jdoc="Returns JextTabbedPane popup menu. This is needed to update look and feel when user changed it.">
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.setCleanIcon(JextTextArea)" access="pub" jdoc="When a text area is saved (or simply cleaned in case of open or new), this method is used to display the &amp;apos;clean&amp;apos; icon in the tab which holds the text area. @param textArea The text area which was cleaned">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.setDirtyIcon(JextTextArea)" access="pub" jdoc="When a text area is modified this method is used to display the &amp;apos;dirty&amp;apos; icon in the tab which holds the text area. @param textArea The text area which was modified">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.addTab(String, Component)" access="pub" jdoc="Overrides default &amp;lt;code&amp;gt;addTab(String, Component)&amp;lt; code&amp;gt; method. This method register the &amp;lt;code&amp;gt;title&amp;lt; code&amp;gt; if it hasn&amp;apos;t been displayed yet to be able to index next titles of same name. Then, &amp;lt;code&amp;gt;super.addTab(String, Component)&amp;lt; code&amp;gt; is called. @param title Title of the new tab @param component Content of the new tab">
				<param name="title"/>
				<param name="component"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.removeTabAt(int)" access="pub" jdoc="Overrides default &amp;lt;code&amp;gt;removeTabAt(int)&amp;lt; code&amp;gt; method. This method checks if no other tab among the remaining ones has got the same name. In this case, the title is unregistered from the indexed titles list. @param index Removes the tab at &amp;lt;code&amp;gt;index&amp;lt; code&amp;gt;">
				<comm cntt="if (index == 0)"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.setTitleAt(int, String)" access="pub" jdoc="Overrides default &amp;lt;code&amp;gt;setTitleAt(int, String)&amp;lt; code&amp;gt; method. Before setting the new title, the new title is registered in the indexed titles list. Then, we call &amp;lt;code&amp;gt;super.setTitleAt(int, String)&amp;lt; code&amp;gt; method but specifying an indexed title. @param index The index of tab to be re-titled @param title The new title">
				<param name="index"/>
				<param name="title"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.removeTitle(int, String)" access="priv" jdoc="">
				<param name="index"/>
				<param name="title"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.setIndexedTitle(String)" access="priv" jdoc="">
				<param name="title"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.getIndexedTitle(String)" access="priv" jdoc="">
				<param name="title"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.nextTab()" access="pub" jdoc="Selects the next tab in the list. If current selected tab is the last one, then the first one is selected.">
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.previousTab()" access="pub" jdoc="Selects the previous tab in the list. If current selected tab is the first one, then the last one is selected.">
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.removeAll()" access="pub" jdoc="Removes any installed component from this tabbed pane. Also resets the titles list.">
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane.stateChanged(ChangeEvent)" access="pub" jdoc="When a tab is selected, and if content of the tab is a &amp;lt;code&amp;gt;JextTextArea&amp;lt; code&amp;gt;, we update infos displayed by Jext and notify Jext listeners.">
				<param name="evt"/>
			</mth>
		<class name="/lib/:org.jext.JextTabbedPane$PopupMenu" intfc="n" abs="n" inn="y" sloc="44" jdoc="">
			<comm cntt="when we constructs this instance, we also"/>
			<comm cntt="build a new popup menu from an external XML file"/>
			<comm cntt="shows popup on right click"/>
			<mth name="/lib/:org.jext.JextTabbedPane$PopupMenu.PopupMenu()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane$PopupMenu.run()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane$PopupMenu.mouseReleased(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane$PopupMenu.mousePressed(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
			<mth name="/lib/:org.jext.JextTabbedPane$PopupMenu.showPopupIfNeeded(MouseEvent)" access="priv" jdoc="">
				<comm cntt="if ((me.getModifiers() &amp; me.BUTTON3_MASK) != 0 &amp;&amp; popupMenu != null)"/>
				<param name="me"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.RegisterablePlugin" intfc="y" abs="n" inn="n" sloc="4" jdoc="An interface which defines the basical behavior of a Jext plugin.">
			<mth name="/lib/:org.jext.RegisterablePlugin.register(JextFrame)" access="pub" jdoc="Called by parent (instance of Jext) to register a frame.">
				<param name="parent"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.GUIUtilities" intfc="n" abs="n" inn="n" sloc="265" jdoc="Contains a bunch of methods used to build the GUI.">
			<comm cntt="Jext icon"/>
			<const name="ICON_IMAGE" access="priv" jdoc=""/>
			<field name="menuItemsActions" access="pub" jdoc="Contains the action name and label of each menu item"/>
			<mth name="/lib/:org.jext.GUIUtilities.getJextIconImage()" access="pub" jdoc="Returns the Jext environment icon.">
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.setScrollableTabbedPane(JTabbedPane)" access="pub" jdoc="Sets the scrollable behavior of a JTabbedPane.">
				<param name="pane"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.requestFocus(Window, Component)" access="pub" jdoc="Focuses on the specified component as soon as the window becomes active. @param win The window @param comp The component">
				<param name="win"/>
				<param name="comp"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.saveGeometry(Window, String)" access="pub" jdoc="Saves a window geometry @param win The &amp;lt;code&amp;gt;Window&amp;lt; code&amp;gt; @param name Name of the properties containing the geometry">
				<param name="win"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.loadGeometry(Window, String)" access="pub" jdoc="Load a window geometry from a propery file and apply it to the specified window. @param win The &amp;lt;code&amp;gt;Window&amp;lt; code&amp;gt; @param name Name of the properties containing the geometry">
				<param name="win"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.message(Frame, String, Object[])" access="pub" jdoc="Displays a dialog box. The title of the dialog is fetched from the &amp;lt;code&amp;gt;&amp;lt;i&amp;gt;name&amp;lt; i&amp;gt;.title&amp;lt; code&amp;gt; property. The message is fetched from the &amp;lt;code&amp;gt;&amp;lt;i&amp;gt;name&amp;lt; i&amp;gt;.message&amp;lt; code&amp;gt; property. The message is formatted by the property manager with &amp;lt;code&amp;gt;args&amp;lt; code&amp;gt; as positional parameters. @param frame The frame to display the dialog for @param name The name of the dialog @param args Positional parameters to be substituted into the message text">
				<param name="frame"/>
				<param name="name"/>
				<param name="args"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.error(Frame, String, Object[])" access="pub" jdoc="Displays an error dialog box. The title of the dialog is fetched from the &amp;lt;code&amp;gt;&amp;lt;i&amp;gt;name&amp;lt; i&amp;gt;.title&amp;lt; code&amp;gt; property. The message is fetched from the &amp;lt;code&amp;gt;&amp;lt;i&amp;gt;name&amp;lt; i&amp;gt;.message&amp;lt; code&amp;gt; property. The message is formatted by the property manager with &amp;lt;code&amp;gt;args&amp;lt; code&amp;gt; as positional parameters. @param frame The frame to display the dialog for @param name The name of the dialog @param args Positional parameters to be substituted into the message text">
				<param name="frame"/>
				<param name="name"/>
				<param name="args"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.parseColor(String)" access="pub" jdoc="Converts a hex color value prefixed with #, for example #ff0088. @param name The color value">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.getColorHexString(Color)" access="pub" jdoc="Converts a color object to its hex value. The hex value prefixed is with #, for example #ff0088. @param c The color object">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.parseStyle(String)" access="pub" jdoc="Converts a style string to a style object. @param str The style string @exception IllegalArgumentException if the style is invalid">
				<param name="str"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.getStyleString(SyntaxStyle)" access="pub" jdoc="Converts a style into it&amp;apos;s string representation. @param style The style">
				<param name="style"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.loadMenu(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.loadMenu(String, boolean)" access="pub" jdoc="Loads a menu from the properties. The white space separated list of menu items is obtained from the property named &amp;lt;code&amp;gt;name&amp;lt; code&amp;gt;. The menu label is obtained from the &amp;lt;code&amp;gt;name.label&amp;lt; code&amp;gt; property. @param name The menu name @param isLabel True if name is label, too">
				<param name="name"/>
				<param name="isLabel"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.loadMenuItem(String)" access="pub" jdoc="This method creates a new JMenuItem. This special version is targeted to be used with plugins. @param action Plugin action name @return A new &amp;lt;code&amp;gt;JMenuItem&amp;lt; code&amp;gt;">
				<param name="action"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.loadMenuItem(String, String, String, boolean)" access="pub" jdoc="This method creates a new JMenuItem. See menus XMenuHandler.class for more informations about its usage. @param label The menu item label @param action The name of the action, specified in Jext @param keyStroke The keystroke used as accelerator @param picture Relative path to an icon @param enabled Disable the item if false @return A new &amp;lt;code&amp;gt;JMenuItem&amp;lt; code&amp;gt;">
				<param name="label"/>
				<param name="action"/>
				<param name="picture"/>
				<param name="enabled"/>
			</mth>
			<mth name="/lib/:org.jext.GUIUtilities.loadMenuItem(String, String, String, boolean, boolean)" access="pub" jdoc="This method creates a new JMenuItem. See menus XMenuHandler.class for more informations about its usage. @param label The menu item label @param action The name of the action, specified in Jext @param keyStroke The keystroke used as accelerator @param picture Relative path to an icon @param enabled Disable the item if false @param list If true adds item info to a list @return A new &amp;lt;code&amp;gt;JMenuItem&amp;lt; code&amp;gt;">
				<comm cntt="if (keyStroke != null) mi.setAccelerator(parseKeyStroke(keyStroke));"/>
				<param name="label"/>
				<param name="action"/>
				<param name="picture"/>
				<param name="enabled"/>
				<param name="list"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.PythonAction" intfc="n" abs="n" inn="n" sloc="24" jdoc="This class implements an &amp;lt;code&amp;gt;ActionListener&amp;lt; code&amp;gt; and handles action events fired by &amp;lt;codeJMenuItem&amp;lt; code&amp;gt;. The action is performed by executing a Python script.">
			<field name="script" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.PythonAction.PythonAction(String, String)" access="pub" jdoc="Creates a new menu action designed by its name and the pyhon execution script. @param name Internal action name @param script Python script">
				<param name="name"/>
				<param name="script"/>
			</mth>
			<mth name="/lib/:org.jext.PythonAction.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="pe.printStackTrace();"/>
				<comm cntt="getJextParent(evt).getPythonLogWindow().logln(pe.toString());"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.OneClickAction" intfc="n" abs="n" inn="n" sloc="22" jdoc="This class handle One Click! actions. Such an action is performed on each mouse click within text area. There are two ways to create an One Click! action: hard coding the action or calling an existing action.">
			<field name="action" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.OneClickAction.OneClickAction(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.OneClickAction.OneClickAction(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="action"/>
			</mth>
			<mth name="/lib/:org.jext.OneClickAction.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.OneClickAction.oneClickActionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JextFrame" intfc="n" abs="n" inn="n" sloc="1170" jdoc="Jext is a fully featured, 100% Pure Java, text editor. It has been mainly designed for programmers, and provides also very useful functions for them (syntax colorization, methods seeker, auto indentation...). @author Romain Guy">
			<comm cntt=""/>
			<comm cntt="LOCAL PRIVATE FIELDS"/>
			<comm cntt=""/>
			<comm cntt="GUI private members"/>
			<comm cntt="GUI components"/>
			<comm cntt="misc"/>
			<comm cntt="gui"/>
			<comm cntt="splitted edition"/>
			<comm cntt="labels"/>
			<comm cntt="misc datas"/>
			<comm cntt=""/>
			<comm cntt="PUBLIC AND PRIVATE NON-STATIC METHODS"/>
			<comm cntt=""/>
			<comm cntt="loads the text area&amp;apos;s gutter properties"/>
			<comm cntt="loads the syntax colorizing styles properties. This method"/>
			<comm cntt="is called by loadTextArea() and exists only to separate the"/>
			<comm cntt="code because loadTextArea() was becoming confusing"/>
			<comm cntt="so Jext.java can save the console"/>
			<comm cntt="friendly"/>
			<comm cntt="helps GC to clean up memory a bit"/>
			<comm cntt="friendly"/>
			<comm cntt="creates a new text area: it constructs it, gives it an"/>
			<comm cntt="input handler, sets default document and finally loads"/>
			<comm cntt="its properties from users settings"/>
			<comm cntt="internal use only: adds a text area in the tabbed pane"/>
			<comm cntt="the area is added, then selected and finally an event"/>
			<comm cntt="of kind TEXT_AREA_OPENED is fired"/>
			<comm cntt="adds the specified ProjectManagement to the map..."/>
			<comm cntt="friendly"/>
			<comm cntt=""/>
			<comm cntt="THE GUI"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="INTERNAL CLASSES"/>
			<comm cntt=""/>
			<field name="toolBar" access="priv" jdoc=""/>
			<field name="pluginsMenu" access="priv" jdoc=""/>
			<field name="menuRecent" access="priv" jdoc=""/>
			<field name="_dividerSize" access="priv" jdoc=""/>
			<field name="xtree" access="priv" jdoc=""/>
			<field name="console" access="priv" jdoc=""/>
			<field name="dawnLogWindow" access="priv" jdoc=""/>
			<field name="pythonLogWindow" access="priv" jdoc=""/>
			<field name="workspaces" access="priv" jdoc=""/>
			<field name="virtualFolders" access="priv" jdoc=""/>
			<field name="auto" access="priv" jdoc=""/>
			<field name="chooser" access="priv" jdoc=""/>
			<field name="accessory" access="priv" jdoc=""/>
			<field name="centerPane" access="priv" jdoc=""/>
			<field name="textAreasPane" access="priv" jdoc=""/>
			<field name="split" access="priv" jdoc=""/>
			<field name="hTabbedPane" access="priv" jdoc=""/>
			<field name="vTabbedPane" access="priv" jdoc=""/>
			<field name="splitter" access="priv" jdoc=""/>
			<field name="textAreaSplitter" access="priv" jdoc=""/>
			<field name="rightFrame" access="priv" jdoc=""/>
			<field name="leftFrame" access="priv" jdoc=""/>
			<field name="consolesFrame" access="priv" jdoc=""/>
			<field name="splittedTextArea" access="priv" jdoc=""/>
			<field name="message" access="priv" jdoc=""/>
			<field name="status" access="priv" jdoc=""/>
			<field name="waitCount" access="priv" jdoc=""/>
			<field name="batchMode" access="priv" jdoc=""/>
			<field name="jextListeners" access="priv" jdoc=""/>
			<field name="transientItems" access="priv" jdoc=""/>
			<field name="transientSwitch" access="priv" jdoc=""/>
			<field name="keyEventInterceptor" access="priv" jdoc=""/>
			<field name="inputHandler" access="priv" jdoc=""/>
			<field name="currentProjectMgr" access="priv" jdoc=""/>
			<field name="projectMgmts" access="priv" jdoc=""/>
			<field name="defaultProjectMgmt" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.JextFrame.getTabbedPane()" access="pub" jdoc="Returns the tabbed pane in which text areas are put.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getVerticalTabbedPane()" access="pub" jdoc="Returns the XTree&amp;apos;s tabbed pane.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getHorizontalTabbedPane()" access="pub" jdoc="Returns the console&amp;apos;s tabbed pane.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getXTree()" access="pub" jdoc="Some external functions may need to manipulate the tree. The XTree itself needs to get other instances to reload&amp;apos;em. @return Current &amp;lt;code&amp;gt;XTree&amp;lt; code&amp;gt; used by Jext">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getVirtualFolders()" access="pub" jdoc="Returns the Virtual Folders panel.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getWorkspaces()" access="pub" jdoc="Returns the Workspaces panel.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getConsole()" access="pub" jdoc="Some external functions may need to manipulate the console. The Scripting system, for instance, need it to launch OS specific commands. @return Current &amp;lt;code&amp;gt;Console&amp;lt; code&amp;gt; used by Jext">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getDawnLogWindow()" access="pub" jdoc="The log window is used by scripting actions. @return Current &amp;lt;code&amp;gt;DawnLogWindow&amp;lt; code&amp;gt; window used by Jext">
				<comm cntt="dawnLogWindow = new DawnLogWindow(this);"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getPythonLogWindow()" access="pub" jdoc="The log window is used by scripting actions. @return Current &amp;lt;code&amp;gt;PythonLogWindow&amp;lt; code&amp;gt; window used by Jext">
				<comm cntt="pythonLogWindow = new PythonLogWindow(this);"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getDawnDock()" access="pub" jdoc="Returns the dock holding the current Dawn LogWindow">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getPythonDock()" access="pub" jdoc="Returns the dock holding the current Python LogWindow">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getFileChooser(int)" access="pub" jdoc="Return the JFileChooser object used to open and save documents By maintaining a single file chooser for each instance of Jext instead of creating and disposing one each time a file is opened or saved, we should see a drastic improvement in memory usage @param mode the mode to open the dialog in @return the file chooser @author Ian D. Stewart &amp;lt;idstewart@softhome.net&amp;gt; &amp;amp; Romain Guy">
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setBatchMode(boolean)" access="pub" jdoc="Set batch mode state. Batch mode must be set when several operations are made over many text areas. It avoids tools like JBrowse to perform tasks.">
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getBatchMode()" access="pub" jdoc="Returns batch mode state.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getKeyEventInterceptor()" access="pub" jdoc="Returns the listener that will handle all key events in this view, if any.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setKeyEventInterceptor(KeyListener)" access="pub" jdoc="Sets the listener that will handle all key events in this view. For example, the complete word command uses this so that all key events are passed to the word list popup while it is visible. @param comp The component">
				<param name="listener"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.freeze()" access="pub" jdoc="Records the componence of the GUI for later restauration. Called after basic initialization of the GUI.">
				<comm cntt="getJextMenuBar().freeze();"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.itemAdded(Component)" access="pub" jdoc="Called after adding a new item to the GUI">
				<param name="comp"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.reset()" access="pub" jdoc="Restores the basic GUI.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setPluginsMenu(JMenu)" access="pub" jdoc="Sets the menu to be used as &amp;apos;plugins&amp;apos;. @param menu The &amp;lt;code&amp;gt;JMenu&amp;lt; code&amp;gt; used as plugins menu">
				<param name="menu"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.fireJextEvent(int)" access="pub" jdoc="Fires a Jext event. @param type Event type">
				<param name="type"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.fireJextEvent(JextTextArea, int)" access="pub" jdoc="Fires a Jext event. @param textArea Related event text area @param type Event type">
				<param name="textArea"/>
				<param name="type"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.removeAllJextListeners()" access="pub" jdoc="Removes all the listeners associated with this instance.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.addJextListener(JextListener)" access="pub" jdoc="Adds a propertiesL listener to this class. @param l The &amp;lt;code&amp;gt;JextListener&amp;lt; code&amp;gt; to add">
				<param name="l"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.removeJextListener(JextListener)" access="pub" jdoc="Remove a specified jext listener from the list. @param l The listener to remove">
				<param name="l"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.loadProperties()" access="pub" jdoc="Load options states from the properties file. Moreover, it sets up the corresponding internal variables and menu items.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.loadProperties(boolean)" access="pub" jdoc="">
				<param name="triggerPanes"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.loadButtonsProperties()" access="pub" jdoc="">
				<comm cntt="buttons colors"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.triggerTabbedPanes()" access="pub" jdoc="Hides or shows the left and top tabbed panes.">
				<comm cntt="if (split.getDividerSize() == 0)"/>
				<comm cntt="if (split.getDividerSize() != 0)"/>
				<comm cntt="SPLITTER BUG FIX"/>
				<comm cntt="If console enabled add splitter back to centerPane and make it visible."/>
				<comm cntt="SPLITTER BUG FIX"/>
				<comm cntt="Since the console isn&amp;apos;t visible and setDividerSize isn&amp;apos;t hiding the"/>
				<comm cntt="splitter then remove the splitter and add split to the centerPane."/>
				<comm cntt="if (leftShow)"/>
				<comm cntt="split.setBorder(topShow ? null : new MatteBorder(1, 0, 0, 0, Color.gray));"/>
				<comm cntt="else"/>
				<comm cntt="split.setBorder(null);"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.splitEditor()" access="pub" jdoc="Splits unsplits editor according to the property &amp;quot;editor.splitted&amp;quot;.">
				<comm cntt="if (split.getRightComponent() != textAreaSplitter)"/>
				<comm cntt="split.remove(textAreasPane);"/>
				<comm cntt="split.setRightComponent(textAreaSplitter);"/>
				<comm cntt="split.setRightComponent(textAreasPane);"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.loadConsoleProperties()" access="pub" jdoc="Load console properties states from the properties file. Should never been called directly.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.loadTextAreaProperties()" access="pub" jdoc="Load text area properties states from the properties file. Should never been called directly.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.loadTextArea(JextTextArea)" access="pub" jdoc="Load a given text area properties from the user settings. @param textArea The text area which has to be set">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.loadGutter(Gutter)" access="priv" jdoc="">
				<param name="gutter"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.loadStyles(TextAreaPainter)" access="priv" jdoc="">
				<param name="painter"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.registerPlugins()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.updatePluginsMenu()" access="pub" jdoc="Recreates the plugins menu.">
				<comm cntt="if (pluginArray.length == 0)"/>
				<comm cntt="and therefore it is a permanent plugin"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.startAutoSave()" access="pub" jdoc="Start the auto saving function. If the &amp;lt;code&amp;gt;Thread&amp;lt; code&amp;gt; used for the auto save is &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;, we need to create it.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.stopAutoSave()" access="pub" jdoc="Stop the auto saving function. We just interrupt the &amp;lt;code&amp;gt;Thread&amp;lt; code&amp;gt; and then &amp;apos;kill&amp;apos; it.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.updateStatus(JextTextArea)" access="pub" jdoc="Update status label which displays informations about caret&amp;apos;s position. @param textArea The text area which caret status has to be updated">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setStatus(JextTextArea)" access="pub" jdoc="Display status of a given text area. @param textArea The text area which status has to be displayed">
				<comm cntt="this one changes the message label, not status one!"/>
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.resetStatus(JextTextArea)" access="pub" jdoc="Makes the given text area being considered as non modified.">
				<comm cntt="TODO for line-end patch"/>
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setNew(JextTextArea)" access="pub" jdoc="When the user create a new file, we need to reset some stuffs such as the bottom labels and the tab icon. @param textArea The text area which was cleared">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setChanged(JextTextArea)" access="pub" jdoc="When the text change, we warn the user while displaying a text in the lower right corner. @param textArea The text area which was modified">
				<comm cntt="if (!textArea.isDirty()) {"/>
				<comm cntt="textArea.setDirty(); checks moved to JextTextArea"/>
				<comm cntt="}"/>
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setSaved(JextTextArea)" access="pub" jdoc="When the user saves its text, we have to reset modifications done by &amp;lt;code&amp;gt;setChanged()&amp;lt; code&amp;gt;.">
				<comm cntt="if (textArea.isDirty()) {"/>
				<comm cntt="textArea.clean()"/>
				<comm cntt="}"/>
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.closeToQuit()" access="pub" jdoc="Close current window after having checked dirty state of each opened file. It should be called only by {@link Jext#closeToQuit(JextFrame)}, which also closes Jext if needed, handling all the background server related issues.">
				<comm cntt="new SaveDialog(this, SaveDialog.CLOSE_WINDOW);"/>
				<comm cntt="end for i..."/>
				<comm cntt="end while more project managements..."/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.closeWindow()" access="pub" jdoc="Destroys current window and close JVM.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.closeWindow(boolean)" access="pub" jdoc="Destroy current window and close JVM if necessary. However the correct way to close a JextFrame (as of Jext3.2pre3) is to call {@link Jext#closeToQuit(JextFrame)} @param jvm If true, we terminate the JVM @deprecated Use closeWindow(), since the JVM is not closed anyway.">
				<comm cntt="fireJextEvent((Jext.getWindowsCount() == 1) ? JextEvent.KILLING_JEXT : JextEvent.CLOSING_WINDOW);"/>
				<comm cntt="fireJextEvent(JextEvent.CLOSING_WINDOW);"/>
				<comm cntt="events are handled by Jext.closeToQuit. But so they are dispatched before the Save on exit dialog."/>
				<comm cntt="Will work?"/>
				<comm cntt="if (console != null &amp;&amp; Jext.getBooleanProperty(&amp;quot;console.save&amp;quot;)) console.save(); GUIUtilities.saveGeometry(this, &amp;quot;jext&amp;quot;); Jext.saveXMLProps(&amp;quot;Jext v&amp;quot; + Jext.RELEASE + &amp;quot; b&amp;quot; + Jext.BUILD);"/>
				<comm cntt="cleanMemory();"/>
				<comm cntt="real exit is done by the calling Jext.closeToQuit(); if all windows have been closed and we are not running the jext background server, and we have been asked to do, then we actually close Jext. if (Jext.getWindowsCount() == 0 &amp;&amp; ! Jext.isRunningBg() &amp;&amp; jvm) Jext.finalCleanupBeforeExit();"/>
				<param name="jvm"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.saveConsole()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.cleanMemory()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.checkContent(JextTextArea)" access="pub" jdoc="Check if content of text area has to be saved or not. @return true if user want to close the area, false otherwise">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setRecentMenu(JextRecentMenu)" access="pub" jdoc="Sets the menu to be used as &amp;apos;recent&amp;apos;. @param menu The &amp;lt;code&amp;gt;JMenu&amp;lt; code&amp;gt; used as recent menu">
				<param name="menu"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.reloadRecent()" access="pub" jdoc="Called by the RecentListener to reload the recent menu.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.removeRecent()" access="pub" jdoc="Clears recent menu.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.saveRecent(String)" access="pub" jdoc="Saves a file as a recent.">
				<param name="file"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.showWaitCursor()" access="pub" jdoc="Shows the wait cursor.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.hideWaitCursor()" access="pub" jdoc="Hides the wait cursor.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.selectProjectManagement(String)" access="pub" jdoc="Selects the specified form of project management; returns &amp;lt;CODE&amp;gt;true&amp;lt; CODE&amp;gt; if successful. @return &amp;lt;CODE&amp;gt;boolean&amp;lt; CODE&amp;gt;.">
				<comm cntt="end if there is an old ProjectManager"/>
				<comm cntt="end if the new ProjectManager has a UI"/>
				<comm cntt="end if the new one is different from the current one..."/>
				<comm cntt="end if still okay..."/>
				<comm cntt="end if such a name..."/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getProjectManager()" access="pub" jdoc="Returns the current &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt;. @return &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setJextToolBar(JextToolBar)" access="pub" jdoc="Set Jext&amp;apos;s toolbar. SHOULD NOT BE CALLED BY AN EXTERNAL PLUGIN ! @param bar The new toolbar">
				<param name="bar"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getJextToolBar()" access="pub" jdoc="Get Jext&amp;apos;s toolbar">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getJextMenuBar()" access="pub" jdoc="Returns Jext menu bar.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getTextArea()" access="pub" jdoc="Returns current selected text area.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getNSTextArea()" access="pub" jdoc="Returns current selected text area, excluding the splitted area.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getTextAreas()" access="pub" jdoc="Returns an array containing all the text areas opened in current window.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.close(JextTextArea)" access="pub" jdoc="Close a specified file and checks if file is dirty first. @param textArea The file to close">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.close(JextTextArea, boolean)" access="pub" jdoc="Closes a specified file. @param textArea The file to close @param checkContent If true, Jext check if text area is dirty before saving">
				<comm cntt="saves memory and helps GC"/>
				<param name="textArea"/>
				<param name="checkContent"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.closeAll()" access="pub" jdoc="Close all the opened files.">
				<comm cntt=""/>
				<comm cntt="JextTextArea[] textAreas = getTextAreas();"/>
				<comm cntt="for (int i = 0; i &amp;lt; textAreas.length; i++)"/>
				<comm cntt="close(textAreas[i]);"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.open(String)" access="pub" jdoc="Opens a file in a new tabbed pane. In case it is already opened, we ask user if he wants to reload it or open it in a new pane.">
				<param name="file"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.open(String, boolean)" access="pub" jdoc="Opens a file in a new tabbed pane. In case it is already opened, we ask user if he wants to reload it or open it in a new pane. @param addToRecentList If false, the file name is not added to recent list">
				<param name="file"/>
				<param name="addToRecentList"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.openForLoading(String)" access="pub" jdoc="">
				<param name="file"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.createTextArea()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.addTextAreaInTabbedPane(JextTextArea)" access="priv" jdoc="">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.addProjectManagement(ProjectManagement)" access="priv" jdoc="">
				<param name="projectMgmt"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.createFile()" access="pub" jdoc="Creates a new empty file.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setTextAreaName(JextTextArea, String)" access="pub" jdoc="Change the name of specified text area. @param textArea The area which name is to be changed @param name The new title which will appear on the tab">
				<param name="textArea"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.updateSplittedTextArea(JextTextArea)" access="pub" jdoc="Updates splitted text area to make it edit the same thing as the selected text area. @param textArea The text area which has to be linked with">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.disableSplittedTextArea()" access="pub" jdoc="If user selects a tab containing something different from a text area, we disable &amp;apos;splitted&amp;apos; one.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setLineTerm(JextTextArea)" access="pub" jdoc="">
				<param name="jta"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setLineTerm(JextTextArea, int)" access="pub" jdoc="This method makes the two textareas show the same lineTerm in their ComboBoxes. Needs to be called only when using one combobox to change the line end.">
				<comm cntt="friendly"/>
				<param name="jta"/>
				<param name="value"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.JextFrame()" access="pub" jdoc="Create a new GUI.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.JextFrame(String)" access="pub" jdoc="Create a new GUI. @param args Arguments (to open a file directly)">
				<param name="args"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.JextFrame(String, boolean)" access="pub" jdoc="">
				<comm cntt="create the text areas pane"/>
				<comm cntt="textAreaSplitter.setResizeWeight(1.0);"/>
				<comm cntt="vTabbedPane.add(Jext.getProperty(&amp;quot;vTabbedPane.project&amp;quot;), new ProjectPanel(this));"/>
				<comm cntt="if (vTabbedPane.getTabCount() == 0)"/>
				<comm cntt="Jext.setProperty(&amp;quot;leftPanel.show&amp;quot;, &amp;quot;off&amp;quot;);"/>
				<comm cntt="creates console"/>
				<comm cntt="TODO: check if getNSTextArea() is the right thing."/>
				<comm cntt="for the left status bar message"/>
				<comm cntt="about isDirty: the JextFrame.setChanged setSaved assume if the dirty flag"/>
				<comm cntt="is in the wrong state(false for setChanged true for setSaved), then the GUI hasn&amp;apos;t been updated."/>
				<comm cntt="This is false here-rotateLineTerm changes actually the dirty flag but doesn&amp;apos;t update the GUI."/>
				<comm cntt="for the right status bar message"/>
				<comm cntt="we finally add the labels, used to display informations, and the toolbar"/>
				<comm cntt="we load the user geometry"/>
				<comm cntt="here is the window listener which call exit on window closing"/>
				<comm cntt="we notify listeners that a new Jext window is opened"/>
				<param name="args"/>
				<param name="toShow"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.getInputHandler()" access="pub" jdoc="Returns the input handler.">
			</mth>
			<mth name="/lib/:org.jext.JextFrame.setInputHandler(InputHandler)" access="pub" jdoc="Sets the input handler. @param inputHandler The new input handler">
				<param name="inputHandler"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame.processKeyEvent(KeyEvent)" access="pub" jdoc="Forwards key events directly to the input handler. This is slightly faster than using a KeyListener because some Swing overhead is avoided.">
				<comm cntt="Handled in text area"/>
				<param name="evt"/>
			</mth>
		<class name="/lib/:org.jext.JextFrame$WindowHandler" intfc="n" abs="n" inn="y" sloc="7" jdoc="">
			<mth name="/lib/:org.jext.JextFrame$WindowHandler.windowClosing(WindowEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JextFrame$PluginHandler" intfc="n" abs="n" inn="y" sloc="31" jdoc="">
			<mth name="/lib/:org.jext.JextFrame$PluginHandler.jextEventFired(JextEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JextFrame$ModeHandler" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<mth name="/lib/:org.jext.JextFrame$ModeHandler.jextEventFired(JextEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.JextFrame$DnDHandler" intfc="n" abs="n" inn="y" sloc="37" jdoc="">
			<mth name="/lib/:org.jext.JextFrame$DnDHandler.dragEnter(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame$DnDHandler.dragOver(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame$DnDHandler.dragExit(DropTargetEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame$DnDHandler.dragScroll(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame$DnDHandler.dropActionChanged(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.JextFrame$DnDHandler.drop(DropTargetDropEvent)" access="pub" jdoc="">
				<comm cntt="what a fix !!!!! (JDK 1.4, JVM hanging on drag and drop if file was already opened)"/>
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.EditAction" intfc="y" abs="n" inn="n" sloc="3" jdoc="An edit action is an action which has effet on text area content. Such an action must not be performed if the text area is in read only mode. @author Romain Guy @version 1.0">
		</class>
		<class name="/lib/:org.jext.Plugin" intfc="y" abs="n" inn="n" sloc="7" jdoc="An interface which defines the basical behavior of a Jext plugin. A plugin MUST implement this.">
			<mth name="/lib/:org.jext.Plugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="Called by parent (instance of Jext) to requires menu items specific to the plugin. Menu items have to be added into the Vector pluginsMenuItems and submenus have to be added into the Vector pluginsMenu.">
				<param name="parent"/>
				<param name="pluginsMenus"/>
				<param name="pluginsMenuItems"/>
			</mth>
			<mth name="/lib/:org.jext.Plugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="Called by Jext when user request plugins options. Plugin has to add an AbstractOptionPane to the AbstractOptionsDialog parent.">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.Plugin.start()" access="pub" jdoc="Called by Jext on startup to start plugin.">
			</mth>
			<mth name="/lib/:org.jext.Plugin.stop()" access="pub" jdoc="Called by Jext on close to stop plugin activities. This is called, in the background mode, only when the JVM exits completely, differently from the{@link org.jext.event.JextEvent#KILLING_JEXT} event. See its docs for a discussion of differencies.">
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.actions">
		<class name="/lib/:org.jext.actions.JoinAllLines" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<mth name="/lib/:org.jext.actions.JoinAllLines.JoinAllLines()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.JoinAllLines.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.BoxComment" intfc="n" abs="n" inn="n" sloc="48" jdoc="">
			<mth name="/lib/:org.jext.actions.BoxComment.BoxComment()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.BoxComment.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.CompleteWordAll" intfc="n" abs="n" inn="n" sloc="108" jdoc="">
			<mth name="/lib/:org.jext.actions.CompleteWordAll.CompleteWordAll()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.CompleteWordAll.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="end of for."/>
				<comm cntt="look for a common partial match"/>
				<comm cntt="end while more elements"/>
				<comm cntt="end if a partial match was found"/>
				<comm cntt="end else--all matches unique beyond what was originally typed"/>
				<comm cntt="end if more than one possible completion"/>
				<comm cntt="end if only one possible completion"/>
				<comm cntt="end else, one or zero completions"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.actions.CompleteWordAll.getDivergentIndex(String, String)" access="priv" jdoc="">
				<comm cntt="end if the Strings are not equal"/>
				<param name="str1"/>
				<param name="str2"/>
			</mth>
			<mth name="/lib/:org.jext.actions.CompleteWordAll.getWord(String, int, String)" access="priv" jdoc="">
				<param name="line"/>
				<param name="offset"/>
				<param name="noWordSep"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.JoinLines" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<mth name="/lib/:org.jext.actions.JoinLines.JoinLines()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.JoinLines.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.Print" intfc="n" abs="n" inn="n" sloc="46" jdoc="">
			<mth name="/lib/:org.jext.actions.Print.Print()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.Print.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.ToUpperCase" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<mth name="/lib/:org.jext.actions.ToUpperCase.ToUpperCase()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.ToUpperCase.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="Element map = doc.getDefaultRootElement();"/>
				<comm cntt="int count = map.getElementCount();"/>
				<comm cntt="for (int i = 0; i &amp;lt; count; i++)"/>
				<comm cntt="{"/>
				<comm cntt="Element lineElement = map.getElement(i);"/>
				<comm cntt="int start = lineElement.getStartOffset();"/>
				<comm cntt="int end = lineElement.getEndOffset() - 1;"/>
				<comm cntt="end -= start;"/>
				<comm cntt="String text = textArea.getText(start, end).toUpperCase();"/>
				<comm cntt="doc.remove(start, end);"/>
				<comm cntt="doc.insertString(start, text, null);"/>
				<comm cntt="}"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.WingComment" intfc="n" abs="n" inn="n" sloc="25" jdoc="">
			<mth name="/lib/:org.jext.actions.WingComment.WingComment()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.WingComment.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.RemoveWhitespace" intfc="n" abs="n" inn="n" sloc="43" jdoc="Remove whitespace from ends of lines. Based on &amp;lt;CODE&amp;gt;RemoveSpaces&amp;lt; CODE&amp;gt;. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt;">
			<comm cntt="inherit doc"/>
			<mth name="/lib/:org.jext.actions.RemoveWhitespace.RemoveWhitespace()" access="pub" jdoc="Construct a new &amp;lt;CODE&amp;gt;RemoveWhitespace&amp;lt; CODE&amp;gt; action.">
			</mth>
			<mth name="/lib/:org.jext.actions.RemoveWhitespace.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="end if text is not null"/>
				<comm cntt="end for through lines"/>
				<comm cntt="end try to do the work"/>
				<comm cntt="do nothing"/>
				<comm cntt="end catch BadLocationException"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.actions.RemoveWhitespace.doRemove(String)" access="priv" jdoc="">
				<param name="in"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.SimpleComment" intfc="n" abs="n" inn="n" sloc="40" jdoc="">
			<mth name="/lib/:org.jext.actions.SimpleComment.SimpleComment()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.SimpleComment.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="better use textArea.getLineStartOffset(line)"/>
				<comm cntt="textArea.getLineEndOffset(line) and so on.."/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.SimpleUnComment" intfc="n" abs="n" inn="n" sloc="58" jdoc="">
			<mth name="/lib/:org.jext.actions.SimpleUnComment.SimpleUnComment()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.SimpleUnComment.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.actions.SimpleUnComment.possiblyUncomentThisLine(Document, JextTextArea, int, int)" access="priv" jdoc="">
				<comm cntt="Now we know how much to delete so DO IT!"/>
				<param name="doc"/>
				<param name="textArea"/>
				<param name="startIndex"/>
				<param name="runLength"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.CompleteWord" intfc="n" abs="n" inn="n" sloc="103" jdoc="">
			<mth name="/lib/:org.jext.actions.CompleteWord.CompleteWord()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.CompleteWord.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="look for a common partial match"/>
				<comm cntt="end while more elements"/>
				<comm cntt="end if a partial match was found"/>
				<comm cntt="end else--all matches unique beyond what was originally typed"/>
				<comm cntt="end if more than one possible completion"/>
				<comm cntt="end if only one possible completion"/>
				<comm cntt="end else, one or zero completions"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.actions.CompleteWord.getDivergentIndex(String, String)" access="priv" jdoc="">
				<comm cntt="end if the Strings are not equal"/>
				<param name="str1"/>
				<param name="str2"/>
			</mth>
			<mth name="/lib/:org.jext.actions.CompleteWord.getWord(String, int, String)" access="priv" jdoc="">
				<param name="line"/>
				<param name="offset"/>
				<param name="noWordSep"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.LeftIndent" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<mth name="/lib/:org.jext.actions.LeftIndent.LeftIndent()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.LeftIndent.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.ToLowerCase" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<mth name="/lib/:org.jext.actions.ToLowerCase.ToLowerCase()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.ToLowerCase.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="Element map = doc.getDefaultRootElement();"/>
				<comm cntt="int count = map.getElementCount();"/>
				<comm cntt="for (int i = 0; i &amp;lt; count; i++)"/>
				<comm cntt="{"/>
				<comm cntt="Element lineElement = map.getElement(i);"/>
				<comm cntt="int start = lineElement.getStartOffset();"/>
				<comm cntt="int end = lineElement.getEndOffset() - 1;"/>
				<comm cntt="end -= start;"/>
				<comm cntt="String text = textArea.getText(start, end).toLowerCase();"/>
				<comm cntt="doc.remove(start, end);"/>
				<comm cntt="doc.insertString(start, text, null);"/>
				<comm cntt="}"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.RightIndent" intfc="n" abs="n" inn="n" sloc="35" jdoc="">
			<mth name="/lib/:org.jext.actions.RightIndent.RightIndent()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.RightIndent.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.OpenUrl" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<mth name="/lib/:org.jext.actions.OpenUrl.OpenUrl()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.OpenUrl.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.BeginLine" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<mth name="/lib/:org.jext.actions.BeginLine.BeginLine()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.BeginLine.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.CreateTemplate" intfc="n" abs="n" inn="n" sloc="79" jdoc="">
			<mth name="/lib/:org.jext.actions.CreateTemplate.CreateTemplate()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.CreateTemplate.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.actions.CreateTemplate.loadFile(String)" access="priv" jdoc="">
				<param name="fileName"/>
			</mth>
			<mth name="/lib/:org.jext.actions.CreateTemplate.addTokensFromInput(JextFrame, String, HashMap)" access="priv" jdoc="">
				<param name="parent"/>
				<param name="input"/>
				<param name="tokens"/>
			</mth>
			<mth name="/lib/:org.jext.actions.CreateTemplate.replace(String, HashMap)" access="priv" jdoc="">
				<param name="input"/>
				<param name="tokens"/>
			</mth>
			<mth name="/lib/:org.jext.actions.CreateTemplate.saveOutput(JextFrame, String)" access="priv" jdoc="">
				<param name="parent"/>
				<param name="output"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.SpacesToTabs" intfc="n" abs="n" inn="n" sloc="75" jdoc="">
			<mth name="/lib/:org.jext.actions.SpacesToTabs.SpacesToTabs()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.SpacesToTabs.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.actions.SpacesToTabs.doSpacesToTabs(String, int)" access="priv" jdoc="">
				<param name="in"/>
				<param name="tabSize"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.EndLine" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<mth name="/lib/:org.jext.actions.EndLine.EndLine()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.EndLine.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.WordCount" intfc="n" abs="n" inn="n" sloc="76" jdoc="">
			<field name="wing" access="priv" jdoc=""/>
			<field name="comments" access="priv" jdoc=""/>
			<field name="characters" access="priv" jdoc=""/>
			<field name="lines" access="priv" jdoc=""/>
			<field name="words" access="priv" jdoc=""/>
			<field name="codeLines" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.actions.WordCount.WordCount()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.WordCount.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.actions.WordCount.doWordCount(String)" access="priv" jdoc="">
				<param name="text"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.actions.TabsToSpaces" intfc="n" abs="n" inn="n" sloc="56" jdoc="">
			<mth name="/lib/:org.jext.actions.TabsToSpaces.TabsToSpaces()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.actions.TabsToSpaces.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.actions.TabsToSpaces.doTabsToSpaces(String, int)" access="priv" jdoc="">
				<param name="in"/>
				<param name="tabSize"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.console">
		<class name="/lib/:org.jext.console.Console" intfc="n" abs="n" inn="n" sloc="588" jdoc="An internal console which provide different kinds of prompts and which allows to execute both internal and external (OS specific) commands. The console is embedded in a &amp;lt;code&amp;gt;JScrollPane&amp;lt; code&amp;gt; and handles it by itself. @author Romain Guy">
			<comm cntt="current separators used in command lines"/>
			<comm cntt="private static final String COMPLETION_SEPARATORS = &amp;quot; \t;: \\\&amp;quot;\&amp;apos;&amp;quot;;"/>
			<comm cntt="commands"/>
			<comm cntt="parent"/>
			<comm cntt="processes specific"/>
			<comm cntt="private fields"/>
			<comm cntt="colors"/>
			<comm cntt="prompt"/>
			<comm cntt="inits commands list"/>
			<comm cntt="builds the prompt according to the prompt pattern"/>
			<comm cntt="TODO: this method, in case of ambiguity, should print completions as bash."/>
			<comm cntt="And should also expand the ~(not by calling constructPath, which is normally used"/>
			<comm cntt="to do this: this expansion should go, probably, inside parseCommand()."/>
			<comm cntt=""/>
			<comm cntt="NEEDED BY JavaScriptParser PLUGIN"/>
			<comm cntt=""/>
			<const name="DOS_PROMPT" access="pub" jdoc="DOS prompt: export home guy &amp;gt;"/>
			<const name="JEXT_PROMPT" access="pub" jdoc="Jext prompt: Gfx@ export home guy &amp;gt;"/>
			<const name="LINUX_PROMPT" access="pub" jdoc="Linux prompt: guy@csdlyon$"/>
			<const name="SUNOS_PROMPT" access="pub" jdoc="SunOS prompt: csdlyon%"/>
			<const name="DEFAULT_PROMPTS" access="pub" jdoc="Default prompt types: DOS, Jext, Linux and SunOS"/>
			<const name="COMPLETION_SEPARATORS" access="priv" jdoc=""/>
			<field name="currentCmd" access="priv" jdoc=""/>
			<field name="firstCmd" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="cProcess" access="priv" jdoc=""/>
			<field name="parser" access="priv" jdoc="This parser is used as interpreter for the Jython mode"/>
			<field name="pythonBuf" access="priv" jdoc="This buffer stores the incomplete Python command lines"/>
			<field name="current" access="priv" jdoc=""/>
			<field name="outputDocument" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<field name="historyModel" access="priv" jdoc=""/>
			<field name="userLimit" access="priv" jdoc="This is the point from where starts the text the user can edit. The text before was either output or (from the user but accepted with &amp;lt;Enter&amp;gt;)"/>
			<field name="typingLocation" access="priv" jdoc="This is where the user-typed text that hasn&amp;apos;t still be accepted ends. If it&amp;apos;s before the document length, the user cannot type."/>
			<field name="index" access="priv" jdoc="If the command is taken from the history, this is its position inside it: 0 for the last command, 1 for the one before and so on; if it&amp;apos;s -1, the command doesn&amp;apos;t come from the history."/>
			<field name="errorColor" access="pub" jdoc=""/>
			<field name="promptColor" access="pub" jdoc=""/>
			<field name="outputColor" access="pub" jdoc=""/>
			<field name="infoColor" access="pub" jdoc=""/>
			<field name="displayPath" access="priv" jdoc=""/>
			<field name="prompt" access="priv" jdoc=""/>
			<field name="hostName" access="priv" jdoc=""/>
			<field name="oldPath" access="priv" jdoc=""/>
			<field name="promptPattern" access="priv" jdoc=""/>
			<field name="alwaysAllowType" access="priv" jdoc=""/>
			<field name="evalCom" access="priv" jdoc=""/>
			<field name="writerSTDOUT" access="priv" jdoc=""/>
			<field name="writeSTDERR" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.Console.Console(JextFrame)" access="pub" jdoc="Instanciates a new console without displaying prompt. @param parent &amp;lt;code&amp;gt;Jext&amp;lt; code&amp;gt; parent">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.Console(JextFrame, boolean)" access="pub" jdoc="Creates a new console, embedding it in a &amp;lt;code&amp;gt;JScrollPane&amp;lt; code&amp;gt;. By default console help is displayed. @param parent &amp;lt;code&amp;gt;Jext&amp;lt; code&amp;gt; parent @param display If set on true, prompt is displayed">
				<comm cntt="load commands from previous sessions"/>
				<param name="parent"/>
				<param name="display"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.getParentFrame()" access="pub" jdoc="Returns this Console&amp;apos;s parent.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.getOutputDocument()" access="pub" jdoc="Return the &amp;lt;code&amp;gt;Document&amp;lt; code&amp;gt; in which output is performed.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.addCommand(Command)" access="pub" jdoc="Adds a command to the linked list of commands.">
				<param name="command"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.builtInCommand(String)" access="priv" jdoc="Return true if command is built-in. If command is built-in, it is also executed. @param command Command to check and execute">
				<param name="command"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.initCommands()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.Console.setBgColor(Color)" access="pub" jdoc="Set console background color. @param color &amp;lt;code&amp;gt;Color&amp;lt; code&amp;gt; to be used">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.setErrorColor(Color)" access="pub" jdoc="Set console error color. @param color &amp;lt;code&amp;gt;Color&amp;lt; code&amp;gt; to be used">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.setPromptColor(Color)" access="pub" jdoc="Set console prompt color. @param color &amp;lt;code&amp;gt;Color&amp;lt; code&amp;gt; to be used">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.setOutputColor(Color)" access="pub" jdoc="Set console output color. @param color &amp;lt;code&amp;gt;Color&amp;lt; code&amp;gt; to be used">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.setInfoColor(Color)" access="pub" jdoc="Set console info color. @param color &amp;lt;code&amp;gt;Color&amp;lt; code&amp;gt; to be used">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.setSelectionColor(Color)" access="pub" jdoc="Set console selection color. @param color &amp;lt;code&amp;gt;Color&amp;lt; code&amp;gt; to be used">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.save()" access="pub" jdoc="Save the history.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.load()" access="pub" jdoc="Load the last saved history.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.setPromptPattern(String)" access="pub" jdoc="Set the prompt pattern. @param type The prompt pattern">
				<param name="prompt"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.getPromptPattern()" access="pub" jdoc="Get prompt pattern.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.displayPrompt()" access="pub" jdoc="Displays the prompt according to the current selected prompt type.">
				<comm cntt="append(&amp;apos;\n&amp;apos; + &amp;quot;[python] &amp;quot; + prompt, promptColor);"/>
				<comm cntt="append(&amp;apos;\n&amp;apos; + prompt, promptColor);"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.buildPrompt()" access="priv" jdoc="">
				<comm cntt="current path"/>
				<comm cntt="user name"/>
				<comm cntt="host name"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.append(String, Color, boolean, boolean)" access="priv" jdoc="This method appends text in the text area. @param text The text to append @param color The color of the text @param italic Set to true will append italic text @param bold Set to true will append bold text">
				<param name="text"/>
				<param name="color"/>
				<param name="italic"/>
				<param name="bold"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.append(String, Color)" access="pub" jdoc="This method appends text in the text area. @param text The text to append in the text area @apram color The color of the text to append">
				<param name="text"/>
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.addHistory(String)" access="pub" jdoc="Adds a command to the history. @param command Command to add in the history">
				<param name="command"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.removeChar()" access="pub" jdoc="Remove a char from current command line. Stands for BACKSPACE action.">
				<comm cntt="if (typingLocation != userLimit)"/>
				<comm cntt="outputDocument.remove(--typingLocation, 1);"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.deleteChar()" access="pub" jdoc="Delete a char from command line. Stands for DELETE action.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.add(String)" access="pub" jdoc="Adds a &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to the current command line. @param add &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to be added">
				<param name="add"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.getUserLimit()" access="pub" jdoc="Returns the position in characters at which user is allowed to type his commands. @return Beginning of user typing space">
			</mth>
			<mth name="/lib/:org.jext.console.Console.getTypingLocation()" access="pub" jdoc="Returns the position of the end of the console prompt.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.doCompletion()" access="pub" jdoc="Completes current filename if possible.">
				<comm cntt="the slash is inside path."/>
				<comm cntt="maximum length of a completion"/>
				<comm cntt="index of the longest completion(if more longest ones,"/>
				<comm cntt="we take the index of the last one)."/>
				<comm cntt="source[0:diffIndex] is the completion common to"/>
				<comm cntt="everything. Note that if there are, i.e., &amp;quot;file&amp;quot; and &amp;quot;fileLonger&amp;quot;, the"/>
				<comm cntt="completion used to be fileLonger. Now we want to get, instead, file; but"/>
				<comm cntt="modify below where MARKed to get old behaviour."/>
				<comm cntt="MARK"/>
				<comm cntt="if (i &amp;gt;= compare.length()) continue;"/>
				<comm cntt="if (compare.charAt(i) != c)"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.doBackwardSearch()" access="pub" jdoc="Search backward in the history for a matching command, according to the command typed in the user typing space.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.historyPrevious()" access="pub" jdoc="Get previous item in the history list.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.historyNext()" access="pub" jdoc="Get next item in the history list.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.setText(String)" access="pub" jdoc="Set user&amp;apos;s command line content. @param text Text to be put on command line.">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.getText()" access="pub" jdoc="Returns current command line.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.help()" access="pub" jdoc="Displays console help.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.info(String)" access="pub" jdoc="Display a message using information color. @since Jext3.2pre4 @param display &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to be displayed">
				<comm cntt="append(&amp;apos;\n&amp;apos; + display, infoColor, false, false);"/>
				<param name="display"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.help(String)" access="pub" jdoc="Display a message using help color. @param display &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to be displayed">
				<comm cntt="append(&amp;apos;\n&amp;apos; + display, infoColor, true, true);"/>
				<param name="display"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.error(String)" access="pub" jdoc="Display a message using error color. @param display &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to be displayed">
				<comm cntt="append(&amp;apos;\n&amp;apos; + display, errorColor, false, false);"/>
				<param name="display"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.output(String)" access="pub" jdoc="Display a message using output color. @param display &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to be displayed">
				<comm cntt="append(&amp;apos;\n&amp;apos; + display, outputColor, false, false);"/>
				<param name="display"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.stop()" access="pub" jdoc="Stops current task.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.parseCommand(String)" access="pub" jdoc="Parse a command. Replace internal variables by their values. @param command Command to be parsed">
				<comm cntt="current opened file (absolute path)"/>
				<comm cntt="user directory"/>
				<comm cntt="current opened file name"/>
				<comm cntt="current opened file name without extension"/>
				<comm cntt="current opened file directory"/>
				<comm cntt="home dir"/>
				<comm cntt="jext dir"/>
				<comm cntt="selected text"/>
				<param name="command"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.execute(String)" access="pub" jdoc="Execute command. First parse it then check if command is built-in. At last, a process is created and threads which handle output streams are started. @param command Command to be execute">
				<comm cntt="userLimit = typingLocation; FIXME: this is part of saved positions refactoring?"/>
				<comm cntt="However, it&amp;apos;s needed to avoid that pressing Enter while a command executes"/>
				<comm cntt="makes Jext read the same command with getText() and execute it again."/>
				<comm cntt="But I&amp;apos;ve put it out, since with it, when I press Up, the command typed"/>
				<comm cntt="remains there, since that line make Jext think it&amp;apos;s part of the prompt."/>
				<comm cntt="check to see if in &amp;quot;jython&amp;quot; mode..."/>
				<comm cntt="if in jython mode, look for &amp;apos;!&amp;apos; as first charater...means"/>
				<comm cntt="treat it like a &amp;quot;normal console&amp;quot; command"/>
				<comm cntt="kludge shorthand for &amp;apos;print&amp;apos;"/>
				<comm cntt="evalCom.handleCommand(this, &amp;quot;eval:&amp;quot; + command);"/>
				<comm cntt="FIXME: use return value to display"/>
				<comm cntt="secondary prompt."/>
				<comm cntt="the command starts with !, so normal processing"/>
				<comm cntt="append(&amp;quot;\n&amp;gt; &amp;quot; + command, infoColor); try { if (Utilities.JDK_VERSION.charAt(2) &amp;lt; &amp;apos;3&amp;apos;) process = Runtime.getRuntime().exec(command); else process = Runtime.getRuntime().exec(command, null, new File(System.getProperty(&amp;quot;user.dir&amp;quot;))); process.getOutputStream().close(); } catch (IOException ioe) { error(Jext.getProperty(&amp;quot;console.error&amp;quot;)); displayPrompt(); return; } stdout = new StdoutThread(); stderr = new StderrThread(); if (process == null) displayPrompt();"/>
				<param name="command"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console.getStdOut()" access="pub" jdoc="Returns a writer in which external classes can send &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to make them being displayed in the console as standard output.">
			</mth>
			<mth name="/lib/:org.jext.console.Console.getStdErr()" access="pub" jdoc="Returns a writer in which external classes can send &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to make them being displayed in the console as error output.">
			</mth>
		<class name="/lib/:org.jext.console.Console$Appender" intfc="n" abs="n" inn="y" sloc="23" jdoc="">
			<field name="text" access="priv" jdoc=""/>
			<field name="color" access="priv" jdoc=""/>
			<field name="italic" access="priv" jdoc=""/>
			<field name="bold" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.Console$Appender.Appender(String, Color, boolean, boolean)" access="pub" jdoc="">
				<param name="_text"/>
				<param name="_color"/>
				<param name="_italic"/>
				<param name="_bold"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console$Appender.run()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.console.Console$ConsoleProcess" intfc="n" abs="n" inn="y" sloc="120" jdoc="">
			<comm cntt="This should be used to notify stdin when the process actually started. But this design is probably broken. Better for now just the sleep(500), even if it&amp;apos;s broken at all and it just has happened to always work."/>
			<comm cntt="private Object stdinCloseLockObj = new Object(); private boolean processStarted = false;"/>
			<field name="executed" access="priv" jdoc=""/>
			<field name="process" access="priv" jdoc=""/>
			<field name="command" access="priv" jdoc=""/>
			<field name="processName" access="priv" jdoc="Name of the command, here for being put inside messages"/>
			<field name="exitCode" access="priv" jdoc=""/>
			<field name="exitCodeLock" access="priv" jdoc=""/>
			<field name="stdout" access="priv" jdoc=""/>
			<field name="stderr" access="priv" jdoc=""/>
			<field name="stdin" access="priv" jdoc=""/>
			<field name="stdinRedir" access="priv" jdoc=""/>
			<field name="stdoutRedir" access="priv" jdoc=""/>
			<field name="lockObj" access="priv" jdoc="Synchronize on this obj(set to null) for event related to threading inside this object."/>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess.ConsoleProcess(String)" access="pub" jdoc="">
				<param name="command"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess.getExitCode()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess.execute()" access="pub" jdoc="">
				<comm cntt="if (stdinRedir != null) alwaysAllowType = false; we don&amp;apos;t let else alwaysAllowType = false; since we forbid typing to stdin, then we set this to false anyway."/>
				<comm cntt="this thread will just"/>
				<comm cntt="close the stream, in this case. It&amp;apos;s needed for some problems on Unix(see below)"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess.handleRedirs(String)" access="priv" jdoc="This handles the parsing of I O redirections, and sets stdinRedir and stdoutRedir.">
				<comm cntt="skips spaces after &amp;gt;"/>
				<comm cntt="the name of the file is from the &amp;gt; to the end or to the &amp;lt;"/>
				<comm cntt="skips spaces before &amp;lt;"/>
				<comm cntt="skips spaces after &amp;lt;"/>
				<comm cntt="the name of the file is from the &amp;lt; to the end or to the &amp;gt;"/>
				<comm cntt="skips spaces before &amp;lt;"/>
				<param name="toParse"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess.stop()" access="pub" jdoc="Stops current task.">
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess.sendToProcess(String)" access="pub" jdoc="">
				<param name="toPrint"/>
			</mth>
		<class name="/lib/:org.jext.console.Console$ConsoleProcess$StdinThread" intfc="n" abs="n" inn="y" sloc="70" jdoc="">
			<field name="toPrint" access="priv" jdoc=""/>
			<field name="inFileName" access="priv" jdoc=""/>
			<field name="justClose" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess$StdinThread.StdinThread(String)" access="pub" jdoc="">
				<param name="inFileName"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess$StdinThread.StdinThread(String, boolean)" access="pub" jdoc="">
				<param name="inFileName"/>
				<param name="justClose"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess$StdinThread.print(String)" access="pub" jdoc="Must be called by the AWT-EventQueue thread, to make this one print some text to the process&amp;apos;s stdin.">
				<param name="toPrint"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess$StdinThread.run()" access="pub" jdoc="">
				<comm cntt="this is needed to catch the interrupt when we are not"/>
				<comm cntt="wait()&amp;apos;ing"/>
				<comm cntt="FIXME: this happens often, so turn it off after debug."/>
				<comm cntt="end if (inFileName != null)"/>
				<comm cntt="end if (!justClose)"/>
				<comm cntt="synchronized(stdinCloseLockObj) { if (! processStarted) stdinCloseLockObj.wait(); }"/>
				<comm cntt="If the close happens when the native process has not yet started truly running, it&amp;apos;s very easy for it to deadlock(at least on Linux). So I add these lines."/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.Console$ConsoleProcess$StdoutThread" intfc="n" abs="n" inn="y" sloc="66" jdoc="">
			<field name="outFileName" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess$StdoutThread.StdoutThread(String)" access="pub" jdoc="">
				<param name="outFileName"/>
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess$StdoutThread.run()" access="pub" jdoc="">
				<comm cntt="synchronized(stdinCloseLockObj) { processStarted = true; stdinCloseLockObj.notify(); }"/>
				<comm cntt="int nRead; char[] buf = new char[100]; boolean started = false; while((nRead = in.read(buf)) != -1) { if (!started) { started = true; append(&amp;quot;\n&amp;quot;, outputColor); } append(new String(buf, 0, nRead), outputColor); userLimit = outputDocument.getLength(); we display text that the user can&amp;apos;t delete and that getText mustn&amp;apos;t read }"/>
				<comm cntt="this should remove some NPE throwns. If we have been interrupted"/>
				<comm cntt="(by stop()), the process var has been set to null"/>
				<comm cntt="this is safe because the other exitCode lock"/>
				<comm cntt="doesn&amp;apos;t contain a lockObj lock"/>
				<comm cntt="this instead must be audited,"/>
				<comm cntt="since it calls SwingUtilities.invokeLater."/>
				<comm cntt="cProcess = null;"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.Console$ConsoleProcess$StderrThread" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess$StderrThread.StderrThread()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.Console$ConsoleProcess$StderrThread.run()" access="pub" jdoc="">
				<comm cntt="two versions of better code. I must first change"/>
				<comm cntt="the convention of messages starting with \n, instead of ending with"/>
				<comm cntt="\n. The second is older and slower, the first not tested."/>
				<comm cntt="char buf[] = new char[64]; int nRead = 0; while(n != -1) { int nRead = in.available(); if (nRead == 0) nRead = in.read(buf); here we block, not in any other case. else { nRead = Math.min(nRead, 64); nRead = in.read(buf, 0, nRead); here we&amp;apos;re guaranted to read the maximum we can without blocking } append(new String(buf, 0, nRead), errorColor); userLimit = outputDocument.getLength(); we display text that the user can&amp;apos;t delete and that getText mustn&amp;apos;t read }"/>
				<comm cntt="int c; while((c = in.read()) != -1) { append(&amp;quot;&amp;quot; + ((char)c), errorColor); }"/>
			</mth>
		</class>
		</class>
		</class>
		<class name="/lib/:org.jext.console.HistoryModel" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<comm cntt="Private members"/>
			<field name="max" access="priv" jdoc=""/>
			<field name="data" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.HistoryModel.HistoryModel(int)" access="pub" jdoc="Creates a new history model, seizing it according to the specified size. @param max The maximum numbers of items this history can hold">
				<param name="max"/>
			</mth>
			<mth name="/lib/:org.jext.console.HistoryModel.addItem(String)" access="pub" jdoc="When the user validate a new entry, we add it to the history. @param text The String to be added to the history">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.console.HistoryModel.getItem(int)" access="pub" jdoc="When user press UP or DOWN, we need to get a previous typed String, stored in the Vector. @param index The index of the String to get @return A String corresponding to a previous entry">
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.console.HistoryModel.getSize()" access="pub" jdoc="As the user can use arrows to get up and down in the list, we need to know its max capacity. @return Maximum capacity of the history">
			</mth>
			<mth name="/lib/:org.jext.console.HistoryModel.addItemToEnd(String)" access="priv" jdoc="We can need to add an item directly at the end of the list. @param item The String to add at the end">
				<param name="item"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.ConsoleTextPane" intfc="n" abs="n" inn="n" sloc="14" jdoc="&amp;lt;code&amp;gt;ConsoleTextPane&amp;lt; code&amp;gt; is the text area of Jext console. That&amp;apos;s where user types his commands, and also where command outputs are displayed. This class handles key and mouse events.">
			<field name="parent" access="priv" jdoc=""/>
			<field name="_keyListener" access="priv" jdoc=""/>
			<field name="_mouseListener" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.ConsoleTextPane.ConsoleTextPane(Console)" access="pub" jdoc="Creates a new text area for the console. @param parent &amp;lt;code&amp;gt;Console&amp;lt; code&amp;gt; parent">
				<comm cntt="_mouseListener = new MouseAdapter() { public void mousePressed(MouseEvent evt) { evt.consume(); if (getCaretPosition() &amp;lt; ConsoleTextPane.this.parent.getUserLimit()) setCaretPosition(getDocument().getLength()); } }; addMouseListener(_mouseListener);"/>
				<param name="parent"/>
			</mth>
		<class name="/lib/:org.jext.console.ConsoleTextPane$ConsoleKeyAdapter" intfc="n" abs="n" inn="y" sloc="96" jdoc="">
			<mth name="/lib/:org.jext.console.ConsoleTextPane$ConsoleKeyAdapter.keyPressed(KeyEvent)" access="pub" jdoc="">
				<comm cntt="event of the form Ctrl+KEY"/>
				<comm cntt="Ctrl+C copies selected text"/>
				<comm cntt="Ctrl+D kills current task"/>
				<comm cntt="we wait 1 second otherwise the prompt could not display as expected"/>
				<comm cntt="we delete a char"/>
				<comm cntt="we delete a char"/>
				<comm cntt="we execute command"/>
				<comm cntt="we get previous typed command"/>
				<comm cntt="we get next typed command"/>
				<comm cntt="we override the press on LEFT"/>
				<comm cntt="to ensure caret is not on prompt"/>
				<comm cntt="complete filename"/>
				<comm cntt="doBackwardSearch();"/>
				<comm cntt="implementation of HOME to go to"/>
				<comm cntt="beginning of prompt and not line"/>
				<comm cntt="see HOME"/>
				<comm cntt="delete line"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleTextPane$ConsoleKeyAdapter.keyTyped(KeyEvent)" access="pub" jdoc="">
				<comm cntt="this forbids from"/>
				<comm cntt="inserting text until prompt is reshown or Enter is pressed(maybe to remove?)"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.ConsoleTextPane$DnDHandler" intfc="n" abs="n" inn="y" sloc="33" jdoc="">
			<mth name="/lib/:org.jext.console.ConsoleTextPane$DnDHandler.dragEnter(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleTextPane$DnDHandler.dragOver(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleTextPane$DnDHandler.dragExit(DropTargetEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleTextPane$DnDHandler.dragScroll(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleTextPane$DnDHandler.dropActionChanged(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleTextPane$DnDHandler.drop(DropTargetDropEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.console.ConsoleListDir" intfc="n" abs="n" inn="n" sloc="240" jdoc="A ls function for Java Shell. Adapted to Jext. @author Romain Guy @version 1.9.4">
			<comm cntt="Thread-safe? Don&amp;apos;t joke, too many statics..."/>
			<comm cntt="the command line splitted into options."/>
			<comm cntt="these instances are used to improve speed of dates calculations."/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="pattern" access="priv" jdoc=""/>
			<field name="moreInfos" access="priv" jdoc=""/>
			<field name="fullNames" access="priv" jdoc=""/>
			<field name="longDates" access="priv" jdoc=""/>
			<field name="hiddenFiles" access="priv" jdoc=""/>
			<field name="noDates" access="priv" jdoc=""/>
			<field name="onlyDirs" access="priv" jdoc=""/>
			<field name="onlyFiles" access="priv" jdoc=""/>
			<field name="recursive" access="priv" jdoc=""/>
			<field name="noInfos" access="priv" jdoc=""/>
			<field name="kiloBytes" access="priv" jdoc=""/>
			<field name="sort" access="priv" jdoc=""/>
			<field name="buffer" access="priv" jdoc=""/>
			<field name="date" access="priv" jdoc=""/>
			<field name="field" access="priv" jdoc=""/>
			<field name="formatter" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.ConsoleListDir.list(Console, String)" access="pub" jdoc="Exec the equivalent of system&amp;apos;s &amp;apos;ls&amp;apos; or &amp;apos;dir&amp;apos; command. @param cparent Console which executed the command @param args The command arguments">
				<comm cntt="we reset flags"/>
				<param name="cparent"/>
				<param name="args"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleListDir.print(String)" access="priv" jdoc="Output a &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; in the parent console. @param print &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to output">
				<param name="print"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleListDir.buildFlags(String)" access="priv" jdoc="Determine which options are enabled. @param args The arguments containing the option flags">
				<comm cntt="hidden files to be shown"/>
				<comm cntt="display full infos"/>
				<comm cntt="use long dates format"/>
				<comm cntt="display full names (don&amp;apos;t cut with &amp;apos;...&amp;apos;)"/>
				<comm cntt="don&amp;apos;t show last modified dates"/>
				<comm cntt="lists dirs only"/>
				<comm cntt="lists files only"/>
				<comm cntt="lists subdirectories"/>
				<comm cntt="don&amp;apos;t show infos"/>
				<comm cntt="display file sizes in kb instead of bytes"/>
				<comm cntt="alphabetically sort files"/>
				<param name="arg"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleListDir.displayFile(File, String)" access="priv" jdoc="">
				<comm cntt="file is writable"/>
				<comm cntt="file is readable"/>
				<comm cntt="file is hidden"/>
				<param name="current"/>
				<param name="indent"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleListDir.run(int)" access="priv" jdoc="List according to the options flag activated.">
				<comm cntt="---1st PART: get file list."/>
				<comm cntt="if no wildcards, interpret things as .. or . or ~, since constructPath doesn&amp;apos;t like"/>
				<comm cntt="wildcards. FIXME: it seems it instead does like them."/>
				<comm cntt="the slash is inside path."/>
				<comm cntt="default pattern used is &amp;apos; &amp;apos;"/>
				<comm cntt="if no match were found and only if there was no wildcard, show an error."/>
				<comm cntt="parent.error(Jext.getProperty(&amp;quot;console.ls.error&amp;quot;));"/>
				<comm cntt="---2nd PART: produce the output."/>
				<comm cntt="determine if we must show or not (according to flags) found file"/>
				<comm cntt="if we are dealing with a dir and -r flag is set, we browse it"/>
				<comm cntt="loop over files[] end"/>
				<comm cntt="display summary infos"/>
				<param name="indentSize"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleListDir.formatNumber(String)" access="priv" jdoc="Format a number from 12000123 to 12 000 123. @param number Number to be formatted">
				<param name="number"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleListDir.createIndent(int)" access="priv" jdoc="Creates the indent for the recursive option. An indent unit adds two &amp;apos;-&amp;apos;. @param len Length of indentation">
				<param name="len"/>
			</mth>
			<mth name="/lib/:org.jext.console.ConsoleListDir.help()" access="pub" jdoc="Display command help in the console.">
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.console.commands">
		<class name="/lib/:org.jext.console.commands.HttpCommand" intfc="n" abs="n" inn="n" sloc="35" jdoc="This command opens an url in text area. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.HttpCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.HttpCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.HttpCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.EvalCommand" intfc="n" abs="n" inn="n" sloc="33" jdoc="This command runs a specified script. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.EvalCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.EvalCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.EvalCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<comm cntt="useless since messages already go to the console."/>
				<comm cntt="JOptionPane.showMessageDialog(console.getParentFrame(), Jext.getProperty(&amp;quot;python.script.errMessage&amp;quot;), Jext.getProperty(&amp;quot;python.script.error&amp;quot;), JOptionPane.ERROR_MESSAGE); if (Jext.getBooleanProperty(&amp;quot;dawn.scripting.debug&amp;quot;)) console.getParentFrame().getPythonLogWindow().logln(pe.toString());"/>
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.RunCommand" intfc="n" abs="n" inn="n" sloc="26" jdoc="This command runs a specified script. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.RunCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.RunCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.RunCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.ClearCommand" intfc="n" abs="n" inn="n" sloc="24" jdoc="This command clears the console output. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.ClearCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.ClearCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.ClearCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.ChangeDirCommand" intfc="n" abs="n" inn="n" sloc="28" jdoc="This command changes current dir. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.ChangeDirCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.ChangeDirCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.ChangeDirCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.ExitCommand" intfc="n" abs="n" inn="n" sloc="21" jdoc="This command exits Jext or closes current window. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.ExitCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.ExitCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.ExitCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.HomeCommand" intfc="n" abs="n" inn="n" sloc="21" jdoc="This command places prompt in Jext dir. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.HomeCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.HomeCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.HomeCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.FileCommand" intfc="n" abs="n" inn="n" sloc="25" jdoc="This command opens a file in the text area. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.FileCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.FileCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.FileCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.HelpCommand" intfc="n" abs="n" inn="n" sloc="21" jdoc="This command displays command help. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.HelpCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.HelpCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.HelpCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.Command" intfc="n" abs="y" inn="n" sloc="7" jdoc="The &amp;lt;code&amp;gt;Command&amp;lt; code&amp;gt; class is an empty implementation of a console command. The commands list is a linked list. @author Romain Guy">
			<field name="next" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.Command.getCommandName()" access="pub" jdoc="Return the command name. Displayed in console help summary.">
			</mth>
			<mth name="/lib/:org.jext.console.commands.Command.getCommandSummary()" access="pub" jdoc="Return the command summary. Displayed in console help summary.">
			</mth>
			<mth name="/lib/:org.jext.console.commands.Command.handleCommand(Console, String)" access="pub" jdoc="Handles a command given by the console. If the command can be handled, return true, false otherwise.">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.ListCommand" intfc="n" abs="n" inn="n" sloc="25" jdoc="This command lists current dir contents. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<const name="COMMAND_NAME_ALTERNATE" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.ListCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.ListCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.ListCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.JythonCommand" intfc="n" abs="n" inn="n" sloc="25" jdoc="This command exits Jext or closes current window. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.JythonCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.JythonCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.JythonCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.console.commands.PwdCommand" intfc="n" abs="n" inn="n" sloc="21" jdoc="This command displays current dir. @author Romain Guy">
			<const name="COMMAND_NAME" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.console.commands.PwdCommand.getCommandName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.PwdCommand.getCommandSummary()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.console.commands.PwdCommand.handleCommand(Console, String)" access="pub" jdoc="">
				<param name="console"/>
				<param name="command"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn">
		<class name="/lib/:org.jext.dawn.DawnUtilities" intfc="n" abs="n" inn="n" sloc="82" jdoc="This class contains some utility methods needed by Dawn or its functions.">
			<mth name="/lib/:org.jext.dawn.DawnUtilities.unescape(String)" access="pub" jdoc="">
				<param name="in"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnUtilities.escape(String)" access="pub" jdoc="Parsers a string and turn common escape sequences into special chars like \n (carriage return) \t (tab space) \\ (single \ character) ... @param in The &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to be parsed">
				<param name="in"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.Function" intfc="n" abs="y" inn="n" sloc="23" jdoc="The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; class defines the standard framework of any Dawn function. A function is defined by its name, the one which will be used to call it from scripts. The function also provides an &amp;lt;code&amp;gt;invoke()&amp;lt; code&amp;gt; method which can throw a &amp;lt;code&amp;gt;DawnRuntimeException&amp;lt; code&amp;gt; on error. @author Romain Guy">
			<comm cntt="function name"/>
			<comm cntt="this name will be used to call the function"/>
			<field name="name" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.dawn.Function.Function()" access="pub" jdoc="Creates a new Dawn function, unnamed.">
			</mth>
			<mth name="/lib/:org.jext.dawn.Function.Function(String)" access="pub" jdoc="Creates a new Dawn function. @param name The function name">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.Function.getHelp()" access="pub" jdoc="Returns the help associated with this function.">
			</mth>
			<mth name="/lib/:org.jext.dawn.Function.getName()" access="pub" jdoc="Returns the function name. The returned name is the name which must be called in a script to invoke the function. @return A &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt;, containing the name">
			</mth>
			<mth name="/lib/:org.jext.dawn.Function.invoke(DawnParser)" access="pub" jdoc="Executes the function. Usually, the function should make use of the &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; given as parameter. @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which inoked the function @throws A &amp;lt;code&amp;gt;DawnRuntimeException&amp;lt; code&amp;gt; if an error occures">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.CodeSnippet" intfc="n" abs="y" inn="n" sloc="9" jdoc="The &amp;lt;code&amp;gt;CodeSnippet&amp;lt; code&amp;gt; class stands for an interface for Dawn code snippets. A code snippet is a mini-script written in Dawn which will be used by &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; to create a function. Code snippets avoid writting annoying Java source code which can generate errors and be a pain to debug. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.CodeSnippet.getName()" access="pub" jdoc="Returns the function name. The returned name is the name which must be called in a script to invoke the function. @return A &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt;, containing the name">
			</mth>
			<mth name="/lib/:org.jext.dawn.CodeSnippet.getHelp()" access="pub" jdoc="Returns the contexive help associated with this function.">
			</mth>
			<mth name="/lib/:org.jext.dawn.CodeSnippet.getCode()" access="pub" jdoc="Returns the function code. This code must be written in Dawn scripting language. A code snippet can contains any Dawn function and also use the &amp;apos;needs&amp;apos; keyword to request the installation of a specific package. @return A &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt;, containing the code">
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.Dawn" intfc="n" abs="n" inn="n" sloc="86" jdoc="">
			<field name="line" access="priv" jdoc=""/>
			<field name="parser" access="priv" jdoc=""/>
			<field name="in" access="priv" jdoc=""/>
			<const name="consoleCode" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.dawn.Dawn.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.Dawn.console()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.Dawn.nativeConsole()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.DawnParser" intfc="n" abs="n" inn="n" sloc="578" jdoc="&amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; is the Dawn scripting language interpreter. Dawn is a language based on RPN. Dawn is also a very modulary language. Basic usage of Dawn is:&amp;lt;br&amp;gt; &amp;lt;pre&amp;gt; DawnParser.init(); code is a String containing the script DawnParser parser = new DawnParser(new StringReader(code)); try { parser.exec(); } catch (DawnRuntimeException dre) { System.err.println(dre.getMessage()); } &amp;lt; pre&amp;gt;&amp;lt;p&amp;gt; Note the call to &amp;lt;code&amp;gt;init()&amp;lt; code&amp;gt;. You may not want to call this method, but if you don&amp;apos;t, then Dawn will provide NO FUNCTION AT ALL. Even basic ones, like + - drop sto rcl, won&amp;apos;t work !! This is due to the fact Dawn can be entirely customized.&amp;lt;br&amp;gt; In fact, &amp;lt;code&amp;gt;init()&amp;lt; code&amp;gt; simply install basic packages (loop, test, util, stack, math, err, io, string, naming). But you can load only one, or many, of them and also install your own packages to replace default ones.&amp;lt;br&amp;gt; You may also load extra packages with the: &amp;lt;code&amp;gt;installPackage()&amp;lt; code&amp;gt; method.&amp;lt;p&amp;gt; Read the documentation for further informations. @author Romain Guy @version 1.1.1">
			<comm cntt="global functions loaded from packages"/>
			<comm cntt="global variables"/>
			<comm cntt="installed packages"/>
			<comm cntt="init flag"/>
			<comm cntt="it true, the parser stops"/>
			<comm cntt="properties set"/>
			<comm cntt="stream tokenizer: this is Dawn parser engine"/>
			<comm cntt="the stack where datas are put"/>
			<comm cntt="functions created on runtime"/>
			<comm cntt="variables created on runtime"/>
			<comm cntt="line number in the script"/>
			<comm cntt="standard streams"/>
			<comm cntt="reads a package file and get classes-to-be-loaded names. it also checks package"/>
			<comm cntt="dependencies. if a dependency is found, requested package is loaded"/>
			<const name="DAWN_VERSION" access="pub" jdoc="Gives Dawn interpreter version numbering"/>
			<const name="DAWN_NUMERIC_TYPE" access="pub" jdoc="Identifier for a stack element containing a numeric value"/>
			<const name="DAWN_STRING_TYPE" access="pub" jdoc="Identifier for a stack element containing a string"/>
			<const name="DAWN_LITERAL_TYPE" access="pub" jdoc="Identifier for a stack element defining a literal (variable name)"/>
			<const name="DAWN_ARRAY_TYPE" access="pub" jdoc="Identifier for a stack element defining an array"/>
			<field name="functions" access="priv" jdoc=""/>
			<field name="variables" access="priv" jdoc=""/>
			<field name="installedPackages" access="priv" jdoc=""/>
			<field name="installedRuntimePackages" access="priv" jdoc=""/>
			<field name="isInited" access="priv" jdoc=""/>
			<field name="stopped" access="priv" jdoc=""/>
			<field name="properties" access="priv" jdoc=""/>
			<field name="st" access="priv" jdoc=""/>
			<field name="stack" access="priv" jdoc=""/>
			<field name="runtimeFunctions" access="priv" jdoc=""/>
			<field name="runtimeVariables" access="priv" jdoc=""/>
			<field name="lineno" access="pub" jdoc=""/>
			<field name="out" access="pub" jdoc=""/>
			<field name="err" access="pub" jdoc=""/>
			<field name="in" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.dawn.DawnParser.init()" access="pub" jdoc="Initializes Dawn default packages. This is strongly recommended to call this method before any use of the parser.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.isInitialized()" access="pub" jdoc="Returns true if the parser has already been initialized. Dawn is considered initialized when a call to &amp;lt;code&amp;gt;init()&amp;lt; code&amp;gt; has been made.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.installPackage(String)" access="pub" jdoc="Installs a package from Dawn archive. @param packageName The package to load">
				<param name="packageName"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.installPackage(Class, String)" access="pub" jdoc="Installs a package specific to a given class. The class will give infos to both load the package file and the package classes. @param loader The &amp;lt;code&amp;gt;Class&amp;lt; code&amp;gt; which calls this, if the class is not part of Dawn standard package @param packageName The package to load">
				<param name="loader"/>
				<param name="packageName"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.installPackage(Class, String, DawnParser)" access="pub" jdoc="Installs a package specific to a given class. The class will give infos to both load the package file and the package classes. @param loader The &amp;lt;code&amp;gt;Class&amp;lt; code&amp;gt; which calls this, if the class is not part of Dawn standard package @param packageName The package to load @param parser If this parameter is not set to null, the package is loaded as runtime package">
				<comm cntt="check first if the package is already installed"/>
				<comm cntt="(case of packages dependencies)"/>
				<comm cntt="get classes to be loaded"/>
				<comm cntt="ClassLoader classLoader = loader.getClassLoader();"/>
				<comm cntt="load classes"/>
				<comm cntt=", true, classLoader);"/>
				<comm cntt="if class is null, we get rid of it"/>
				<comm cntt="we create an instance of the class to check it"/>
				<comm cntt="if it is a function, then we add it to the list"/>
				<comm cntt="it is a coded function, we build it"/>
				<param name="loader"/>
				<param name="packageName"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getClasses(Class, String)" access="priv" jdoc="">
				<param name="loader"/>
				<param name="packageName"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.DawnParser(Reader)" access="pub" jdoc="Creates a new parser. @param in A &amp;lt;code&amp;gt;Reader&amp;lt; code&amp;gt; which will deliver the script to the parser">
				<param name="in"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.setOut(PrintStream)" access="pub" jdoc="Sets the parser print stream. Default packages may pass informations through this stream (println function for instance). @param out The new &amp;lt;code&amp;gt;PrintStream&amp;lt; code&amp;gt;">
				<param name="out"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.setErr(PrintStream)" access="pub" jdoc="Sets the parser error print stream. Default packages may pass informations through this stream. @param err The new &amp;lt;code&amp;gt;PrintStream&amp;lt; code&amp;gt; used for errors">
				<param name="err"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.setIn(InputStream)" access="pub" jdoc="Sets the parser input stream. Default packages may pass informations through this stream (inputLine...) @param out The new &amp;lt;code&amp;gt;OutputStream&amp;lt; code&amp;gt;">
				<param name="in"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.setStream(StreamTokenizer)" access="pub" jdoc="Sets the &amp;lt;code&amp;gt;StreamTokenizer&amp;lt; code&amp;gt; used to execute a script. It is HIGHLY recommended NOT TO CALL this without a very good reason. @param _st The new stream where to get the script from">
				<param name="_st"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getStream()" access="pub" jdoc="Returns current &amp;lt;code&amp;gt;StreamTokenizer&amp;lt; code&amp;gt;. It is mostly used by functions to parse the script further. &amp;apos;if&amp;apos; statement from test package is a good example (see also for and while from the loop package).">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.createTokenizer(Reader)" access="pub" jdoc="Creates a new StreamTokenizer, setting its properties according to the Dawn scripting language specifications. the stream is built from a Reader which is most of the time a StringReader. @param in The &amp;lt;code&amp;gt;Reader&amp;lt; code&amp;gt; which will deliver the script">
				<param name="in"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getFunctions()" access="pub" jdoc="Returns an Hashtable containing all the current global functions.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getRuntimeFunctions()" access="pub" jdoc="Returns the set of runtimes functions. This is needed by installPackage() when the keyword &amp;apos;needsGlobal&amp;apos; is used in a script.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getStack()" access="pub" jdoc="Returns the stack which containes all the current availables datas.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.checkVarName(Function, String)" access="pub" jdoc="Checks if a given variable name is valid or not. @parma function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which called this method @param var The variable name to be tested">
				<param name="function"/>
				<param name="var"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.checkArgsNumber(Function, int)" access="pub" jdoc="Checks if stack contains enough datas to feed a function. @parma function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which called this method @param nb The amount of arguments needed">
				<param name="function"/>
				<param name="nb"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.checkEmpty(Function)" access="pub" jdoc="Checks if the stack is empty. @parma function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which called this method">
				<param name="function"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.checkLevel(Function, int)" access="pub" jdoc="Checks if a given level is bound in the limits of the stack. @parma function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which called this method @param level The level to be tested">
				<param name="function"/>
				<param name="level"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.setProperty(Object, Object)" access="pub" jdoc="Sets a property in the parser. Properties are used by external functions to store objects they may need later. @param name An &amp;lt;code&amp;gt;Object&amp;lt; code&amp;gt; describing the property. It stands for the key @param property The property value">
				<param name="name"/>
				<param name="property"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getProperty(Object)" access="pub" jdoc="Returns a property according a given key. @param name The property key">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.unsetProperty(Object)" access="pub" jdoc="Unsets (remove) a given property.">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.stop()" access="pub" jdoc="Stops the parser.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.exec()" access="pub" jdoc="Executes loaded script.">
				<comm cntt="end of script"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getVariables()" access="pub" jdoc="Returns the &amp;lt;code&amp;gt;Hashtable&amp;lt; code&amp;gt; which contains the local variables.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getGlobalVariables()" access="pub" jdoc="Returns the &amp;lt;code&amp;gt;Hashtable&amp;lt; code&amp;gt; which contains the global variables.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getVariable(String)" access="pub" jdoc="Returns the value of a given variable. Note that global variables got priority on runtime ones. @param var The variable to be recalled">
				<param name="var"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.setVariable(String, Object)" access="pub" jdoc="Sets a runtime variable. Runtime variables are stored temporarily. After the execution of the script, they are flushed. @param var The variable name @param value An &amp;lt;code&amp;gt;Object&amp;lt; code&amp;gt; containg the variable value">
				<param name="var"/>
				<param name="value"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.setGlobalVariable(String, Object)" access="pub" jdoc="Sets a global variable. Global variables are stored permanently, until the JVM is killed or until the method &amp;lt;code&amp;gt;clearGlobalVariables()&amp;lt; code&amp;gt; is called. @param var The variable name @param value An &amp;lt;code&amp;gt;Object&amp;lt; code&amp;gt; containg the variable value">
				<param name="var"/>
				<param name="value"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.clearGlobalVariables()" access="pub" jdoc="Clears all the global variables.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.lineno()" access="pub" jdoc="Returns current line number in the script.">
				<comm cntt="return st.lineno();"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.dump()" access="pub" jdoc="Returns a &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; containing a simple description of the current stack state. All the levels are shown, each labeled by its level number.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.popNumber()" access="pub" jdoc="Get topmost element of the stack and return is as a double value if it can. Otherwise, an exception is thrown. In any case, the element is removed from the stack.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.peekNumber()" access="pub" jdoc="Get topmost element of the stack and return is as a double value if it can. Otherwise, an exception is thrown.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.pushNumber(double)" access="pub" jdoc="Pushes a number on top of the stack. @param number The number to be put on the stack">
				<param name="number"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.popString()" access="pub" jdoc="Get the topmost element of the stack and returns it as a &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt;. If the string is enclosed by &amp;quot; quote characters, they are removed. The element is removed from the stack.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.peekString()" access="pub" jdoc="Get the topmost element of the stack and returns it as a &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt;. If the string is enclosed by &amp;quot; quote characters, they are removed.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.pushString(String)" access="pub" jdoc="Puts a &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; on top of the stack. @param str The string to be put on the stack">
				<param name="str"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.popArray()" access="pub" jdoc="Gets topmost stack element and returns it as a &amp;lt;code&amp;gt;Vector&amp;lt; code&amp;gt; which is the Java object for Dawn arrays. The element is removed from the stack.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.peekArray()" access="pub" jdoc="Gets topmost stack element and returns it as a &amp;lt;code&amp;gt;Vector&amp;lt; code&amp;gt; which is the Java object for Dawn arrays.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.pushArray(Vector)" access="pub" jdoc="Pushes an array on top of the stack. @param array The array to be put on the stack">
				<param name="array"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.pop()" access="pub" jdoc="Returns topmost objet of the stack and remove it.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.peek()" access="pub" jdoc="Returns topmost object of the stack.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.push(Object)" access="pub" jdoc="Puts an object on the top of the stack. @param obj The object to be put on the top">
				<param name="obj"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.isTopNumeric()" access="pub" jdoc="Tells wether topmost object is a numeric value or not.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.isTopString()" access="pub" jdoc="Tells wether topmost object is a string or not.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.isTopArray()" access="pub" jdoc="Tells wether topmost object is an array or not.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.isTopLiteral()" access="pub" jdoc="Tells wether topmost object is a literal identifier or not.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.getTopType()" access="pub" jdoc="Returns topmost stack element type.">
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.addGlobalFunction(Function)" access="pub" jdoc="Adds given function to the global functions list. @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; to be added">
				<param name="function"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.addRuntimeFunction(Function)" access="pub" jdoc="Adds given function to the runtime functions list. @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; to be added">
				<param name="function"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.createOnFlyFunction(String)" access="pub" jdoc="Creates dynamically a function which can execute the Dawn script passed in parameter. @param code The Dawn code which will be executed by the returned function on invoke() call">
				<comm cntt="copy changed variables"/>
				<param name="code"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.createGlobalFunction(String, String)" access="pub" jdoc="Creates dynamically a function which can execute the Dawn script passed in parameter. The function is added to the global functions list and not returned. @param name Function Dawn name @param code The Dawn code which will be executed by function">
				<param name="name"/>
				<param name="code"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnParser.createRuntimeFunction(String, String)" access="pub" jdoc="Creates dynamically a function which can execute the Dawn script passed in parameter. The function is added to the runtime functions list and not returned. @param name Function Dawn name @param code The Dawn code which will be executed by function">
				<param name="name"/>
				<param name="code"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.DawnRuntimeException" intfc="n" abs="n" inn="n" sloc="11" jdoc="&amp;lt;code&amp;gt;DawnRuntimeException&amp;lt; code&amp;gt; is thrown whenever a function encounter an error. Basically, this exception is thrown if a function is not implemented. Yet, many functions will use it to warn user (i.e: empty stack, not enough arguments, etc...).">
			<mth name="/lib/:org.jext.dawn.DawnRuntimeException.DawnRuntimeException(DawnParser, String)" access="pub" jdoc="Create a new exception. The message is built here to avoid keeping pointers to many other objects. @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; responsible of the invocation @param message A short description of the error">
				<param name="parser"/>
				<param name="message"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.DawnRuntimeException.DawnRuntimeException(Function, DawnParser, String)" access="pub" jdoc="Create a new exception. The message is built here to avoid keeping pointers to many other objects. @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which thrown the exception @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; responsible of the invocation @param message A short description of the error">
				<param name="function"/>
				<param name="parser"/>
				<param name="message"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.array">
		<class name="/lib/:org.jext.dawn.array.SetElementAtFunction" intfc="n" abs="n" inn="n" sloc="19" jdoc="Sets the element at given index.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;array object index setElementAt&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.array.SetElementAtFunction.SetElementAtFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.array.SetElementAtFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.array.ElementsFunction" intfc="n" abs="n" inn="n" sloc="17" jdoc="Adds a specified amount of elements.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;array amount elements&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.array.ElementsFunction.ElementsFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.array.ElementsFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.array.ElementAtFunction" intfc="n" abs="n" inn="n" sloc="18" jdoc="Returns the element stored at the given index of an array.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;array index elementAt&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; This function then pushes both the array and the object on the stack. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.array.ElementAtFunction.ElementAtFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.array.ElementAtFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.array.LengthFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Returns the length of a given array. The length of an array represents the total amount of elements put in it.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;array length&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Then this function pushes the array length AND the array on stack. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.array.LengthFunction.LengthFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.array.LengthFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.array.ClearArrayFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Removes all elements from a given array.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;array clearArray&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.array.ClearArrayFunction.ClearArrayFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.array.ClearArrayFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.array.AddElementFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Adds an element at the end of a given array.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;array object addElement&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Then, the array is pushed on the stack with the new object in it. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.array.AddElementFunction.AddElementFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.array.AddElementFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.array.RemoveElementAtFunction" intfc="n" abs="n" inn="n" sloc="18" jdoc="Removes the element at given index in an array.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;array index removeElementAt&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.array.RemoveElementAtFunction.RemoveElementAtFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.array.RemoveElementAtFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.array.InsertElementAtFunction" intfc="n" abs="n" inn="n" sloc="19" jdoc="Inserts the element at given index.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;array object index insertElementAt&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.array.InsertElementAtFunction.InsertElementAtFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.array.InsertElementAtFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.array.ArrayFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Creates a new array.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;array&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.array.ArrayFunction.ArrayFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.array.ArrayFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.err">
		<class name="/lib/:org.jext.dawn.err.ErrorFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Throws last error.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;err&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.err.ErrorFunction.ErrorFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.err.ErrorFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.err.ErrManager" intfc="n" abs="n" inn="n" sloc="11" jdoc="Handles last error. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.err.ErrManager.getErr(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.err.ErrManager.setErr(DawnParser, DawnRuntimeException)" access="pub" jdoc="">
				<param name="parser"/>
				<param name="dre"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.err.ErrMsgFunction" intfc="n" abs="n" inn="n" sloc="15" jdoc="Put last error message on stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;errMsg&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.err.ErrMsgFunction.ErrMsgFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.err.ErrMsgFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.err.TryCatchFunction" intfc="n" abs="n" inn="n" sloc="87" jdoc="Try catch block: catches any exception in the block and void the parser to stop.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;try [code] catch [code] err&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.err.TryCatchFunction.TryCatchFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.err.TryCatchFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="LONG LONG CATCH"/>
				<comm cntt="parser.lineno++;"/>
				<comm cntt="OUPS"/>
				<comm cntt="parser.exec();"/>
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.io">
		<class name="/lib/:org.jext.dawn.io.ReadFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Reads from an opened file, designed by its ID.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;ID read&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.ReadFunction.ReadFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.ReadFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.PrintFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Prints a string&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string print&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.PrintFunction.PrintFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.PrintFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.CloseFileFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Closes a file designed by its ID.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;ID closeFile&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.CloseFileFunction.CloseFileFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.CloseFileFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.WriteLineFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Writes a line to a file, designed by its ID.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string ID writeLine&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.WriteLineFunction.WriteLineFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.WriteLineFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.FileManager" intfc="n" abs="n" inn="n" sloc="128" jdoc="Manages the files for the whole IO package. This class provides functions to open close files and also to read write into them. Each opened file is stored as a property in &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt;. Each file is designed by a given ID.">
			<const name="NEW_LINE" access="pub" jdoc="Default line separator (system&amp;apos;s one) used by the file manager."/>
			<mth name="/lib/:org.jext.dawn.io.FileManager.openFileForInput(String, String, Function, DawnParser)" access="pub" jdoc="Opens a file for input (i.e to read from it). @param ID The file internal ID @param file The path, relative or absolute, to the file to be opened @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which is opening the file @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="ID"/>
				<param name="file"/>
				<param name="function"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileManager.openFileForOutput(String, String, Function, DawnParser)" access="pub" jdoc="Opens a file for output (i.e to write into it). @param ID The file internal ID @param file The path, relative or absolute, to the file to be opened created @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which is opening the file @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="ID"/>
				<param name="file"/>
				<param name="function"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileManager.readLine(String, Function, DawnParser)" access="pub" jdoc="Reads a line from a given file. @param ID The file internal ID @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which is opening the file @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="ID"/>
				<param name="function"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileManager.read(String, Function, DawnParser)" access="pub" jdoc="Reads a character from a given file. @param ID The file internal ID @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which is opening the file @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="ID"/>
				<param name="function"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileManager.read(boolean, String, Function, DawnParser)" access="pub" jdoc="Reads from a file according to the &amp;lt;code&amp;gt;line&amp;lt; code&amp;gt; parameter.. @param line If true, a whole line is read. Otherwise, only a char is read. @param ID The file internal ID @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which is opening the file @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="line"/>
				<param name="ID"/>
				<param name="function"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileManager.writeLine(String, String, Function, DawnParser)" access="pub" jdoc="Writes a line into a given file (write the text then adds a return char). @param ID The file internal ID @param line The line to be written @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which is opening the file @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="ID"/>
				<param name="line"/>
				<param name="function"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileManager.write(String, String, Function, DawnParser)" access="pub" jdoc="Writes a line into a given file (does not add a return char). @param ID The file internal ID @param line The line to be written @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which is opening the file @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="ID"/>
				<param name="line"/>
				<param name="function"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileManager.write(boolean, String, String, Function, DawnParser)" access="pub" jdoc="Writes a line into a given file. The return char is added according to the &amp;lt;code&amp;gt;isLine&amp;lt; code&amp;gt; parameter. @param isLine If true, the &amp;lt;code&amp;gt;NEW_LINE&amp;lt; code&amp;gt; value is added to the line @param ID The file internal ID @param line The line to be written @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which is opening the file @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="isLine"/>
				<param name="ID"/>
				<param name="line"/>
				<param name="function"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileManager.closeFile(String, Function, DawnParser)" access="pub" jdoc="Closes a given file. @param ID The file internal ID @param function The &amp;lt;code&amp;gt;Function&amp;lt; code&amp;gt; which is opening the file @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="ID"/>
				<param name="function"/>
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileManager.isFileAvailable(String, DawnParser)" access="pub" jdoc="Checks if a given file is still available or not. @param ID The file internal ID @param parser The &amp;lt;code&amp;gt;DawnParser&amp;lt; code&amp;gt; which is executing the above function">
				<param name="ID"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.FileSizeFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Returns the size of a given file.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;file fileSize&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.FileSizeFunction.FileSizeFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.FileSizeFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.PrintlnFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Prints a string, adding a line feed at the end.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string println&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.PrintlnFunction.PrintlnFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.PrintlnFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.ExistFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Check if a given file exists on HD.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;file exists&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.ExistFunction.ExistFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.ExistFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.ReadLineFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Reads a line from an opened file, designed by its ID.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;ID readLine&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.ReadLineFunction.ReadLineFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.ReadLineFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.InputLineFunction" intfc="n" abs="n" inn="n" sloc="19" jdoc="Inputs a line.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;inputLine&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.InputLineFunction.InputLineFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.InputLineFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.OpenInputFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Opens a file from the HD. The opened file is designed by an ID.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;file ID openForInput&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Where file and ID are both string. First one is the path to the file - which can be either absolute, either relative -, and the second one is the file ID. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.OpenInputFunction.OpenInputFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.OpenInputFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.OpenOutputFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Opens a file from the HD to write in it. The opened file is designed by an ID.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;file ID openForOutput&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Where file and ID are both string. First one is the path to the file - which can be either absolute, either relative -, and the second one is the file ID. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.OpenOutputFunction.OpenOutputFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.OpenOutputFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.LineSeparatorFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="As each OS has a different line separator (\n, \r\n, etc...), this function puts the OS one on the stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;lineSeparator&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.LineSeparatorFunction.LineSeparatorFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.LineSeparatorFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.WriteFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Writes a string to a file, designed by its ID.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string ID write&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.WriteFunction.WriteFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.WriteFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.io.IsAvailableFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Checks if a specified file is still available.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;ID isFileAvailable&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.io.IsAvailableFunction.IsAvailableFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.io.IsAvailableFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.javaccess">
		<class name="/lib/:org.jext.dawn.javaccess.InvokeFunction" intfc="n" abs="n" inn="n" sloc="71" jdoc="Invokes a method.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;object parameters method invoke&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns the result of the invocation if any. @author Guillaume Desnoix">
			<mth name="/lib/:org.jext.dawn.javaccess.InvokeFunction.InvokeFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.javaccess.InvokeFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;RESULT = &amp;quot;+r);"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.javaccess.ConstructorFunction" intfc="n" abs="n" inn="n" sloc="43" jdoc="Returns a constructor.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;class string constructor&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns the constructor of the given class and declaration. @author Guillaume Desnoix">
			<mth name="/lib/:org.jext.dawn.javaccess.ConstructorFunction.ConstructorFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.javaccess.ConstructorFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;RESULT=&amp;quot;+r);"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.javaccess.ClassFunction" intfc="n" abs="n" inn="n" sloc="20" jdoc="Returns a class.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string class&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns the class of the given name. @author Guillaume Desnoix">
			<mth name="/lib/:org.jext.dawn.javaccess.ClassFunction.ClassFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.javaccess.ClassFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;RESULT=&amp;quot;+r);"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.javaccess.NullFunction" intfc="n" abs="n" inn="n" sloc="15" jdoc="Return NULL. Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns NULL. @author Guillaume Desnoix">
			<const name="NULL" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.dawn.javaccess.NullFunction.NullFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.javaccess.NullFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.javaccess.FieldFunction" intfc="n" abs="n" inn="n" sloc="27" jdoc="Returns a field.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;class string field&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns the field of the given class and declaration. @author Guillaume Desnoix">
			<mth name="/lib/:org.jext.dawn.javaccess.FieldFunction.FieldFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.javaccess.FieldFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;RESULT=&amp;quot;+r);"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.javaccess.MethodFunction" intfc="n" abs="n" inn="n" sloc="43" jdoc="Returns a method.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;class string method&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns the method of the given class and declaration. @author Guillaume Desnoix">
			<mth name="/lib/:org.jext.dawn.javaccess.MethodFunction.MethodFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.javaccess.MethodFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;RESULT=&amp;quot;+r);"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.javaccess.NewFunction" intfc="n" abs="n" inn="n" sloc="94" jdoc="Create an object. Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;class new&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns the new instance. @author Guillaume Desnoix">
			<mth name="/lib/:org.jext.dawn.javaccess.NewFunction.NewFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.javaccess.NewFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.javaccess.NewFunction.useDefaultConstructor(DawnParser, Class)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;RESULT=&amp;quot;+r);"/>
				<param name="parser"/>
				<param name="clazz"/>
			</mth>
			<mth name="/lib/:org.jext.dawn.javaccess.NewFunction.invokeConstructor(DawnParser, Constructor)" access="priv" jdoc="">
				<comm cntt="this code is the same than invoke() in InvokeFunction."/>
				<param name="parser"/>
				<param name="c"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.loop">
		<class name="/lib/:org.jext.dawn.loop.DoLoopFunction" intfc="n" abs="n" inn="n" sloc="91" jdoc="Do loop.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;do [code] loop expression until&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.loop.DoLoopFunction.DoLoopFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.loop.DoLoopFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="LONG LONG CATCH"/>
				<comm cntt="parser.lineno++;"/>
				<comm cntt="parser.lineno++;"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.loop.ForFunction" intfc="n" abs="n" inn="n" sloc="87" jdoc="For loop.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;start end variable for [code] next&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.loop.ForFunction.ForFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.loop.ForFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="LONG LONG TRY"/>
				<comm cntt="parser.lineno++;"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.loop.WhileFunction" intfc="n" abs="n" inn="n" sloc="89" jdoc="While loop.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;while expression repeat [code] wend&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.loop.WhileFunction.WhileFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.loop.WhileFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="LONG LONG CATCH"/>
				<comm cntt="parser.lineno++;"/>
				<comm cntt="parser.lineno++;"/>
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.math">
		<class name="/lib/:org.jext.dawn.math.FactFunction" intfc="n" abs="n" inn="n" sloc="18" jdoc="! operator&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number !&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.FactFunction.FactFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.FactFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.PowerFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="^ operator&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number number ^&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.PowerFunction.PowerFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.PowerFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.CosFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns the cosinus of a numeric value.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number cos&amp;lt; code&amp;gt;. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.CosFunction.CosFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.CosFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.IncreaseFunction" intfc="n" abs="n" inn="n" sloc="25" jdoc="Increases a numeric value (which can be in a variable) by one.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number ++&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;var ++&amp;lt; code&amp;gt;. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.IncreaseFunction.IncreaseFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.IncreaseFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.DecreaseFunction" intfc="n" abs="n" inn="n" sloc="25" jdoc="Decreases a numeric value (which can be in a variable) by one.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number --&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;var --&amp;lt; code&amp;gt;. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.DecreaseFunction.DecreaseFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.DecreaseFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.SqrtFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="square root operator&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number sqrt&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.SqrtFunction.SqrtFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.SqrtFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.ArcSinFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns the arc sinus of a numeric value.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number asin&amp;lt; code&amp;gt;. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.ArcSinFunction.ArcSinFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.ArcSinFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.PiFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="PI constant. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.PiFunction.PiFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.PiFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.InvertFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns the inverse value of a numeric value.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number inv&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.InvertFunction.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.InvertFunction.getCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.ModuloFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="% operator&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number number %&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.ModuloFunction.ModuloFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.ModuloFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.TanFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns the tangeant of a numeric value.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number tan&amp;lt; code&amp;gt;. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.TanFunction.TanFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.TanFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.RoundFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Rounds a numeric value.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number round&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.RoundFunction.RoundFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.RoundFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.MinusFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="- operator&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number number -&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.MinusFunction.MinusFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.MinusFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.ArcCosFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns the arc cosinus of a numeric value.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number acos&amp;lt; code&amp;gt;. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.ArcCosFunction.ArcCosFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.ArcCosFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.TimesFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="operator&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number number &amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.TimesFunction.TimesFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.TimesFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.PlusFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="+ operator&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number number +&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.PlusFunction.PlusFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.PlusFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.ArcTanFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns the arc tangeant of a numeric value.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number atan&amp;lt; code&amp;gt;. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.ArcTanFunction.ArcTanFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.ArcTanFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.EFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="E constant. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.EFunction.EFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.EFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.SinFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns the sinus of a numeric value.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number sin&amp;lt; code&amp;gt;. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.SinFunction.SinFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.SinFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.NegFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns the opposite value of a numeric value.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number neg&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.NegFunction.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.NegFunction.getCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.math.DivideFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="operator&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number number &amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.math.DivideFunction.DivideFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.math.DivideFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.naming">
		<class name="/lib/:org.jext.dawn.naming.CreateFunction" intfc="n" abs="n" inn="n" sloc="53" jdoc="Creates a new function.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string function [code] endFunction&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Where &amp;apos;strings&amp;apos; holds function name. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.naming.CreateFunction.CreateFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.naming.CreateFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="parser.lineno++;"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.naming.CreateGlobalFunction" intfc="n" abs="n" inn="n" sloc="53" jdoc="Creates a new global function.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string global [code] endGlobal&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Where &amp;apos;strings&amp;apos; holds function name. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.naming.CreateGlobalFunction.CreateGlobalFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.naming.CreateGlobalFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="parser.lineno++;"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.naming.FromLiteralFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Turns a literal into a string. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.naming.FromLiteralFunction.FromLiteralFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.naming.FromLiteralFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.naming.ToLiteralFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Turns a string into a literal @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.naming.ToLiteralFunction.ToLiteralFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.naming.ToLiteralFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.stack">
		<class name="/lib/:org.jext.dawn.stack.RclFunction" intfc="n" abs="n" inn="n" sloc="30" jdoc="Recalls a variable value on the stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;variable rcl&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.RclFunction.RclFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.RclFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.DupDupFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Duplicates topmost stack element twice.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;element dupdup&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.DupDupFunction.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.DupDupFunction.getCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.UnrotFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Rolls down three elements of the stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;unrot&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.UnrotFunction.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.UnrotFunction.getCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.StoFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Store topmost stack value into a variable.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;value variable sto&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.StoFunction.StoFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.StoFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.RotFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Rolls three elements of the stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;rot&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.RotFunction.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.RotFunction.getCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.RollFunction" intfc="n" abs="n" inn="n" sloc="22" jdoc="Rotates the n first elements of the stack by putting each one to the next level but the first one which goes on top.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number roll&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.RollFunction.RollFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.RollFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.DepthFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns the depth (size) of the stack. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.DepthFunction.DepthFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.DepthFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.DupnFunction" intfc="n" abs="n" inn="n" sloc="16" jdoc="Duplicate n first stack elements.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number dupn&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.DupnFunction.DupnFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.DupnFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.DupFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Duplicate topmost stack object.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;dup&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.DupFunction.DupFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.DupFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.DropnFunction" intfc="n" abs="n" inn="n" sloc="15" jdoc="Drop n succesive objects from stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number dropn&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.DropnFunction.DropnFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.DropnFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.RollDownFunction" intfc="n" abs="n" inn="n" sloc="22" jdoc="Rotates the n first elements of the stack by putting each one to the previous level but the first one which goes at last pos.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number rolld&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.RollDownFunction.RollDownFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.RollDownFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.ClearFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Clears stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;clear&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.ClearFunction.ClearFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.ClearFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.NDupFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Duplicate n times topmost stack object.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number ndup&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.NDupFunction.NDupFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.NDupFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.SwapFunction" intfc="n" abs="n" inn="n" sloc="15" jdoc="Swaps topmost object with next one.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;swap&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.SwapFunction.SwapFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.SwapFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.SetFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Set the topmost stack value into a variable.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;value variable -&amp;gt;&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.SetFunction.SetFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.SetFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.ReverseFunction" intfc="n" abs="n" inn="n" sloc="18" jdoc="Reverses the stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;rev&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.ReverseFunction.ReverseFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.ReverseFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.PickFunction" intfc="n" abs="n" inn="n" sloc="15" jdoc="Picks an object on any stack level and duplicate it.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number oick&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.PickFunction.PickFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.PickFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.stack.DropFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Drop topmost stack object.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;drop&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.stack.DropFunction.DropFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.stack.DropFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.string">
		<class name="/lib/:org.jext.dawn.string.HeadFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Get first char of a string.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string head&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.HeadFunction.HeadFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.HeadFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.NumFunction" intfc="n" abs="n" inn="n" sloc="16" jdoc="Returns the ascii value of each char of a given String.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string num&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.NumFunction.NumFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.NumFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.FromStringFunction" intfc="n" abs="n" inn="n" sloc="16" jdoc="Turns a numeric value into a String. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.FromStringFunction.FromStringFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.FromStringFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.TokenizeDelimFunction" intfc="n" abs="n" inn="n" sloc="16" jdoc="Tokenizes a string using a specified set of delimiters.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string delims tokenize&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; It then returns a string per token and the number of tokens on the top of the stack. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.TokenizeDelimFunction.TokenizeDelimFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.TokenizeDelimFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="parser.checkArgsNumber(this, 2);"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.TrimFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Trims (remove blanks spaces at the beginning and at the end) a string.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string trim&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.TrimFunction.TrimFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.TrimFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.ChrFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Turns a numeric value into a single character string.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;number chr&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.ChrFunction.ChrFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.ChrFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.EndsWithFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Test if a string ends with another one.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string1 string2 endsWith&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns 1.0 if string1 ends with string2. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.EndsWithFunction.EndsWithFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.EndsWithFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.TokenizeFunction" intfc="n" abs="n" inn="n" sloc="16" jdoc="Tokenizes a string using a set of default delimiters: &amp;quot;\n \r\f\t&amp;quot;&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string tokenize&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; It then returns a string per token and the number of tokens on the top of the stack. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.TokenizeFunction.TokenizeFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.TokenizeFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.UpperCaseFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Turn any lower case char from a string into the upper case equivalent.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string upperCase&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.UpperCaseFunction.UpperCaseFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.UpperCaseFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.SizeFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Returns the size of a string.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string size&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.SizeFunction.SizeFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.SizeFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.ToStringFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Turns an element to a string @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.ToStringFunction.ToStringFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.ToStringFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.PosFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Returns the index of a string in another one.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string1 string2 pos&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns index of string2 in string1. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.PosFunction.PosFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.PosFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.ConcatFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Concates two strings into a single one.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string string concat&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.ConcatFunction.ConcatFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.ConcatFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.SubFunction" intfc="n" abs="n" inn="n" sloc="21" jdoc="Returns a part of a string.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string start end sub&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns the portion of &amp;apos;string&amp;apos; between start and end. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.SubFunction.SubFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.SubFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.TailFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Get first char of a string.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string Tail&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.TailFunction.TailFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.TailFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.LastPosFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Returns the last index of a string in another one.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string1 string2 lastPos&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns last index of string2 in string1. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.LastPosFunction.LastPosFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.LastPosFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.LowerCaseFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Turn any upper case char from a string into the lower case equivalent.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string lowerCase&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.LowerCaseFunction.LowerCaseFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.LowerCaseFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.TokenizeArrayFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Tokenizes a string and store result in an array.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string tokenizeArray&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.TokenizeArrayFunction.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.TokenizeArrayFunction.getCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.CharAtFunction" intfc="n" abs="n" inn="n" sloc="16" jdoc="Gets a character in a string.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string position charAt&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.CharAtFunction.CharAtFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.CharAtFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.string.StartsWithFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Test if a string begins with another one.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string1 string2 startsWith&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns 1.0 if string1 begins with string2. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.string.StartsWithFunction.StartsWithFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.string.StartsWithFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.test">
		<class name="/lib/:org.jext.dawn.test.LowerThanFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;lower than&amp;apos; function.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right &amp;gt;&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns &amp;lt;code&amp;gt;1.0&amp;lt; code&amp;gt; if true. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.LowerThanFunction.LowerThanFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.LowerThanFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.GreaterThanFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;greater than&amp;apos; function.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right &amp;lt;&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns &amp;lt;code&amp;gt;1.0&amp;lt; code&amp;gt; if true. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.GreaterThanFunction.GreaterThanFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.GreaterThanFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.LowerEqualsFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;lower equals&amp;apos; function.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right &amp;gt;=&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns &amp;lt;code&amp;gt;1.0&amp;lt; code&amp;gt; if true. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.LowerEqualsFunction.LowerEqualsFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.LowerEqualsFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.NotFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Simple &amp;apos;not (!)&amp;apos; operator.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left not&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @authNot Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.NotFunction.NotFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.NotFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.GetTypeFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Gets type of topmost element: 0 (numeric), 1 (string) or 2 (literal)&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;element type&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.GetTypeFunction.GetTypeFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.GetTypeFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.SameFunction" intfc="n" abs="n" inn="n" sloc="15" jdoc="Tests if two objects are the same. This works as &amp;apos;==&amp;apos; concerning numeric values.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right same&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @authSame Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.SameFunction.SameFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.SameFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.IfFunction" intfc="n" abs="n" inn="n" sloc="99" jdoc="This class provides an implementation of the if else statement.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;if [condition] then [code] else [code] end&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; else is optional. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.IfFunction.IfFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.IfFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="LONG LONG TRY"/>
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.IsArrayFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;is array&amp;apos; test.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;element isArray&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.IsArrayFunction.IsArrayFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.IsArrayFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.AndFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;and (&amp;&amp;)&amp;apos; operator.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right and&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.AndFunction.AndFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.AndFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.EqualsFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;equals&amp;apos; function.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right ==&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns &amp;lt;code&amp;gt;1.0&amp;lt; code&amp;gt; if true. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.EqualsFunction.EqualsFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.EqualsFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.IsLiteralFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;is literal&amp;apos; test.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;element isLiteral&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.IsLiteralFunction.IsLiteralFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.IsLiteralFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.GreaterEqualsFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;greater equals&amp;apos; function.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right &amp;lt;=&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns &amp;lt;code&amp;gt;1.0&amp;lt; code&amp;gt; if true. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.GreaterEqualsFunction.GreaterEqualsFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.GreaterEqualsFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.DifferentFromFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;different from&amp;apos; function.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right !=&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Returns &amp;lt;code&amp;gt;1.0&amp;lt; code&amp;gt; if true. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.DifferentFromFunction.DifferentFromFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.DifferentFromFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.XorFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;xor (^)&amp;apos; operator.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right xor&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.XorFunction.XorFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.XorFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.SameTypeFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Tests the type of two given elements.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;element element sameType&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.SameTypeFunction.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.SameTypeFunction.getCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.IsStringFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;is string&amp;apos; test.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;element isString&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.IsStringFunction.IsStringFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.IsStringFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.BinAndFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;binary and (&amp;)&amp;apos; operator.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right &amp;&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.BinAndFunction.BinAndFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.BinAndFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.IsNumericFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;is numeric&amp;apos; test.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;element isNumeric&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.IsNumericFunction.IsNumericFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.IsNumericFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.BinOrFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;binary or (|)&amp;apos; operator.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right |&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.BinOrFunction.BinOrFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.BinOrFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.test.OrFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Simple &amp;apos;Or (||)&amp;apos; operator.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;left right or&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.test.OrFunction.OrFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.test.OrFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.dawn.util">
		<class name="/lib/:org.jext.dawn.util.ExitFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Exits the scripts. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.ExitFunction.ExitFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.ExitFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.DateFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Displays date. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.DateFunction.DateFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.DateFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.RdzFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Sets random seed.. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.RdzFunction.RdzFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.RdzFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.RandomizeFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Resets random seed (can be useful if you called &amp;apos;rdz&amp;apos; before). @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.RandomizeFunction.RandomizeFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.RandomizeFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.FormattedDateFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Displays a formatted date.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;format fdate&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Format example: &amp;quot;MM dd yyyy - HH:mm:ss&amp;quot;&amp;lt;br&amp;gt; MM stands for month, dd for day, yyyy for year, HH for hours, mm for minutes and ss for seconds. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.FormattedDateFunction.FormattedDateFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.FormattedDateFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.ConstructPathFunction" intfc="n" abs="n" inn="n" sloc="14" jdoc="Constructs an absolute path from a relative path.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;path constructPath&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.ConstructPathFunction.ConstructPathFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.ConstructPathFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.ScriptExecFunction" intfc="n" abs="n" inn="n" sloc="28" jdoc="Executes another script.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string run&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; Where string is the path (absolute or relative) to a script. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.ScriptExecFunction.ScriptExecFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.ScriptExecFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.HelpFunction" intfc="n" abs="n" inn="n" sloc="22" jdoc="Displays all the available functions. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.HelpFunction.HelpFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.HelpFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.DumpFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Dumps the stack. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.DumpFunction.DumpFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.DumpFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.RandomFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Returns a random number. @author Romain Guy">
			<field name="_random" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.dawn.util.RandomFunction.RandomFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.RandomFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.TimeFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Returns time in milliseconds. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.TimeFunction.TimeFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.TimeFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.WaitFunction" intfc="n" abs="n" inn="n" sloc="15" jdoc="Waits for a given delay (in seconds).&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;delay wait&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.WaitFunction.WaitFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.WaitFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.ExecFunction" intfc="n" abs="n" inn="n" sloc="21" jdoc="Executes an OS command.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;string exec&amp;lt; code&amp;gt;&amp;lt;b&amp;gt; Where string contains the command to be executed. When command terminates, Dawn pushes the exit code on stack. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.ExecFunction.ExecFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.ExecFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.VersionFunction" intfc="n" abs="n" inn="n" sloc="11" jdoc="Pushes Dawn version on the stack. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.VersionFunction.VersionFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.VersionFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.dawn.util.EvalFunction" intfc="n" abs="n" inn="n" sloc="20" jdoc="Evaluates a string as a code snippet. @author Romain Guy">
			<mth name="/lib/:org.jext.dawn.util.EvalFunction.EvalFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.dawn.util.EvalFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.event">
		<class name="/lib/:org.jext.event.JextEvent" intfc="n" abs="n" inn="n" sloc="46" jdoc="The &amp;lt;code&amp;gt;JextEvent&amp;lt; code&amp;gt; emitted by Jext windows on the order of a &amp;lt;code&amp;gt;Jext&amp;lt; code&amp;gt; instance or on the order of another class (&amp;lt;code&amp;gt;JextTextArea&amp;lt; code&amp;gt; for example). @author Romain Guy @see org.jext.event.JextListener">
			<comm cntt="text area specific"/>
			<comm cntt="private"/>
			<const name="PROPERTIES_CHANGED" access="pub" jdoc="Event type indicating a change of the options"/>
			<const name="SYNTAX_MODE_CHANGED" access="pub" jdoc="Event type indicating a change of the colorizing syntax mode"/>
			<const name="CHANGED_UPDATE" access="pub" jdoc="Event type indicating a change in a text area"/>
			<const name="INSERT_UPDATE" access="pub" jdoc="Event type indicating an insertion in a text area"/>
			<const name="REMOVE_UPDATE" access="pub" jdoc="Event type indicating a removing in a text area"/>
			<const name="FILE_OPENED" access="pub" jdoc="Event type indicating a file was opened"/>
			<const name="FILE_CLEARED" access="pub" jdoc="Event type indicating a file was cleared (new)"/>
			<const name="BATCH_MODE_SET" access="pub" jdoc="Event type indicating batch mode is on"/>
			<const name="BATCH_MODE_UNSET" access="pub" jdoc="Event type indicating batch mode is off"/>
			<const name="TEXT_AREA_FOCUS_GAINED" access="pub" jdoc="Event type indicating current selected text area has gained focus. UNUSED"/>
			<const name="TEXT_AREA_SELECTED" access="pub" jdoc="Event type indicating current selected text area has changed"/>
			<const name="TEXT_AREA_OPENED" access="pub" jdoc="Event type indicating a new text area is available"/>
			<const name="TEXT_AREA_CLOSED" access="pub" jdoc="Event type indicating a text area was closed"/>
			<const name="OPENING_WINDOW" access="pub" jdoc="Event type indicating a new window was opened"/>
			<const name="CLOSING_WINDOW" access="pub" jdoc="Event type indicating a window was closed"/>
			<const name="KILLING_JEXT" access="pub" jdoc="Event type indicating the last Jext window is being killed, and maybe Jext itself. In the background mode, in fact, when the last window of Jext is closed, you&amp;apos;ll get this event and you should, i.e., save properties; but when a new window is created, the start method won&amp;apos;t be called, so it won&amp;apos;t be able to reinitialize freed resources. If Jext instead is completely closed, Plugin.stop() is called. But it is not assured that the stop method will be called, for instance if the user shutdowns the PC while Jext is still in the bg(and the user won&amp;apos;t close Jext when it&amp;apos;s in the BG). So don&amp;apos;t rely on stop()."/>
			<field name="event" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.event.JextEvent.JextEvent(JextFrame, int)" access="pub" jdoc="Creates a new JextEvent, registering the parent of this event, the type of the event and also the text area which was selected when event was created. @param parent &amp;lt;code&amp;gt;Jext&amp;lt; code&amp;gt; parent @param eventType A int value which determine the nature of the event">
				<param name="parent"/>
				<param name="eventType"/>
			</mth>
			<mth name="/lib/:org.jext.event.JextEvent.JextEvent(JextFrame, JextTextArea, int)" access="pub" jdoc="Creates a new JextEvent, registering the parent of this event, the type of the event and also the text area which was selected when event was created. @param parent &amp;lt;code&amp;gt;Jext&amp;lt; code&amp;gt; parent @param The event related text area @param eventType A int value which determine the nature of the event">
				<param name="parent"/>
				<param name="textArea"/>
				<param name="eventType"/>
			</mth>
			<mth name="/lib/:org.jext.event.JextEvent.getWhat()" access="pub" jdoc="Returns the type of event. @return A int indicating the type of the fired event">
			</mth>
			<mth name="/lib/:org.jext.event.JextEvent.getJextFrame()" access="pub" jdoc="Returns the &amp;lt;code&amp;gt;Jext&amp;lt; code&amp;gt; parent from which the event has been fired. @return A &amp;lt;code&amp;gt;Jext&amp;lt; code&amp;gt; instance, indicating which window has fired the event">
			</mth>
			<mth name="/lib/:org.jext.event.JextEvent.getTextArea()" access="pub" jdoc="Returns the text area which was visible when the event has been fired as the selected text area may have changed when event is received due to the action of another listener. @return A &amp;lt;code&amp;gt;JextTextArea&amp;lt; code&amp;gt; designating the selected text area when event has been fired">
			</mth>
		</class>
		<class name="/lib/:org.jext.event.JextListener" intfc="y" abs="n" inn="n" sloc="4" jdoc="The listener interface for receiving Jext events. This events can be of different kinds: options change, text area change, etc... @author Romain Guy">
			<mth name="/lib/:org.jext.event.JextListener.jextEventFired(JextEvent)" access="pub" jdoc="Invoked when a class fires a &amp;lt;code&amp;gt;JextEvent&amp;lt; code&amp;gt; object by the method &amp;lt;code&amp;gt;fireJextEvent(short eventType)&amp;lt; code&amp;gt; in &amp;lt;code&amp;gt;Jext&amp;lt; code&amp;gt; class. @param evt The received &amp;lt;code&amp;gt;JextEvent&amp;lt; code&amp;gt;">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.gui">
		<class name="/lib/:org.jext.gui.JextLabeledMenuSeparatorUI" intfc="n" abs="n" inn="n" sloc="42" jdoc="">
			<field name="stext" access="priv" jdoc=""/>
			<field name="labelFont" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextLabeledMenuSeparatorUI.JextLabeledMenuSeparatorUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextLabeledMenuSeparatorUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextLabeledMenuSeparatorUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<param name="g"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextLabeledMenuSeparatorUI.getPreferredSize(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.AbstractOptionPane" intfc="n" abs="n" inn="n" sloc="56" jdoc="Abstract implementation of the &amp;lt;code&amp;gt;OptionPane&amp;lt; code&amp;gt; interface.">
			<comm cntt="private fields"/>
			<field name="y" access="prot" jdoc=""/>
			<field name="gridBag" access="prot" jdoc=""/>
			<field name="name" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.AbstractOptionPane.isCacheable()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.AbstractOptionPane.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.AbstractOptionPane.addComponent(String, Component)" access="prot" jdoc="Adds a labeled component in the pane. All the components are placed on bottom of each other (vertically sorted). @param label The label to be displayed next to the component @param comp The component to be added">
				<param name="label"/>
				<param name="comp"/>
			</mth>
			<mth name="/lib/:org.jext.gui.AbstractOptionPane.addComponent(Component)" access="prot" jdoc="Does the same as &amp;lt;code&amp;gt;addComponent(String, Component)&amp;lt; code&amp;gt; but don&amp;apos;t add a label next to the component. @param comp The component to be added">
				<param name="comp"/>
			</mth>
			<mth name="/lib/:org.jext.gui.AbstractOptionPane.AbstractOptionPane(String)" access="pub" jdoc="Creates a new option pane. @param name The name used by OptionDialog to display title">
				<comm cntt="Jext.getProperty(&amp;quot;options.&amp;quot; + name + &amp;quot;.label&amp;quot;);"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.gui.AbstractOptionPane.getComponent()" access="pub" jdoc="Returns itself.">
			</mth>
			<mth name="/lib/:org.jext.gui.AbstractOptionPane.getName()" access="pub" jdoc="Overrides default getName() method. Needed by tabbed panes to display a title on the parent tab.">
			</mth>
			<mth name="/lib/:org.jext.gui.AbstractOptionPane.save()" access="pub" jdoc="Empty implementation of save() method, inherited from the OptionPane interface.">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.VoidComponent" intfc="n" abs="n" inn="n" sloc="40" jdoc="&amp;lt;code&amp;gt;VoidComponent&amp;lt; code&amp;gt; is a component of both height and width set to zero which cannot contain anything.">
			<field name="zero" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.VoidComponent.getHeight()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.VoidComponent.getMaximumSize()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.VoidComponent.getMinimumSize()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.VoidComponent.getPreferredSize()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.VoidComponent.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.VoidComponent.getWidth()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.VoidComponent.paint(Graphics)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/lib/:org.jext.gui.VoidComponent.setSize(Dimension)" access="pub" jdoc="">
				<param name="d"/>
			</mth>
			<mth name="/lib/:org.jext.gui.VoidComponent.setSize(int, int)" access="pub" jdoc="">
				<param name="w"/>
				<param name="h"/>
			</mth>
			<mth name="/lib/:org.jext.gui.VoidComponent.update(Graphics)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.SplashScreen" intfc="n" abs="n" inn="n" sloc="103" jdoc="Splash screen. This class can also load classes listed in file classlist.">
			<comm cntt="private fields"/>
			<comm cntt="get the classes to be loaded from the file &amp;apos;classlist&amp;apos;."/>
			<field name="thread" access="priv" jdoc=""/>
			<field name="finished" access="priv" jdoc=""/>
			<field name="classes" access="priv" jdoc=""/>
			<field name="progress" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.SplashScreen.SplashScreen()" access="pub" jdoc="Creates a new splash screen which displays a picture, a copyright and a progress bar used to indicate the loading progress of the application.">
			</mth>
			<mth name="/lib/:org.jext.gui.SplashScreen.createClassesList()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.SplashScreen.run()" access="pub" jdoc="Loads the classes dinamycally from the list.">
			</mth>
			<mth name="/lib/:org.jext.gui.SplashScreen.setText(String)" access="pub" jdoc="Sets the current text of the progress bar but only in the case the loading of classes is ended.">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.gui.SplashScreen.setProgress(int)" access="pub" jdoc="Sets the current progress value of the progress bar but only in the case the loading of classes is ended.">
				<param name="percent"/>
			</mth>
			<mth name="/lib/:org.jext.gui.SplashScreen.stop()" access="pub" jdoc="Stop the loading process.">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.SkinManager" intfc="n" abs="n" inn="n" sloc="51" jdoc="">
			<comm cntt="we remember the last apply()ed to unapply() it."/>
			<field name="skinList" access="priv" jdoc=""/>
			<field name="currSkin" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.SkinManager.SkinManager()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.SkinManager.getSkinList()" access="pub" jdoc="This internal method returns an HashMap containing all available skins.">
				<comm cntt="this should be modified, maybe; used in org.jext.options."/>
				<comm cntt="UIOptions"/>
			</mth>
			<mth name="/lib/:org.jext.gui.SkinManager.registerSkinFactory(SkinFactory)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Added a SkinFactory named: &amp;quot; + sf.getClass().getName());"/>
				<param name="sf"/>
			</mth>
			<mth name="/lib/:org.jext.gui.SkinManager.applySelectedSkin()" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;The current skin is:&amp;quot; + Jext.getProperty(&amp;quot;current_skin&amp;quot;,&amp;quot;metal&amp;quot;));"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.SkinFactory" intfc="y" abs="n" inn="n" sloc="4" jdoc="This is the generic SkinFactory base class. Override it to let Jext access a new skin group, plugin and so on; if the inheriting class is also a Plugin descendant the method is called authomatically for you when loading the plugin. @author Blaisorblade">
			<mth name="/lib/:org.jext.gui.SkinFactory.getSkins()" access="pub" jdoc="Must return an array of already constructed Skin&amp;apos;s.">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.GenericSkin" intfc="n" abs="n" inn="n" sloc="42" jdoc="This is a generic skin class which will be able to wrap most possible skin, actually the normal LookAndFeel&amp;apos;s. If you need special processing, write your own Skin interface implementation or extend this one.">
			<comm cntt="public void setValues(String name, String intName, String lafClassName, ClassLoader cl) { built = true; this.name = name; this.intName = intName; this.lafClassName = lafClassName; this.skLoader = cl; }"/>
			<comm cntt="If you extend this class, use this method to pass the value you would pass instead to the constructor; note that you can&amp;apos;t call it public void setValues(String name, String intName, String lafClassName) { built = true; this.name = name; this.intName = intName; this.lafClassName = lafClassName; }"/>
			<field name="name" access="priv" jdoc=""/>
			<field name="intName" access="priv" jdoc=""/>
			<field name="lafClassName" access="prot" jdoc=""/>
			<field name="laf" access="prot" jdoc=""/>
			<field name="skLoader" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.gui.GenericSkin.GenericSkin(String, String, String)" access="pub" jdoc="Constructor; use it to provide the caption, the internal name and the name of the class to use as LookAndFeel(the same you would pass to UIManager.setLookAndFeel).">
				<param name="name"/>
				<param name="intName"/>
				<param name="lafClassName"/>
			</mth>
			<mth name="/lib/:org.jext.gui.GenericSkin.GenericSkin(String, String, String, ClassLoader)" access="pub" jdoc="Constructor; use it to provide the caption, the internal name, the name of the class to use as LookAndFeel(the same you would pass to UIManager.setLookAndFeel) and the ClassLoader that will be used to load the LookAndFeel and related classes; useful especially if you write a plugin. In this case pass as classLoader &amp;lt;Your class&amp;gt;.class.getClassLoader(), as KLNF does.">
				<param name="name"/>
				<param name="intName"/>
				<param name="lafClassName"/>
				<param name="cl"/>
			</mth>
			<mth name="/lib/:org.jext.gui.GenericSkin.GenericSkin(String, String, LookAndFeel)" access="pub" jdoc="Constructor; use it to provide the caption, the internal name and the built LookAndFeel instance (the same you would pass to UIManager.setLookAndFeel).">
				<param name="name"/>
				<param name="intName"/>
				<param name="laf"/>
			</mth>
			<mth name="/lib/:org.jext.gui.GenericSkin.GenericSkin(String, String, LookAndFeel, ClassLoader)" access="pub" jdoc="Constructor; use it to provide the caption, the internal name and the built LookAndFeel instance (the same you would pass to UIManager.setLookAndFeel). This constructor allows you to specify a ClassLoader that will be used to load the LookAndFeel and related classes; useful especially if you write a plugin. In this case pass as classLoader &amp;lt;Your class&amp;gt;.class.getClassLoader(), as KLNF does.">
				<param name="name"/>
				<param name="intName"/>
				<param name="laf"/>
				<param name="cl"/>
			</mth>
			<mth name="/lib/:org.jext.gui.GenericSkin.isAvailable()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.GenericSkin.getSkinName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.GenericSkin.getSkinInternName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.GenericSkin.apply()" access="pub" jdoc="This method applies the skin; if you have not called one of the constructors, it will fail silently.">
				<comm cntt="check this!"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.DisabledCellRenderer" intfc="n" abs="n" inn="n" sloc="17" jdoc="">
			<mth name="/lib/:org.jext.gui.DisabledCellRenderer.DisabledCellRenderer()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.DisabledCellRenderer.getTableCellRendererComponent(JTable, Object, boolean, boolean, int, int)" access="pub" jdoc="">
				<param name="table"/>
				<param name="value"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.PlasticSettings" intfc="n" abs="n" inn="n" sloc="159" jdoc="Describes most of the optional settings of the JGoodies Looks. Used by the &amp;lt;code&amp;gt;DemoFrame&amp;lt; code&amp;gt; to configure the UI. @author Karsten Lentzsch @version $Revision: 1.4 $ @see com.jgoodies.plaf.BorderStyle @see com.jgoodies.plaf.FontSizeHints @see com.jgoodies.plaf.HeaderStyle @see com.jgoodies.plaf.Options">
			<comm cntt="Instance Creation"/>
			<comm cntt="Accessors"/>
			<field name="selectedLookAndFeel" access="priv" jdoc=""/>
			<field name="selectedTheme" access="priv" jdoc=""/>
			<field name="useSystemFonts" access="priv" jdoc=""/>
			<field name="fontSizeHints" access="priv" jdoc=""/>
			<field name="useNarrowButtons" access="priv" jdoc=""/>
			<field name="tabIconsEnabled" access="priv" jdoc=""/>
			<field name="popupDropShadowEnabled" access="priv" jdoc=""/>
			<field name="plasticTabStyle" access="priv" jdoc=""/>
			<field name="plasticHighContrastFocusEnabled" access="priv" jdoc=""/>
			<field name="menuBarHeaderStyle" access="priv" jdoc=""/>
			<field name="menuBarPlasticBorderStyle" access="priv" jdoc=""/>
			<field name="menuBarWindowsBorderStyle" access="priv" jdoc=""/>
			<field name="menuBar3DHint" access="priv" jdoc=""/>
			<field name="toolBarHeaderStyle" access="priv" jdoc=""/>
			<field name="toolBarPlasticBorderStyle" access="priv" jdoc=""/>
			<field name="toolBarWindowsBorderStyle" access="priv" jdoc=""/>
			<field name="toolBar3DHint" access="priv" jdoc=""/>
			<field name="clearLookMode" access="priv" jdoc=""/>
			<field name="clearLookPolicyName" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.PlasticSettings.PlasticSettings()" access="priv" jdoc="">
				<comm cntt="Override default constructor; prevents instantiability."/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.createDefault()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getClearLookMode()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setClearLookMode(ClearLookMode)" access="pub" jdoc="">
				<param name="clearLookMode"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getClearLookPolicyName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setClearLookPolicyName(String)" access="pub" jdoc="">
				<param name="clearLookPolicyName"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getFontSizeHints()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setFontSizeHints(FontSizeHints)" access="pub" jdoc="">
				<param name="fontSizeHints"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getMenuBar3DHint()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setMenuBar3DHint(Boolean)" access="pub" jdoc="">
				<param name="menuBar3DHint"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getMenuBarHeaderStyle()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setMenuBarHeaderStyle(HeaderStyle)" access="pub" jdoc="">
				<param name="menuBarHeaderStyle"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getMenuBarPlasticBorderStyle()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setMenuBarPlasticBorderStyle(BorderStyle)" access="pub" jdoc="">
				<param name="menuBarPlasticBorderStyle"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getMenuBarWindowsBorderStyle()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setMenuBarWindowsBorderStyle(BorderStyle)" access="pub" jdoc="">
				<param name="menuBarWindowsBorderStyle"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.isPopupDropShadowEnabled()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setPopupDropShadowEnabled(Boolean)" access="pub" jdoc="">
				<param name="popupDropShadowEnabled"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.isPlasticHighContrastFocusEnabled()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setPlasticHighContrastFocusEnabled(boolean)" access="pub" jdoc="">
				<param name="plasticHighContrastFocusEnabled"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getPlasticTabStyle()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setPlasticTabStyle(String)" access="pub" jdoc="">
				<param name="plasticTabStyle"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getSelectedLookAndFeel()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setSelectedLookAndFeel(LookAndFeel)" access="pub" jdoc="">
				<param name="selectedLookAndFeel"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getSelectedTheme()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setSelectedTheme(PlasticTheme)" access="pub" jdoc="">
				<param name="selectedTheme"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.isTabIconsEnabled()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setTabIconsEnabled(boolean)" access="pub" jdoc="">
				<param name="tabIconsEnabled"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getToolBar3DHint()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setToolBar3DHint(Boolean)" access="pub" jdoc="">
				<param name="toolBar3DHint"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getToolBarHeaderStyle()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setToolBarHeaderStyle(HeaderStyle)" access="pub" jdoc="">
				<param name="toolBarHeaderStyle"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getToolBarPlasticBorderStyle()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setToolBarPlasticBorderStyle(BorderStyle)" access="pub" jdoc="">
				<param name="toolBarPlasticBorderStyle"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.getToolBarWindowsBorderStyle()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setToolBarWindowsBorderStyle(BorderStyle)" access="pub" jdoc="">
				<param name="toolBarWindowsBorderStyle"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.isUseNarrowButtons()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setUseNarrowButtons(boolean)" access="pub" jdoc="">
				<param name="useNarrowButtons"/>
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.isUseSystemFonts()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.PlasticSettings.setUseSystemFonts(Boolean)" access="pub" jdoc="">
				<param name="useSystemFonts"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextMenuSeparatorUI" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<mth name="/lib/:org.jext.gui.JextMenuSeparatorUI.JextMenuSeparatorUI()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMenuSeparatorUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextMenuSeparatorUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<param name="g"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextMenuSeparatorUI.getPreferredSize(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.Skin" intfc="n" abs="y" inn="n" sloc="11" jdoc="This is the generic Skin base class. Override it to provide a new skin. @author BlaisorBlade">
			<comm cntt="as with plugins, we catch all sort of exceptions to not stop jext for"/>
			<comm cntt="buggy skins."/>
			<mth name="/lib/:org.jext.gui.Skin.apply()" access="pub" jdoc="It must actually apply the Skin; to indicate errors it will throw any sort of exception. Tipically it will include a call to UIManager.setLookAndFeel to apply actual LookAndFeel object.">
			</mth>
			<mth name="/lib/:org.jext.gui.Skin.getSkinName()" access="pub" jdoc="The name to show inside the option dialog; this should be get using a Jext property with Jext.getProperty.">
			</mth>
			<mth name="/lib/:org.jext.gui.Skin.getSkinInternName()" access="pub" jdoc="The internal name of the skin, used to identify it; it mustn&amp;apos;t be translated.">
			</mth>
			<mth name="/lib/:org.jext.gui.Skin.isAvailable()" access="pub" jdoc="If your skin is not available in certain cases, override this; it could even call the LookAndFeel.isAvailable method. (But you shouldn&amp;apos;t since LookAndFeel creation is expensive).">
			</mth>
			<mth name="/lib/:org.jext.gui.Skin.unapply()" access="pub" jdoc="You can override this to execute code when this skin is replaced by another.">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextHighlightButton" intfc="n" abs="n" inn="n" sloc="52" jdoc="">
			<comm cntt=", savedNColor;"/>
			<field name="nColor" access="priv" jdoc=""/>
			<field name="_mouseListener" access="priv" jdoc=""/>
			<field name="commonHighlightColor" access="priv" jdoc=""/>
			<field name="blockHighlightChange" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextHighlightButton.setHighlightColor(Color)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextHighlightButton.getHighlightColor()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextHighlightButton.blockHighlightChange()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextHighlightButton.unBlockHighlightChange()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextHighlightButton.init()" access="priv" jdoc="">
				<comm cntt="savedNColor ="/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextHighlightButton.JextHighlightButton()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextHighlightButton.JextHighlightButton(String)" access="pub" jdoc="">
				<param name="label"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextHighlightButton.JextHighlightButton(Icon)" access="pub" jdoc="">
				<param name="icon"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextHighlightButton.JextHighlightButton(String, Icon)" access="pub" jdoc="">
				<param name="label"/>
				<param name="icon"/>
			</mth>
		<class name="/lib/:org.jext.gui.JextHighlightButton$MouseHandler" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<comm cntt="public void mousePressed(MouseEvent me) { nColor = savedNColor; without this, when a button is pressed(and becomes darker) we remember as nColor(normal color) the darker one. }"/>
			<mth name="/lib/:org.jext.gui.JextHighlightButton$MouseHandler.mouseEntered(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextHighlightButton$MouseHandler.mouseExited(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.gui.JextMenu" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<field name="menuComponents" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextMenu.JextMenu()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMenu.JextMenu(String)" access="pub" jdoc="">
				<param name="label"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextMenu.setBorders()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMenu.freeze()" access="pub" jdoc="Stores the menu before starting plugins.">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMenu.reset()" access="pub" jdoc="Restores the menu.">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextButton" intfc="n" abs="n" inn="n" sloc="107" jdoc="">
			<field name="_mouseListener" access="priv" jdoc=""/>
			<field name="grayedIcon" access="priv" jdoc=""/>
			<field name="coloredIcon" access="priv" jdoc=""/>
			<field name="nColor" access="priv" jdoc=""/>
			<field name="commonHighlightColor" access="priv" jdoc=""/>
			<field name="rollover" access="priv" jdoc=""/>
			<field name="blockHighlightChange" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextButton.setRollover(boolean)" access="pub" jdoc="">
				<param name="enabled"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.setHighlightColor(Color)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.getHighlightColor()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.blockHighlightChange()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.unBlockHighlightChange()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.init()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.JextButton()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.JextButton(Icon)" access="pub" jdoc="">
				<param name="icon"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.JextButton(String)" access="pub" jdoc="">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.JextButton(String, Icon)" access="pub" jdoc="">
				<param name="text"/>
				<param name="icon"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.setGrayed(boolean)" access="pub" jdoc="">
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton.fireActionPerformed(ActionEvent)" access="prot" jdoc="">
				<param name="event"/>
			</mth>
		<class name="/lib/:org.jext.gui.JextButton$MouseHandler" intfc="n" abs="n" inn="y" sloc="23" jdoc="">
			<mth name="/lib/:org.jext.gui.JextButton$MouseHandler.mouseEntered(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextButton$MouseHandler.mouseExited(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.gui.FontSelector" intfc="n" abs="n" inn="n" sloc="77" jdoc="">
			<field name="key" access="priv" jdoc=""/>
			<field name="styles" access="priv" jdoc=""/>
			<const name="HIDEFONTS" access="priv" jdoc="For some reason the default Java fonts show up in the list with .bold, .bolditalic, and .italic extensions."/>
			<mth name="/lib/:org.jext.gui.FontSelector.FontSelector(String)" access="pub" jdoc="Constructs the FontSelector, a clickable button to select fonts. @param key The name of the property to use to save the fonts(the values are actually stored in keys whose names depend on this).">
				<param name="key"/>
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector.load()" access="pub" jdoc="It reloads the fonts properties, when for instance a you want to undo a unsaved change made by the user(most notably, you must call this in your option pane&amp;apos;s load() method).">
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector.save()" access="pub" jdoc="It saves the fonts properties, when you want to save changes made by the user (most notably, you must call this in your option pane&amp;apos;s save() method).">
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector.changeFont(Font)" access="priv" jdoc="">
				<param name="font"/>
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector.setFontLabel()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector.getAvailableFontFamilyNames()" access="pub" jdoc="Gets a list of all available font family names. When possible (in JDK 1.2 or later), this will return GraphicsEnvironment.getAvailableFontFamilyNames(). However this method gracefully degrades to returning Toolkit.getFontList() in JDK 1.1.">
			</mth>
		<class name="/lib/:org.jext.gui.FontSelector$SelectorFrame" intfc="n" abs="n" inn="y" sloc="148" jdoc="">
			<field name="sizes" access="priv" jdoc=""/>
			<field name="fontSelected" access="priv" jdoc=""/>
			<field name="example" access="priv" jdoc=""/>
			<field name="ok" access="priv" jdoc=""/>
			<field name="cancel" access="priv" jdoc=""/>
			<field name="fontsList" access="priv" jdoc=""/>
			<field name="sizesList" access="priv" jdoc=""/>
			<field name="stylesList" access="priv" jdoc=""/>
			<field name="fontsField" access="priv" jdoc=""/>
			<field name="sizesField" access="priv" jdoc=""/>
			<field name="stylesField" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.FontSelector$SelectorFrame.SelectorFrame(Font)" access="pub" jdoc="">
				<comm cntt="setIconImage(GUIUtilities.getJextIconImage());"/>
				<param name="font"/>
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector$SelectorFrame.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector$SelectorFrame.getSelectedFont()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector$SelectorFrame.buildFont()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector$SelectorFrame.preview()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector$SelectorFrame.valueChanged(ListSelectionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.gui.FontSelector$SelectorFrame.createTextFieldAndListPanel(String, JTextField, JList)" access="priv" jdoc="">
				<param name="label"/>
				<param name="textField"/>
				<param name="list"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.gui.JextLabeledMenuSeparator" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<comm cntt="label"/>
			<const name="uiClassID" access="priv" jdoc=""/>
			<field name="stext" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextLabeledMenuSeparator.JextLabeledMenuSeparator()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextLabeledMenuSeparator.JextLabeledMenuSeparator(String)" access="pub" jdoc="">
				<param name="stext"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextLabeledMenuSeparator.getSeparatorText()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextLabeledMenuSeparator.getUIClassID()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextLabeledMenuSeparator.updateUI()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextMetalTheme" intfc="n" abs="n" inn="n" sloc="45" jdoc="">
			<field name="color" access="priv" jdoc=""/>
			<field name="font" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.JextMetalTheme()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.getControlTextColor()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.getMenuTextColor()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.getSystemTextColor()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.getUserTextColor()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.getControlTextFont()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.getMenuTextFont()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.getSystemTextFont()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.getUserTextFont()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMetalTheme.getWindowTitleFont()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextToggleButton" intfc="n" abs="n" inn="n" sloc="53" jdoc="">
			<field name="nColor" access="priv" jdoc=""/>
			<field name="_mouseListener" access="priv" jdoc=""/>
			<field name="commonHighlightColor" access="priv" jdoc=""/>
			<field name="blockHighlightChange" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextToggleButton.setHighlightColor(Color)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextToggleButton.getHighlightColor()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextToggleButton.blockHighlightChange()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextToggleButton.unBlockHighlightChange()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextToggleButton.init()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextToggleButton.JextToggleButton()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextToggleButton.JextToggleButton(String)" access="pub" jdoc="">
				<param name="label"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextToggleButton.JextToggleButton(Icon)" access="pub" jdoc="">
				<param name="icon"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextToggleButton.JextToggleButton(String, Icon)" access="pub" jdoc="">
				<param name="label"/>
				<param name="icon"/>
			</mth>
		<class name="/lib/:org.jext.gui.JextToggleButton$MouseHandler" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<mth name="/lib/:org.jext.gui.JextToggleButton$MouseHandler.mouseEntered(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextToggleButton$MouseHandler.mouseExited(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.gui.BundledSkinFactory" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<mth name="/lib/:org.jext.gui.BundledSkinFactory.getSkins()" access="pub" jdoc="">
				<comm cntt="these skins are added only if they are present on the underlying system"/>
				<comm cntt="I use the same name since only one of the two will really exist."/>
				<comm cntt="for windows Skin, it doesn&amp;apos;t work, since the bytecode always exists."/>
				<comm cntt="So we override the standard isAvailable() method"/>
				<comm cntt="it passes a Skin[] to the toArray method;"/>
				<comm cntt="otherwise the array would be an Object array with Skin&amp;apos;s as elements;"/>
				<comm cntt="so, instead it is at runtime a Skin array."/>
			</mth>
			<mth name="/lib/:org.jext.gui.BundledSkinFactory.addSkinIfPresent(ArrayList, String, String, String)" access="priv" jdoc="Adds the descripted skin to the array list if the skins exists. The test is made against the presence of the Look And Feel class on the system. @return If the operation succeed, i.e. if the skin was added to the list">
				<param name="skins"/>
				<param name="description"/>
				<param name="name"/>
				<param name="lnfClass"/>
			</mth>
		<class name="/lib/:org.jext.gui.BundledSkinFactory$MetalSkin" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$MetalSkin.getSkinName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$MetalSkin.getSkinInternName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$MetalSkin.apply()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.BundledSkinFactory$JextSkin" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$JextSkin.getSkinName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$JextSkin.getSkinInternName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$JextSkin.apply()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.BundledSkinFactory$PlasticSkin" intfc="n" abs="n" inn="y" sloc="34" jdoc="">
			<field name="settings" access="priv" jdoc=""/>
			<field name="oldUIClassLoader" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$PlasticSkin.getSkinName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$PlasticSkin.getSkinInternName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$PlasticSkin.unapply()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.BundledSkinFactory$PlasticSkin.apply()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.gui.OptionGroup" intfc="n" abs="n" inn="n" sloc="58" jdoc="">
			<field name="name" access="priv" jdoc=""/>
			<field name="members" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.OptionGroup.OptionGroup(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.gui.OptionGroup.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.OptionGroup.addOptionGroup(OptionGroup)" access="pub" jdoc="">
				<param name="group"/>
			</mth>
			<mth name="/lib/:org.jext.gui.OptionGroup.addOptionPane(OptionPane)" access="pub" jdoc="">
				<param name="pane"/>
			</mth>
			<mth name="/lib/:org.jext.gui.OptionGroup.getMembers()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.OptionGroup.getMember(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.gui.OptionGroup.getMemberIndex(Object)" access="pub" jdoc="">
				<param name="member"/>
			</mth>
			<mth name="/lib/:org.jext.gui.OptionGroup.getMemberCount()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.OptionGroup.save()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.AbstractDisposer" intfc="n" abs="n" inn="n" sloc="23" jdoc="This class handles a press on the ESCAPE key in a &amp;lt;code&amp;gt;java.awt.Window&amp;lt; code&amp;gt; instance. This includes &amp;lt;code&amp;gt;JFrame&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;JDialog&amp;lt; code&amp;gt;. When such an event is caught, the instance is simply disposed. @author Romain Guy">
			<comm cntt="private members"/>
			<field name="parent" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.AbstractDisposer.AbstractDisposer(Window)" access="pub" jdoc="Creates a new KeyListener which register a specified Window. Normally, this window should register this class as one of its key listeners.">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.gui.AbstractDisposer.keyPressed(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.gui.AbstractDisposer.finalize()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextSeparator" intfc="n" abs="n" inn="n" sloc="17" jdoc="">
			<const name="uiClassID" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextSeparator.getUIClassID()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextSeparator.updateUI()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextProgressBarUI" intfc="n" abs="n" inn="n" sloc="39" jdoc="">
			<mth name="/lib/:org.jext.gui.JextProgressBarUI.JextProgressBarUI()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextProgressBarUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextProgressBarUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<param name="g"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextProgressBarUI.getHeaderBackground()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.EnhancedMenuItem" intfc="n" abs="n" inn="n" sloc="72" jdoc="The &amp;lt;code&amp;gt;EnhancedMenuItem&amp;lt; code&amp;gt; is just a &amp;lt;code&amp;gt;JItem&amp;lt; code&amp;gt; which displays the key shortcuts in a different way.">
			<comm cntt="private members"/>
			<field name="keyBinding" access="priv" jdoc=""/>
			<field name="acceleratorFont" access="priv" jdoc=""/>
			<field name="acceleratorForeground" access="priv" jdoc=""/>
			<field name="acceleratorSelectionForeground" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.EnhancedMenuItem.EnhancedMenuItem(String)" access="pub" jdoc="Creates a new enhanced menu item of given label. @param label The label which is displayed by the item">
				<param name="label"/>
			</mth>
			<mth name="/lib/:org.jext.gui.EnhancedMenuItem.EnhancedMenuItem(String, String)" access="pub" jdoc="Creates a new enhanced menu item of given label and specified attached key shortcut. @param label The label which is displayed by the item @param keyBinding Relative keyshortcut">
				<param name="label"/>
				<param name="keyBinding"/>
			</mth>
			<mth name="/lib/:org.jext.gui.EnhancedMenuItem.getPreferredSize()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.EnhancedMenuItem.paint(Graphics)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/lib/:org.jext.gui.EnhancedMenuItem.getActionCommand()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.EnhancedMenuItem.fireActionPerformed(ActionEvent)" access="prot" jdoc="">
				<comm cntt="super.fireActionPerformed(event);"/>
				<param name="event"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextMenuSeparator" intfc="n" abs="n" inn="n" sloc="17" jdoc="">
			<const name="uiClassID" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextMenuSeparator.getUIClassID()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextMenuSeparator.updateUI()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.ModifiedCellRenderer" intfc="n" abs="n" inn="n" sloc="13" jdoc="">
			<mth name="/lib/:org.jext.gui.ModifiedCellRenderer.getListCellRendererComponent(JList, Object, int, boolean, boolean)" access="pub" jdoc="">
				<param name="list"/>
				<param name="value"/>
				<param name="index"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.OptionPane" intfc="y" abs="n" inn="n" sloc="8" jdoc="An interface which defines the basical behavior of an option pane. Options panes are targeted to be displayed in an option dialogs.">
			<mth name="/lib/:org.jext.gui.OptionPane.getName()" access="pub" jdoc="Returns the name of the option pane. This name can be required by componens holder such as tabbed panes.">
			</mth>
			<mth name="/lib/:org.jext.gui.OptionPane.getComponent()" access="pub" jdoc="Returns the component which stands for the option pane itself. In fact, an option pane can be label, a checkbox, etc...">
			</mth>
			<mth name="/lib/:org.jext.gui.OptionPane.save()" access="pub" jdoc="When user closes an option dialog by clicking ok, the settings have to be changed. So, all the settings relative to an option pane have to be saved in this method.">
			</mth>
			<mth name="/lib/:org.jext.gui.OptionPane.isCacheable()" access="pub" jdoc="This is implemented in AbstractOptionPane and returns false by default; if your plugin has a working load() method (not the one provided by AbstractOptionPane), you must override it as &amp;lt;code&amp;gt;public boolean isCacheable() {return true;} &amp;lt; code&amp;gt; It is not allowed to return different values.">
			</mth>
			<mth name="/lib/:org.jext.gui.OptionPane.load()" access="pub" jdoc="When the user closes the option dialog by clicking cancel, the settings have to be reloaded next time the dialog appears, so this method is called. For old plugins, however, it won&amp;apos;t be called, since the default implementation of isCacheable returns false, and the pane will be completely rebuilt. If you implement it, note that the constructor or however the createOptionPanes method of your plugin must call it. The constructor should not contain the code to load values; only this method should.">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextSeparatorUI" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<mth name="/lib/:org.jext.gui.JextSeparatorUI.JextSeparatorUI()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextSeparatorUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextSeparatorUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<param name="g"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.Dockable" intfc="n" abs="n" inn="n" sloc="105" jdoc="FIXME: change this comment to reflect the correction of the API This class can be used to turn a pane into a dockable. Simply take your JPanel and pass it to the constructor. Then call setDockingStatus to put it where you want. It&amp;apos;s that. NOTE: this is version 0 of the API. It&amp;apos;s broken. Don&amp;apos;t use it. 3.2pre5 (or 3.2, I don&amp;apos;t know the future name) will have a corrected version of the API, so plugins will be able to use it. It&amp;apos;s broken because from a design point of view we don&amp;apos;t have an &amp;quot;is-a&amp;quot; relation between this class and JFrame. If we had protected inheritance as in C++, we should use it. Specifically, a DockablePane is not a JFrame because it&amp;apos;s not safe to call DockablePane.show(). If a DockablePane is casted up to a JFrame and passed to something which wants to show it, it won&amp;apos;t check if it&amp;apos;s docked. And if it&amp;apos;s docked and we show it, we get an empty JFrame in the screen. So, design is broken. In the future(maybe), this class will support down and right panels. Maybe. @since Jext3.2pre4 @version 0">
			<comm cntt="Ok, that&amp;apos;s the new API: DockablePane doesn&amp;apos;t inherit from anything. You build a JFrame, then put it into a DockablePane. So your code(which builds a JFrame) doesn&amp;apos;t change a lot: needing little changes was the reason I first thought that &amp;quot;DockablePane extends JFrame&amp;quot;. If the JFrame needs to access the DockablePane instance, it can keep a reference to it, passed by the factory method. Yes, you need a factory, because the external code must not be able to access the JFrame; yet, the constructor can be public, so that external code can get a plain JFrame without any docking allowed. However, remember that showing a JFrame which has been docked it&amp;apos;s not safe, so getting the JFrame from external code isn&amp;apos;t either: so, maybe getFrame() should remain private."/>
			<comm cntt="it&amp;apos;s protected only to ease transiction."/>
			<comm cntt="The things to care about are: -the content JPanel -the size of JPanel -hiding showing the window"/>
			<comm cntt="These two are not yet implemented."/>
			<comm cntt="public void show() { int currState = getDockingStatus(); if (currState == HIDDEN) { super.show(); _setDockingStatus(FLOATING); } else if (currState != FLOATING) { System.err.println(&amp;quot;&amp;quot;); } } public void hide() { int currState = getDockingStatus(); if (currState == FLOATING) { super.hide(); _setDockingStatus(HIDDEN); } else if (currState != HIDDEN) { System.err.println(&amp;quot;&amp;quot;); } }"/>
			<comm cntt="public DockablePane(JextFrame parent, String title) { this(parent, title, title); }"/>
			<comm cntt="These 2 are used to avoid code repetition."/>
			<field name="parent" access="prot" jdoc=""/>
			<field name="frame" access="priv" jdoc=""/>
			<field name="content" access="priv" jdoc=""/>
			<field name="tabTitle" access="priv" jdoc=""/>
			<field name="ownerPane" access="priv" jdoc=""/>
			<field name="handler" access="priv" jdoc=""/>
			<field name="dockingStatus" access="priv" jdoc="The current status"/>
			<const name="DOCK_MASK" access="pub" jdoc="Mask for the status: if getDockingStatus() &amp;amp; DOCK_MASK != 0 then the panel is visible and not floating."/>
			<const name="HIDDEN" access="pub" jdoc="Constant for the status: hidden"/>
			<const name="FLOATING" access="pub" jdoc="Constant for the status: floating window"/>
			<const name="DOCK_TO_LEFT_PANEL" access="pub" jdoc="Constant for the status: docked in the left pane"/>
			<const name="DOCK_TO_UP_PANEL" access="pub" jdoc="Constant for the status: docked in the top pane"/>
			<const name="DOCK_TO_RIGHT_PANEL" access="pub" jdoc="Constant for the status: docked in the right pane"/>
			<const name="DOCK_TO_DOWN_PANEL" access="pub" jdoc="Constant for the status: docked in the down pane"/>
			<field name="savedMinSize" access="priv" jdoc=""/>
			<const name="zeroDim" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.Dockable.getFrame()" access="pub" jdoc="Returns the frame that will be used to display the panel when the status is FLOATING">
				<comm cntt="if (frame == null) { frame = new JFrame(title); if (where == FLOATING) System.err.println(&amp;quot;We were floating but without a frame.&amp;quot;); } return frame; return this;"/>
			</mth>
			<mth name="/lib/:org.jext.gui.Dockable.Dockable(JFrame, String, JextFrame, DockChangeHandler)" access="pub" jdoc="The only constructor. You can set the parent later if you want, but it&amp;apos;s up to you and not guaranted to work. At least, set the correct parent before docking. And change it only when you are undocked.">
				<param name="frame"/>
				<param name="tabTitle"/>
				<param name="parent"/>
				<param name="handler"/>
			</mth>
			<mth name="/lib/:org.jext.gui.Dockable.setParent(JextFrame)" access="pub" jdoc="Sets the parent Jext window. We put ourself in it if docking and outside of it if not docking">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.gui.Dockable.isDocked()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.Dockable.getDockingStatus()" access="pub" jdoc="">
				<comm cntt="MARK"/>
				<comm cntt="MARK"/>
			</mth>
			<mth name="/lib/:org.jext.gui.Dockable._setDockingStatus(int)" access="priv" jdoc="Sets the internal dockingStatus var to represent the &amp;lt;code&amp;gt;newWhere&amp;lt; code&amp;gt; status. It is for internal use, to incapsulate the dockingStatus logic (i.e. how to set the HIDDEN status, see the 2 versions of the method) from the rest of the code. This method does not interact with the GUI">
				<comm cntt="MARK"/>
				<comm cntt="MARK"/>
				<comm cntt="dockingStatus = newWhere;"/>
				<param name="newWhere"/>
			</mth>
			<mth name="/lib/:org.jext.gui.Dockable.setDockingStatus(int)" access="pub" jdoc="Changes the docking status. @param newWhere the new docking status; must be one of the constants from this class.">
				<comm cntt="First we need to remove the pane from where it is. If undocking, we restore minimum size."/>
				<comm cntt="maybe just hide?"/>
				<comm cntt="FIXME:should never happen. Remove this."/>
				<comm cntt="we must undock"/>
				<comm cntt="we must dock"/>
				<param name="newWhere"/>
			</mth>
			<mth name="/lib/:org.jext.gui.Dockable.showFrame()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.Dockable.putInPane(int)" access="priv" jdoc="">
				<param name="newWhere"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.DockChangeHandler" intfc="y" abs="n" inn="n" sloc="3" jdoc="">
			<mth name="/lib/:org.jext.gui.DockChangeHandler.dockChangeHandler(int, int)" access="pub" jdoc="Override to do special handling of the change of docking status. @param where old docking status @param newWhere new docking status">
				<param name="where"/>
				<param name="newWhere"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextProgressBar" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<const name="uiClassID" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.gui.JextProgressBar.JextProgressBar()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextProgressBar.JextProgressBar(int)" access="pub" jdoc="">
				<param name="orient"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextProgressBar.JextProgressBar(int, int)" access="pub" jdoc="">
				<param name="min"/>
				<param name="max"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextProgressBar.JextProgressBar(int, int, int)" access="pub" jdoc="">
				<param name="orient"/>
				<param name="min"/>
				<param name="max"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextProgressBar.getUIClassID()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.gui.JextProgressBar.updateUI()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.gui.JextCheckBox" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/lib/:org.jext.gui.JextCheckBox.JextCheckBox(String)" access="pub" jdoc="">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.gui.JextCheckBox.JextCheckBox(String, boolean)" access="pub" jdoc="">
				<param name="text"/>
				<param name="enabled"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.menus">
		<class name="/lib/:org.jext.menus.TemplatesMenu" intfc="n" abs="n" inn="n" sloc="55" jdoc="">
			<field name="creater" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.menus.TemplatesMenu.TemplatesMenu()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.menus.TemplatesMenu.processDirectory(JMenu, String)" access="pub" jdoc="">
				<comm cntt="if (file.equals(Jext.getProperty(&amp;quot;templates.directory&amp;quot;)))"/>
				<comm cntt="fileName = Jext.getProperty(&amp;quot;templates.label&amp;quot;);"/>
				<param name="menu"/>
				<param name="file"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.menus.JextMenuBar" intfc="n" abs="n" inn="n" sloc="105" jdoc="The menu bar of Jext windows. This menu bar allows to add items and menus according to a position indicated by a menu ID. Indeed, this class allows to register menus with an ID.&amp;lt;br&amp;gt;Using IDs allows, for instance, to add plugins submenus in other menus than in Plugins. (see Java and HTML plugins to see how this works). @author Romain Guy">
			<field name="menus" access="priv" jdoc=""/>
			<field name="fileMenusAdded" access="priv" jdoc=""/>
			<field name="fileItemsAdded" access="priv" jdoc=""/>
			<field name="editMenusAdded" access="priv" jdoc=""/>
			<field name="editItemsAdded" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.menus.JextMenuBar.JextMenuBar()" access="pub" jdoc="Creates a new menu bar.">
			</mth>
			<mth name="/lib/:org.jext.menus.JextMenuBar.addIdentifiedMenu(JMenu, String)" access="pub" jdoc="Adds a menu in the menu bar and register it with an identifier which can be used later to add items or submenus in this menu. @param menu The menu to be added @param ID The identification string for this menu">
				<param name="menu"/>
				<param name="ID"/>
			</mth>
			<mth name="/lib/:org.jext.menus.JextMenuBar.addMenu(JMenu, String)" access="pub" jdoc="Adds a submenu in a menu designed by an ID string. @param item The menu to be added @param ID The ID string of the menu in which item has to be added">
				<param name="item"/>
				<param name="ID"/>
			</mth>
			<mth name="/lib/:org.jext.menus.JextMenuBar.addMenuItem(JMenuItem, String)" access="pub" jdoc="Adds an item in a menu designed by an ID string. @param item The menu item to be added @param ID The ID string of the menu in which item has to be added">
				<param name="item"/>
				<param name="ID"/>
			</mth>
			<mth name="/lib/:org.jext.menus.JextMenuBar.reset()" access="pub" jdoc="Restores the menu bar.">
			</mth>
			<mth name="/lib/:org.jext.menus.JextMenuBar.getJextFrame()" access="priv" jdoc="Get the parent JextFrame @return org.jext.JextFrame">
				<comm cntt="JLayeredPane"/>
				<comm cntt="JRootPane"/>
				<comm cntt="JextFrame"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.menus.JextRecentMenu" intfc="n" abs="n" inn="n" sloc="88" jdoc="">
			<field name="opener" access="priv" jdoc=""/>
			<field name="recentMenu" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="maxRecent" access="priv" jdoc=""/>
			<field name="recent" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.menus.JextRecentMenu.JextRecentMenu(JextFrame, JMenu)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="recentMenu"/>
			</mth>
			<mth name="/lib/:org.jext.menus.JextRecentMenu.removeRecent()" access="pub" jdoc="Cleans recent menu.">
			</mth>
			<mth name="/lib/:org.jext.menus.JextRecentMenu.createRecent()" access="pub" jdoc="Creates the recent menu from an array of &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; containing paths to the most recently opened files. @param mnu The menu where to put last opened files">
			</mth>
			<mth name="/lib/:org.jext.menus.JextRecentMenu.saveRecent(String)" access="pub" jdoc="Add an item to the recent menu. @param file The path of the file to be added">
				<param name="file"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.misc">
		<class name="/lib/:org.jext.misc.DownloaderThread" intfc="n" abs="n" inn="n" sloc="28" jdoc="">
			<comm cntt="public static DownloaderThread newInstance(InputStream _in, OutputStream _out, HandlingRunnable _notify, int _expectedLen, String _outPath) { }"/>
			<field name="source" access="prot" jdoc=""/>
			<field name="outPath" access="prot" jdoc=""/>
			<field name="tempPath" access="prot" jdoc=""/>
			<field name="outFile" access="prot" jdoc=""/>
			<field name="tempFile" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.misc.DownloaderThread.DownloaderThread(URL, HandlingRunnable, String)" access="pub" jdoc="">
				<param name="source"/>
				<param name="notify"/>
				<param name="outPath"/>
			</mth>
			<mth name="/lib/:org.jext.misc.DownloaderThread.work()" access="pub" jdoc="">
				<comm cntt="FIXME: think about the case below. The caller must avoid that we download the file 2 times."/>
				<comm cntt="Not us!"/>
				<comm cntt="if (tempFile.exists()) tempFile.renameTo(new File(tempPath + &amp;quot;.bak&amp;quot;)); Could fail and return false!"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.AboutWindow" intfc="n" abs="n" inn="n" sloc="39" jdoc="">
			<mth name="/lib/:org.jext.misc.AboutWindow.AboutWindow(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.StringSorter" intfc="n" abs="n" inn="n" sloc="43" jdoc="">
			<mth name="/lib/:org.jext.misc.StringSorter.sort(Document, boolean)" access="pub" jdoc="">
				<param name="doc"/>
				<param name="reverse"/>
			</mth>
			<mth name="/lib/:org.jext.misc.StringSorter.sort(Document, int, int, boolean)" access="pub" jdoc="">
				<param name="doc"/>
				<param name="offset"/>
				<param name="length"/>
				<param name="reverse"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.AboutPlugins" intfc="n" abs="n" inn="n" sloc="67" jdoc="">
			<comm cntt="private members"/>
			<field name="ok" access="priv" jdoc=""/>
			<field name="plugs" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.AboutPlugins.createBox(String)" access="priv" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.misc.AboutPlugins.AboutPlugins(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.misc.AboutPlugins.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		<class name="/lib/:org.jext.misc.AboutPlugins$InstalledPlugin" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<comm cntt="private fields"/>
			<field name="name" access="priv" jdoc=""/>
			<field name="box" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.AboutPlugins$InstalledPlugin.InstalledPlugin(JCheckBox, String)" access="pub" jdoc="">
				<param name="box"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.misc.AboutPlugins$InstalledPlugin.getCheckBox()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.AboutPlugins$InstalledPlugin.save()" access="pub" jdoc="">
				<comm cntt="Jext.setProperty(&amp;quot;plugin.&amp;quot; + name + &amp;quot;.disabled&amp;quot;, box.isSelected() ? &amp;quot;no&amp;quot; : &amp;quot;yes&amp;quot;);"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.SaveDialog" intfc="n" abs="n" inn="n" sloc="159" jdoc="">
			<comm cntt="private"/>
			<const name="CLOSE_WINDOW" access="pub" jdoc=""/>
			<const name="CLOSE_TEXT_AREAS_ONLY" access="pub" jdoc=""/>
			<const name="DO_NOTHING" access="pub" jdoc=""/>
			<field name="mode" access="priv" jdoc=""/>
			<field name="dirty" access="priv" jdoc=""/>
			<field name="areas" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="all" access="priv" jdoc=""/>
			<field name="none" access="priv" jdoc=""/>
			<field name="cancel" access="priv" jdoc=""/>
			<field name="ok" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.SaveDialog.SaveDialog(JextFrame, int)" access="pub" jdoc="">
				<comm cntt="+ &amp;quot; [&amp;quot; + parent.getWorkspaces().getName() + &amp;apos;]&amp;apos;"/>
				<comm cntt="if (boxer.getComponentCount() &amp;gt; 0)"/>
				<comm cntt="boxer.remove(boxer.getComponentCount() - 1);"/>
				<param name="parent"/>
				<param name="mode"/>
			</mth>
			<mth name="/lib/:org.jext.misc.SaveDialog.createTextAreasArray()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.SaveDialog.save()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.SaveDialog.exit()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.SaveDialog.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		<class name="/lib/:org.jext.misc.SaveDialog$WorkspaceLabel" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<mth name="/lib/:org.jext.misc.SaveDialog$WorkspaceLabel.WorkspaceLabel(String)" access="pub" jdoc="">
				<param name="label"/>
			</mth>
			<mth name="/lib/:org.jext.misc.SaveDialog$WorkspaceLabel.paintComponent(Graphics)" access="prot" jdoc="">
				<comm cntt="int x = getIcon().getIconWidth() + Math.max(0, getIconTextGap() - 1);"/>
				<param name="g"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.SaveDialog$DirtyArea" intfc="n" abs="n" inn="y" sloc="26" jdoc="">
			<comm cntt="private fields"/>
			<field name="box" access="priv" jdoc=""/>
			<field name="area" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.SaveDialog$DirtyArea.DirtyArea(JCheckBox, JextTextArea)" access="pub" jdoc="">
				<param name="box"/>
				<param name="area"/>
			</mth>
			<mth name="/lib/:org.jext.misc.SaveDialog$DirtyArea.getCheckBox()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.SaveDialog$DirtyArea.isSelected()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.SaveDialog$DirtyArea.setSelected(boolean)" access="pub" jdoc="">
				<param name="selected"/>
			</mth>
			<mth name="/lib/:org.jext.misc.SaveDialog$DirtyArea.getTextArea()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.AutoSave" intfc="n" abs="n" inn="n" sloc="46" jdoc="">
			<field name="parent" access="priv" jdoc=""/>
			<field name="interval" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.AutoSave.AutoSave(JextFrame)" access="pub" jdoc="Starts the auto save thread.">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.misc.AutoSave.getInterval()" access="pub" jdoc="Returns the intervale, in seconds, between each save.">
			</mth>
			<mth name="/lib/:org.jext.misc.AutoSave.setInterval(int)" access="pub" jdoc="Sets the interval, in seconds, between each save.">
				<param name="newInterval"/>
			</mth>
			<mth name="/lib/:org.jext.misc.AutoSave.run()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.CompleteWordList" intfc="n" abs="n" inn="n" sloc="78" jdoc="">
			<field name="itemsList" access="priv" jdoc=""/>
			<field name="word" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.CompleteWordList.CompleteWordList(JextFrame, String, String[])" access="pub" jdoc="">
				<param name="parent"/>
				<param name="word"/>
				<param name="list"/>
			</mth>
			<mth name="/lib/:org.jext.misc.CompleteWordList.caretUpdate(CaretEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.CompleteWordList.dispose()" access="pub" jdoc="">
			</mth>
		<class name="/lib/:org.jext.misc.CompleteWordList$KeyHandler" intfc="n" abs="n" inn="y" sloc="76" jdoc="">
			<mth name="/lib/:org.jext.misc.CompleteWordList$KeyHandler.keyTyped(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.CompleteWordList$KeyHandler.keyPressed(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.CompleteWordList$MouseHandler" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<mth name="/lib/:org.jext.misc.CompleteWordList$MouseHandler.mouseClicked(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.VirtualFolders" intfc="n" abs="n" inn="n" sloc="466" jdoc="Virtual Folders are a kind of project manager. Virtual Folders allow to sort documents into folder, categorizing them. @author Romain Guy, Grant Stead @version 2.0">
			<comm cntt="miscallenaous"/>
			<comm cntt="the buttons panel"/>
			<comm cntt="the popup menu"/>
			<comm cntt="the tree"/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="deleteItem" access="priv" jdoc=""/>
			<field name="openFile" access="priv" jdoc=""/>
			<field name="addFile" access="priv" jdoc=""/>
			<field name="addAllFiles" access="priv" jdoc=""/>
			<field name="newFolder" access="priv" jdoc=""/>
			<field name="popup" access="priv" jdoc=""/>
			<field name="deleteM" access="priv" jdoc=""/>
			<field name="openFileM" access="priv" jdoc=""/>
			<field name="addFileM" access="priv" jdoc=""/>
			<field name="addAllFilesM" access="priv" jdoc=""/>
			<field name="newFolderM" access="priv" jdoc=""/>
			<field name="tree" access="priv" jdoc=""/>
			<field name="treeModel" access="priv" jdoc=""/>
			<field name="root" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.VirtualFolders.VirtualFolders(JextFrame)" access="pub" jdoc="">
				<comm cntt="Open"/>
				<comm cntt="New Folder"/>
				<comm cntt="Add"/>
				<comm cntt="Add all"/>
				<comm cntt="Delete"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.jextEventFired(JextEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.toXML(VirtualFolderNode, int)" access="priv" jdoc="">
				<param name="parent"/>
				<param name="depth"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.getIndentation(int)" access="priv" jdoc="">
				<param name="depth"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.save()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.load()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.fixVisible()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.createFolder(String)" access="priv" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.createFolder(String, boolean)" access="priv" jdoc="">
				<param name="name"/>
				<param name="expand"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.createFolder(String, boolean, VirtualFolderNode)" access="priv" jdoc="">
				<param name="name"/>
				<param name="expand"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.createLeaf(VirtualFolderNode, String)" access="priv" jdoc="">
				<param name="parent"/>
				<param name="content"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.folderExists(VirtualFolderNode, String)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.newFolder()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.newFolder(VirtualFolderNode)" access="priv" jdoc="">
				<param name="parentNode"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.removeItem()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.addFile()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.addFile(String)" access="priv" jdoc="">
				<param name="fileName"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.addAllFiles()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.openSelection(boolean)" access="priv" jdoc="">
				<param name="fromMenu"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.openNode(VirtualFolderNode, boolean)" access="pub" jdoc="">
				<param name="node"/>
				<param name="fromMenu"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.notifyChanges()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.notify(DefaultTreeModel)" access="pub" jdoc="">
				<param name="model"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders.valueChanged(TreeSelectionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		<class name="/lib/:org.jext.misc.VirtualFolders$MouseHandler" intfc="n" abs="n" inn="y" sloc="16" jdoc="">
			<mth name="/lib/:org.jext.misc.VirtualFolders$MouseHandler.mousePressed(MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.VirtualFolders$VirtualFoldersHandler" intfc="n" abs="n" inn="y" sloc="39" jdoc="">
			<field name="parent" access="pub" jdoc=""/>
			<field name="folderName" access="pub" jdoc=""/>
			<field name="fileName" access="pub" jdoc=""/>
			<field name="isVisible" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFoldersHandler.startElement(String)" access="pub" jdoc="">
				<param name="elname"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFoldersHandler.endElement(String)" access="pub" jdoc="">
				<param name="elname"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFoldersHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.VirtualFolders$VirtualFolderNode" intfc="n" abs="n" inn="y" sloc="41" jdoc="">
			<field name="isLeaf" access="priv" jdoc=""/>
			<field name="filePath" access="priv" jdoc=""/>
			<field name="label" access="priv" jdoc=""/>
			<field name="isVisible" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFolderNode.VirtualFolderNode(String)" access="pub" jdoc="">
				<param name="filePath"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFolderNode.VirtualFolderNode(String, boolean)" access="pub" jdoc="">
				<param name="filePath"/>
				<param name="isLeaf"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFolderNode.ensureVisible(boolean)" access="pub" jdoc="">
				<param name="isVisible"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFolderNode.shouldBeVisible()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFolderNode.getFilePath()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFolderNode.isLeaf()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$VirtualFolderNode.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.VirtualFolders$KeyHandler" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<mth name="/lib/:org.jext.misc.VirtualFolders$KeyHandler.keyPressed(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.VirtualFolders$DnDHandler" intfc="n" abs="n" inn="y" sloc="38" jdoc="">
			<mth name="/lib/:org.jext.misc.VirtualFolders$DnDHandler.dragEnter(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$DnDHandler.dragOver(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$DnDHandler.dragExit(DropTargetEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$DnDHandler.dragScroll(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$DnDHandler.dropActionChanged(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.VirtualFolders$DnDHandler.drop(DropTargetDropEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.TabSwitcher" intfc="n" abs="n" inn="n" sloc="22" jdoc="Switches tabs due to the failure of JRE 1.4 to properly do so. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt;">
			<comm cntt="inherit doc"/>
			<field name="right" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.TabSwitcher.TabSwitcher(boolean)" access="pub" jdoc="Construct a new &amp;lt;CODE&amp;gt;TabSwitcher&amp;lt; CODE&amp;gt;. @param right whether to switch the selected tab index right or left.">
				<param name="right"/>
			</mth>
			<mth name="/lib/:org.jext.misc.TabSwitcher.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="end if right"/>
				<comm cntt="end if not right"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.JextMail" intfc="n" abs="n" inn="n" sloc="289" jdoc="">
			<field name="y" access="priv" jdoc=""/>
			<field name="pane" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="mailer" access="priv" jdoc=""/>
			<field name="tracer" access="priv" jdoc=""/>
			<field name="traceState" access="priv" jdoc=""/>
			<field name="scroller" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<field name="gridBag" access="priv" jdoc=""/>
			<field name="send" access="priv" jdoc=""/>
			<field name="cancel" access="priv" jdoc=""/>
			<field name="details" access="priv" jdoc=""/>
			<field name="host" access="priv" jdoc=""/>
			<field name="from" access="priv" jdoc=""/>
			<field name="to" access="priv" jdoc=""/>
			<field name="subject" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.JextMail.addComponent(String, Component)" access="prot" jdoc="">
				<param name="label"/>
				<param name="comp"/>
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.JextMail(JextTextArea)" access="pub" jdoc="">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.load()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.save()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.wait(boolean)" access="priv" jdoc="">
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.send()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.stop()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.run()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.check()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.showDetails()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.trace(String)" access="priv" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.error(String)" access="priv" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/lib/:org.jext.misc.JextMail.sendMail(String, String, String, String)" access="pub" jdoc="This mails area&amp;apos;s contents trhough mail. @param host The SMTP host address @param from The sender&amp;apos;s mail @param to The receiver&amp;apos;s mail @param subject Mail&amp;apos;s subject @return True if no error has occured, false otherwise">
				<param name="host"/>
				<param name="from"/>
				<param name="to"/>
				<param name="subject"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.PluginAuthor" intfc="n" abs="n" inn="n" sloc="18" jdoc="">
			<field name="name" access="priv" jdoc=""/>
			<field name="email" access="priv" jdoc=""/>
			<field name="content" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.PluginAuthor.PluginAuthor(String)" access="pub" jdoc="">
				<param name="_content"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginAuthor.PluginAuthor(String, String)" access="pub" jdoc="">
				<param name="_name"/>
				<param name="_email"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginAuthor.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.PluginDownload" intfc="n" abs="n" inn="n" sloc="208" jdoc="This is the master class of all the plugin update process; see the code of main() for a sample of use. @author Blaisorblade @since Jext3.2pre4">
			<comm cntt="URL&amp;apos;s to refer to(they are initialized below, in the static constructor)"/>
			<comm cntt="Where we save the new version of autoUpdate.jar"/>
			<comm cntt="classloaders for the update."/>
			<comm cntt="references to data model and UI elements."/>
			<comm cntt="flags"/>
			<comm cntt="Property keys"/>
			<comm cntt="private static final String versionKey = &amp;quot;plugDownload.core.version&amp;quot;;"/>
			<comm cntt="private static final String baseUrlKey = ;"/>
			<comm cntt="this is needed during testing, when all starts from our main()."/>
			<comm cntt="baseURL = &amp;quot;http: localhost jext &amp;quot;; Uncomment this for local testing."/>
			<comm cntt="FIXME: Also add proxing ability!! See system properties set by jEdit"/>
			<comm cntt="inside jEdit.java"/>
			<comm cntt="FIXME: needs to be rewritten. As of now, it starts a thread which downloads the jar core, which run a callback in the event-handling thread, which checks if things went ok and downloads the plugin list in a new thread, which then shows the dialog in a callback."/>
			<comm cntt="private static void downloadJar() { if (debug || !hasBooted) { try { InputStream releaseInp = autoUpdateVersionUrl.openStream(); byte buf[] = new byte[10]; releaseInp.read(buf); int currVersion = Integer.parseInt(Jext.getProperty(&amp;quot;plugDownload.core.version&amp;quot;)); final int newVersion = Integer.parseInt(new String(buf).trim()); if (currVersion &amp;lt; newVersion) { final JDialog dial = new WaitDialog(parentFrame); dial.setVisible(true); Utilities.copy(true, new DownloaderThread(autoUpdateJarUrl, null, downloadedJarPath.getPath()) { public Object construct() { Throwable ret = (Throwable) super.construct(); dial.dispose(); if (ret != null) { ret.printStackTrace(); JOptionPane.showMessageDialog(dial, Jext.getProperty(&amp;quot;plugDownload.core.coreDownError.text&amp;quot;), Jext.getProperty(&amp;quot;plugDownload.core.downError.title&amp;quot;), JOptionPane.ERROR_MESSAGE); return ret; } if (!debug) { during testing this is commented out. Jext.setProperty(&amp;quot;plugDownload.core.version&amp;quot;, String.valueOf(newVersion)); } hasBooted = true; downloadList(); return null; } }); return; Utilities.downloadFile(autoUpdateJarUrl, downloadedJarPath.getPath(), true, new HandlingRunnable() { public void run() { let&amp;apos;s close the window and let things go on. dial.dispose(); if (excep != null) { excep.printStackTrace(); JOptionPane.showMessageDialog(dial, Jext.getProperty(&amp;quot;plugDownload.core.coreDownError.text&amp;quot;), Jext.getProperty(&amp;quot;plugDownload.core.downError.title&amp;quot;), JOptionPane.ERROR_MESSAGE); return; } if (!debug) { during testing this is commented out. Jext.setProperty(&amp;quot;plugDownload.core.version&amp;quot;, String.valueOf(newVersion)); } hasBooted = true; downloadList(); } }); the file must be ready for the call to buildChainingClassLoader, below, so if threaded there is need for special caution: fixed. The buildChainingClassLoader is done by the back-notify Runnable. actually, when doing things the right way, the lib download will start together with a progress monitor. } else { otherwise, the jar is up-to-date. hasBooted = true; } } catch (IOException ioe) { In this case, we can&amp;apos;t update the autoUpdate.jar file; but then we use the current one. System.err.println(&amp;quot;Caught exception while trying to update autoUpdate.jar&amp;quot;); ioe.printStackTrace(); } } If for any reason the jar wasn&amp;apos;t updated(either for problems or because it was up-to-date) we show here the dialog. downloadList(); }"/>
			<field name="autoUpdateVersionUrl" access="priv" jdoc=""/>
			<field name="autoUpdateListUrl" access="priv" jdoc=""/>
			<const name="jarName" access="priv" jdoc=""/>
			<field name="autoUpdateJarUrl" access="priv" jdoc=""/>
			<const name="downloadedJarPath" access="priv" jdoc=""/>
			<const name="downloadedListPath" access="priv" jdoc=""/>
			<field name="defaultJarPath" access="priv" jdoc=""/>
			<field name="loader" access="priv" jdoc=""/>
			<field name="newVerLoader" access="priv" jdoc=""/>
			<field name="defLoader" access="priv" jdoc=""/>
			<field name="plugReader" access="priv" jdoc=""/>
			<field name="updateWindow" access="priv" jdoc=""/>
			<field name="parentFrame" access="priv" jdoc=""/>
			<field name="hasBooted" access="priv" jdoc="Remember if we have already done the boot process(currently downloading the latest version of autoUpdate.jar)."/>
			<field name="debug" access="pub" jdoc=""/>
			<const name="waitLabelKey" access="priv" jdoc=""/>
			<const name="waitTitleKey" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.PluginDownload.PluginDownload()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.getDefaultJarPath()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.downloadJar()" access="priv" jdoc="">
				<comm cntt="try {"/>
				<comm cntt="now if we didn&amp;apos;t do this yet, check for new core version."/>
				<comm cntt="If there is a new version, download it."/>
				<comm cntt="does the download work."/>
				<comm cntt="during testing this is commented out."/>
				<comm cntt="anyway, the jar is up-to-date, and we remember this."/>
				<comm cntt="In this case, we can&amp;apos;t update the autoUpdate.jar file; but then we use the current one."/>
				<comm cntt="if needed, we&amp;apos;ve tried to do the update. Now let&amp;apos;s get the list."/>
				<comm cntt="} catch (Throwable t) { will never happen, because the above construct doesn&amp;apos;t return any exception. t.printStackTrace(); }"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.downloadList()" access="priv" jdoc="This method downloads the list of plugins and loads it into the AbstractPlugReader(there is an instance which can be got through getUpdater(). It&amp;apos;s called by the downloader thread, while its internal runnable is called in the AWT thread.">
				<comm cntt="try { Utilities.downloadFile(autoUpdateListUrl, downloadedListPath.getPath(), false, null); } catch (IOException ioe) { JOptionPane.showMessageDialog(null, Jext.getProperty(&amp;quot;plugDownload.core.downError.text&amp;quot;), Jext.getProperty(&amp;quot;plugDownload.core.downError.title&amp;quot;), JOptionPane.ERROR_MESSAGE); System.err.println(&amp;quot;Failed loading of XML!&amp;quot;); ioe.printStackTrace(); return; }"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.loadList()" access="pub" jdoc="This method loads the list of plugins into the AbstractPlugReader instance which can be got through getUpdater().">
				<comm cntt="HERE we must give some user visible output.(I.e. in the GUI). In fact, it happens in the caller method."/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.buildChainingClassLoader()" access="priv" jdoc="">
				<comm cntt="Now, if autoUpdate.jar has been updated, it is in the right place in the user&amp;apos;s home;"/>
				<comm cntt="otherwise we need to use the default one, in jext lib dir. Or maybe somewhere else, such as bin,"/>
				<comm cntt="since it mustn&amp;apos;t be loaded at startup."/>
				<comm cntt="And we build the chaining class loader that will be used to load all resources."/>
				<comm cntt="We build first a ClassLoader which loads the supplied autoUpdate.jar, then"/>
				<comm cntt="another one which looks in the downloaded one BUT uses as fallback one"/>
				<comm cntt="the first one. The fallback is provided trasparently by the JDK by using"/>
				<comm cntt="the fallback classloader as parent of the new one. But this only works for"/>
				<comm cntt="resources, since for classes we must fallback not only in the case of ClassNotFoundEx."/>
				<comm cntt="here defLoader becomes the father of newVerLoader"/>
				<comm cntt="The file is there, but there could be problems anyway."/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.getInstanceFromLoader(String)" access="priv" jdoc="">
				<comm cntt="the class is missing in both chained classLoaders."/>
				<comm cntt="if the class was found in newVerLoader, we&amp;apos;ve tried with it, but it didn&amp;apos;t work."/>
				<comm cntt="So we only need trying with defLoader, and only if != loader."/>
				<param name="className"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.newUpdater()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.newUpdatePanel()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.getUpdater()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.getDtd()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.getUpdateWindow()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.startUpdate()" access="pub" jdoc="This method starts the update: downloads the new autoUpdate.jar if needed, and when this is done shows the window.">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.showUpdateWindow()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDownload.main(String[])" access="pub" jdoc="">
				<comm cntt="for testing"/>
				<param name="args"/>
			</mth>
		<class name="/lib/:org.jext.misc.PluginDownload$WaitDialog" intfc="n" abs="n" inn="y" sloc="7" jdoc="">
			<mth name="/lib/:org.jext.misc.PluginDownload$WaitDialog.WaitDialog()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.ZipExplorer" intfc="n" abs="n" inn="n" sloc="126" jdoc="">
			<comm cntt="private members"/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="zipName" access="priv" jdoc=""/>
			<field name="zipTable" access="priv" jdoc=""/>
			<field name="zipFile" access="priv" jdoc=""/>
			<field name="open" access="priv" jdoc=""/>
			<field name="cancel" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<field name="zipModel" access="priv" jdoc=""/>
			<field name="zipEntries" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.ZipExplorer.ZipExplorer(JextFrame, JextTextArea, String)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="textArea"/>
				<param name="zipName"/>
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer.createZipTableScroller()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer.readZip(String)" access="priv" jdoc="">
				<param name="zipName"/>
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer.readZipContent(String)" access="priv" jdoc="">
				<param name="fileChosen"/>
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="use the passed textArea, or else there would be a ghost textArea"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer.cancel()" access="priv" jdoc="">
			</mth>
		<class name="/lib/:org.jext.misc.ZipExplorer$ZipTableModel" intfc="n" abs="n" inn="y" sloc="77" jdoc="">
			<field name="zipContents" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.ZipExplorer$ZipTableModel.ZipTableModel()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer$ZipTableModel.getColumnCount()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer$ZipTableModel.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer$ZipTableModel.getValueAt(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer$ZipTableModel.isCellEditable(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer$ZipTableModel.getColumnName(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.misc.ZipExplorer$ZipTableModel.addZipEntry(ZipEntry)" access="priv" jdoc="">
				<param name="file"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.VersionCheck" intfc="n" abs="n" inn="n" sloc="54" jdoc="">
			<mth name="/lib/:org.jext.misc.VersionCheck.VersionCheck()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.VersionCheck.run()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.WorkspaceSwitcher" intfc="n" abs="n" inn="n" sloc="39" jdoc="">
			<field name="mode" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="dropDown" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.WorkspaceSwitcher.WorkspaceSwitcher(JextFrame)" access="pub" jdoc="">
				<comm cntt="buildDropDownList();"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.misc.WorkspaceSwitcher.buildDropDownList()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.WorkspaceSwitcher.mouseClicked(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
		<class name="/lib/:org.jext.misc.WorkspaceSwitcher$Switcher" intfc="n" abs="n" inn="y" sloc="28" jdoc="">
			<mth name="/lib/:org.jext.misc.WorkspaceSwitcher$Switcher.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.HandlingRunnable" intfc="y" abs="n" inn="n" sloc="3" jdoc="">
			<mth name="/lib/:org.jext.misc.HandlingRunnable.run(Object, Throwable)" access="pub" jdoc="">
				<param name="result"/>
				<param name="excep"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.AbstractPlugReader" intfc="y" abs="n" inn="n" sloc="5" jdoc="">
			<mth name="/lib/:org.jext.misc.AbstractPlugReader.loadXml(Reader)" access="pub" jdoc="">
				<param name="in"/>
			</mth>
			<mth name="/lib/:org.jext.misc.AbstractPlugReader.getPlugins()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.AbstractPlugReader.getMirrors()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.CopyThread" intfc="n" abs="n" inn="n" sloc="29" jdoc="">
			<field name="in" access="prot" jdoc=""/>
			<field name="out" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.misc.CopyThread.CopyThread(HandlingRunnable)" access="prot" jdoc="If you call this, you must set the &amp;lt;code&amp;gt;in&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;out&amp;lt; code&amp;gt; stream by yourself.">
				<param name="notifier"/>
			</mth>
			<mth name="/lib/:org.jext.misc.CopyThread.CopyThread(InputStream, OutputStream, HandlingRunnable)" access="pub" jdoc="">
				<param name="in"/>
				<param name="out"/>
				<param name="notifier"/>
			</mth>
			<mth name="/lib/:org.jext.misc.CopyThread.work()" access="pub" jdoc="">
				<comm cntt="this is very large to reduce the load imposed by the thread: the read() call"/>
				<comm cntt="will return a very few times."/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.SwingWorker" intfc="n" abs="y" inn="n" sloc="77" jdoc="This class comes from the SwingWorker class described at the URL below(3rd version), but has substantially changed; http: java.sun.com docs books tutorial uiswing misc threads.html">
			<comm cntt="see getValue(), setValue()"/>
			<field name="value" access="priv" jdoc=""/>
			<field name="exception" access="priv" jdoc=""/>
			<field name="thread" access="priv" jdoc=""/>
			<field name="notifier" access="prot" jdoc=""/>
			<field name="threadVar" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.SwingWorker.getValue()" access="pub" jdoc="Get the value produced by the worker thread, or null if it hasn&amp;apos;t been constructed yet.">
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker.setValue(Object)" access="priv" jdoc="Set the value produced by worker thread">
				<param name="x"/>
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker.getException()" access="pub" jdoc="Get the value produced by the worker thread, or null if it hasn&amp;apos;t been constructed yet.">
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker.setException(Throwable)" access="priv" jdoc="Set the value produced by worker thread">
				<param name="x"/>
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker.work()" access="pub" jdoc="Compute the value to be returned by the &amp;lt;code&amp;gt;get&amp;lt; code&amp;gt; method.">
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker.finished()" access="pub" jdoc="Called on the event dispatching thread (not on the worker thread) after the &amp;lt;code&amp;gt;work&amp;lt; code&amp;gt; method has returned.">
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker.interrupt()" access="pub" jdoc="A new method that interrupts the worker thread. Call this method to force the worker to stop what it&amp;apos;s doing.">
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker.get()" access="pub" jdoc="Return the value created by the &amp;lt;code&amp;gt;work&amp;lt; code&amp;gt; method. Returns null if either the constructing thread or the current thread was interrupted before a value was produced. @return the value created by the &amp;lt;code&amp;gt;work&amp;lt; code&amp;gt; method">
				<comm cntt="propagate"/>
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker.SwingWorker(HandlingRunnable)" access="pub" jdoc="Create a thread that will call the &amp;lt;code&amp;gt;work&amp;lt; code&amp;gt; method and then run">
				<param name="notifier"/>
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker.start(boolean)" access="pub" jdoc="Start the worker thread.">
				<comm cntt="public void start() { Thread t = threadVar.get(); if (t != null) { t.start(); } } Run the work in the calling thread, and then the &amp;lt;code&amp;gt;notifier&amp;lt; code&amp;gt; callback."/>
				<comm cntt="public Object run() throws Throwable { Object o = null; Throwable t = null; try { o = work(); } catch (Throwable th) { t = th; setException(t); } setValue(o); finished(); if (t != null) throw t; return o; }"/>
				<param name="threaded"/>
			</mth>
		<class name="/lib/:org.jext.misc.SwingWorker$ThreadVar" intfc="n" abs="n" inn="y" sloc="6" jdoc="Class to maintain reference to current worker thread under separate synchronization control.">
			<field name="thread" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.SwingWorker$ThreadVar.ThreadVar(Thread)" access="pub" jdoc="">
				<param name="t"/>
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker$ThreadVar.get()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.SwingWorker$ThreadVar.clear()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.Workspaces" intfc="n" abs="n" inn="n" sloc="314" jdoc="">
			<comm cntt="miscallenaous"/>
			<comm cntt="the buttons panel"/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="workspacesList" access="priv" jdoc=""/>
			<field name="model" access="priv" jdoc=""/>
			<field name="currentWorkspace" access="priv" jdoc=""/>
			<field name="loading" access="priv" jdoc=""/>
			<field name="newWorkspace" access="priv" jdoc=""/>
			<field name="removeWorkspace" access="priv" jdoc=""/>
			<field name="switchWorkspace" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.Workspaces.Workspaces(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.save()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.convertToXML(String)" access="pub" jdoc="">
				<param name="source"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.getList()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.getWorkspacesNames()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.addFile(JextTextArea)" access="pub" jdoc="">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.removeFile(JextTextArea)" access="pub" jdoc="">
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.newWorkspace()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.createWorkspace(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.clear()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.closeAllWorkspaces()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.removeWorkspace()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.loadTextAreas()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.selectWorkspaceOfName(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.selectWorkspaceOfNameOrCreate(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces.valueChanged(ListSelectionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		<class name="/lib/:org.jext.misc.Workspaces$WorkspacesHandler" intfc="n" abs="n" inn="y" sloc="60" jdoc="">
			<field name="caretPosition" access="pub" jdoc=""/>
			<field name="selectedIndex" access="pub" jdoc=""/>
			<field name="fileName" access="pub" jdoc=""/>
			<field name="workspaceName" access="pub" jdoc=""/>
			<field name="currentWorkspaceName" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.misc.Workspaces$WorkspacesHandler.startElement(String)" access="pub" jdoc="">
				<comm cntt="currentWorkspace.setSelectedIndex(0);"/>
				<param name="elname"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$WorkspacesHandler.endElement(String)" access="pub" jdoc="">
				<param name="elname"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$WorkspacesHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.Workspaces$WorkspaceElement" intfc="n" abs="n" inn="y" sloc="29" jdoc="">
			<field name="name" access="priv" jdoc=""/>
			<field name="sIndex" access="priv" jdoc=""/>
			<field name="first" access="priv" jdoc=""/>
			<field name="contents" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.misc.Workspaces$WorkspaceElement.WorkspaceElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$WorkspaceElement.getSelectedIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$WorkspaceElement.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$WorkspaceElement.setSelectedIndex(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$WorkspaceElement.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.Workspaces$DnDHandler" intfc="n" abs="n" inn="y" sloc="36" jdoc="">
			<mth name="/lib/:org.jext.misc.Workspaces$DnDHandler.dragEnter(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$DnDHandler.dragOver(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$DnDHandler.dragExit(DropTargetEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$DnDHandler.dragScroll(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$DnDHandler.dropActionChanged(DropTargetDragEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.misc.Workspaces$DnDHandler.drop(DropTargetDropEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.PluginDesc" intfc="n" abs="n" inn="n" sloc="207" jdoc="">
			<comm cntt="these are the datas which are stored. This class is mainly a get set method collector."/>
			<comm cntt="maybe an additional fields with the jar name to check if it is already installed?"/>
			<comm cntt="FIXME: add fields to remember whether a plugin has been downloaded in this session; give errors if redownloading,"/>
			<comm cntt="offering to do it anyway."/>
			<comm cntt="User-specific installation folders."/>
			<comm cntt="System-wide installation folders."/>
			<comm cntt="This is an enumeration of path positions inside the array."/>
			<comm cntt="FIXME: this should be true on Windows 9x system."/>
			<comm cntt="FIXME: instead of using all these &amp;quot;notify&amp;quot;-back runnables, let&amp;apos;s establish"/>
			<comm cntt="one general purpose logger to use. Maybe(runnables can have other side effects)."/>
			<comm cntt="But let&amp;apos;s keep them only as possibility, adding another logging way."/>
			<comm cntt="FIXME: passing the mirror is broken, since we must have a list of mirror, when one of them fails."/>
			<comm cntt="--FIELDS part."/>
			<comm cntt="SET"/>
			<comm cntt="GET"/>
			<field name="srcName" access="priv" jdoc=""/>
			<field name="binName" access="priv" jdoc=""/>
			<field name="srcSize" access="priv" jdoc=""/>
			<field name="binSize" access="priv" jdoc=""/>
			<field name="desc" access="priv" jdoc=""/>
			<field name="name" access="priv" jdoc=""/>
			<field name="displayName" access="priv" jdoc=""/>
			<field name="release" access="priv" jdoc=""/>
			<field name="authors" access="priv" jdoc=""/>
			<field name="deps" access="priv" jdoc=""/>
			<field name="format" access="priv" jdoc="this is the format string which is used to build the Url using the mirror and file names"/>
			<field name="binDownloaded" access="priv" jdoc=""/>
			<field name="srcDownloaded" access="priv" jdoc=""/>
			<const name="LOCAL_DOWNLOAD_PATH" access="priv" jdoc=""/>
			<const name="LOCAL_DOC_PATH" access="priv" jdoc=""/>
			<const name="LOCAL_BINLIBRARY_PATH" access="priv" jdoc=""/>
			<const name="LOCAL_LIBRARY_PATH" access="priv" jdoc=""/>
			<const name="LOCAL_PLUGINS_PATH" access="priv" jdoc=""/>
			<const name="SYSTEM_DOWNLOAD_PATH" access="priv" jdoc=""/>
			<const name="SYSTEM_DOC_PATH" access="priv" jdoc=""/>
			<const name="SYSTEM_BINLIBRARY_PATH" access="priv" jdoc=""/>
			<const name="SYSTEM_LIBRARY_PATH" access="priv" jdoc=""/>
			<const name="SYSTEM_PLUGINS_PATH" access="priv" jdoc=""/>
			<const name="DOWNLOAD_PATH_ID" access="priv" jdoc=""/>
			<const name="DOC_PATH_ID" access="priv" jdoc=""/>
			<const name="BINLIBRARY_PATH_ID" access="priv" jdoc=""/>
			<const name="LIBRARY_PATH_ID" access="priv" jdoc=""/>
			<const name="PLUGINS_PATH_ID" access="priv" jdoc=""/>
			<const name="LOCAL_PATHS" access="priv" jdoc=""/>
			<const name="SYSTEM_PATHS" access="priv" jdoc=""/>
			<field name="PATHS" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.PluginDesc.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.PluginDesc(String, String, String)" access="pub" jdoc="">
				<param name="_name"/>
				<param name="_release"/>
				<param name="_displayName"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.isLocalInstallation()" access="pub" jdoc="Return the &amp;quot;local installation&amp;quot; flag. We say that a plugin is installed &amp;lt;i&amp;gt;locally&amp;lt; i&amp;gt; if it is put in the user-specific &amp;lt;code&amp;gt;Jext.SETTINGS_DIRECTORY&amp;lt; code&amp;gt;, (i.e. .jext); otherwise, it is installed in the &amp;lt;code&amp;gt;Jext.JEXT_HOME&amp;lt; code&amp;gt;. Call only from the AWT EventQueue thread. @return The value of the &amp;quot;local installation&amp;quot; flag. @see #setLocalInstallation(boolean)">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setLocalInstallation(boolean)" access="pub" jdoc="Sets the &amp;quot;local installation&amp;quot; flag. Call only from the AWT EventQueue thread. @see #isLocalInstallation() for the meaning of this flag.">
				<param name="local"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.initDirectories()" access="pub" jdoc="This method tries to build all folders used by PluginGet. CHECKED">
				<comm cntt="friendly"/>
				<comm cntt="delete the final Char."/>
				<comm cntt="preserve possible existing files."/>
				<comm cntt="it keeps on going, however."/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.downloadSrc(HandlingRunnable, String)" access="pub" jdoc="">
				<comm cntt="srcDownloaded = true;"/>
				<param name="notifier"/>
				<param name="mirror"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.downloadBin(HandlingRunnable, String)" access="pub" jdoc="">
				<comm cntt="binDownloaded = true;"/>
				<param name="notifier"/>
				<param name="mirror"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.install(Runnable)" access="pub" jdoc="">
				<param name="notifyMissing"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.install(Runnable, String)" access="pub" jdoc="">
				<comm cntt="For instance the themes directory for SkinLF."/>
				<comm cntt="i.e. it is under a folder!!"/>
				<comm cntt="but many plugins would require installing themselves"/>
				<comm cntt="within system bin folder. How to solve this? FIXME"/>
				<comm cntt="the plugin&amp;apos;s jar has the same name as the plugin,"/>
				<comm cntt="while the other jars are libraries."/>
				<comm cntt="for text files; we create a doc &amp;lt;plugName&amp;gt; folder."/>
				<comm cntt="Other files."/>
				<comm cntt="??"/>
				<comm cntt="Could fail and return false!"/>
				<comm cntt="FIXME: Utilities.copy() doesn&amp;apos;t throw any more any exception."/>
				<param name="notifyMissing"/>
				<param name="path"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getSrcUrl(String)" access="pub" jdoc="Returns the url of the source pack of this plugin">
				<param name="mirror"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getBinUrl(String)" access="pub" jdoc="Returns the url of the binary pack of this plugin">
				<param name="mirror"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setName(String)" access="pub" jdoc="">
				<param name="_name"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setDisplayName(String)" access="pub" jdoc="">
				<param name="_displayName"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setRelease(String)" access="pub" jdoc="">
				<param name="_release"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setDesc(String)" access="pub" jdoc="">
				<param name="_desc"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setSrcName(String, int)" access="pub" jdoc="">
				<param name="_srcName"/>
				<param name="_size"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setBinName(String, int)" access="pub" jdoc="">
				<param name="_binName"/>
				<param name="_size"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setUrlFormatter(Format)" access="pub" jdoc="">
				<param name="_format"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setAuthors(PluginAuthor[])" access="pub" jdoc="">
				<param name="_authors"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.setDeps(String[])" access="pub" jdoc="">
				<param name="_deps"/>
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getDisplayName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getBinSize()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getSrcSize()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getDesc()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getRelease()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getAuthors()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.PluginDesc.getDeps()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.ProjectPanel" intfc="n" abs="n" inn="n" sloc="29" jdoc="">
			<field name="panelCard" access="priv" jdoc=""/>
			<field name="carder" access="priv" jdoc=""/>
			<field name="workspaces" access="priv" jdoc=""/>
			<field name="bookmarks" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.misc.ProjectPanel.ProjectPanel(JextFrame)" access="pub" jdoc="">
				<comm cntt="adds components"/>
				<comm cntt="panelCard.setBorder(LineBorder.createBlackLineBorder()); new BevelBorder(BevelBorder.LOWERED));"/>
				<comm cntt="buttons"/>
				<comm cntt="JPanel buttonsPanel = new JPanel();"/>
				<comm cntt="group"/>
				<comm cntt="show and set"/>
				<param name="parent"/>
			</mth>
		<class name="/lib/:org.jext.misc.ProjectPanel$ToggleHandler" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<mth name="/lib/:org.jext.misc.ProjectPanel$ToggleHandler.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.Indent" intfc="n" abs="n" inn="n" sloc="152" jdoc="">
			<mth name="/lib/:org.jext.misc.Indent.indent(JextTextArea, int, boolean, boolean)" access="pub" jdoc="">
				<comm cntt="Get properties"/>
				<comm cntt="Get line text"/>
				<comm cntt="If &amp;apos;prevLineIndent&amp;apos; matches a line --&amp;gt; +1"/>
				<comm cntt="On the previous line, if(bob) { --&amp;gt; +1 if(bob) { } --&amp;gt; 0 } else if(bob) { --&amp;gt; +1"/>
				<comm cntt="False after initial indent"/>
				<comm cntt="Indent width (tab expanded)"/>
				<comm cntt="Additional bracket indent"/>
				<comm cntt="On the current line, } --&amp;gt; -1 } else if(bob) { --&amp;gt; -1 if(bob) { } --&amp;gt; 0"/>
				<comm cntt="False after initial indent"/>
				<comm cntt="Indent width (tab expanded)"/>
				<comm cntt="White space count"/>
				<comm cntt="Additional bracket indent"/>
				<comm cntt="For lining up closing"/>
				<comm cntt="and opening brackets"/>
				<comm cntt="Do it"/>
				<param name="textArea"/>
				<param name="lineIndex"/>
				<param name="canIncreaseIndent"/>
				<param name="canDecreaseIndent"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.FindAccessory" intfc="n" abs="n" inn="n" sloc="219" jdoc="A threaded file search accessory for JFileChooser. &amp;lt;P&amp;gt; Presents JFileChooser users with a tabbed panel interface for specifying file search criteria including (1) search by name, (2) search by date of modification, and (3) search by file content. Finded are performed &amp;quot;in the background&amp;quot; with found files displayed dynamically as they are found. Only one search can be active at a time. FindResults are displayed in a scrolling list within a results tab panel. &amp;lt;P&amp;gt; Findes are performed asynchronously so the user can continue browsing the file system. The user may stop the search at any time. Accepting or cancelling the file chooser or closing the dialog window will automatically stop a search in progress. &amp;lt;P&amp;gt; The starting folder of the search (the search base) is displayed at the top of the accessory panel. The search base dsiplay will not change while a search is running. Thes search base display will change to reflect the current directory of JFileChooser when a search is not running. &amp;lt;P&amp;gt; Changing the search options does not affect a search in progress. @version 1.0, 2000 01 19 @author Ken Klinner, kklinner@opiom.com">
			<comm cntt="&amp;quot; Find &amp;quot;;"/>
			<comm cntt="&amp;quot;Start&amp;quot;;"/>
			<comm cntt="&amp;quot;Stop&amp;quot;;"/>
			<const name="ACCESSORY_NAME" access="pub" jdoc="Label for this accessory."/>
			<const name="DEFAULT_MAX_SEARCH_HITS" access="pub" jdoc="Default max number of found items. Prevents overloading results list."/>
			<const name="ACTION_START" access="pub" jdoc="Find start action name"/>
			<const name="ACTION_STOP" access="pub" jdoc="Find stop action name"/>
			<field name="chooser" access="prot" jdoc="Parent JFileChooser component"/>
			<field name="actionStart" access="prot" jdoc=""/>
			<field name="actionStop" access="prot" jdoc=""/>
			<field name="searchThread" access="prot" jdoc="This version of FindAccesory supports only one active search thread"/>
			<field name="killFind" access="prot" jdoc="Set to true to stop current search"/>
			<field name="searchTabs" access="prot" jdoc="Find options with results list"/>
			<field name="controlPanel" access="prot" jdoc="Find controls with progress display"/>
			<field name="total" access="prot" jdoc="Number of items inspected by current last search"/>
			<field name="matches" access="prot" jdoc="Number of items found by current last search"/>
			<field name="maxMatches" access="prot" jdoc="Max number of found items to prevent overloading the results list."/>
			<mth name="/lib/:org.jext.misc.FindAccessory.FindAccessory()" access="pub" jdoc="Construct a search panel with start and stop actions, option panes and a results list pane that can display up to DEFAULT_MAX_SEARCH_HITS items.">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.FindAccessory(JFileChooser)" access="pub" jdoc="Construct a search panel with start and stop actions and &amp;quot;attach&amp;quot; it to the specified JFileChooser component. Calls register() to establish FindAccessory as a PropertyChangeListener of JFileChooser. @param parent JFileChooser containing this accessory">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.FindAccessory(JFileChooser, int)" access="pub" jdoc="Construct a search panel with start and stop actions and &amp;quot;attach&amp;quot; it to the specified JFileChooser component. Calls register() to establish FindAccessory as a PropertyChangeListener of JFileChooser. Sets maximum number of found items to limit the load in the results list. @param parent JFileChooser containing this accessory @param max Max number of items for results list. Find stops when max number of items found.">
				<param name="c"/>
				<param name="max"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.setMaxFindHits(int)" access="pub" jdoc="Sets maximum capacity of the results list. Find stops when max number of items found. @param max Max capacity of results list.">
				<param name="max"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.getMaxFindHits()" access="pub" jdoc="Returns maximum capacity of results list. @return Max capacity of results list.">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.actionPerformed(ActionEvent)" access="pub" jdoc="Called by JFileChooser when the user provokes an action like &amp;quot;cancel&amp;quot; or &amp;quot;open&amp;quot;. Listens for APPROVE_SELECTION and CANCEL_SELECTION action and stops the current search, if there is one. @param e ActionEvent from parent JFileChooser.">
				<comm cntt="Can this happen? Probably not. Call me paranoid."/>
				<param name="e"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.goTo(File)" access="pub" jdoc="Set parent&amp;apos;s current directory to the parent folder of the specified file and select the specified file. This method is invoked when the user double clicks on an item in the results list. @param f File to select in parent JFileChooser">
				<comm cntt="Make sure that files and directories can be displayed"/>
				<comm cntt="Make sure that parent file chooser will show the type of file"/>
				<comm cntt="specified"/>
				<comm cntt="The current filter will not display the specified file."/>
				<comm cntt="Set the file filter to the built-in accept-all filter ( . )"/>
				<comm cntt="Tell parent file chooser to display contents of parentFolder."/>
				<comm cntt="Prior to Java 1.2.2 setSelectedFile() did not set the current"/>
				<comm cntt="directory the folder containing the file to be selected."/>
				<comm cntt="Nullify the current selection, if any."/>
				<comm cntt="Why is this necessary?"/>
				<comm cntt="Emperical evidence suggests that JFileChooser gets &amp;quot;sticky&amp;quot; (i.e. it"/>
				<comm cntt="does not always relinquish the current selection). Nullifying the"/>
				<comm cntt="current selection seems to yield better results."/>
				<comm cntt="Select the file"/>
				<comm cntt="Refresh file chooser display."/>
				<comm cntt="Is this really necessary? Testing on a variety of systems with"/>
				<comm cntt="Java 1.2.2 suggests that this helps. Sometimes it doesn&amp;apos;t work,"/>
				<comm cntt="but it doesn&amp;apos;t do any harm."/>
				<param name="f"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.startThread()" access="pub" jdoc="Start a search. The path display will show the starting folder of the search. Finds are recursive and will span the entire folder hierarchy below the base folder. The user may continue to browse with JFileChooser.">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.stop()" access="pub" jdoc="Stop the active search.">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.isRunning()" access="pub" jdoc="@return true if a search is currently running">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.run()" access="pub" jdoc="Find thread">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.runFind(File, FindFilter[])" access="prot" jdoc="Recursive search beginning at folder &amp;lt;b&amp;gt;base&amp;lt; b&amp;gt; for files and folders matching each filter in the &amp;lt;b&amp;gt;filters&amp;lt; b&amp;gt; array. To interrupt set &amp;lt;b&amp;gt;killFind&amp;lt; b&amp;gt; to true. Also stops when number of search hits (matches) equals &amp;lt;b&amp;gt;maxMatches&amp;lt; b&amp;gt;. &amp;lt;P&amp;gt; &amp;lt;b&amp;gt;Note:&amp;lt; b&amp;gt; Convert this to a nonrecursive search algorithm on systems where stack space might be limited and or the search hierarchy might be very deep. @param base starting folder of search @param filters matches must pass each filters in array @exception InterruptedException if thread is interrupted">
				<comm cntt="Not likely to happen"/>
				<comm cntt="Utilities.listFiles(folder.list(), false);"/>
				<comm cntt="stopgap measure so that we don&amp;apos;t overload"/>
				<param name="base"/>
				<param name="filters"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.accept(File, FindFilter[])" access="prot" jdoc="@param file file to pass to each filter&amp;apos;s accept method @param filters array of selection criteria @return true if specified file matches each filter&amp;apos;s selection criteria">
				<param name="file"/>
				<param name="filters"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.reportProgress(FindFilter, File, long, long)" access="pub" jdoc="Called by FindFilter to report progress of a search. Purely a voluntary report. This really should be implemented as a property change listener. Percentage completion = (current total) 100. @param filter FindFilter reporting progress @param file file being searched @param current current &amp;quot;location&amp;quot; of search @param total expected maximum value of current @return true to continue search, false to abort">
				<param name="filter"/>
				<param name="file"/>
				<param name="current"/>
				<param name="total"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.newFind()" access="prot" jdoc="Begins a new search by resetting the &amp;lt;b&amp;gt;total&amp;lt; b&amp;gt; and &amp;lt;b&amp;gt;matches&amp;lt; b&amp;gt; progress variables and retrieves the search filter array from the options panel. Each tab in the options panel is responsible for generating a FindFilter based on its current settings. @return Array of search filters from the options panel.">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.updateProgress()" access="prot" jdoc="Display progress of running search.">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.register(JFileChooser)" access="prot" jdoc="Add this component to the specified JFileChooser&amp;apos;s list of property change listeners and action listeners. @param c parent JFileChooser">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.unregister(JFileChooser)" access="prot" jdoc="Remove this component from the specified JFileChooser&amp;apos;s list of property change listeners and action listeners. @param c parent JFileChooser">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.quit()" access="pub" jdoc="Stop the current search and unregister in preparation for parent shutdown.">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory.action(String)" access="pub" jdoc="Invoked by FindAction objects to start and stop searches.">
				<param name="command"/>
			</mth>
		<class name="/lib/:org.jext.misc.FindAccessory$FindAction" intfc="n" abs="n" inn="y" sloc="11" jdoc="Convenience class for adding action objects to the control panel.">
			<mth name="/lib/:org.jext.misc.FindAccessory$FindAction.FindAction(String, Icon)" access="pub" jdoc="Construct a search control action currently implements FindAccesory.ACTION_START and FindAccessory.ACTION_STOP. @param text command @param icon button icon">
				<param name="text"/>
				<param name="icon"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindAction.actionPerformed(ActionEvent)" access="pub" jdoc="Invoke FindAction&amp;apos;s action() method. @param e action event">
				<param name="e"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.FindAccessory$FindControls" intfc="n" abs="n" inn="y" sloc="25" jdoc="Find controls panel displays default action components for starting and stopping a search. Also displays the search progress in the form of a text display indicating the number of items found and the total number of items encountered in the search.">
			<field name="searchDirectory" access="prot" jdoc=""/>
			<field name="progress" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindControls.FindControls(FindAction, FindAction, boolean)" access="pub" jdoc="Construct a simple search control panel with buttons for starting and stopping a search and a simple display for search progress.">
				<comm cntt="So that frequent updates will appear smooth"/>
				<comm cntt="progress.setForeground(Color.black);"/>
				<comm cntt="progress.setFont(new Font(&amp;quot;Helvetica&amp;quot;,Font.PLAIN, 9));"/>
				<param name="find"/>
				<param name="stop"/>
				<param name="recurse"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindControls.showProgress(int, int)" access="pub" jdoc="Display search progress as a text field &amp;quot;no. of matches total searched&amp;quot;. @param matches number of items found @param total number of items investigated">
				<param name="matches"/>
				<param name="total"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.FindAccessory$FindTabs" intfc="n" abs="n" inn="y" sloc="58" jdoc="Contains a collecton of search options displayed as tabbed panes and at least one pane for displaying the search results. Each options tab pane is a user interface for sprecifying the search criteria and a factory for a FindFilter to implement the acceptance function. By making the search option pane responsible for generating a FindFilter object, the programmer can easily extend the search capabilities without modifying the controlling search engine.">
			<comm cntt="&amp;quot;Name&amp;quot;;"/>
			<comm cntt="&amp;quot;Date&amp;quot;;"/>
			<comm cntt="&amp;quot;Found&amp;quot;;"/>
			<field name="TAB_NAME" access="prot" jdoc=""/>
			<field name="TAB_DATE" access="prot" jdoc=""/>
			<field name="TAB_RESULTS" access="prot" jdoc=""/>
			<field name="resultsPanel" access="prot" jdoc=""/>
			<field name="resultsScroller" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindTabs.FindTabs()" access="pub" jdoc="Construct a search tabbed pane with tab panels for seach by filename, search by date, search by content and search results.">
				<comm cntt="setForeground(Color.black);"/>
				<comm cntt="setFont(new Font(&amp;quot;Monospaced&amp;quot;,Font.BOLD, 10));"/>
				<comm cntt="Add search-by-name panel"/>
				<comm cntt="Add search-by-date panel"/>
				<comm cntt="Add results panel"/>
				<comm cntt="so that updates will be smooth"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindTabs.addFoundFile(File)" access="pub" jdoc="Adds the specified file to the results list. @param f file to add to results list">
				<param name="f"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindTabs.showFindResults()" access="pub" jdoc="Bring the search results tab panel to the front.">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindTabs.newFind()" access="pub" jdoc="Prepares the panel for a new search by clearing the results list, bringing the results tab panel to the front and generating an array of search filters for each search options pane that implements the FindFilterFactory interface. @return array of FindFilters to be used by the controlling search engine">
				<comm cntt="Clear the results display"/>
				<comm cntt="Fix the width of the scrolling results panel so the layout"/>
				<comm cntt="managers don&amp;apos;t try to make it too wide for JFileChooser"/>
				<comm cntt="Return an array of FindFilters"/>
				<comm cntt="The FindResults pane does not implement FindFilterFactory"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.FindAccessory$FindResults" intfc="n" abs="n" inn="y" sloc="51" jdoc="Appears as a special pane within the FindOptions tabbed panel. The only one that does not generate a FindFilter.">
			<field name="model" access="prot" jdoc=""/>
			<field name="fileList" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindResults.FindResults()" access="pub" jdoc="Construct a search results pane with a scrollable list of files. When an item is double-clicked the FindAccessory controller will be instructed to select the file in the parent JFileChooser&amp;apos;s item display.">
				<comm cntt="Double click listener"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindResults.append(File)" access="pub" jdoc="Add a file to the results list. @param f file found">
				<param name="f"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindResults.clear()" access="pub" jdoc="Clear all items from the results list.">
			</mth>
		<class name="/lib/:org.jext.misc.FindAccessory$FindResults$FindResultsCellRenderer" intfc="n" abs="n" inn="y" sloc="35" jdoc="Convenience class for rendering cells in the results list.">
			<mth name="/lib/:org.jext.misc.FindAccessory$FindResults$FindResultsCellRenderer.FindResultsCellRenderer()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.misc.FindAccessory$FindResults$FindResultsCellRenderer.getListCellRendererComponent(JList, Object, int, boolean, boolean)" access="pub" jdoc="">
				<comm cntt="This shouldn&amp;apos;t happen since we won&amp;apos;t be using this"/>
				<comm cntt="renderer in a combo box"/>
				<comm cntt="setFont(new Font(&amp;quot;Helvetica&amp;quot;,Font.PLAIN, 10));"/>
				<comm cntt="show absolute path of file"/>
				<comm cntt="selection characteristics"/>
				<param name="list"/>
				<param name="value"/>
				<param name="index"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
			</mth>
		</class>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.FindFilter" intfc="y" abs="n" inn="n" sloc="4" jdoc="Each search option tab that implements FindFilterFactory defines an inner class that implements FindFilter. When a search is started the search panel invokes createFindFilter() on each panel that implements FindFilterFactory, thus causing the panel to create a FindFilter object that implements its search settings.">
			<comm cntt="public boolean accept (File f);"/>
			<mth name="/lib/:org.jext.misc.FindFilter.accept(File, FindProgressCallback)" access="pub" jdoc="">
				<param name="f"/>
				<param name="monitor"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.FindProgressCallback" intfc="y" abs="n" inn="n" sloc="5" jdoc="">
			<mth name="/lib/:org.jext.misc.FindProgressCallback.reportProgress(FindFilter, File, long, long)" access="pub" jdoc="Should be called by all time-consuming search filters at a reasonable interval. Allows the search controller to report progress and to abort the search in a clean and timely way. @param filter FindFilter reporting the progress @param file the file being searched @param current current &amp;quot;location&amp;quot; of search @param total maximum value @return true if search should continue, false to abort">
				<param name="filter"/>
				<param name="file"/>
				<param name="current"/>
				<param name="total"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.FindFilterFactory" intfc="y" abs="n" inn="n" sloc="4" jdoc="Implemented by each search option panel. Each panel is responsible for creating a FindFilter object that implements the search criteria specified by its user interface.">
			<mth name="/lib/:org.jext.misc.FindFilterFactory.createFindFilter()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.misc.FindByDate" intfc="n" abs="n" inn="n" sloc="117" jdoc="Implements a user interface and generates FindFilter for selecting files by date.">
			<comm cntt="&amp;quot;The Big Bang&amp;quot;;"/>
			<comm cntt="&amp;quot;The Big Crunch&amp;quot;;"/>
			<comm cntt="&amp;quot;Yesterday&amp;quot;;"/>
			<comm cntt="&amp;quot;Today&amp;quot;;"/>
			<comm cntt="&amp;quot;Now&amp;quot;;"/>
			<comm cntt="&amp;quot;Modified&amp;quot;;"/>
			<comm cntt="&amp;quot;mm dd yyyy&amp;quot;;"/>
			<comm cntt="&amp;quot;between start of&amp;quot;;"/>
			<comm cntt="&amp;quot;and end of&amp;quot;;"/>
			<field name="THE_BIG_BANG" access="pub" jdoc=""/>
			<field name="THE_BIG_CRUNCH" access="pub" jdoc=""/>
			<field name="YESTERDAY" access="pub" jdoc=""/>
			<field name="TODAY" access="pub" jdoc=""/>
			<field name="NOW" access="pub" jdoc=""/>
			<field name="MODIFIED_LABEL" access="pub" jdoc=""/>
			<field name="FORMAT_LABEL" access="pub" jdoc=""/>
			<field name="FROM_DATE_LABEL" access="pub" jdoc=""/>
			<field name="TO_DATE_LABEL" access="pub" jdoc=""/>
			<field name="fromDateField" access="prot" jdoc=""/>
			<field name="toDateField" access="prot" jdoc=""/>
			<field name="fromDateItems" access="prot" jdoc=""/>
			<field name="toDateItems" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.misc.FindByDate.FindByDate()" access="pub" jdoc="">
				<comm cntt="Font font = new Font(&amp;quot;Helvetica&amp;quot;,Font.PLAIN, 10);"/>
				<comm cntt="Grid Layout"/>
				<comm cntt="Date selection criteria"/>
				<comm cntt="modified.setFont(font);"/>
				<comm cntt="modified.setForeground(Color.black);"/>
				<comm cntt="format note"/>
				<comm cntt="format.setFont(font);"/>
				<comm cntt="format.setForeground(Color.black);"/>
				<comm cntt="between"/>
				<comm cntt="betweenLabel.setFont(font);"/>
				<comm cntt="betweenLabel.setForeground(Color.black);"/>
				<comm cntt="from date"/>
				<comm cntt="fromDateField = new JTextField(8);"/>
				<comm cntt="fromDateField.setFont(font);"/>
				<comm cntt="and"/>
				<comm cntt="andLabel.setFont(font);"/>
				<comm cntt="andLabel.setForeground(Color.black);"/>
				<comm cntt="toDateField = new JTextField(8);"/>
				<comm cntt="toDateField.setFont(font);"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindByDate.createFindFilter()" access="pub" jdoc="Generate a search filter object based on the setting of this UI component. @return a FindFilter object that implements the selection criteria">
			</mth>
			<mth name="/lib/:org.jext.misc.FindByDate.startDateToTime(String)" access="prot" jdoc="Convenience method for converting the start date text to milliseconds since January 1, 1970. @return milliseconds since January 1, 1970">
				<comm cntt="Not exactly the beginning of time, but"/>
				<comm cntt="close enough for computer work"/>
				<param name="s"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindByDate.endDateToTime(String)" access="prot" jdoc="Convenience method for converting the end date text to milliseconds since January 1, 1970. The end time is the end of the specified day. @return milliseconds since January 1, 1970">
				<comm cntt="Valid date. Now add 24 hours to make sure that the"/>
				<comm cntt="date is inclusive"/>
				<param name="s"/>
			</mth>
		<class name="/lib/:org.jext.misc.FindByDate$DateFilter" intfc="n" abs="n" inn="y" sloc="27" jdoc="Filter object for selecting files by the date range specified by the UI.">
			<field name="startTime" access="prot" jdoc=""/>
			<field name="endTime" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.misc.FindByDate$DateFilter.DateFilter(long, long)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindByDate$DateFilter.accept(File, FindProgressCallback)" access="pub" jdoc="">
				<param name="f"/>
				<param name="callback"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.misc.FindByName" intfc="n" abs="n" inn="n" sloc="40" jdoc="Implements user interface and generates FindFilter for selecting files by name.">
			<comm cntt="&amp;quot;pattern&amp;quot;;"/>
			<comm cntt="&amp;quot;contains&amp;quot;;"/>
			<comm cntt="&amp;quot;is&amp;quot;;"/>
			<comm cntt="&amp;quot;starts with&amp;quot;;"/>
			<comm cntt="&amp;quot;ends with&amp;quot;;"/>
			<field name="NAME_PATTERN" access="prot" jdoc=""/>
			<field name="NAME_CONTAINS" access="prot" jdoc=""/>
			<field name="NAME_IS" access="prot" jdoc=""/>
			<field name="NAME_STARTS_WITH" access="prot" jdoc=""/>
			<field name="NAME_ENDS_WITH" access="prot" jdoc=""/>
			<field name="NAME_PATTERN_INDEX" access="prot" jdoc=""/>
			<field name="NAME_CONTAINS_INDEX" access="prot" jdoc=""/>
			<field name="NAME_IS_INDEX" access="prot" jdoc=""/>
			<field name="NAME_STARTS_WITH_INDEX" access="prot" jdoc=""/>
			<field name="NAME_ENDS_WITH_INDEX" access="prot" jdoc=""/>
			<field name="criteria" access="prot" jdoc=""/>
			<field name="nameField" access="prot" jdoc=""/>
			<field name="combo" access="prot" jdoc=""/>
			<field name="ignoreCaseCheck" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.misc.FindByName.FindByName()" access="pub" jdoc="">
				<comm cntt="Grid Layout"/>
				<comm cntt="Name"/>
				<comm cntt="combo.setFont(new Font(&amp;quot;Helvetica&amp;quot;,Font.PLAIN, 10));"/>
				<comm cntt="nameField.setFont(new Font(&amp;quot;Helvetica&amp;quot;,Font.PLAIN, 10));"/>
				<comm cntt="ignore case"/>
				<comm cntt="ignoreCaseCheck.setFont(new Font(&amp;quot;Helvetica&amp;quot;,Font.PLAIN, 10));"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindByName.createFindFilter()" access="pub" jdoc="">
			</mth>
		<class name="/lib/:org.jext.misc.FindByName$NameFilter" intfc="n" abs="n" inn="y" sloc="95" jdoc="Filter object for selecting files by name.">
			<field name="match" access="prot" jdoc=""/>
			<field name="howToMatch" access="prot" jdoc=""/>
			<field name="ignoreCase" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.misc.FindByName$NameFilter.NameFilter(String, int, boolean)" access="pub" jdoc="">
				<param name="name"/>
				<param name="how"/>
				<param name="ignore"/>
			</mth>
			<mth name="/lib/:org.jext.misc.FindByName$NameFilter.accept(File, FindProgressCallback)" access="pub" jdoc="">
				<param name="f"/>
				<param name="callback"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.oneclick">
		<class name="/lib/:org.jext.oneclick.OneAutoIndent" intfc="n" abs="n" inn="n" sloc="12" jdoc="">
			<mth name="/lib/:org.jext.oneclick.OneAutoIndent.OneAutoIndent()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.oneclick.OneAutoIndent.oneClickActionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.options">
		<class name="/lib/:org.jext.options.LoadingOptions" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<field name="xtreeEnabled" access="priv" jdoc=""/>
			<field name="consoleEnabled" access="priv" jdoc=""/>
			<field name="loadClasses" access="priv" jdoc=""/>
			<field name="keepInMemory" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.LoadingOptions.LoadingOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.LoadingOptions.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.LoadingOptions.save()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.options.PrintOptions" intfc="n" abs="n" inn="n" sloc="88" jdoc="">
			<field name="fonts" access="priv" jdoc=""/>
			<field name="pageLayout" access="priv" jdoc=""/>
			<field name="pgfmt" access="priv" jdoc=""/>
			<field name="lineNumbers" access="priv" jdoc=""/>
			<field name="wrap" access="priv" jdoc=""/>
			<field name="syntax" access="priv" jdoc=""/>
			<field name="header" access="priv" jdoc=""/>
			<field name="footer" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.PrintOptions.PrintOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.PrintOptions.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.PrintOptions.handleComponents()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.PrintOptions.save()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.PrintOptions.pageLayout()" access="pub" jdoc="">
				<comm cntt="make sure the pageformat is ok"/>
			</mth>
			<mth name="/lib/:org.jext.options.PrintOptions.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.options.LangOptions" intfc="n" abs="n" inn="n" sloc="43" jdoc="">
			<field name="langList" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.LangOptions.LangOptions()" access="pub" jdoc="">
				<comm cntt="langList.setVisibleRowCount(10);"/>
			</mth>
			<mth name="/lib/:org.jext.options.LangOptions.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.LangOptions.save()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.options.FileFiltersOptions" intfc="n" abs="n" inn="n" sloc="38" jdoc="">
			<field name="filtersTable" access="priv" jdoc=""/>
			<field name="filters" access="priv" jdoc=""/>
			<field name="theTableModel" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.FileFiltersOptions.FileFiltersOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions.save()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions.createTableScroller()" access="priv" jdoc="">
			</mth>
		<class name="/lib/:org.jext.options.FileFiltersOptions$FiltersTableModel" intfc="n" abs="n" inn="y" sloc="62" jdoc="">
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FiltersTableModel.FiltersTableModel()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FiltersTableModel.reload()" access="pub" jdoc="">
				<comm cntt="Evil hack, I know. Don&amp;apos;t blame me. The plain mode is not inserted as row, so when we meet it, all next rows have"/>
				<comm cntt="an index littler by 1. So displacement is 1. Very evil, I know. But so goes the world."/>
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FiltersTableModel.getColumnCount()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FiltersTableModel.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FiltersTableModel.getValueAt(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FiltersTableModel.isCellEditable(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FiltersTableModel.getColumnName(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FiltersTableModel.setValueAt(Object, int, int)" access="pub" jdoc="">
				<param name="value"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.options.FileFiltersOptions$FileFilter" intfc="n" abs="n" inn="y" sloc="26" jdoc="">
			<field name="_mode" access="priv" jdoc=""/>
			<field name="_name" access="priv" jdoc=""/>
			<field name="_filter" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FileFilter.FileFilter(String, String, String)" access="pub" jdoc="">
				<param name="mode"/>
				<param name="name"/>
				<param name="filter"/>
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FileFilter.getMode()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FileFilter.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FileFilter.getFilter()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.FileFiltersOptions$FileFilter.setFilter(String)" access="pub" jdoc="">
				<param name="filter"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.options.GeneralOptions" intfc="n" abs="n" inn="n" sloc="106" jdoc="">
			<field name="prompt" access="priv" jdoc=""/>
			<field name="saveDelay" access="priv" jdoc=""/>
			<field name="maxRecent" access="priv" jdoc=""/>
			<field name="promptPattern" access="priv" jdoc=""/>
			<field name="templatesDir" access="priv" jdoc=""/>
			<field name="check" access="priv" jdoc=""/>
			<field name="tips" access="priv" jdoc=""/>
			<field name="console" access="priv" jdoc=""/>
			<field name="fullFileName" access="priv" jdoc=""/>
			<field name="autoSave" access="priv" jdoc=""/>
			<field name="labeledSeparator" access="priv" jdoc=""/>
			<field name="saveSession" access="priv" jdoc=""/>
			<field name="scriptingDebug" access="priv" jdoc=""/>
			<field name="leftPanel" access="priv" jdoc=""/>
			<field name="topPanel" access="priv" jdoc=""/>
			<field name="newWindow" access="priv" jdoc=""/>
			<field name="scrollableTabbedPanes" access="priv" jdoc=""/>
			<field name="jythonMode" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.GeneralOptions.GeneralOptions()" access="pub" jdoc="">
				<comm cntt="this must be done here, so the values loading doesn&amp;apos;t trigger an actionPerformed"/>
			</mth>
			<mth name="/lib/:org.jext.options.GeneralOptions.load()" access="pub" jdoc="">
				<comm cntt="no item selected"/>
			</mth>
			<mth name="/lib/:org.jext.options.GeneralOptions.getComponent()" access="pub" jdoc="">
				<comm cntt="scroller.setBorder(javax.swing.border.LineBorder.createBlackLineBorder());"/>
			</mth>
			<mth name="/lib/:org.jext.options.GeneralOptions.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="else nothing is selected and nothing must be done"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.options.GeneralOptions.save()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.options.GutterOptions" intfc="n" abs="n" inn="n" sloc="66" jdoc="">
			<field name="font" access="priv" jdoc=""/>
			<field name="numberAlignment" access="priv" jdoc=""/>
			<field name="gutterExpanded" access="priv" jdoc=""/>
			<field name="lineNumbersEnabled" access="priv" jdoc=""/>
			<field name="highlightInterval" access="priv" jdoc=""/>
			<field name="gutterBorderWidth" access="priv" jdoc=""/>
			<field name="gutterWidth" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.GutterOptions.GutterOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.GutterOptions.load()" access="pub" jdoc="">
				<comm cntt="gutterExpanded.getModel().setSelected(!&amp;quot;yes&amp;quot;.equals(Jext.getProperty(&amp;quot;textArea.gutter.collapsed&amp;quot;))); lineNumbersEnabled.getModel().setSelected(!&amp;quot;no&amp;quot;.equals(Jext.getProperty(&amp;quot;textArea.gutter.lineNumbers&amp;quot;)));"/>
			</mth>
			<mth name="/lib/:org.jext.options.GutterOptions.save()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.options.KeyShortcutsOptions" intfc="n" abs="n" inn="n" sloc="91" jdoc="">
			<field name="table" access="priv" jdoc=""/>
			<field name="actions" access="priv" jdoc=""/>
			<field name="labels" access="priv" jdoc=""/>
			<field name="_keys" access="priv" jdoc=""/>
			<field name="theTableModel" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions.KeyShortcutsOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions.save()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions.createTableScroller()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions.sortStrings(String[], String[])" access="pub" jdoc="Quick sort an array of Strings. @param string Strings to be sorted">
				<param name="strings"/>
				<param name="aStrings"/>
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions.sortStrings(String, String, int, int)" access="pub" jdoc="Quick sort an array of Strings. @param a Strings to be sorted @param lo0 Lower bound @param hi0 Higher bound">
				<param name="a"/>
				<param name="b"/>
				<param name="lo0"/>
				<param name="hi0"/>
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions.swap(String, int, int)" access="pub" jdoc="Swaps two Strings. @param a The array to be swapped @param i First String index @param j Second String index">
				<param name="a"/>
				<param name="i"/>
				<param name="j"/>
			</mth>
		<class name="/lib/:org.jext.options.KeyShortcutsOptions$KeysTableModel" intfc="n" abs="n" inn="y" sloc="92" jdoc="">
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions$KeysTableModel.KeysTableModel()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions$KeysTableModel.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions$KeysTableModel.getColumnCount()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions$KeysTableModel.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions$KeysTableModel.getValueAt(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions$KeysTableModel.isCellEditable(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions$KeysTableModel.getColumnName(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.options.KeyShortcutsOptions$KeysTableModel.setValueAt(Object, int, int)" access="pub" jdoc="">
				<param name="value"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.options.SecurityOptions" intfc="n" abs="n" inn="n" sloc="28" jdoc="">
			<field name="enableServer" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.SecurityOptions.SecurityOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.SecurityOptions.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.SecurityOptions.save()" access="pub" jdoc="">
				<comm cntt="Writer writer = new BufferedWriter(new FileWriter(sec));"/>
				<comm cntt="writer.flush();"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.options.ColorTable" intfc="n" abs="n" inn="n" sloc="16" jdoc="This has been extracted from StylesOptions for universal use, especially by colorizing plugins. @author Slava Pestov, Mike Dillon, Romain Guy, Matt Benson">
			<comm cntt="end class ColorTableModel"/>
			<mth name="/lib/:org.jext.options.ColorTable.ColorTable()" access="pub" jdoc="Construct a &amp;lt;CODE&amp;gt;ColorTable&amp;lt; CODE&amp;gt; with an empty model.">
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable.ColorTable(ColorTableModel)" access="pub" jdoc="Construct a &amp;lt;CODE&amp;gt;ColorTable&amp;lt; CODE&amp;gt; with the specified model. @param model the &amp;lt;CODE&amp;gt;ColorTableModel&amp;lt; CODE&amp;gt; to use.">
				<param name="model"/>
			</mth>
		<class name="/lib/:org.jext.options.ColorTable$ListHandler" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<mth name="/lib/:org.jext.options.ColorTable$ListHandler.valueChanged(ListSelectionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.options.ColorTable$ColorTableModel" intfc="n" abs="n" inn="y" sloc="78" jdoc="&amp;lt;CODE&amp;gt;TableModel&amp;lt; CODE&amp;gt; for the &amp;lt;CODE&amp;gt;ColorTable&amp;lt; CODE&amp;gt;.">
			<comm cntt="end class ColorChoice"/>
			<comm cntt="end class ColorRenderer"/>
			<field name="colorChoices" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.ColorTableModel()" access="pub" jdoc="Construct an empty &amp;lt;CODE&amp;gt;ColorTableModel&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.ColorTableModel(Map)" access="pub" jdoc="Construct a &amp;lt;CODE&amp;gt;ColorTableModel&amp;lt; CODE&amp;gt; and initialize it with the contents of the specified &amp;lt;CODE&amp;gt;Map&amp;lt; CODE&amp;gt;. @param choices the &amp;lt;CODE&amp;gt;Map&amp;lt; CODE&amp;gt; containing the initial choices for this &amp;lt;CODE&amp;gt;ColorTableModel&amp;lt; CODE&amp;gt;. This should be a map of &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; to &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt;, so it would be sensible to use a &amp;lt;CODE&amp;gt;Properties&amp;lt; CODE&amp;gt; object, but this is not enforced beyond that the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; forms of the keys and values in the &amp;lt;CODE&amp;gt;Map&amp;lt; CODE&amp;gt; will be used. Each map entry will be added to the &amp;lt;CODE&amp;gt;ColorTableModel&amp;lt; CODE&amp;gt; as if by &amp;lt;code&amp;gt;addColorChoice(String, String)&amp;lt; code&amp;gt;. @see addColorChoice(String, String)">
				<comm cntt="end while more keys"/>
				<param name="choices"/>
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.getColumnCount()" access="pub" jdoc="@see TableModel#getColumnCount()">
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.getRowCount()" access="pub" jdoc="@see TableModel#getRowCount()">
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.getValueAt(int, int)" access="pub" jdoc="@see TableModel#getValueAt(int,int)">
				<comm cntt="end switch on column number"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.setValueAt(Object, int, int)" access="pub" jdoc="@see TableModel#setValueAt(Object,int,int)">
				<param name="value"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.getColumnName(int)" access="pub" jdoc="@see TableModel#getColumnName(int)">
				<comm cntt="end switch on index"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.save()" access="pub" jdoc="Save the contents of this &amp;lt;CODE&amp;gt;ColorTableModel&amp;lt; CODE&amp;gt; to Jext properties.">
				<comm cntt="end for through color choices"/>
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.load()" access="pub" jdoc="Reload all the colors of this &amp;lt;CODE&amp;gt;ColorTableModel&amp;lt; CODE&amp;gt; from Jext properties. Added for the Option Dialog caching.">
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel.addColorChoice(String, String)" access="pub" jdoc="Add the specified color choice to this &amp;lt;CODE&amp;gt;ColorTableModel&amp;lt; CODE&amp;gt;. @param label &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; property name for the description. @param property &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; property name for the color.">
				<param name="label"/>
				<param name="property"/>
			</mth>
		<class name="/lib/:org.jext.options.ColorTable$ColorTableModel$ColorChoice" intfc="n" abs="n" inn="y" sloc="16" jdoc="">
			<field name="label" access="pub" jdoc=""/>
			<field name="property" access="pub" jdoc=""/>
			<field name="color" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel$ColorChoice.ColorChoice(String, String)" access="pub" jdoc="">
				<comm cntt=", Color color"/>
				<param name="label"/>
				<param name="property"/>
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel$ColorChoice.resetColor()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.options.ColorTable$ColorTableModel$ColorRenderer" intfc="n" abs="n" inn="y" sloc="31" jdoc="">
			<comm cntt="TableCellRenderer implementation"/>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel$ColorRenderer.ColorRenderer()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.ColorTable$ColorTableModel$ColorRenderer.getTableCellRendererComponent(JTable, Object, boolean, boolean, int, int)" access="pub" jdoc="">
				<comm cntt="end if selected"/>
				<comm cntt="end else, not selected"/>
				<param name="table"/>
				<param name="value"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
		</class>
		</class>
		</class>
		<class name="/lib/:org.jext.options.EditorOptions" intfc="n" abs="n" inn="n" sloc="145" jdoc="">
			<comm cntt="JPanel implements OptionPane"/>
			<field name="fonts" access="priv" jdoc=""/>
			<field name="autoScroll" access="priv" jdoc=""/>
			<field name="linesInterval" access="priv" jdoc=""/>
			<field name="wrapGuide" access="priv" jdoc=""/>
			<field name="newline" access="priv" jdoc=""/>
			<field name="tabSize" access="priv" jdoc=""/>
			<field name="modes" access="priv" jdoc=""/>
			<field name="encoding" access="priv" jdoc=""/>
			<field name="orientation" access="priv" jdoc=""/>
			<field name="enterIndent" access="priv" jdoc=""/>
			<field name="tabIndent" access="priv" jdoc=""/>
			<field name="softTabs" access="priv" jdoc=""/>
			<field name="blockCaret" access="priv" jdoc=""/>
			<field name="selection" access="priv" jdoc=""/>
			<field name="smartHomeEnd" access="priv" jdoc=""/>
			<field name="splitArea" access="priv" jdoc=""/>
			<field name="fullFileName" access="priv" jdoc=""/>
			<field name="lineHighlight" access="priv" jdoc=""/>
			<field name="eolMarkers" access="priv" jdoc=""/>
			<field name="blinkCaret" access="priv" jdoc=""/>
			<field name="tabStop" access="priv" jdoc=""/>
			<field name="linesIntervalEnabled" access="priv" jdoc=""/>
			<field name="wrapGuideEnabled" access="priv" jdoc=""/>
			<field name="dirDefaultDialog" access="priv" jdoc=""/>
			<field name="overSpace" access="priv" jdoc=""/>
			<field name="addExtraLineFeed" access="priv" jdoc=""/>
			<field name="preserveLineTerm" access="priv" jdoc=""/>
			<field name="modeNames" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.EditorOptions.EditorOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.EditorOptions.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.EditorOptions.getComponent()" access="pub" jdoc="">
				<comm cntt="scroller.setBorder(javax.swing.border.LineBorder.createBlackLineBorder());"/>
			</mth>
			<mth name="/lib/:org.jext.options.EditorOptions.save()" access="pub" jdoc="">
				<comm cntt="Jext.setProperty(&amp;quot;editor.colorize.mode&amp;quot;, ((Mode) Jext.modes.get(modes.getSelectedIndex())).getModeName());"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.options.OptionsDialog" intfc="n" abs="n" inn="n" sloc="304" jdoc="">
			<comm cntt="private Hashtable panes; not any more needed"/>
			<comm cntt="if the user clicks cancel, options must be reloaded"/>
			<comm cntt="when it&amp;apos;s building the dialog the first time, it must now use it to"/>
			<comm cntt="select plugins which support the re-load()&amp;apos;ing of options."/>
			<comm cntt="the plugin it&amp;apos;s currently loading."/>
			<comm cntt="need to know this to show wait cursor after first load; commented out since it doesn&amp;apos;t work"/>
			<comm cntt="anyway"/>
			<comm cntt="for UIOptions"/>
			<field name="paneTree" access="priv" jdoc=""/>
			<field name="cardPanel" access="priv" jdoc=""/>
			<field name="currentLabel" access="priv" jdoc=""/>
			<field name="ok" access="priv" jdoc=""/>
			<field name="cancel" access="priv" jdoc=""/>
			<field name="apply" access="priv" jdoc=""/>
			<field name="jextGroup" access="priv" jdoc=""/>
			<field name="pluginsGroup" access="priv" jdoc=""/>
			<field name="theInstance" access="priv" jdoc=""/>
			<field name="theTree" access="priv" jdoc=""/>
			<field name="toReload" access="priv" jdoc=""/>
			<field name="isLoadingPlugs" access="priv" jdoc=""/>
			<field name="isLoadingCore" access="priv" jdoc=""/>
			<field name="currPaneName" access="priv" jdoc=""/>
			<field name="currPlugin" access="priv" jdoc=""/>
			<field name="cachPlugPanes" access="priv" jdoc=""/>
			<field name="notCachPlugPanes" access="priv" jdoc=""/>
			<field name="notCachPlugin" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.OptionsDialog.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.showOptionDialog(JextFrame)" access="pub" jdoc="Call this to show the dialog; every other method should not be called, except (very rarely, however) by Jext kernel itself, with the only exceptions of{@link #addOptionPane(OptionPane) addOptionPane} and{@link #addOptionGroup(OptionGroup) addOptionGroup} methods.">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.OptionsDialog(JextFrame)" access="priv" jdoc="">
				<comm cntt="number of elements. It should be more than needed one."/>
				<comm cntt="BorderFactory.createCompoundBorder("/>
				<comm cntt="new SoftBevelBorder(SoftBevelBorder.RAISED),"/>
				<comm cntt="new EtchedBorder(EtchedBorder.RAISED));"/>
				<comm cntt="currentLabel displays the path of the currently selected"/>
				<comm cntt="OptionPane at the top of the stage area"/>
				<comm cntt="compute the Jext branch"/>
				<comm cntt="register the Options dialog as a TreeSelectionListener."/>
				<comm cntt="this is done before the initial selection to ensure that the"/>
				<comm cntt="first selected OptionPane is displayed on startup."/>
				<comm cntt="select the first member of the Jext group"/>
				<comm cntt="register the MouseHandler to open and close branches"/>
				<param name="_parent"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.ok(boolean)" access="priv" jdoc="">
				<param name="close"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.ok()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.cancel()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.reload()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.reloadStdPanes()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.reloadPluginPanes()" access="priv" jdoc="">
				<comm cntt="This is when a plugin does not extends"/>
				<comm cntt="AbstractOptionPane but implements directly the interface OptionPane, which has now new"/>
				<comm cntt="methods"/>
				<comm cntt="I hope this will never happen, but it has happened with the Java plugin(JBrowse option pane)."/>
				<comm cntt="This is when a plugin does not extends"/>
				<comm cntt="AbstractOptionPane but implements directly the interface OptionPane, which has now new"/>
				<comm cntt="methods"/>
				<comm cntt="I hope this will never happen, but it has happened with the Java plugin(JBrowse option pane)."/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.addOptionGroup(OptionGroup)" access="pub" jdoc="Use this method or addOptionPane to add your option pane to Jext. You must use this one and not anything else! See Jext Docs(the Plugin section is very good). If you use OptionGroup.addOptionPane after adding the pane, it is a bug. The pane must be added both to the tree and to a CardLayout to show it. Also, it must be managed to be eventually cached.">
				<param name="group"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.addOptionPane(OptionPane)" access="pub" jdoc="Use this method or addOptionGroup to add your option pane to Jext. You must use this one and not anything else! See Jext Docs(the Plugin section is very good). If you use OptionGroup.addOptionPane after adding the pane, it is a bug. The pane must be added both to the tree and to a CardLayout to show it. Also, it must be managed to be eventually cached.">
				<param name="pane"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.addOptionGroup(OptionGroup, OptionGroup)" access="priv" jdoc="">
				<param name="child"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.addOptionPane(OptionPane, OptionGroup)" access="priv" jdoc="">
				<comm cntt="Let&amp;apos;s trace reloadable panes and the ones I must rebuild."/>
				<comm cntt="a value is given to currPlugin in createOptionTreeModel()"/>
				<comm cntt="so every plugin is added to notCachPlugin only one time."/>
				<comm cntt="NOTE: when a single plugin has both reloadable and not reloadable plugin panes, all this code is likely to be"/>
				<comm cntt="buggy."/>
				<param name="pane"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.createOptionTreeModel()" access="priv" jdoc="">
				<comm cntt="Either isLoadingCore or isLoadingPlugs must be true in order to make addOptionPane work."/>
				<comm cntt="addOptionPane(new KeywordsOptions(), jextGroup);"/>
				<comm cntt="initialize the Plugins branch of the options tree"/>
				<comm cntt="Query plugins for option panes"/>
				<comm cntt="so the added panes are tracked to know what ones must be rebuilt and what ones must be reloaded."/>
				<comm cntt="This is when a plugin does not extends"/>
				<comm cntt="AbstractOptionPane but implements directly the interface OptionPane, which has now new"/>
				<comm cntt="methods"/>
				<comm cntt="I hope this will never happen, but it has happened with the Java plugin(JBrowse option pane)."/>
				<comm cntt="only add the Plugins branch if there are OptionPanes"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog.valueChanged(TreeSelectionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		<class name="/lib/:org.jext.options.OptionsDialog$MouseHandler" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<mth name="/lib/:org.jext.options.OptionsDialog$MouseHandler.mouseClicked(MouseEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.options.OptionsDialog$PaneNameRenderer" intfc="n" abs="n" inn="y" sloc="50" jdoc="">
			<field name="noFocusBorder" access="priv" jdoc=""/>
			<field name="focusBorder" access="priv" jdoc=""/>
			<field name="paneFont" access="priv" jdoc=""/>
			<field name="groupFont" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.OptionsDialog$PaneNameRenderer.PaneNameRenderer()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$PaneNameRenderer.getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)" access="pub" jdoc="">
				<param name="tree"/>
				<param name="value"/>
				<param name="selected"/>
				<param name="expanded"/>
				<param name="leaf"/>
				<param name="row"/>
				<param name="hasFocus"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel" intfc="n" abs="n" inn="y" sloc="115" jdoc="">
			<field name="root" access="priv" jdoc=""/>
			<field name="listenerList" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.addTreeModelListener(TreeModelListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.removeTreeModelListener(TreeModelListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.getChild(Object, int)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.getChildCount(Object)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.getIndexOfChild(Object, Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="child"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.getRoot()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.isLeaf(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.valueForPathChanged(TreePath, Object)" access="pub" jdoc="">
				<comm cntt="this model may not be changed by the TableCellEditor"/>
				<param name="path"/>
				<param name="newValue"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.fireNodesChanged(Object, Object[], int[], Object[])" access="prot" jdoc="">
				<param name="source"/>
				<param name="path"/>
				<param name="childIndices"/>
				<param name="children"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.fireNodesInserted(Object, Object[], int[], Object[])" access="prot" jdoc="">
				<param name="source"/>
				<param name="path"/>
				<param name="childIndices"/>
				<param name="children"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.fireNodesRemoved(Object, Object[], int[], Object[])" access="prot" jdoc="">
				<param name="source"/>
				<param name="path"/>
				<param name="childIndices"/>
				<param name="children"/>
			</mth>
			<mth name="/lib/:org.jext.options.OptionsDialog$OptionTreeModel.fireTreeStructureChanged(Object, Object[], int[], Object[])" access="prot" jdoc="">
				<param name="source"/>
				<param name="path"/>
				<param name="childIndices"/>
				<param name="children"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.options.UIOptions" intfc="n" abs="n" inn="n" sloc="127" jdoc="">
			<comm cntt="antiAliasing,"/>
			<comm cntt=""/>
			<comm cntt="BB1"/>
			<comm cntt="Updates all Jext instances + the options dialog box"/>
			<comm cntt=""/>
			<field name="icons" access="priv" jdoc=""/>
			<field name="skins" access="priv" jdoc=""/>
			<field name="showToolbar" access="priv" jdoc=""/>
			<field name="labeledSeparator" access="priv" jdoc=""/>
			<field name="gray" access="priv" jdoc=""/>
			<field name="flatMenus" access="priv" jdoc=""/>
			<field name="buttonsHighlight" access="priv" jdoc=""/>
			<field name="toolbarRollover" access="priv" jdoc=""/>
			<field name="decoratedFrames" access="priv" jdoc=""/>
			<const name="iconsInternNames" access="priv" jdoc=""/>
			<const name="iconsNames" access="priv" jdoc=""/>
			<field name="currSkinIndex" access="priv" jdoc=""/>
			<field name="skinsNames" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.UIOptions.UIOptions()" access="pub" jdoc="">
				<comm cntt="addComponent(antiAliasing = new JextCheckBox(Jext.getProperty(&amp;quot;options.antialiasing.label&amp;quot;)));"/>
				<comm cntt="WAITING FOR ANTI-ALIAS BUG FIX"/>
				<comm cntt="antiAliasing.setEnabled(false);"/>
				<comm cntt="addComponent(jextTheme = new JextCheckBox(Jext.getProperty(&amp;quot;options.jexttheme.label&amp;quot;)));"/>
			</mth>
			<mth name="/lib/:org.jext.options.UIOptions.load()" access="pub" jdoc="">
				<comm cntt="WAITING FOR ANTI-ALIAS BUG FIX"/>
				<comm cntt="antiAliasing.setSelected(Jext.getBooleanProperty(&amp;quot;editor.antiAliasing&amp;quot;));"/>
			</mth>
			<mth name="/lib/:org.jext.options.UIOptions.getComponent()" access="pub" jdoc="">
				<comm cntt="scroller.setBorder(javax.swing.border.LineBorder.createBlackLineBorder());"/>
			</mth>
			<mth name="/lib/:org.jext.options.UIOptions.control(boolean)" access="priv" jdoc="">
				<param name="selection"/>
			</mth>
			<mth name="/lib/:org.jext.options.UIOptions.save()" access="pub" jdoc="">
				<comm cntt="Jext.setProperty(&amp;quot;editor.antiAliasing&amp;quot;, antiAliasing.isSelected() ? &amp;quot;on&amp;quot; : &amp;quot;off&amp;quot;);"/>
				<comm cntt=""/>
				<comm cntt="BB1"/>
				<comm cntt=""/>
			</mth>
			<mth name="/lib/:org.jext.options.UIOptions.updateUIs()" access="priv" jdoc="">
				<comm cntt="frame.pack(); it would make sense, but the window becomes too big."/>
				<comm cntt="So REMOVED."/>
			</mth>
		<class name="/lib/:org.jext.options.UIOptions$SkinItem" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<field name="skinName" access="pub" jdoc=""/>
			<field name="skinIntName" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.options.UIOptions$SkinItem.SkinItem(String, String)" access="pub" jdoc="">
				<param name="skinName"/>
				<param name="skinIntName"/>
			</mth>
			<mth name="/lib/:org.jext.options.UIOptions$SkinItem.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/lib/:org.jext.options.UIOptions$SkinItem.compareTo(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/lib/:org.jext.options.UIOptions$SkinItem.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.options.StyleTable" intfc="n" abs="n" inn="n" sloc="16" jdoc="This has been extracted from StylesOptions for universal use. @author Slava Pestov, Mike Dillon, Romain Guy, Matt Benson">
			<comm cntt="end class ListHandler"/>
			<comm cntt="end class StyleTableModel"/>
			<comm cntt="end class StyleEditor"/>
			<mth name="/lib/:org.jext.options.StyleTable.StyleTable()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable.StyleTable(StyleTableModel)" access="pub" jdoc="">
				<param name="model"/>
			</mth>
		<class name="/lib/:org.jext.options.StyleTable$ListHandler" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<mth name="/lib/:org.jext.options.StyleTable$ListHandler.valueChanged(ListSelectionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.options.StyleTable$StyleTableModel" intfc="n" abs="n" inn="y" sloc="78" jdoc="&amp;lt;CODE&amp;gt;TableModel&amp;lt; CODE&amp;gt; for the &amp;lt;CODE&amp;gt;StyleTable&amp;lt; CODE&amp;gt;.">
			<comm cntt="end class StyleChoice"/>
			<comm cntt="end class StyleRenderer"/>
			<field name="styleChoices" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.StyleTableModel()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.StyleTableModel(Map)" access="pub" jdoc="Construct a &amp;lt;CODE&amp;gt;StyleTableModel&amp;lt; CODE&amp;gt; and initialize it with the contents of the specified &amp;lt;CODE&amp;gt;Map&amp;lt; CODE&amp;gt;. @param choices the &amp;lt;CODE&amp;gt;Map&amp;lt; CODE&amp;gt; containing the initial choices for this &amp;lt;CODE&amp;gt;StyleTableModel&amp;lt; CODE&amp;gt;. This should be a map of &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; to &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt;, so it would be sensible to use a &amp;lt;CODE&amp;gt;Properties&amp;lt; CODE&amp;gt; object, but this is not enforced beyond that the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; forms of the keys and values in the &amp;lt;CODE&amp;gt;Map&amp;lt; CODE&amp;gt; will be used. Each map entry will be added to the &amp;lt;CODE&amp;gt;StyleTableModel&amp;lt; CODE&amp;gt; as if by &amp;lt;code&amp;gt;addStyleChoice(String, String)&amp;lt; code&amp;gt;. @see addStyleChoice(String, String)">
				<comm cntt="end while more keys"/>
				<param name="choices"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.getColumnCount()" access="pub" jdoc="@see TableModel#getColumnCount()">
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.getRowCount()" access="pub" jdoc="@see TableModel#getRowCount()">
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.getValueAt(int, int)" access="pub" jdoc="@see TableModel#getValueAt(int,int)">
				<comm cntt="end switch on column number"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.setValueAt(Object, int, int)" access="pub" jdoc="@see TableModel#setValueAt(Object,int,int)">
				<param name="value"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.getColumnName(int)" access="pub" jdoc="@see TableModel#getColumnName(int)">
				<comm cntt="end switch on index"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.save()" access="pub" jdoc="Save the contents of this &amp;lt;CODE&amp;gt;StyleTableModel&amp;lt; CODE&amp;gt; to Jext properties.">
				<comm cntt="end for through style choices"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel.addStyleChoice(String, String)" access="pub" jdoc="Add the specified style choice to this &amp;lt;CODE&amp;gt;StyleTableModel&amp;lt; CODE&amp;gt;. @param label &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; property name for the description. @param property &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; property name for the style.">
				<param name="label"/>
				<param name="property"/>
			</mth>
		<class name="/lib/:org.jext.options.StyleTable$StyleTableModel$StyleChoice" intfc="n" abs="n" inn="y" sloc="16" jdoc="">
			<field name="label" access="pub" jdoc=""/>
			<field name="property" access="pub" jdoc=""/>
			<field name="style" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel$StyleChoice.StyleChoice(String, String)" access="pub" jdoc="">
				<comm cntt=", SyntaxStyle style"/>
				<param name="label"/>
				<param name="property"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel$StyleChoice.resetStyle()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.options.StyleTable$StyleTableModel$StyleRenderer" intfc="n" abs="n" inn="y" sloc="34" jdoc="">
			<comm cntt="TableCellRenderer implementation"/>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel$StyleRenderer.StyleRenderer()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleTableModel$StyleRenderer.getTableCellRendererComponent(JTable, Object, boolean, boolean, int, int)" access="pub" jdoc="">
				<comm cntt="end else, not selected"/>
				<comm cntt="end if value not null"/>
				<param name="table"/>
				<param name="value"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.options.StyleTable$StyleEditor" intfc="n" abs="n" inn="y" sloc="85" jdoc="">
			<comm cntt="private members"/>
			<field name="okClicked" access="priv" jdoc=""/>
			<field name="bold" access="priv" jdoc=""/>
			<field name="italics" access="priv" jdoc=""/>
			<field name="ok" access="priv" jdoc=""/>
			<field name="cancel" access="priv" jdoc=""/>
			<field name="color" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.StyleTable$StyleEditor.StyleEditor(Component, SyntaxStyle)" access="pub" jdoc="">
				<comm cntt="setDefaultCloseOperation(DISPOSE_ON_CLOSE);"/>
				<comm cntt="Dimension screen = getToolkit().getScreenSize();"/>
				<comm cntt="setLocation((screen.width - getSize().width) 2,"/>
				<comm cntt="(screen.height - getSize().height) 2);"/>
				<param name="comp"/>
				<param name="style"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleEditor.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="end if source is the ok button"/>
				<comm cntt="end if source is the color button"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleEditor.keyPressed(KeyEvent)" access="pub" jdoc="">
				<comm cntt="end switch on key code"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleEditor.keyReleased(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleEditor.keyTyped(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.options.StyleTable$StyleEditor.getStyle()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.options.StylesOptions" intfc="n" abs="n" inn="n" sloc="98" jdoc="">
			<comm cntt="private members"/>
			<const name="noFocusBorder" access="pub" jdoc=""/>
			<field name="colorModel" access="priv" jdoc=""/>
			<field name="colorTable" access="priv" jdoc=""/>
			<field name="styleModel" access="priv" jdoc=""/>
			<field name="styleTable" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.options.StylesOptions.StylesOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StylesOptions.save()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StylesOptions.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StylesOptions.createColorTableScroller()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StylesOptions.createColorTableModel()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StylesOptions.createStyleTableScroller()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.options.StylesOptions.createStyleTableModel()" access="priv" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.print">
		<class name="/lib/:org.jext.print.PrintingOptions" intfc="n" abs="n" inn="n" sloc="78" jdoc="Stores the print options for printing using the PrintText class.">
			<comm cntt="the page font (default)"/>
			<comm cntt="the page font (default)"/>
			<field name="printLineNumbers_" access="priv" jdoc=""/>
			<field name="wrapText_" access="priv" jdoc=""/>
			<field name="printHeader_" access="priv" jdoc=""/>
			<field name="printSyntax_" access="priv" jdoc=""/>
			<field name="pageFont_" access="priv" jdoc=""/>
			<field name="headerFont_" access="priv" jdoc=""/>
			<field name="pageFormat_" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.print.PrintingOptions.PrintingOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.PrintingOptions(boolean, boolean, boolean, boolean, Font, PageFormat)" access="pub" jdoc="">
				<comm cntt="Build the header font;"/>
				<param name="printLineNumbers"/>
				<param name="wrapText"/>
				<param name="printHeader"/>
				<param name="printSyntax"/>
				<param name="pageFont"/>
				<param name="pageFormat"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.setPrintLineNumbers(boolean)" access="pub" jdoc="">
				<param name="printLineNumbers"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.getPrintLineNumbers()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.setWrapText(boolean)" access="pub" jdoc="">
				<param name="wrapText"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.getWrapText()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.setPrintHeader(boolean)" access="pub" jdoc="">
				<param name="printHeader"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.getPrintHeader()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.setPrintSyntax(boolean)" access="pub" jdoc="">
				<param name="printSyntax"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.getPrintSyntax()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.setPageFont(Font)" access="pub" jdoc="">
				<comm cntt="Build the header font;"/>
				<param name="pageFont"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.getPageFont()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.getHeaderFont()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.setPageFormat(PageFormat)" access="pub" jdoc="">
				<param name="pageFormat"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintingOptions.getPageFormat()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.print.PrintSyntax" intfc="n" abs="n" inn="n" sloc="118" jdoc="">
			<field name="seg" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.print.PrintSyntax.print(JextFrame, JextTextArea)" access="pub" jdoc="">
				<comm cntt="GUIUtilities.loadStyles(fontFamily, fontSize);"/>
				<param name="parent"/>
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintSyntax.paintSyntaxLine(JextTextArea, Graphics, TabExpander, TokenMarker, SyntaxStyle[], FontMetrics, int, Font, Color, int, int)" access="prot" jdoc="">
				<comm cntt="y += fm.getHeight();"/>
				<param name="textArea"/>
				<param name="gfx"/>
				<param name="expander"/>
				<param name="tokenMarker"/>
				<param name="styles"/>
				<param name="fm"/>
				<param name="line"/>
				<param name="defaultFont"/>
				<param name="defaultColor"/>
				<param name="x"/>
				<param name="y"/>
			</mth>
		<class name="/lib/:org.jext.print.PrintSyntax$PrintTabExpander" intfc="n" abs="n" inn="y" sloc="15" jdoc="">
			<field name="leftMargin" access="priv" jdoc=""/>
			<field name="tabSize" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.print.PrintSyntax$PrintTabExpander.PrintTabExpander(int, int)" access="pub" jdoc="">
				<param name="leftMargin"/>
				<param name="tabSize"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintSyntax$PrintTabExpander.nextTabStop(float, int)" access="pub" jdoc="">
				<param name="x"/>
				<param name="tabOffset"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.print.PrintText" intfc="n" abs="n" inn="n" sloc="264" jdoc="A simple printing class to handle basic text printing. Accepts an array of Strings or a PlainDocument and prints all the lines contained there in. Each String in the array is assumed to be a separate line.">
			<comm cntt="The number of pages"/>
			<comm cntt="This holds each page"/>
			<comm cntt="Used to determine where to begin a wrapped line."/>
			<comm cntt="Used for document title (i.e. file name) when including the page header"/>
			<comm cntt="Text to print."/>
			<comm cntt="Print options (i.e. font, print header, etc.)"/>
			<comm cntt="Indicates whether soft or hard tabs are used."/>
			<comm cntt="Tab stop if hard tabs are used."/>
			<field name="numberOfpages_" access="priv" jdoc=""/>
			<field name="pages_" access="priv" jdoc=""/>
			<field name="wrapOffset_" access="priv" jdoc=""/>
			<field name="docTitle_" access="priv" jdoc=""/>
			<field name="text_" access="priv" jdoc=""/>
			<field name="printOptions_" access="priv" jdoc=""/>
			<field name="softTabs_" access="priv" jdoc=""/>
			<field name="tabSize_" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.print.PrintText.PrintText(PlainDocument)" access="pub" jdoc="Constructor - Accepts a plain document and uses default font. No header information will be printed.">
				<param name="document"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText.PrintText(PlainDocument, String, PrintingOptions, boolean, int)" access="pub" jdoc="Constructor - Accepts a plain document as well as other print options, including font, page title, and header indicator (true if printing header, false otherwise).">
				<comm cntt="If a new doc and no title, set docTitle to &amp;quot;New Document&amp;quot;"/>
				<comm cntt="Get Root element of the document"/>
				<comm cntt="get the number of lines (i.e. child elements)"/>
				<comm cntt="Allocate the array"/>
				<comm cntt="Get each line element, get its text and put it in the string array"/>
				<comm cntt="Nothing gets added to the Array if there is a bad location"/>
				<param name="document"/>
				<param name="docTitle"/>
				<param name="printOptions"/>
				<param name="softTabs"/>
				<param name="tabSize"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText.PrintText(String[])" access="pub" jdoc="Constructor - accepts an array of Strings, uses the default font, no header.">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText.PrintText(String[], Font)" access="pub" jdoc="Constructor - accepts an array of Strings and a font, no header.">
				<param name="text"/>
				<param name="font"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText.printTextArray()" access="pub" jdoc="Where the print processing begins.">
				<comm cntt="create a printjob"/>
				<comm cntt="pgfmt = job.pageDialog(pgfmt); set a page format. Comment this if you do not want this to show"/>
				<comm cntt="pgfmt = job.validatePage(pgfmt); make sure the pageformat is ok"/>
				<comm cntt="do the pagination"/>
				<comm cntt="set the book pageable so the printjob knows we are printing more than one page (maybe)"/>
				<comm cntt="print. This calls each Page object&amp;apos;s print method"/>
				<comm cntt="catch any errors and be as ambiguous about them as possible :)"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText.removeEOLChar()" access="priv" jdoc="Eliminates end of line characters">
				<comm cntt="Process tabs. Assume tab stops."/>
				<comm cntt="Calcualte the numbe of spaces to the tab stop."/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText.addLineNumbers()" access="priv" jdoc="Addes line numbers to the beginning of each line.">
				<comm cntt="Get the total number of digits in last line number"/>
				<comm cntt="So that spacing and alignment can be done properly."/>
				<comm cntt="Set the wrap offset so that we can start wrapped lines in the proper place."/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText.wrapText()" access="priv" jdoc="Creates a new array of lines that all fit the width of the page.">
			</mth>
			<mth name="/lib/:org.jext.print.PrintText.pageinateText()" access="priv" jdoc="The pagination method, Paginate the text onto Printable page objects">
				<comm cntt="lines on one page"/>
				<comm cntt="line I am currently reading"/>
				<comm cntt="page #"/>
				<comm cntt="height of a page"/>
				<comm cntt="number of pages"/>
				<comm cntt="number of lines on a page"/>
				<comm cntt="set number of pages"/>
				<comm cntt="one page of text"/>
				<comm cntt="a temporary string to read from master string"/>
				<comm cntt="method to keep out errors"/>
				<comm cntt="create a new page"/>
				<comm cntt="read the string"/>
				<comm cntt="add to the page"/>
				<comm cntt="increase the page number I am on"/>
				<comm cntt="create a new page object with the text and add it to the book"/>
				<comm cntt="return the completed book"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText.convertUnprintables()" access="priv" jdoc="Converts unprintable things to a space. stops some errors.">
			</mth>
		<class name="/lib/:org.jext.print.PrintText$Page" intfc="n" abs="n" inn="y" sloc="52" jdoc="An inner class that defines one page of text based on data about the PageFormat etc. from the book defined in the parent class">
			<comm cntt="the text for the page"/>
			<field name="pageText_" access="priv" jdoc=""/>
			<field name="pageNumber_" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.print.PrintText$Page.Page(String[], int)" access="pub" jdoc="">
				<comm cntt="set the page&amp;apos;s text"/>
				<comm cntt="set page number."/>
				<param name="text"/>
				<param name="pageNum"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText$Page.print(Graphics, PageFormat, int)" access="pub" jdoc="Defines the Printable print method, for printing a Page">
				<comm cntt="the printing part"/>
				<comm cntt="draw a line of text"/>
				<comm cntt="Set the font"/>
				<comm cntt="set color"/>
				<comm cntt="draw a line of text"/>
				<comm cntt="print the page"/>
				<param name="graphics"/>
				<param name="pageFormat"/>
				<param name="pageIndex"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.print.PrintText$PrintableText" intfc="n" abs="n" inn="y" sloc="39" jdoc="An inner class that defines one section of printable text. This allows the flexability to assign different fonts to individual words or phrases (i.e. for headers footers or Syntax highlighting (pretty print).">
			<field name="font_" access="priv" jdoc=""/>
			<field name="newLine_" access="priv" jdoc=""/>
			<field name="text_" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.print.PrintText$PrintableText.PrintableText()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintText$PrintableText.PrintableText(String, Font, boolean)" access="pub" jdoc="">
				<param name="text"/>
				<param name="font"/>
				<param name="newLine"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText$PrintableText.getText()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintText$PrintableText.setText(String)" access="pub" jdoc="">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText$PrintableText.getFont()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintText$PrintableText.setFont(Font)" access="pub" jdoc="">
				<param name="font"/>
			</mth>
			<mth name="/lib/:org.jext.print.PrintText$PrintableText.isNewLine()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.print.PrintText$PrintableText.setNewLine(boolean)" access="pub" jdoc="">
				<param name="newLine"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.project">
		<class name="/lib/:org.jext.project.ProjectManagement" intfc="y" abs="n" inn="n" sloc="5" jdoc="The interface which should be implemented by all Jext project management plugins. This has been made separate from &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; so that the plugin class itself does not have to implement the much heavier &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; interface. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt;">
			<mth name="/lib/:org.jext.project.ProjectManagement.getLabel()" access="pub" jdoc="Returns the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; to use as a description of this &amp;lt;CODE&amp;gt;ProjectManagement&amp;lt; CODE&amp;gt; in a list.">
			</mth>
			<mth name="/lib/:org.jext.project.ProjectManagement.getProjectManager()" access="pub" jdoc="Returns the &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; for this &amp;lt;CODE&amp;gt;ProjectManagement&amp;lt; CODE&amp;gt;.">
			</mth>
		</class>
		<class name="/lib/:org.jext.project.DefaultProjectManagement" intfc="n" abs="n" inn="n" sloc="19" jdoc="Default &amp;lt;CODE&amp;gt;ProjectManagement&amp;lt; CODE&amp;gt; implementation.">
			<field name="parent" access="priv" jdoc=""/>
			<field name="pm" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.project.DefaultProjectManagement.DefaultProjectManagement(JextFrame)" access="pub" jdoc="Constructs a new &amp;lt;CODE&amp;gt;DefaultProjectManagement&amp;lt; CODE&amp;gt;. @param parent the &amp;lt;CODE&amp;gt;JextFrame&amp;lt; CODE&amp;gt; to which this &amp;lt;CODE&amp;gt;DefaultProjectManagement&amp;lt; CODE&amp;gt; belongs.">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManagement.getLabel()" access="pub" jdoc="@see ProjectManagement#getLabel()">
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManagement.getProjectManager()" access="pub" jdoc="@see ProjectManagement#getProjectManager()">
			</mth>
		</class>
		<class name="/lib/:org.jext.project.Project" intfc="y" abs="n" inn="n" sloc="13" jdoc="Defines a basic project created using Jext. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt;">
			<mth name="/lib/:org.jext.project.Project.getName()" access="pub" jdoc="Returns the name of this &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @return &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.Project.getFiles()" access="pub" jdoc="Returns the &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt;s that compose this &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. If any of these &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt;s is a directory, it is understood that all &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt;s in and below this directory are part of this &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @return &amp;lt;CODE&amp;gt;File[]&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.Project.openFile(File)" access="pub" jdoc="Open the specified &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt; in this &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. Although it is an implementation decision, this act might also add the specified &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt; to this &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @param f the &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt; to close.">
				<param name="f"/>
			</mth>
			<mth name="/lib/:org.jext.project.Project.closeFile(File)" access="pub" jdoc="Close the specified &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt;. @param f the &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt; to close.">
				<param name="f"/>
			</mth>
			<mth name="/lib/:org.jext.project.Project.selectFile(File)" access="pub" jdoc="Select the specified &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt;. It is recommended that this method be implemented such that the &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt; is opened if not already open. @param f the &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt; to select. @see openFile(File)">
				<param name="f"/>
			</mth>
			<mth name="/lib/:org.jext.project.Project.getSelectedFile()" access="pub" jdoc="Returns the currently selected &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt; of this &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @return &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.Project.getAttribute(String)" access="pub" jdoc="Returns the value of the specified attribute for this &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @param key the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; key to which this attribute is tied. @return &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt;">
				<param name="key"/>
			</mth>
			<mth name="/lib/:org.jext.project.Project.getAttribute(String, Object)" access="pub" jdoc="Returns the value of the specified attribute for this &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;, returning the specified default value if no such attribute exists. @param key the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; key to which this attribute is tied. @param defaultValue the default &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt; to return if no such attribute exists. @return &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt;">
				<param name="key"/>
				<param name="defaultValue"/>
			</mth>
			<mth name="/lib/:org.jext.project.Project.getAttributeAsString(String)" access="pub" jdoc="Returns the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; value of the specified attribute for this &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @param key the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; key to which this attribute is tied. @return &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt;">
				<param name="key"/>
			</mth>
			<mth name="/lib/:org.jext.project.Project.setAttribute(String, Object)" access="pub" jdoc="Sets the specified attribute. @param key the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; key of the attribute to be set. @param value the &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt; value to assign.">
				<param name="key"/>
				<param name="value"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.project.DefaultProjectManager" intfc="n" abs="n" inn="n" sloc="145" jdoc="A default &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt;. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt;">
			<comm cntt="for ordering"/>
			<comm cntt="end class DefaultProject"/>
			<field name="ui" access="priv" jdoc=""/>
			<field name="projectNames" access="priv" jdoc=""/>
			<field name="projects" access="priv" jdoc=""/>
			<field name="currentProject" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.DefaultProjectManager(JextFrame)" access="pub" jdoc="Create a new &amp;lt;CODE&amp;gt;DefaultProjectManager&amp;lt; CODE&amp;gt;. @param parent the &amp;lt;CODE&amp;gt;JextFrame&amp;lt; CODE&amp;gt; for which this &amp;lt;CODE&amp;gt;DefaultProjectManager&amp;lt; CODE&amp;gt; shall be an agent.">
				<comm cntt="end if null parent supplied"/>
				<comm cntt="end contentsChanged"/>
				<comm cntt="end for i..."/>
				<comm cntt="end intervalAdded"/>
				<comm cntt="end for i..."/>
				<comm cntt="end intervalRemoved"/>
				<comm cntt="end anonymous ListDataListener"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.loadFromWorkspaces()" access="priv" jdoc="">
				<comm cntt="end for i..."/>
				<comm cntt="all that&amp;apos;s left are closed projects"/>
				<comm cntt="end while more project names"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.jextEventFired(JextEvent)" access="pub" jdoc="@see org.jext.event.JextListener#jextEventFired(org.jext.event.JextEvent)">
				<comm cntt="end if Project changed..."/>
				<comm cntt="end switch on event type"/>
				<comm cntt="end if we are the current ProjectManager"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.setCurrentProjectFromWorkspace()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.getProjects()" access="pub" jdoc="@see ProjectManager#getProjects()">
				<comm cntt="long implementation preserves ordering..."/>
				<comm cntt="end for i through the projects"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.getCurrentProject()" access="pub" jdoc="@see ProjectManager#getCurrentProject()">
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.newProject()" access="pub" jdoc="@see ProjectManager#newProject()">
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.openProject(Object)" access="pub" jdoc="@see ProjectManager#openProject(Object)">
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.closeProject(Project)" access="pub" jdoc="@see ProjectManager#closeProject(Project)">
				<comm cntt="end if this WorkspaceElement is the one specified..."/>
				<comm cntt="end for i..."/>
				<param name="p"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.saveProject(Project)" access="pub" jdoc="@see ProjectManager#saveProject(Project)">
				<comm cntt="it takes a lot of work to save only one Workspace, implement better later"/>
				<param name="p"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager.getUI()" access="pub" jdoc="@see ProjectManager#getUI()">
			</mth>
		<class name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject" intfc="n" abs="n" inn="y" sloc="103" jdoc="Default &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; implementation.">
			<comm cntt="inherit doc"/>
			<comm cntt="inherit doc"/>
			<comm cntt="inherit doc"/>
			<comm cntt="inherit doc"/>
			<comm cntt="inherit doc"/>
			<comm cntt="inherit doc"/>
			<comm cntt="inherit doc"/>
			<comm cntt="inherit doc"/>
			<field name="ws" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject.DefaultProject(Workspaces.WorkspaceElement)" access="pub" jdoc="Construct a &amp;lt;CODE&amp;gt;DefaultProject&amp;lt; CODE&amp;gt;. @param ws the &amp;lt;CODE&amp;gt;Workspaces.WorkspaceElement&amp;lt; CODE&amp;gt; to which this project corresponds.">
				<param name="ws"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject.getFiles()" access="pub" jdoc="">
				<comm cntt="end if there is a file here"/>
				<comm cntt="end if this is a JextTextArea, WorkspaceElements may allow recursion in the future..."/>
				<comm cntt="end for i..."/>
				<comm cntt="end try"/>
				<comm cntt="end while more contents of the list"/>
				<comm cntt="end catch ArrayStoreException"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject.openFile(File)" access="pub" jdoc="">
				<comm cntt="end if this project is not selected"/>
				<param name="f"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject.closeFile(File)" access="pub" jdoc="">
				<comm cntt="end if this project is not selected"/>
				<comm cntt="end if this is the correct file"/>
				<comm cntt="end while this iterator has more"/>
				<param name="f"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject.selectFile(File)" access="pub" jdoc="">
				<comm cntt="end if this file matches"/>
				<comm cntt="end for i..."/>
				<comm cntt="end if not already open"/>
				<comm cntt="end else--already open"/>
				<param name="f"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject.getSelectedFile()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.project.DefaultProjectManager$DefaultProject.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.project.ProjectEvent" intfc="n" abs="n" inn="n" sloc="100" jdoc="The event emitted by a Jext &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; when a meaningful change happens to one of its &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;s. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt; @see org.jext.project.ProjectListener">
			<comm cntt="project related events"/>
			<comm cntt="file related events"/>
			<comm cntt="attribute related events"/>
			<const name="PROJECT_OPENED" access="pub" jdoc=""/>
			<const name="PROJECT_CLOSED" access="pub" jdoc=""/>
			<const name="PROJECT_SELECTED" access="pub" jdoc=""/>
			<const name="FILE_ADDED" access="pub" jdoc=""/>
			<const name="FILE_REMOVED" access="pub" jdoc=""/>
			<const name="FILE_OPENED" access="pub" jdoc=""/>
			<const name="FILE_CLOSED" access="pub" jdoc=""/>
			<const name="FILE_SELECTED" access="pub" jdoc=""/>
			<const name="FILE_CHANGED" access="pub" jdoc=""/>
			<const name="ATTRIBUTE_SET" access="pub" jdoc=""/>
			<const name="ATTRIBUTE_UNSET" access="pub" jdoc=""/>
			<const name="OTHER" access="pub" jdoc=""/>
			<field name="event" access="priv" jdoc=""/>
			<field name="projectManager" access="priv" jdoc=""/>
			<field name="project" access="priv" jdoc=""/>
			<field name="target" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.project.ProjectEvent.ProjectEvent(ProjectManager, int)" access="pub" jdoc="Creates a new ProjectEvent, registering the parent &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; of this event and the type of the event (the event is assumed to be specific to the &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt;&amp;apos;s currently active &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @param projectManager &amp;lt;code&amp;gt;ProjectManager&amp;lt; code&amp;gt; parent. @param eventType &amp;lt;CODE&amp;gt;int&amp;lt; CODE&amp;gt; value which specifies the nature of the &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt;.">
				<param name="projectManager"/>
				<param name="eventType"/>
			</mth>
			<mth name="/lib/:org.jext.project.ProjectEvent.ProjectEvent(ProjectManager, Project, int)" access="pub" jdoc="Creates a new ProjectEvent, registering the parent &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; of this event, the type of the event and the relevant &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @param projectManager &amp;lt;code&amp;gt;ProjectManager&amp;lt; code&amp;gt; parent. @param project &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; relevant to this &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt;. @param eventType &amp;lt;CODE&amp;gt;int&amp;lt; CODE&amp;gt; value which specifies the nature of the &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt;.">
				<param name="projectManager"/>
				<param name="project"/>
				<param name="eventType"/>
			</mth>
			<mth name="/lib/:org.jext.project.ProjectEvent.ProjectEvent(ProjectManager, Project, int, Object)" access="pub" jdoc="Creates a new ProjectEvent, registering the parent &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; of this event, the type of the event, the relevant &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;, and the target of the event. @param projectManager &amp;lt;code&amp;gt;ProjectManager&amp;lt; code&amp;gt; parent. @param project &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; relevant to this &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt;. @param eventType &amp;lt;CODE&amp;gt;int&amp;lt; CODE&amp;gt; value which specifies the nature of the &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt;. @param target &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt; which, along with the &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;, is the target of the &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt;.">
				<comm cntt="end if null projectManager"/>
				<comm cntt="end if null project"/>
				<comm cntt="end if File"/>
				<comm cntt="end else"/>
				<comm cntt="end if String"/>
				<comm cntt="end switch event type"/>
				<param name="projectManager"/>
				<param name="project"/>
				<param name="eventType"/>
				<param name="target"/>
			</mth>
			<mth name="/lib/:org.jext.project.ProjectEvent.getWhat()" access="pub" jdoc="Returns the type of event. @return &amp;lt;CODE&amp;gt;int&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.ProjectEvent.getProjectManager()" access="pub" jdoc="Returns the &amp;lt;code&amp;gt;ProjectManager&amp;lt; code&amp;gt; from which the event was fired. @return &amp;lt;code&amp;gt;ProjectManager&amp;lt; code&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.ProjectEvent.getProject()" access="pub" jdoc="Returns the &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; for which the &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt; was generated. @return &amp;lt;code&amp;gt;Project&amp;lt; code&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.ProjectEvent.getTarget()" access="pub" jdoc="Returns the &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt; target of the event; if this is a &amp;quot;project&amp;quot; event, then the result should be the same &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; as returned by &amp;lt;CODE&amp;gt;getProject&amp;lt; CODE&amp;gt;; if this is a &amp;quot;file&amp;quot; event, the result should be the affected &amp;lt;CODE&amp;gt;File&amp;lt; CODE&amp;gt;; if this is an &amp;quot;attribute&amp;quot; event, the result should be the affected &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; attribute name. @return &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.ProjectEvent.toString()" access="pub" jdoc="@see java.lang.Object#toString()">
			</mth>
		</class>
		<class name="/lib/:org.jext.project.ProjectListener" intfc="y" abs="n" inn="n" sloc="4" jdoc="The listener interface for receiving &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; events. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt;">
			<mth name="/lib/:org.jext.project.ProjectListener.projectEventFired(ProjectEvent)" access="pub" jdoc="A &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; should invoke this method on all its registered &amp;lt;CODE&amp;gt;ProjectListener&amp;lt; CODE&amp;gt;s when a significant &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; change occurs. @param evt The received &amp;lt;code&amp;gt;ProjectEvent&amp;lt; code&amp;gt;.">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.project.AbstractProject" intfc="n" abs="y" inn="n" sloc="48" jdoc="Defines a basic project created using Jext. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt;">
			<const name="attributes" access="prot" jdoc=""/>
			<const name="manager" access="prot" jdoc=""/>
			<const name="name" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.project.AbstractProject.AbstractProject(String, AbstractProjectManager)" access="prot" jdoc="Create a new &amp;lt;CODE&amp;gt;AbstractProject&amp;lt; CODE&amp;gt;. @param name the name of this &amp;lt;CODE&amp;gt;AbstractProject&amp;lt; CODE&amp;gt;. @param manager the &amp;lt;CODE&amp;gt;AbstractProjectManager&amp;lt; CODE&amp;gt; in charge of this &amp;lt;CODE&amp;gt;AbstractProject&amp;lt; CODE&amp;gt;.">
				<comm cntt="end if null manager set"/>
				<param name="name"/>
				<param name="manager"/>
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProject.getName()" access="pub" jdoc="Returns the name of this &amp;lt;CODE&amp;gt;AbstractProject&amp;lt; CODE&amp;gt;. @return &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProject.getAttribute(String)" access="pub" jdoc="Returns the value of the specified attribute for this &amp;lt;CODE&amp;gt;AbstractProject&amp;lt; CODE&amp;gt;. @param key the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; key to which this attribute is tied. @return &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt;">
				<param name="key"/>
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProject.getAttribute(String, Object)" access="pub" jdoc="Returns the value of the specified attribute for this &amp;lt;CODE&amp;gt;AbstractProject&amp;lt; CODE&amp;gt;, returning the specified default value if no such attribute exists. @param key the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; key to which this attribute is tied. @param defaultValue the default &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt; to return if no such attribute exists. @return &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt;">
				<param name="key"/>
				<param name="defaultValue"/>
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProject.getAttributeAsString(String)" access="pub" jdoc="Returns the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; value of the specified attribute for this &amp;lt;CODE&amp;gt;AbstractProject&amp;lt; CODE&amp;gt;. @param key the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; key to which this attribute is tied. @return &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt;">
				<param name="key"/>
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProject.setAttribute(String, Object)" access="pub" jdoc="Sets the specified attribute. @param key the &amp;lt;CODE&amp;gt;String&amp;lt; CODE&amp;gt; key of the attribute to be set. @param value the &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt; value to assign.">
				<param name="key"/>
				<param name="value"/>
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProject.fireProjectEvent(int)" access="prot" jdoc="Fire the specified &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt; for this &amp;lt;CODE&amp;gt;AbstractProject&amp;lt; CODE&amp;gt;. This @param eventType the &amp;lt;CODE&amp;gt;int&amp;lt; CODE&amp;gt; code for the type of event to fire.">
				<param name="eventType"/>
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProject.fireProjectEvent(int, Object)" access="prot" jdoc="Fire the specified &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt; for this &amp;lt;CODE&amp;gt;AbstractProject&amp;lt; CODE&amp;gt;. This @param eventType the &amp;lt;CODE&amp;gt;int&amp;lt; CODE&amp;gt; code for the type of event to fire. @param target the &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt; target of the event to fire.">
				<param name="eventType"/>
				<param name="target"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.project.ProjectManager" intfc="y" abs="n" inn="n" sloc="12" jdoc="A manager for Jext &amp;lt;CODE&amp;gt;Projects&amp;lt; CODE&amp;gt;. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt;">
			<mth name="/lib/:org.jext.project.ProjectManager.addProjectListener(ProjectListener)" access="pub" jdoc="Adds a listener to the list that&amp;apos;s notified each time a &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; change occurs.">
				<param name="listener"/>
			</mth>
			<mth name="/lib/:org.jext.project.ProjectManager.removeProjectListener(ProjectListener)" access="pub" jdoc="Removes a listener from the list that&amp;apos;s notified each time a &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; change occurs.">
				<param name="listener"/>
			</mth>
			<mth name="/lib/:org.jext.project.ProjectManager.getProjects()" access="pub" jdoc="Returns all this &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt;&amp;apos;s &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;s. @return &amp;lt;CODE&amp;gt;Project[]&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.ProjectManager.getCurrentProject()" access="pub" jdoc="Returns this &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt;&amp;apos;s currently active &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @return &amp;lt;CODE&amp;gt;Project[]&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.ProjectManager.newProject()" access="pub" jdoc="Causes this &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; to start a new &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.ProjectManager.openProject(Object)" access="pub" jdoc="Causes this &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; to open the specified &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @param id the &amp;lt;CODE&amp;gt;Object&amp;lt; CODE&amp;gt; identifier of the &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;.">
				<param name="id"/>
			</mth>
			<mth name="/lib/:org.jext.project.ProjectManager.closeProject(Project)" access="pub" jdoc="Causes this &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; to close the specified &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;. @param p the &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; to close.">
				<param name="p"/>
			</mth>
			<mth name="/lib/:org.jext.project.ProjectManager.saveProject(Project)" access="pub" jdoc="Causes this &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt; to save the specified &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt;, @param p the &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; to save.">
				<param name="p"/>
			</mth>
			<mth name="/lib/:org.jext.project.ProjectManager.getUI()" access="pub" jdoc="Returns a swing component that acts as the interface between the user and this &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt;.">
			</mth>
		</class>
		<class name="/lib/:org.jext.project.AbstractProjectManager" intfc="n" abs="y" inn="n" sloc="41" jdoc="An abstract &amp;lt;CODE&amp;gt;ProjectManager&amp;lt; CODE&amp;gt;. @author &amp;lt;a href=&amp;quot;mailto:orangeherbert@users.sourceforge.net&amp;quot;&amp;gt;Matt Benson&amp;lt; a&amp;gt;">
			<field name="listeners" access="prot" jdoc=""/>
			<mth name="/lib/:org.jext.project.AbstractProjectManager.AbstractProjectManager()" access="prot" jdoc="Creates a new &amp;lt;CODE&amp;gt;AbstractProjectManager&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProjectManager.addProjectListener(ProjectListener)" access="pub" jdoc="Adds a listener to the list that&amp;apos;s notified each time a &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; change occurs.">
				<param name="listener"/>
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProjectManager.removeProjectListener(ProjectListener)" access="pub" jdoc="Removes a listener from the list that&amp;apos;s notified each time a &amp;lt;CODE&amp;gt;Project&amp;lt; CODE&amp;gt; change occurs.">
				<param name="listener"/>
			</mth>
			<mth name="/lib/:org.jext.project.AbstractProjectManager.fireProjectEvent(ProjectEvent)" access="prot" jdoc="Fire the specified &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt;. @param e the &amp;lt;CODE&amp;gt;ProjectEvent&amp;lt; CODE&amp;gt; to fire.">
				<comm cntt="end if this listener has not yet been done"/>
				<comm cntt="end while more listeners"/>
				<comm cntt="end try to notify listeners"/>
				<comm cntt="get a new Iterator"/>
				<comm cntt="end catch ConcurrentModificationException"/>
				<comm cntt="end while some listeners have not been notified"/>
				<param name="e"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.protocol.jextresource">
		<class name="/lib/:org.jext.protocol.jextresource.PluginResURLConnection" intfc="n" abs="n" inn="n" sloc="44" jdoc="">
			<comm cntt="private members"/>
			<field name="in" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.protocol.jextresource.PluginResURLConnection.PluginResURLConnection(URL)" access="pub" jdoc="">
				<param name="url"/>
			</mth>
			<mth name="/lib/:org.jext.protocol.jextresource.PluginResURLConnection.connect()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.protocol.jextresource.PluginResURLConnection.getInputStream()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.protocol.jextresource.PluginResURLConnection.getHeaderField(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.protocol.jextresource.Handler" intfc="n" abs="n" inn="n" sloc="9" jdoc="">
			<mth name="/lib/:org.jext.protocol.jextresource.Handler.openConnection(URL)" access="pub" jdoc="">
				<param name="url"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.scripting">
		<class name="/lib/:org.jext.scripting.Logger" intfc="y" abs="n" inn="n" sloc="6" jdoc="">
			<mth name="/lib/:org.jext.scripting.Logger.logln(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.Logger.log(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.Logger.getStdOut()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.Logger.getStdErr()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.AbstractLogWindow" intfc="n" abs="y" inn="n" sloc="57" jdoc="">
			<field name="contDock" access="prot" jdoc=""/>
			<field name="parent" access="prot" jdoc=""/>
			<field name="textArea" access="prot" jdoc=""/>
			<field name="writerStdOut" access="priv" jdoc=""/>
			<field name="writeStdErr" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow.getContainingDock()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow.log(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow.logln(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow.getStdOut()" access="pub" jdoc="Returns a writer in which external classes can send &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to make them being displayed in the console as standard output.">
			</mth>
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow.getStdErr()" access="pub" jdoc="Returns a writer in which external classes can send &amp;lt;code&amp;gt;String&amp;lt; code&amp;gt; to make them being displayed in the console as error output.">
			</mth>
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow.buildInstance(AbstractLogWindow, String, JextFrame)" access="prot" jdoc="">
				<param name="frame"/>
				<param name="tabTitle"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow.AbstractLogWindow(JextFrame, String)" access="prot" jdoc="">
				<param name="parent"/>
				<param name="title"/>
			</mth>
		<class name="/lib/:org.jext.scripting.AbstractLogWindow$LoggingWriter" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow$LoggingWriter.close()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow$LoggingWriter.flush()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.AbstractLogWindow$LoggingWriter.write(char, int, int)" access="pub" jdoc="">
				<param name="cbuf"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.scripting.dawn">
		<class name="/lib/:org.jext.scripting.dawn.Run" intfc="n" abs="n" inn="n" sloc="56" jdoc="">
			<comm cntt="the script is executed within a thread"/>
			<mth name="/lib/:org.jext.scripting.dawn.Run.execute(String, JextFrame)" access="pub" jdoc="Executes some Dawn code. @param code The script code to be interpreted @param parent The window which execuets the script">
				<param name="code"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.Run.execute(String, JextFrame, boolean)" access="pub" jdoc="Executes some Dawn code. @param code The script code to be interpreted @param parent The window which execuets the script @param isThreaded If true, Dawn libraries loading is threaded">
				<param name="code"/>
				<param name="parent"/>
				<param name="isThreaded"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.Run.runScript(String, JextFrame)" access="pub" jdoc="Runs a Jext script from a file. @param fileName Path to the script @param parent The Jext window which have to execute the script">
				<param name="fileName"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.Run.runScript(String, JextFrame, boolean)" access="pub" jdoc="Runs a Jext script from a file. @param fileName Path to the script @param parent The Jext window which have to execute the script @param isThreaded If true, loading of libraries is threaded">
				<param name="fileName"/>
				<param name="parent"/>
				<param name="isThreaded"/>
			</mth>
		<class name="/lib/:org.jext.scripting.dawn.Run$ThreadExecuter" intfc="n" abs="n" inn="y" sloc="35" jdoc="">
			<field name="code" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.scripting.dawn.Run$ThreadExecuter.ThreadExecuter(String, JextFrame)" access="pub" jdoc="">
				<param name="code"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.Run$ThreadExecuter.run()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.DawnLogWindow" intfc="n" abs="n" inn="n" sloc="34" jdoc="">
			<field name="clear" access="priv" jdoc=""/>
			<field name="immediate" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.scripting.dawn.DawnLogWindow.getInstance(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.DawnLogWindow.DawnLogWindow(JextFrame)" access="priv" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.DawnLogWindow.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.scripting.dawn.functions">
		<class name="/lib/:org.jext.scripting.dawn.functions.IsPropertyEnabledFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Checks if a property is enabled.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;property isPropertyEnabled&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.IsPropertyEnabledFunction.IsPropertyEnabledFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.IsPropertyEnabledFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.GetPropertyFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="Gets a property.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;property getProperty&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.GetPropertyFunction.GetPropertyFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.GetPropertyFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.JextActionFunction" intfc="n" abs="n" inn="n" sloc="18" jdoc="Executes a jext action.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;actionName jextAction&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.JextActionFunction.JextActionFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.JextActionFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.YesNoFunction" intfc="n" abs="n" inn="n" sloc="16" jdoc="Displays a yes no dialog box.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;message yesNo&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.YesNoFunction.YesNoFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.YesNoFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.OpenFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Opens a file.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;file open&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.OpenFunction.OpenFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.OpenFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.InsertTextFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Inserts text in current text area.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;text insertText&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.InsertTextFunction.InsertTextFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.InsertTextFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.MsgBoxFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Displays a dialog box.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;message msgBox&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.MsgBoxFunction.MsgBoxFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.MsgBoxFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.SetPropertyFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Sets a property.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;property value setProperty&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.SetPropertyFunction.SetPropertyFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.SetPropertyFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.InputFunction" intfc="n" abs="n" inn="n" sloc="17" jdoc="Displays an input dialog box.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;message input&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.InputFunction.InputFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.InputFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.CreateActionFunction" intfc="n" abs="n" inn="n" sloc="24" jdoc="Creates a new action in Jext.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;code actionLabel actionName createAction&amp;lt; code&amp;gt;&amp;lt;br&amp;gt; code is the Dawn code which will be executed on click, actionLabel is the name which will appear in Jext menu bar, and actionName is Jext internal action name. @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.CreateActionFunction.CreateActionFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.CreateActionFunction.invoke(DawnParser)" access="pub" jdoc="">
				<comm cntt="Jext.setProperty(actionName + &amp;quot;.label&amp;quot;, actionLabel);"/>
				<param name="parser"/>
			</mth>
		<class name="/lib/:org.jext.scripting.dawn.functions.CreateActionFunction$DawnAction" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<field name="code" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.scripting.dawn.functions.CreateActionFunction$DawnAction.DawnAction(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="code"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.CreateActionFunction$DawnAction.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.GetSelectedTextFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Puts text from current text area selection onto the stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;getSelectedText&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.GetSelectedTextFunction.GetSelectedTextFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.GetSelectedTextFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.YesNoCancelFunction" intfc="n" abs="n" inn="n" sloc="16" jdoc="Displays a yes no cancel dialog box.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;message yesNoCancel&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.YesNoCancelFunction.YesNoCancelFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.YesNoCancelFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.GetTextFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Puts text from current text area onto the stack.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;getText&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.GetTextFunction.GetTextFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.GetTextFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.ConsoleFunction" intfc="n" abs="n" inn="n" sloc="17" jdoc="Makes the console execute a command.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;command console&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.ConsoleFunction.ConsoleFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.ConsoleFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.scripting.dawn.functions.SetTextFunction" intfc="n" abs="n" inn="n" sloc="13" jdoc="Sets current text area text.&amp;lt;br&amp;gt; Usage:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt;text setText&amp;lt; code&amp;gt; @author Romain Guy">
			<mth name="/lib/:org.jext.scripting.dawn.functions.SetTextFunction.SetTextFunction()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.dawn.functions.SetTextFunction.invoke(DawnParser)" access="pub" jdoc="">
				<param name="parser"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.scripting.python">
		<class name="/lib/:org.jext.scripting.python.PythonLogWindow" intfc="n" abs="n" inn="n" sloc="62" jdoc="">
			<field name="regexp" access="priv" jdoc=""/>
			<field name="docked" access="priv" jdoc=""/>
			<field name="clear" access="priv" jdoc=""/>
			<field name="dock" access="priv" jdoc=""/>
			<field name="textAreaScroller" access="priv" jdoc=""/>
			<field name="handler" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.scripting.python.PythonLogWindow.getInstance(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.PythonLogWindow.PythonLogWindow(JextFrame)" access="priv" jdoc="">
				<comm cntt="super(parent, Jext.getProperty(&amp;quot;python.window.title&amp;quot;), Jext.getProperty(&amp;quot;python.window.tab&amp;quot;));"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.PythonLogWindow.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.PythonLogWindow.toggleDocking()" access="priv" jdoc="Switches the docking status between DOCK_TO_LEFT_PANEL and FLOATING">
			</mth>
		<class name="/lib/:org.jext.scripting.python.PythonLogWindow$MouseHandler" intfc="n" abs="n" inn="y" sloc="42" jdoc="">
			<mth name="/lib/:org.jext.scripting.python.PythonLogWindow$MouseHandler.mouseClicked(MouseEvent)" access="pub" jdoc="">
				<comm cntt="file"/>
				<comm cntt="line number"/>
				<comm cntt="how can an exception be thrown here ? jeeezz... :)"/>
				<comm cntt="script is executed from a text area"/>
				<comm cntt="from a file"/>
				<comm cntt="select error line"/>
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.scripting.python.Run" intfc="n" abs="n" inn="n" sloc="113" jdoc="">
			<field name="parser" access="priv" jdoc=""/>
			<field name="packageList" access="priv" jdoc="This is the list of the packages. It should be used to add here other packages: JARClassLoader, while scanning for plugins, should add here new packages found. @since Jext3.2pre4"/>
			<mth name="/lib/:org.jext.scripting.python.Run.addPackage(String)" access="pub" jdoc="Use this to add a package to the list of packages usable by Python. It will work only for Interpreters we setup after this call. @since Jext3.2pre5">
				<comm cntt="else the following line could create a NPE."/>
				<param name="packageName"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.Run.buildPackageList()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.scripting.python.Run.startupPythonInterpreter(PythonInterpreter)" access="pub" jdoc="This method does the global setup for PythonInterpreter: on each one you&amp;apos;ll need to call it only once. @since Jext3.2pre4">
				<param name="interp"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.Run.setupPythonInterpreter(PythonInterpreter, JextFrame, Console)" access="pub" jdoc="This method does the local setup for PythonInterpreter: on each one you&amp;apos;ll need to call it every time parent changes. It setups the __jext__ script variable and the I O streams. @param interp the PythonInterpreter to setup @param parent the value to give to the __jext__ var; if null, output will go to Jext&amp;apos;s stdout and stderr(i.e. System.out and System.err) @param console if null, output will go to the log window of parent; else, it will go inside this console @since Jext3.2pre4">
				<param name="interp"/>
				<param name="parent"/>
				<param name="console"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.Run.getPythonInterpreter(JextFrame)" access="pub" jdoc="Creates an interpreter. @param parent The window which executes the script">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.Run.getPythonInterpreter(JextFrame, Console)" access="pub" jdoc="Creates an interpreter. @param parent The window which executes the script @param console">
				<param name="parent"/>
				<param name="console"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.Run.eval(String, String, Object[], JextFrame)" access="pub" jdoc="Evaluates some Python code. @param code The script code to be evaluated @param map A map of properties to add to interpreter @param parent The window which executes the script @return The result of the evaluation">
				<comm cntt="security ?"/>
				<param name="code"/>
				<param name="mapName"/>
				<param name="map"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.Run.execute(String, JextFrame)" access="pub" jdoc="Executes some Python code. @param code The script code to be interpreted @param parent The window which executes the script">
				<comm cntt="security ?"/>
				<comm cntt="FIXME: I don&amp;apos;t understand the above comment. But isn&amp;apos;t this a too"/>
				<comm cntt="drastic way to solve things?"/>
				<param name="code"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.scripting.python.Run.runScript(String, JextFrame)" access="pub" jdoc="Runs a Jext script from a file. @param fileName Path to the script @param parent The Jext window which have to execute the script">
				<comm cntt="security ?"/>
				<param name="fileName"/>
				<param name="parent"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.search">
		<class name="/lib/:org.jext.search.Search" intfc="n" abs="n" inn="n" sloc="167" jdoc="">
			<field name="matcher" access="pub" jdoc=""/>
			<field name="replacePattern" access="pub" jdoc=""/>
			<field name="findPattern" access="pub" jdoc=""/>
			<field name="pythonScript" access="pub" jdoc=""/>
			<field name="useRegexp" access="pub" jdoc=""/>
			<field name="ignoreCase" access="pub" jdoc=""/>
			<field name="script" access="pub" jdoc=""/>
			<field name="reverseSearch" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.search.Search.load()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.Search.save()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.Search.getPythonScriptString()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.Search.setPythonScriptString(String)" access="pub" jdoc="">
				<param name="pythonScript"/>
			</mth>
			<mth name="/lib/:org.jext.search.Search.getPythonScript()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.Search.setPythonScript(boolean)" access="pub" jdoc="">
				<param name="script"/>
			</mth>
			<mth name="/lib/:org.jext.search.Search.getRegexp()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.Search.setRegexp(boolean)" access="pub" jdoc="">
				<param name="useRegexp"/>
			</mth>
			<mth name="/lib/:org.jext.search.Search.getIgnoreCase()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.Search.setIgnoreCase(boolean)" access="pub" jdoc="">
				<param name="icase"/>
			</mth>
			<mth name="/lib/:org.jext.search.Search.setFindPattern(String)" access="pub" jdoc="">
				<param name="findPattern"/>
			</mth>
			<mth name="/lib/:org.jext.search.Search.getFindPattern()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.Search.setReplacePattern(String)" access="pub" jdoc="">
				<param name="replacePattern"/>
			</mth>
			<mth name="/lib/:org.jext.search.Search.getReplacePattern()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.Search.getSearchMatcher()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.Search.getSearchMatcher(boolean)" access="pub" jdoc="">
				<comm cntt="if (matcher != null &amp;&amp; (reverseOK || !reverseSearch))"/>
				<comm cntt="return matcher;"/>
				<comm cntt="replace must not be null"/>
				<comm cntt="String pythonScript = Search.pythonScript;"/>
				<comm cntt="if (script &amp;&amp; replace.length() != 0)"/>
				<comm cntt="{"/>
				<comm cntt="Interpreter interp = BeanShell.getInterpreter();"/>
				<comm cntt="interp.eval(&amp;quot;_replace(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)\n{\nreturn (&amp;quot; + replace + &amp;quot;);\n}&amp;quot;);"/>
				<comm cntt="replaceMethod = interp.getNameSpace().getMethod(&amp;quot;_replace&amp;quot;);"/>
				<comm cntt="}"/>
				<param name="reverseOK"/>
			</mth>
			<mth name="/lib/:org.jext.search.Search.find(JextTextArea, int)" access="pub" jdoc="">
				<param name="textArea"/>
				<param name="start"/>
			</mth>
			<mth name="/lib/:org.jext.search.Search.replace(JextTextArea)" access="pub" jdoc="">
				<comm cntt="setSelectedText() clears these values, so save them"/>
				<comm cntt="textArea.setSelectionStart(selStart);"/>
				<comm cntt="textArea.setSelectionRectangular(rect);"/>
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.search.Search.replaceAll(JextTextArea, int, int)" access="pub" jdoc="">
				<param name="textArea"/>
				<param name="start"/>
				<param name="end"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.search.BoyerMooreSearchMatcher" intfc="n" abs="n" inn="n" sloc="139" jdoc="">
			<comm cntt="private members"/>
			<comm cntt="Boyer-Moore member fields"/>
			<comm cntt="a good introduction to the Boyer-Moore fast string matching algorithm may be found on Moore&amp;apos;s website at: http: www.cs.utexas.edu users moore best-ideas string-searching"/>
			<comm cntt="Boyer-Moore helper methods"/>
			<comm cntt="the &amp;apos;skip&amp;apos; array is used to determine for each index in the hashed alphabet how many characters can be skipped if a mismatch occurs on a characater hashing to that index."/>
			<comm cntt="to avoid our skip table having a length of 2 ^ 16, we hash each character of the input into a character in the alphabet [\x00-\xFF] using the lower 8 bits of the character&amp;apos;s value (resulting in a more reasonable skip table of length 2 ^ 8). the result of this is that more than one character can hash to the same index, but since the skip table encodes the position of occurence of the character furthest into the string with a particular index (whether or not it is the only character with that index), an index collision only means that that this heuristic will give a sub-optimal skip (i.e. a complete skip table could use the differences between colliding characters to maximal effect, at the expense of building a table that is over 2 orders of magnitude larger and very sparse)."/>
			<comm cntt="XXX: hairy code that is basically just a functional(?) port of some other code i barely understood"/>
			<field name="pattern" access="priv" jdoc=""/>
			<field name="replace" access="priv" jdoc=""/>
			<field name="ignoreCase" access="priv" jdoc=""/>
			<field name="reverseSearch" access="priv" jdoc=""/>
			<field name="script" access="priv" jdoc=""/>
			<field name="pythonScript" access="priv" jdoc=""/>
			<field name="replaceArgs" access="priv" jdoc=""/>
			<field name="skip" access="priv" jdoc=""/>
			<field name="suffix" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.search.BoyerMooreSearchMatcher.BoyerMooreSearchMatcher(String, String, boolean, boolean, boolean, String)" access="pub" jdoc="Creates a new string literal matcher.">
				<param name="pattern"/>
				<param name="replace"/>
				<param name="ignoreCase"/>
				<param name="reverseSearch"/>
				<param name="script"/>
				<param name="pythonScript"/>
			</mth>
			<mth name="/lib/:org.jext.search.BoyerMooreSearchMatcher.nextMatch(Segment)" access="pub" jdoc="Returns the offset of the first match of the specified text within this matcher. @param text The text to search in @return an array where the first element is the start offset of the match, and the second element is the end offset of the match">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.search.BoyerMooreSearchMatcher.substitute(String)" access="pub" jdoc="Returns the specified text, with any substitution specified within this matcher performed. @param text The text">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.search.BoyerMooreSearchMatcher.match(char[], int, int)" access="pub" jdoc="">
				<comm cntt="position variable for pattern start"/>
				<comm cntt="position variable for pattern test position"/>
				<comm cntt="last possible start position of a match with this pattern;"/>
				<comm cntt="this is negative if the pattern is longer than the text"/>
				<comm cntt="causing the search loop below to immediately fail"/>
				<comm cntt="each time the pattern is checked, we start this many"/>
				<comm cntt="characters ahead of &amp;apos;anchor&amp;apos;"/>
				<comm cntt="the search works by starting the anchor (first character"/>
				<comm cntt="of the pattern) at the initial offset. as long as the"/>
				<comm cntt="anchor is far enough from the enough of the text for the"/>
				<comm cntt="pattern to match, and until the pattern matches, we"/>
				<comm cntt="compare the pattern to the text from the last character"/>
				<comm cntt="to the first character in reverse order. where a character"/>
				<comm cntt="in the pattern mismatches, we use the two heuristics"/>
				<comm cntt="based on the mismatch character and its position in the"/>
				<comm cntt="pattern to determine the furthest we can move the anchor"/>
				<comm cntt="without missing any potential pattern matches."/>
				<comm cntt="pattern test"/>
				<comm cntt="character mismatch, determine how many characters to skip"/>
				<comm cntt="heuristic #1"/>
				<comm cntt="heuristic #2"/>
				<comm cntt="skip the greater of the two distances provided by the"/>
				<comm cntt="heuristics"/>
				<comm cntt="go back to the while loop"/>
				<comm cntt="MATCH: return the position of its first character"/>
				<comm cntt="MISMATCH: return -1 as defined by API"/>
				<param name="text"/>
				<param name="offset"/>
				<param name="length"/>
			</mth>
			<mth name="/lib/:org.jext.search.BoyerMooreSearchMatcher.generateSkipArray()" access="priv" jdoc="">
				<comm cntt="initialize the skip array to all zeros"/>
				<comm cntt="leave the table cleanly-initialized for an empty pattern"/>
			</mth>
			<mth name="/lib/:org.jext.search.BoyerMooreSearchMatcher.getSkipIndex(char)" access="priv" jdoc="">
				<param name="ch"/>
			</mth>
			<mth name="/lib/:org.jext.search.BoyerMooreSearchMatcher.generateSuffixArray()" access="priv" jdoc="">
				<comm cntt="the code above builds a 1-indexed suffix array,"/>
				<comm cntt="but we shift it to be 0-indexed, ignoring the"/>
				<comm cntt="original 0-th element"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.search.SearchHighlight" intfc="n" abs="n" inn="n" sloc="68" jdoc="">
			<field name="matches" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<field name="next" access="priv" jdoc=""/>
			<field name="enabled" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.search.SearchHighlight.disable()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.SearchHighlight.enable()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.SearchHighlight.trigger(boolean)" access="pub" jdoc="">
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.jext.search.SearchHighlight.setMatches(ArrayList)" access="pub" jdoc="">
				<param name="matches"/>
			</mth>
			<mth name="/lib/:org.jext.search.SearchHighlight.init(JEditTextArea, TextAreaHighlight)" access="pub" jdoc="">
				<param name="textArea"/>
				<param name="next"/>
			</mth>
			<mth name="/lib/:org.jext.search.SearchHighlight.paintHighlight(Graphics, int, int)" access="pub" jdoc="">
				<comm cntt="gfx.setColor(Color.red);"/>
				<comm cntt="int off = (pos[0] - lineElement.getStartOffset()) width + horOffset;"/>
				<param name="gfx"/>
				<param name="line"/>
				<param name="y"/>
			</mth>
			<mth name="/lib/:org.jext.search.SearchHighlight.getToolTipText(MouseEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.search.LiteralSearchMatcher" intfc="n" abs="n" inn="n" sloc="137" jdoc="">
			<comm cntt="private members"/>
			<field name="search" access="priv" jdoc=""/>
			<field name="replace" access="priv" jdoc=""/>
			<field name="ignoreCase" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.search.LiteralSearchMatcher.LiteralSearchMatcher(String, String, boolean)" access="pub" jdoc="Creates a new string literal matcher. @param search The search string @param replace The replacement string @param ignoreCase True if the matcher should be case insensitive, false otherwise">
				<param name="search"/>
				<param name="replace"/>
				<param name="ignoreCase"/>
			</mth>
			<mth name="/lib/:org.jext.search.LiteralSearchMatcher.nextMatch(String)" access="pub" jdoc="Returns the offset of the first match of the specified text within this matcher. @param text The text to search in @return an array where the first element is the start offset of the match, and the second element is the end offset of the match">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.search.LiteralSearchMatcher.nextMatch(String, int)" access="pub" jdoc="">
				<param name="text"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.search.LiteralSearchMatcher.substitute(String)" access="pub" jdoc="Returns the specified text, with any substitution specified within this matcher performed. @param text The text">
				<param name="text"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.search.FindAllDialog" intfc="n" abs="n" inn="n" sloc="230" jdoc="">
			<field name="results" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="fieldSearch" access="priv" jdoc=""/>
			<field name="resultModel" access="priv" jdoc=""/>
			<field name="fieldSearchEditor" access="priv" jdoc=""/>
			<field name="find" access="priv" jdoc=""/>
			<field name="cancel" access="priv" jdoc=""/>
			<field name="useRegexp" access="priv" jdoc=""/>
			<field name="ignoreCase" access="priv" jdoc=""/>
			<field name="highlight" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.search.FindAllDialog.FindAllDialog(JextFrame)" access="pub" jdoc="">
				<comm cntt="results.setMaximumSize(new Dimension(40 fm.charWidth(&amp;apos;m&amp;apos;),"/>
				<comm cntt="10 results.getFixedCellHeight()));"/>
				<comm cntt="scroller.getViewport().setPreferredSize(results.getMaximumSize());"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindAllDialog.exit()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.FindAllDialog.addSearchHistory()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.FindAllDialog.addSearchHistory(String)" access="priv" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindAllDialog.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindAllDialog.findAll()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.FindAllDialog.nextMatch(String, int)" access="priv" jdoc="">
				<param name="str"/>
				<param name="index"/>
			</mth>
		<class name="/lib/:org.jext.search.FindAllDialog$ListHandler" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<mth name="/lib/:org.jext.search.FindAllDialog$ListHandler.valueChanged(ListSelectionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.search.FindAllDialog$KeyHandler" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<mth name="/lib/:org.jext.search.FindAllDialog$KeyHandler.keyPressed(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.search.SearchResult" intfc="n" abs="n" inn="n" sloc="42" jdoc="">
			<field name="str" access="priv" jdoc=""/>
			<field name="end" access="priv" jdoc=""/>
			<field name="start" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.search.SearchResult.SearchResult(JextTextArea, Position, Position)" access="pub" jdoc="">
				<param name="textArea"/>
				<param name="start"/>
				<param name="end"/>
			</mth>
			<mth name="/lib/:org.jext.search.SearchResult.getPos()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.SearchResult.getLine(Element)" access="priv" jdoc="">
				<param name="elem"/>
			</mth>
			<mth name="/lib/:org.jext.search.SearchResult.getTextArea()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.SearchResult.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.search.RESearchMatcher" intfc="n" abs="n" inn="n" sloc="45" jdoc="A regular expression string matcher. @author Slava Pestov @version $Id: RESearchMatcher.java,v 1.2 2001 08 29 20:29:42 gfx Exp $">
			<comm cntt="private members"/>
			<const name="RE_SYNTAX_JEXT" access="pub" jdoc="Perl5 syntax with character classes enabled. @since jEdit 3.0pre5"/>
			<field name="replace" access="priv" jdoc=""/>
			<field name="re" access="priv" jdoc=""/>
			<field name="script" access="priv" jdoc=""/>
			<field name="pythonScript" access="priv" jdoc=""/>
			<field name="replaceArgs" access="pub" jdoc=""/>
			<mth name="/lib/:org.jext.search.RESearchMatcher.RESearchMatcher(String, String, boolean, boolean, String)" access="pub" jdoc="Creates a new regular expression string matcher.">
				<param name="search"/>
				<param name="replace"/>
				<param name="ignoreCase"/>
				<param name="script"/>
				<param name="pythonScript"/>
			</mth>
			<mth name="/lib/:org.jext.search.RESearchMatcher.nextMatch(Segment)" access="pub" jdoc="Returns the offset of the first match of the specified text within this matcher. @param text The text to search in @return an array where the first element is the start offset of the match, and the second element is the end offset of the match">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.search.RESearchMatcher.substitute(String)" access="pub" jdoc="Returns the specified text, with any substitution specified within this matcher performed. @param text The text">
				<comm cntt="Interpreter interp = BeanShell.getInterpreter();"/>
				<param name="text"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.search.FindReplace" intfc="n" abs="n" inn="n" sloc="428" jdoc="The &amp;lt;code&amp;gt;FindReplace&amp;lt; code&amp;gt; class is a component which displays a dialog for either finding either replacing text. It provides two combo lists, which holds latest patterns, and many buttons or check boxes for options. @author Romain Guy">
			<comm cntt="Constant declarations"/>
			<comm cntt="Private declarations"/>
			<comm cntt="This method is used to easily build the GridBagLayout"/>
			<comm cntt="load the search and replace histories from user"/>
			<comm cntt="properties. It also selects latest pattern from"/>
			<comm cntt="the list."/>
			<comm cntt="exits the dialog after having saved the search and"/>
			<comm cntt="replace histories."/>
			<comm cntt="adds current search pattern in the search history list"/>
			<comm cntt="adds a pattern in the search history list"/>
			<comm cntt="the pattern to be added is specified by the param c"/>
			<comm cntt="adds current replace pattern in the replace history list"/>
			<comm cntt="adds a pattern in the replace history list"/>
			<comm cntt="the pattern to be added is given by the param c"/>
			<comm cntt="Catch the action performed and then look for its source"/>
			<comm cntt="According to the source object we call appropriate methods"/>
			<comm cntt="replace all the occurences of search pattern by"/>
			<comm cntt="the replace one. If &amp;apos;All Files&amp;apos; is checked, this is"/>
			<comm cntt="done in all the opened file in the component &amp;apos;parent&amp;apos;"/>
			<comm cntt="replaces specified search pattern by the replace one."/>
			<comm cntt="this is done only if a match is found."/>
			<comm cntt="finds the next occurence of current search pattern"/>
			<comm cntt="the search is done in current text area"/>
			<comm cntt="finds the next occurence of the search pattern in a"/>
			<comm cntt="a given text area. if match is not found, and if user"/>
			<comm cntt="don&amp;apos;t ask to start over from beginning, then the method"/>
			<comm cntt="calls itself by specifying next opened text area."/>
			<const name="SEARCH" access="pub" jdoc="Defines a search only dialog"/>
			<const name="REPLACE" access="pub" jdoc="Defines a search and replace dialog"/>
			<field name="type" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="fieldSearch" access="priv" jdoc=""/>
			<field name="fieldReplace" access="priv" jdoc=""/>
			<field name="fieldSearchEditor" access="priv" jdoc=""/>
			<field name="fieldReplaceEditor" access="priv" jdoc=""/>
			<field name="script" access="priv" jdoc=""/>
			<field name="btnFind" access="priv" jdoc=""/>
			<field name="btnReplace" access="priv" jdoc=""/>
			<field name="btnReplaceAll" access="priv" jdoc=""/>
			<field name="btnCancel" access="priv" jdoc=""/>
			<field name="checkIgnoreCase" access="priv" jdoc=""/>
			<field name="saveStates" access="priv" jdoc=""/>
			<field name="useRegexp" access="priv" jdoc=""/>
			<field name="allFiles" access="priv" jdoc=""/>
			<field name="scripted" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.search.FindReplace.buildConstraints(GridBagConstraints, int, int, int, int, int, int)" access="priv" jdoc="">
				<param name="agbc"/>
				<param name="agx"/>
				<param name="agy"/>
				<param name="agw"/>
				<param name="agh"/>
				<param name="awx"/>
				<param name="awy"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.FindReplace(JextFrame, int, boolean)" access="pub" jdoc="Constructs a new find dialog according to the specified type of dialog requested. The dialog can be either a FIND dialog, either a REPLACE dialog. In both cases, components displayed remain the sames, but the ones specific to replace feature are grayed out. @param parent The window holder @param type The type of the dialog: &amp;lt;code&amp;gt;FindReplace.FIND&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;FindReplace.REPLACE&amp;lt; code&amp;gt; @param modal Displays dialog as a modal window if true">
				<comm cntt="patch added by gandalf march 25 2003"/>
				<comm cntt="patch added by gandalf march 25 2003"/>
				<comm cntt="patch by MJB 8 1 2002"/>
				<comm cntt="end MJB patch"/>
				<param name="parent"/>
				<param name="type"/>
				<param name="modal"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.load()" access="priv" jdoc="">
				<comm cntt="selects contents"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.exit()" access="priv" jdoc="">
				<comm cntt="patch added by gandalf march 25 2003"/>
				<comm cntt="patch added by gandalf march 25 2003"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.addSearchHistory()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.addSearchHistory(String)" access="priv" jdoc="">
				<comm cntt="for (int i = 24; i &amp;lt; fieldSearch.getItemCount(); i++)"/>
				<comm cntt="patch added by gandalf march 25 2003"/>
				<comm cntt="patch added by gandalf march 25 2003"/>
				<comm cntt="Search.setFindPattern(fieldSearchEditor.getText());"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.addReplaceHistory()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.addReplaceHistory(String)" access="priv" jdoc="">
				<comm cntt="for (int i = 24; i &amp;lt; fieldReplace.getItemCount(); i++)"/>
				<comm cntt="patch added by gandalf march 25 2003"/>
				<comm cntt="patch added by gandalf march 25 2003"/>
				<comm cntt="Search.setReplacePattern(fieldReplaceEditor.getText());"/>
				<param name="c"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.setSettings()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.doReplaceAll()" access="priv" jdoc="">
				<comm cntt="nothing"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.doReplace()" access="priv" jdoc="">
				<comm cntt="nothing"/>
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.doFind()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.search.FindReplace.find(JextTextArea)" access="priv" jdoc="">
				<param name="textArea"/>
			</mth>
		<class name="/lib/:org.jext.search.FindReplace$KeyHandler" intfc="n" abs="n" inn="y" sloc="17" jdoc="">
			<mth name="/lib/:org.jext.search.FindReplace$KeyHandler.keyPressed(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.search.SearchMatcher" intfc="y" abs="n" inn="n" sloc="5" jdoc="An abstract interface for matching strings. @author Slava Pestov @version $Id: SearchMatcher.java,v 1.1.1.1 2001 08 20 22:33:30 gfx Exp $">
			<mth name="/lib/:org.jext.search.SearchMatcher.nextMatch(Segment)" access="pub" jdoc="Returns the offset of the first match of the specified text within this matcher. @param text The text to search in @return an array where the first element is the start offset of the match, and the second element is the end offset of the match">
				<param name="text"/>
			</mth>
			<mth name="/lib/:org.jext.search.SearchMatcher.substitute(String)" access="pub" jdoc="Returns the specified text, with any substitution specified within this matcher performed. @param text The text @return The changed string">
				<param name="text"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.textarea">
		<class name="/lib/:org.jext.textarea.ScrollUp" intfc="n" abs="n" inn="n" sloc="13" jdoc="">
			<mth name="/lib/:org.jext.textarea.ScrollUp.ScrollUp()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.textarea.ScrollUp.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.textarea.IndentOnTab" intfc="n" abs="n" inn="n" sloc="48" jdoc="">
			<mth name="/lib/:org.jext.textarea.IndentOnTab.IndentOnTab()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.textarea.IndentOnTab.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.textarea.ScrollPageDown" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<mth name="/lib/:org.jext.textarea.ScrollPageDown.ScrollPageDown()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.textarea.ScrollPageDown.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.textarea.CsWord" intfc="n" abs="n" inn="n" sloc="116" jdoc="">
			<const name="DIRECTIONS" access="pub" jdoc=""/>
			<const name="ACTIONS" access="pub" jdoc=""/>
			<const name="NO_ACTION" access="pub" jdoc=""/>
			<const name="SELECT" access="pub" jdoc=""/>
			<const name="DELETE" access="pub" jdoc=""/>
			<field name="action" access="priv" jdoc=""/>
			<field name="direction" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.textarea.CsWord.CsWord(int, int)" access="pub" jdoc="">
				<param name="action"/>
				<param name="direction"/>
			</mth>
			<mth name="/lib/:org.jext.textarea.CsWord.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="end if a selection exists"/>
				<comm cntt="end if action == DELETE"/>
				<comm cntt="end if Character.isLetterOrDigit(checkChar)"/>
				<comm cntt="end if FORWARD and not letter or digit"/>
				<comm cntt="(these two"/>
				<comm cntt="or these two)"/>
				<comm cntt="and this"/>
				<comm cntt="end big fat if statement"/>
				<comm cntt="end 2nd big fat if statement"/>
				<comm cntt="end while more white space (different types)"/>
				<comm cntt="end try"/>
				<comm cntt="end catch IndexOutOfBoundsException"/>
				<comm cntt="end if whitespace characters"/>
				<comm cntt="end if origCaret == caret"/>
				<comm cntt="end try"/>
				<comm cntt="end try"/>
				<comm cntt="end catch"/>
				<comm cntt="end catch"/>
				<comm cntt="end if select"/>
				<comm cntt="end try to remove word"/>
				<comm cntt="end catch"/>
				<comm cntt="end else"/>
				<comm cntt="end else"/>
				<comm cntt="end else"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.textarea.PrevLineIndent" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<mth name="/lib/:org.jext.textarea.PrevLineIndent.PrevLineIndent()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.textarea.PrevLineIndent.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.textarea.IndentOnEnter" intfc="n" abs="n" inn="n" sloc="16" jdoc="">
			<mth name="/lib/:org.jext.textarea.IndentOnEnter.IndentOnEnter()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.textarea.IndentOnEnter.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.textarea.ScrollPageUp" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<mth name="/lib/:org.jext.textarea.ScrollPageUp.ScrollPageUp()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.textarea.ScrollPageUp.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.textarea.ScrollDown" intfc="n" abs="n" inn="n" sloc="13" jdoc="">
			<mth name="/lib/:org.jext.textarea.ScrollDown.ScrollDown()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.textarea.ScrollDown.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.textarea.NextLineIndent" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<mth name="/lib/:org.jext.textarea.NextLineIndent.NextLineIndent()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.textarea.NextLineIndent.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.toolbar">
		<class name="/lib/:org.jext.toolbar.FastSyntax" intfc="n" abs="n" inn="n" sloc="54" jdoc="">
			<field name="parent" access="priv" jdoc=""/>
			<field name="modeNames" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.toolbar.FastSyntax.FastSyntax(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.FastSyntax.jextEventFired(JextEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.FastSyntax.selectMode(JextTextArea)" access="priv" jdoc="">
				<comm cntt="selectMode = true;"/>
				<param name="textArea"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.FastSyntax.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.toolbar.FastFind" intfc="n" abs="n" inn="n" sloc="61" jdoc="">
			<field name="parent" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.toolbar.FastFind.FastFind(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.FastFind.keyPressed(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.FastFind.keyTyped(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.FastFind.keyReleased(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.FastFind.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="setText(null);"/>
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.FastFind.find(JextTextArea, boolean)" access="priv" jdoc="">
				<param name="textArea"/>
				<param name="showError"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.toolbar.JextToolBar" intfc="n" abs="n" inn="n" sloc="87" jdoc="This toolbar allows plugins to append buttons after Jext default ones. Indeed, depending the order the plugins are loaded, added buttons might appear after another component like a JChooseBox. @author Romain Guy">
			<field name="grayed" access="priv" jdoc=""/>
			<field name="buttonsPanel" access="priv" jdoc=""/>
			<field name="persistentToolBar" access="priv" jdoc=""/>
			<field name="transientToolBar" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.toolbar.JextToolBar.JextToolBar(JextFrame)" access="pub" jdoc="Creates a new tool bar.">
				<comm cntt="super(Jext.getProperty(&amp;quot;jext.toolbar.title&amp;quot;));"/>
				<comm cntt="addMisc(parent);"/>
				<comm cntt="first we load persistent plugins"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.JextToolBar.addMisc(JextFrame)" access="pub" jdoc="">
				<comm cntt="fast find"/>
				<comm cntt="fast syntax"/>
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.JextToolBar.setGrayed(boolean)" access="pub" jdoc="">
				<param name="on"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.JextToolBar.addButton(JextButton)" access="pub" jdoc="Appends a button in the tool bar. @param button The button to be added">
				<comm cntt="added by Steve Lawson"/>
				<param name="button"/>
			</mth>
			<mth name="/lib/:org.jext.toolbar.JextToolBar.addButtonSeparator()" access="pub" jdoc="Adds a separator in the buttons panel.">
			</mth>
			<mth name="/lib/:org.jext.toolbar.JextToolBar.freeze()" access="pub" jdoc="Stores the toolbar before starting mode-specific plugins. (Actually switches the toolbar)">
			</mth>
			<mth name="/lib/:org.jext.toolbar.JextToolBar.reset()" access="pub" jdoc="Restores the toolbar.">
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.xinsert">
		<class name="/lib/:org.jext.xinsert.XTreeNode" intfc="n" abs="n" inn="n" sloc="47" jdoc="">
			<field name="pos" access="priv" jdoc=""/>
			<field name="modes" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xinsert.XTreeNode.XTreeNode(String)" access="pub" jdoc="">
				<param name="userObject"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeNode.XTreeNode(String, String)" access="pub" jdoc="">
				<param name="userObject"/>
				<param name="modes"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeNode.XTreeNode(String, String, int)" access="pub" jdoc="">
				<param name="userObject"/>
				<param name="modes"/>
				<param name="pos"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeNode.getIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeNode.setIndex(int)" access="pub" jdoc="">
				<param name="pos"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeNode.isPermanent()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeNode.isAssociatedToMode(String)" access="pub" jdoc="">
				<param name="mode"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xinsert.XTreeObject" intfc="n" abs="n" inn="n" sloc="34" jdoc="">
			<field name="index" access="priv" jdoc=""/>
			<field name="xtreeNode" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xinsert.XTreeObject.XTreeObject(XTreeNode, int)" access="pub" jdoc="">
				<param name="xtreeNode"/>
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeObject.getIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeObject.setIndex(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeObject.getXTreeNode()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeObject.setXTreeNode(XTreeNode)" access="pub" jdoc="">
				<param name="xtreeNode"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeObject.incrementIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeObject.decrementIndex()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.xinsert.XTree" intfc="n" abs="n" inn="n" sloc="419" jdoc="">
			<comm cntt="nested submenus"/>
			<comm cntt="this loads the main file, while loadLocalFiles thinks to local files."/>
			<field name="inserts" access="priv" jdoc=""/>
			<field name="file" access="priv" jdoc=""/>
			<field name="currentMode" access="priv" jdoc=""/>
			<field name="tree" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="treeModel" access="priv" jdoc="This contains the complete content of the files. It&amp;apos;s never associated to the JTree: associateXTreeToMode reads it and chooses the right nodes. @see associateXTreeToMode"/>
			<field name="expand" access="priv" jdoc=""/>
			<field name="collapse" access="priv" jdoc=""/>
			<field name="reload" access="priv" jdoc=""/>
			<field name="carriageReturn" access="priv" jdoc=""/>
			<field name="executeScript" access="priv" jdoc=""/>
			<field name="textSurrounding" access="priv" jdoc=""/>
			<field name="rootIndex" access="priv" jdoc=""/>
			<field name="root" access="priv" jdoc=""/>
			<field name="menuStack" access="priv" jdoc=""/>
			<field name="xtreeObj" access="priv" jdoc=""/>
			<const name="leaves" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xinsert.XTree.addMenu(String, String)" access="pub" jdoc="">
				<param name="nodeName"/>
				<param name="modes"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.closeMenu()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.addInsert(String, String, int)" access="pub" jdoc="">
				<param name="nodeName"/>
				<param name="content"/>
				<param name="type"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.XTree(JextFrame, String)" access="pub" jdoc="">
				<comm cntt="new BorderLayout());"/>
				<comm cntt=","/>
				<comm cntt="BorderLayout.NORTH);"/>
				<comm cntt=","/>
				<comm cntt="BorderLayout.CENTER);"/>
				<comm cntt=","/>
				<comm cntt="BorderLayout.SOUTH);"/>
				<param name="parent"/>
				<param name="file"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.init(String)" access="priv" jdoc="">
				<param name="file"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.init(String, boolean)" access="priv" jdoc="">
				<param name="file"/>
				<param name="useThread"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.stop()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.run()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.loadLocalFiles()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.jextEventFired(JextEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.associateXTreeToMode()" access="priv" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.associateXTreeToMode(boolean)" access="priv" jdoc="This method builds a copy of treeModel containing only nodes relevant to current mode, and then uses the new TreeModel for the tree. Must be called by the event-dispatching thread!">
				<comm cntt="if we must reload(at user&amp;apos;s request or when loading is finished), we do this even when"/>
				<comm cntt="mode has not changed."/>
				<comm cntt="so we need to be in the event-dispatching thread."/>
				<param name="checkColorizingMode"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.valueChanged(TreeSelectionEvent)" access="pub" jdoc="">
				<param name="tse"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.reload(DefaultTreeModel)" access="pub" jdoc="">
				<comm cntt="tree.setModel(model);"/>
				<param name="model"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree.insert(int)" access="priv" jdoc="">
				<param name="index"/>
			</mth>
		<class name="/lib/:org.jext.xinsert.XTree$XTreeCellRenderer" intfc="n" abs="n" inn="y" sloc="31" jdoc="">
			<mth name="/lib/:org.jext.xinsert.XTree$XTreeCellRenderer.XTreeCellRenderer()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTree$XTreeCellRenderer.getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)" access="pub" jdoc="">
				<param name="source"/>
				<param name="value"/>
				<param name="sel"/>
				<param name="expanded"/>
				<param name="leaf"/>
				<param name="row"/>
				<param name="hasFocus"/>
			</mth>
		</class>
		</class>
		<class name="/lib/:org.jext.xinsert.XTreeItem" intfc="n" abs="n" inn="n" sloc="41" jdoc="">
			<const name="PLAIN" access="pub" jdoc=""/>
			<const name="SCRIPT" access="pub" jdoc=""/>
			<const name="MIXED" access="pub" jdoc=""/>
			<field name="type" access="priv" jdoc=""/>
			<field name="content" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xinsert.XTreeItem.XTreeItem(String)" access="pub" jdoc="">
				<param name="content"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeItem.XTreeItem(String, int)" access="pub" jdoc="">
				<param name="content"/>
				<param name="type"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeItem.isMixed()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeItem.isScript()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeItem.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeItem.setType(int)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeItem.getContent()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xinsert.XTreeItem.setContent(String)" access="pub" jdoc="">
				<param name="content"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/lib/:org.jext.xml">
		<class name="/lib/:org.jext.xml.XBarReader" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<mth name="/lib/:org.jext.xml.XBarReader.read(JextFrame, InputStream, String)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="fileName"/>
				<param name="file"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.OneClickActionsReader" intfc="n" abs="n" inn="n" sloc="34" jdoc="">
			<mth name="/lib/:org.jext.xml.OneClickActionsReader.OneClickActionsReader()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.OneClickActionsReader.read(InputStream, String)" access="pub" jdoc="">
				<comm cntt="Should NEVER happend !"/>
				<param name="fileName"/>
				<param name="file"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.XPropertiesReader" intfc="n" abs="n" inn="n" sloc="43" jdoc="">
			<mth name="/lib/:org.jext.xml.XPropertiesReader.XPropertiesReader()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.XPropertiesReader.read(InputStream, String)" access="pub" jdoc="This method loads XML properties from the specified InputStream or from the translated file named &amp;quot;name&amp;quot;. So the caller should not provide the translated one(that is, calling getLanguageString to obtain parameters.">
				<comm cntt="InputStream in = Jext.getLanguageStream(fileName, name); if (in == null) return false; else return read(in);"/>
				<param name="fileStream"/>
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPropertiesReader.read(InputStream, String, boolean)" access="pub" jdoc="If toTranslate is true, it behaves just like read(InputStream, String); else it loads XML properties from the specified InputStream, which must be the right(i.e. already translated) one. @since Jext3.2pre1">
				<param name="fileStream"/>
				<param name="name"/>
				<param name="toTranslate"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.XBarHandler" intfc="n" abs="n" inn="n" sloc="90" jdoc="">
			<comm cntt="private members"/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="tbar" access="priv" jdoc=""/>
			<field name="stateStack" access="priv" jdoc=""/>
			<field name="enabled" access="priv" jdoc=""/>
			<field name="lastShortcut" access="priv" jdoc=""/>
			<field name="lastAction" access="priv" jdoc=""/>
			<field name="lastPicture" access="priv" jdoc=""/>
			<field name="lastLabel" access="priv" jdoc=""/>
			<field name="lastTip" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xml.XBarHandler.XBarHandler(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XBarHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XBarHandler.doctypeDecl(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XBarHandler.startElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XBarHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XBarHandler.startDocument()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.XBarHandler.endDocument()" access="pub" jdoc="">
				<comm cntt="tbar.setFloatable(false);"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.XInsertHandler" intfc="n" abs="n" inn="n" sloc="79" jdoc="">
			<comm cntt="private members"/>
			<field name="tree" access="priv" jdoc=""/>
			<field name="stateStack" access="priv" jdoc=""/>
			<field name="lastAttr" access="priv" jdoc=""/>
			<field name="lastName" access="priv" jdoc=""/>
			<field name="lastValue" access="priv" jdoc=""/>
			<field name="lastAttrValue" access="priv" jdoc=""/>
			<field name="lastModes" access="priv" jdoc=""/>
			<field name="type" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xml.XInsertHandler.XInsertHandler(XTree)" access="pub" jdoc="">
				<param name="tree"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XInsertHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XInsertHandler.doctypeDecl(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XInsertHandler.charData(char[], int, int)" access="pub" jdoc="">
				<param name="c"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XInsertHandler.startElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XInsertHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XInsertHandler.startDocument()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.OneClickActionsHandler" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<comm cntt="private members"/>
			<field name="pName" access="priv" jdoc=""/>
			<field name="iName" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xml.OneClickActionsHandler.OneClickActionsHandler()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.OneClickActionsHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/lib/:org.jext.xml.OneClickActionsHandler.doctypeDecl(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:org.jext.xml.OneClickActionsHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.XMenuHandler" intfc="n" abs="n" inn="n" sloc="137" jdoc="">
			<comm cntt="private members"/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="mbar" access="priv" jdoc=""/>
			<field name="stateStack" access="priv" jdoc=""/>
			<field name="lastAttrValue" access="priv" jdoc=""/>
			<field name="lastMenu" access="priv" jdoc=""/>
			<field name="currentMenu" access="priv" jdoc=""/>
			<field name="enabled" access="priv" jdoc=""/>
			<field name="labelSeparator" access="priv" jdoc=""/>
			<field name="debug" access="priv" jdoc=""/>
			<field name="lastAttr" access="priv" jdoc=""/>
			<field name="lastName" access="priv" jdoc=""/>
			<field name="lastAction" access="priv" jdoc=""/>
			<field name="lastPicture" access="priv" jdoc=""/>
			<field name="lastID" access="priv" jdoc=""/>
			<field name="lastLabel" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xml.XMenuHandler.XMenuHandler(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XMenuHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XMenuHandler.doctypeDecl(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XMenuHandler.startElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XMenuHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XMenuHandler.startDocument()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.XMenuHandler.endDocument()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.PyActionsReader" intfc="n" abs="n" inn="n" sloc="34" jdoc="">
			<mth name="/lib/:org.jext.xml.PyActionsReader.PyActionsReader()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.PyActionsReader.read(InputStream, String)" access="pub" jdoc="">
				<comm cntt="Should NEVER happend !"/>
				<param name="fileName"/>
				<param name="file"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.XInsertReader" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<mth name="/lib/:org.jext.xml.XInsertReader.XInsertReader()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.XInsertReader.read(XTree, InputStream, String)" access="pub" jdoc="">
				<comm cntt="Should NEVER happend !"/>
				<param name="tree"/>
				<param name="fileName"/>
				<param name="file"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.XPropertiesHandler" intfc="n" abs="n" inn="n" sloc="80" jdoc="">
			<comm cntt="private members"/>
			<field name="props" access="priv" jdoc=""/>
			<field name="pName" access="priv" jdoc=""/>
			<field name="pValue" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xml.XPropertiesHandler.XPropertiesHandler()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.XPropertiesHandler.parse(String)" access="priv" jdoc="">
				<param name="in"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPropertiesHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPropertiesHandler.doctypeDecl(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPropertiesHandler.charData(char[], int, int)" access="pub" jdoc="">
				<param name="c"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPropertiesHandler.startElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPropertiesHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPropertiesHandler.startDocument()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.XMenuReader" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<mth name="/lib/:org.jext.xml.XMenuReader.read(JextFrame, InputStream, String)" access="pub" jdoc="">
				<comm cntt="Should NEVER happend !"/>
				<param name="parent"/>
				<param name="fileName"/>
				<param name="file"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.XPopupHandler" intfc="n" abs="n" inn="n" sloc="102" jdoc="">
			<comm cntt="private members"/>
			<field name="popup" access="priv" jdoc=""/>
			<field name="stateStack" access="priv" jdoc=""/>
			<field name="currentMenu" access="priv" jdoc=""/>
			<field name="lastAttrValue" access="priv" jdoc=""/>
			<field name="enabled" access="priv" jdoc=""/>
			<field name="lastAttr" access="priv" jdoc=""/>
			<field name="lastName" access="priv" jdoc=""/>
			<field name="lastAction" access="priv" jdoc=""/>
			<field name="lastPicture" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xml.XPopupHandler.XPopupHandler()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.XPopupHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPopupHandler.doctypeDecl(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPopupHandler.startElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPopupHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/lib/:org.jext.xml.XPopupHandler.startDocument()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.XPopupHandler.endDocument()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.XPopupHandler.getPopupMenu()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.PyActionsHandler" intfc="n" abs="n" inn="n" sloc="35" jdoc="">
			<comm cntt="private members"/>
			<field name="pEditAction" access="priv" jdoc=""/>
			<field name="pName" access="priv" jdoc=""/>
			<field name="pValue" access="priv" jdoc=""/>
			<mth name="/lib/:org.jext.xml.PyActionsHandler.PyActionsHandler()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.PyActionsHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/lib/:org.jext.xml.PyActionsHandler.doctypeDecl(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/lib/:org.jext.xml.PyActionsHandler.charData(char[], int, int)" access="pub" jdoc="">
				<param name="c"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
			<mth name="/lib/:org.jext.xml.PyActionsHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
		</class>
		<class name="/lib/:org.jext.xml.XPopupReader" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<mth name="/lib/:org.jext.xml.XPopupReader.XPopupReader()" access="pub" jdoc="">
			</mth>
			<mth name="/lib/:org.jext.xml.XPopupReader.read(InputStream, String)" access="pub" jdoc="">
				<comm cntt="Should NEVER happend !"/>
				<param name="fileName"/>
				<param name="file"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/FindAll/FindAll.java:default">
		<class name="/plugins/FindAll/FindAll.java:default.FindAll" intfc="n" abs="n" inn="n" sloc="284" jdoc="">
			<comm cntt="End of patch"/>
			<field name="results" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="fieldSearch" access="priv" jdoc=""/>
			<field name="resultModel" access="priv" jdoc=""/>
			<field name="fieldSearchEditor" access="priv" jdoc=""/>
			<field name="find" access="priv" jdoc=""/>
			<field name="unHighlight" access="priv" jdoc=""/>
			<field name="useRegexp" access="priv" jdoc=""/>
			<field name="ignoreCase" access="priv" jdoc=""/>
			<field name="highlight" access="priv" jdoc=""/>
			<field name="allFiles" access="priv" jdoc=""/>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.FindAll(JextFrame)" access="pub" jdoc="">
				<comm cntt="= new Dimension(20 fm.charWidth(&amp;apos;m&amp;apos;), fieldSearch.getSize().height);"/>
				<comm cntt="fieldSearch.setPreferredSize(size);"/>
				<param name="parent"/>
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.exit()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.removeHighlights()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.addSearchHistory()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.addSearchHistory(String)" access="priv" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.findText()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.findAll()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.nextMatch(String, int)" access="priv" jdoc="">
				<param name="str"/>
				<param name="index"/>
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.jextEventFired(JextEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll.finalize()" access="prot" jdoc="Patch -&amp;gt; Memory management improvements : it may help the garbage collector. -&amp;gt; Author : Julien Ponge (julien@izforge.com) -&amp;gt; Date : 23, May 2001">
			</mth>
		<class name="/plugins/FindAll/FindAll.java:default.FindAll$ListHandler" intfc="n" abs="n" inn="y" sloc="15" jdoc="">
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll$ListHandler.valueChanged(ListSelectionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		<class name="/plugins/FindAll/FindAll.java:default.FindAll$KeyHandler" intfc="n" abs="n" inn="y" sloc="12" jdoc="">
			<mth name="/plugins/FindAll/FindAll.java:default.FindAll$KeyHandler.keyPressed(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/FindAll/FindAllAction.java:default">
		<class name="/plugins/FindAll/FindAllAction.java:default.FindAllAction" intfc="n" abs="n" inn="n" sloc="17" jdoc="">
			<field name="findAll" access="pub" jdoc=""/>
			<mth name="/plugins/FindAll/FindAllAction.java:default.FindAllAction.FindAllAction()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindAll/FindAllAction.java:default.FindAllAction.setFindAll(FindAll)" access="pub" jdoc="">
				<param name="findAll"/>
			</mth>
			<mth name="/plugins/FindAll/FindAllAction.java:default.FindAllAction.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/FindAll/FindAllPlugin.java:default">
		<class name="/plugins/FindAll/FindAllPlugin.java:default.FindAllPlugin" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<field name="findAll" access="pub" jdoc=""/>
			<field name="action" access="pub" jdoc=""/>
			<mth name="/plugins/FindAll/FindAllPlugin.java:default.FindAllPlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="pluginsMenus"/>
				<param name="pluginsMenuItems"/>
			</mth>
			<mth name="/plugins/FindAll/FindAllPlugin.java:default.FindAllPlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/FindAll/FindAllPlugin.java:default.FindAllPlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindAll/FindAllPlugin.java:default.FindAllPlugin.stop()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/FindInFiles/src/FindInFiles.java:default">
		<class name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles" intfc="n" abs="n" inn="n" sloc="211" jdoc="">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="MAX_PATHS" access="priv" jdoc=""/>
			<const name="MAX_FILTERS" access="priv" jdoc=""/>
			<const name="MAX_PATTERNS" access="priv" jdoc=""/>
			<const name="USE_REGX_PROP" access="priv" jdoc=""/>
			<const name="SEARCH_SUB_DIR_PROP" access="priv" jdoc=""/>
			<const name="IGNORE_CASE_PROP" access="priv" jdoc=""/>
			<const name="PATH_PROP" access="priv" jdoc=""/>
			<const name="FILTER_PROP" access="priv" jdoc=""/>
			<const name="PATTERN_PROP" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="me" access="priv" jdoc=""/>
			<field name="dataList" access="priv" jdoc=""/>
			<field name="searchButton" access="priv" jdoc=""/>
			<field name="chooseButton" access="priv" jdoc=""/>
			<field name="pathCombo" access="priv" jdoc=""/>
			<field name="filterCombo" access="priv" jdoc=""/>
			<field name="patternCombo" access="priv" jdoc=""/>
			<field name="regexChechBox" access="priv" jdoc=""/>
			<field name="subDirChechBox" access="priv" jdoc=""/>
			<field name="ignoreCaseChechBox" access="priv" jdoc=""/>
			<field name="statusLabel" access="priv" jdoc=""/>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.FindInFiles(JextFrame)" access="pub" jdoc="">
				<comm cntt="build the panel with the combobox"/>
				<comm cntt="let it shrink"/>
				<comm cntt="let it shrink"/>
				<comm cntt="let it shrink"/>
				<comm cntt="check boxes"/>
				<param name="parent"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.addListeners()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.addHistory(JComboBox)" access="priv" jdoc="">
				<param name="combo"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.exit()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.saveProp(JComboBox, String, int)" access="priv" jdoc="">
				<param name="combo"/>
				<param name="propName"/>
				<param name="maxProps"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.saveProp(JCheckBox, String)" access="priv" jdoc="">
				<param name="checkBox"/>
				<param name="propName"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.loadProp(JComboBox, String, int)" access="priv" jdoc="">
				<param name="combo"/>
				<param name="propName"/>
				<param name="maxProps"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.loadProp(JCheckBox, String)" access="priv" jdoc="">
				<param name="checkBox"/>
				<param name="propName"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.jextEventFired(JextEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles.showStatus(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		<class name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles$MyCellRenderer" intfc="n" abs="n" inn="y" sloc="17" jdoc="">
			<comm cntt="This is the only method defined by ListCellRenderer."/>
			<comm cntt="We just reconfigure the JLabel each time we&amp;apos;re called."/>
			<mth name="/plugins/FindInFiles/src/FindInFiles.java:default.FindInFiles$MyCellRenderer.getListCellRendererComponent(JList, Object, int, boolean, boolean)" access="pub" jdoc="">
				<comm cntt="value to display"/>
				<comm cntt="cell index"/>
				<comm cntt="is the cell selected"/>
				<comm cntt="the list and the cell have the focus"/>
				<param name="list"/>
				<param name="value"/>
				<param name="index"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/FindInFiles/src/FindInFilesHelper.java:default">
		<class name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper" intfc="n" abs="n" inn="n" sloc="91" jdoc="">
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="tabSize" access="priv" jdoc=""/>
			<mth name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper.getFileNames(File, String, boolean)" access="priv" jdoc="">
				<comm cntt="given a file"/>
				<comm cntt="given a file"/>
				<param name="dir"/>
				<param name="filter"/>
				<param name="searchSubdirectories"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper.addFile2Vector(File, String[], Vector)" access="priv" jdoc="">
				<param name="dir"/>
				<param name="strings"/>
				<param name="vect"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper.addFile2Vector(String[], Vector)" access="priv" jdoc="">
				<param name="strings"/>
				<param name="vect"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper.vector2StringArray(Vector)" access="priv" jdoc="">
				<param name="vect"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper.search(File, String, String, boolean, boolean, boolean)" access="pub" jdoc="">
				<param name="dir"/>
				<param name="filter"/>
				<param name="pattern"/>
				<param name="searchSubdirectories"/>
				<param name="ignoreCase"/>
				<param name="useRegExp"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper.search(String[], String, boolean, boolean)" access="pub" jdoc="">
				<param name="files"/>
				<param name="pattern"/>
				<param name="ignoreCase"/>
				<param name="useRegExp"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper.searchInFile(String, SearchMatcher)" access="priv" jdoc="">
				<param name="file"/>
				<param name="matcher"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper.replaceTabs(String, String)" access="priv" jdoc="">
				<param name="text"/>
				<param name="tabSpace"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesHelper.java:default.FindInFilesHelper.getTabSpace()" access="priv" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/FindInFiles/src/FindInFilesMatch.java:default">
		<class name="/plugins/FindInFiles/src/FindInFilesMatch.java:default.FindInFilesMatch" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<comm cntt="headers are really just place holders for labels"/>
			<comm cntt="only valid on headers"/>
			<comm cntt="only valid on non-headers"/>
			<comm cntt="only valid on non-headers"/>
			<field name="isHeader" access="priv" jdoc=""/>
			<field name="matchCount" access="priv" jdoc=""/>
			<field name="filename" access="priv" jdoc=""/>
			<field name="lineText" access="priv" jdoc=""/>
			<field name="lineNumber" access="priv" jdoc=""/>
			<mth name="/plugins/FindInFiles/src/FindInFilesMatch.java:default.FindInFilesMatch.FindInFilesMatch(String, int)" access="pub" jdoc="">
				<param name="filename"/>
				<param name="matchCount"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesMatch.java:default.FindInFilesMatch.FindInFilesMatch(String, String, long)" access="pub" jdoc="">
				<param name="filename"/>
				<param name="lineText"/>
				<param name="lineNumber"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesMatch.java:default.FindInFilesMatch.FindInFilesMatch(String, String, long, boolean, int)" access="priv" jdoc="">
				<param name="filename"/>
				<param name="lineText"/>
				<param name="lineNumber"/>
				<param name="isHeader"/>
				<param name="matchCount"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesMatch.java:default.FindInFilesMatch.getFilename()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesMatch.java:default.FindInFilesMatch.getLineText()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesMatch.java:default.FindInFilesMatch.getLineNumber()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesMatch.java:default.FindInFilesMatch.isHeader()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesMatch.java:default.FindInFilesMatch.getMatchCount()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/FindInFiles/src/FindInFilesOptions.java:default">
		<class name="/plugins/FindInFiles/src/FindInFilesOptions.java:default.FindInFilesOptions" intfc="n" abs="n" inn="n" sloc="14" jdoc="">
			<field name="useGlob" access="priv" jdoc=""/>
			<mth name="/plugins/FindInFiles/src/FindInFilesOptions.java:default.FindInFilesOptions.FindInFilesOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesOptions.java:default.FindInFilesOptions.save()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/FindInFiles/src/FindInFilesPlugin.java:default">
		<class name="/plugins/FindInFiles/src/FindInFilesPlugin.java:default.FindInFilesPlugin" intfc="n" abs="n" inn="n" sloc="25" jdoc="">
			<const name="USE_GLOB_PROP" access="pub" jdoc=""/>
			<field name="findInFiles" access="priv" jdoc=""/>
			<mth name="/plugins/FindInFiles/src/FindInFilesPlugin.java:default.FindInFilesPlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="optionsDialog"/>
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesPlugin.java:default.FindInFilesPlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesPlugin.java:default.FindInFilesPlugin.stop()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FindInFiles/src/FindInFilesPlugin.java:default.FindInFilesPlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="pluginsMenus"/>
				<param name="pluginsMenuItems"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/FunnyBrackets/src/FunnyBrackets.java:default">
		<class name="/plugins/FunnyBrackets/src/FunnyBrackets.java:default.FunnyBrackets" intfc="n" abs="n" inn="n" sloc="41" jdoc="">
			<field name="isRunning" access="priv" jdoc=""/>
			<mth name="/plugins/FunnyBrackets/src/FunnyBrackets.java:default.FunnyBrackets.FunnyBrackets()" access="pub" jdoc="">
				<comm cntt="super(&amp;quot;plugin.FunnyBracketsPlugin.hotkey.funnybrackets&amp;quot;);"/>
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBrackets.java:default.FunnyBrackets.setRunningMode(boolean)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBrackets.java:default.FunnyBrackets.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="On est devant une braket inf�rieure"/>
				<comm cntt="Une popup uniquement si la brakete sup�rieure n&amp;apos;est pas visible"/>
				<comm cntt="�a veut dire que la ligne ne contient que ( ou {"/>
				<comm cntt="on prend donc la ligne du dessus"/>
				<comm cntt="Une popup uniquement pour les lignes non vides"/>
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/FunnyBrackets/src/FunnyBracketsPlugin.java:default">
		<class name="/plugins/FunnyBrackets/src/FunnyBracketsPlugin.java:default.FunnyBracketsPlugin" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<const name="fpHandler" access="priv" jdoc=""/>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPlugin.java:default.FunnyBracketsPlugin.FunnyBracketsPlugin()" access="pub" jdoc="">
				<comm cntt="Creation de la classe &amp;quot; Action&amp;quot;"/>
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPlugin.java:default.FunnyBracketsPlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="pluginsMenus"/>
				<param name="pluginsMenuItems"/>
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPlugin.java:default.FunnyBracketsPlugin.register(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPlugin.java:default.FunnyBracketsPlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPlugin.java:default.FunnyBracketsPlugin.start()" access="pub" jdoc="">
				<comm cntt="Active le plugin"/>
				<comm cntt="..."/>
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPlugin.java:default.FunnyBracketsPlugin.stop()" access="pub" jdoc="">
				<comm cntt="D�sactive le plugin"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default">
		<class name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default.FunnyBracketsPopup" intfc="n" abs="n" inn="n" sloc="67" jdoc="">
			<field name="parent" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default.FunnyBracketsPopup.FunnyBracketsPopup(JextFrame, String)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="word"/>
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default.FunnyBracketsPopup.dispose()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default.FunnyBracketsPopup.caretUpdate(CaretEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default.FunnyBracketsPopup.finalize()" access="prot" jdoc="">
			</mth>
		<class name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default.FunnyBracketsPopup$KeyHandler" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default.FunnyBracketsPopup$KeyHandler.keyPressed(KeyEvent)" access="pub" jdoc="">
				<comm cntt="D�s que l&amp;apos;on appuie sur une touche on nique le popup"/>
				<comm cntt="est fait suivre l&amp;apos;action ..."/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default.FunnyBracketsPopup$MouseHandler" intfc="n" abs="n" inn="y" sloc="7" jdoc="">
			<mth name="/plugins/FunnyBrackets/src/FunnyBracketsPopup.java:default.FunnyBracketsPopup$MouseHandler.mouseClicked(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/Attribute.java:default">
		<class name="/plugins/HTML/Attribute.java:default.Attribute" intfc="n" abs="n" inn="n" sloc="18" jdoc="">
			<field name="attribute" access="pub" jdoc=""/>
			<mth name="/plugins/HTML/Attribute.java:default.Attribute.Attribute(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="value"/>
			</mth>
			<mth name="/plugins/HTML/Attribute.java:default.Attribute.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/CompleteTagList.java:default">
		<class name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList" intfc="n" abs="n" inn="n" sloc="132" jdoc="">
			<comm cntt="private Object[] list;"/>
			<comm cntt="End of patch"/>
			<field name="tags" access="priv" jdoc=""/>
			<field name="selfInput" access="priv" jdoc=""/>
			<field name="itemsList" access="priv" jdoc=""/>
			<field name="word" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<field name="completion" access="priv" jdoc=""/>
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList.CompleteTagList(JextFrame, TagsCompletion, String, Tag[])" access="pub" jdoc="">
				<param name="parent"/>
				<param name="completion"/>
				<param name="word"/>
				<param name="list"/>
			</mth>
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList.CompleteTagList(JextFrame, TagsCompletion, String, Entity[])" access="pub" jdoc="">
				<param name="parent"/>
				<param name="completion"/>
				<param name="word"/>
				<param name="list"/>
			</mth>
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList.CompleteTagList(JextFrame, TagsCompletion, String, Object[], boolean)" access="priv" jdoc="">
				<comm cntt="this.list = list;"/>
				<param name="parent"/>
				<param name="completion"/>
				<param name="word"/>
				<param name="list"/>
				<param name="tags"/>
			</mth>
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList.caretUpdate(CaretEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList.dispose()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList.insertEntity()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList.insertTag()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList.finalize()" access="prot" jdoc="Patch -&amp;gt; Memory management improvements : it may help the garbage collector. -&amp;gt; Author : Julien Ponge (julien@izforge.com) -&amp;gt; Date : 23, May 2001">
			</mth>
		<class name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList$KeyHandler" intfc="n" abs="n" inn="y" sloc="95" jdoc="">
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList$KeyHandler.keyTyped(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList$KeyHandler.keyPressed(KeyEvent)" access="pub" jdoc="">
				<comm cntt="case KeyEvent.VK_SPACE:"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList$MouseHandler" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList$MouseHandler.mouseClicked(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
		</class>
		<class name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList$TagsCellRenderer" intfc="n" abs="n" inn="y" sloc="34" jdoc="">
			<mth name="/plugins/HTML/CompleteTagList.java:default.CompleteTagList$TagsCellRenderer.getListCellRendererComponent(JList, Object, int, boolean, boolean)" access="pub" jdoc="">
				<param name="list"/>
				<param name="value"/>
				<param name="index"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/EntitiesListHandler.java:default">
		<class name="/plugins/HTML/EntitiesListHandler.java:default.EntitiesListHandler" intfc="n" abs="n" inn="n" sloc="28" jdoc="">
			<field name="entity" access="priv" jdoc=""/>
			<field name="name" access="priv" jdoc=""/>
			<mth name="/plugins/HTML/EntitiesListHandler.java:default.EntitiesListHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/plugins/HTML/EntitiesListHandler.java:default.EntitiesListHandler.startElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/HTML/EntitiesListHandler.java:default.EntitiesListHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/HTML/EntitiesListHandler.java:default.EntitiesListHandler.startDocument()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/EntitiesListReader.java:default">
		<class name="/plugins/HTML/EntitiesListReader.java:default.EntitiesListReader" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<mth name="/plugins/HTML/EntitiesListReader.java:default.EntitiesListReader.EntitiesListReader()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/EntitiesListReader.java:default.EntitiesListReader.read(InputStream, String)" access="pub" jdoc="">
				<comm cntt="Should NEVER happend !"/>
				<param name="fileName"/>
				<param name="file"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/Entity.java:default">
		<class name="/plugins/HTML/Entity.java:default.Entity" intfc="n" abs="n" inn="n" sloc="16" jdoc="">
			<field name="name" access="priv" jdoc=""/>
			<mth name="/plugins/HTML/Entity.java:default.Entity.Entity(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/HTML/Entity.java:default.Entity.getEntity()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/Entity.java:default.Entity.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/HTMLIndenter.java:default">
		<class name="/plugins/HTML/HTMLIndenter.java:default.HTMLIndenter" intfc="n" abs="n" inn="n" sloc="154" jdoc="">
			<field name="INDENT_ON_TAG" access="pub" jdoc=""/>
			<field name="indent" access="priv" jdoc=""/>
			<field name="indentSize" access="priv" jdoc=""/>
			<field name="lastWasTag" access="priv" jdoc=""/>
			<field name="MAX_LINE_WIDTH" access="pub" jdoc=""/>
			<const name="TAG" access="priv" jdoc=""/>
			<const name="NULL" access="priv" jdoc=""/>
			<const name="CLOSING_TAG" access="priv" jdoc=""/>
			<mth name="/plugins/HTML/HTMLIndenter.java:default.HTMLIndenter.HTMLIndenter()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/HTMLIndenter.java:default.HTMLIndenter.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/HTMLIndenter.java:default.HTMLIndenter.indentTag(String)" access="priv" jdoc="">
				<param name="tag"/>
			</mth>
			<mth name="/plugins/HTML/HTMLIndenter.java:default.HTMLIndenter.createIndent(int)" access="priv" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/plugins/HTML/HTMLIndenter.java:default.HTMLIndenter.parse(String, JextTextArea)" access="priv" jdoc="">
				<param name="html"/>
				<param name="textArea"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/HTMLPlugin.java:default">
		<class name="/plugins/HTML/HTMLPlugin.java:default.HTMLPlugin" intfc="n" abs="n" inn="n" sloc="42" jdoc="">
			<mth name="/plugins/HTML/HTMLPlugin.java:default.HTMLPlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<comm cntt="menus.addElement(GUIUtilities.loadMenu(&amp;quot;HTML_menu&amp;quot;));"/>
				<param name="parent"/>
				<param name="menus"/>
				<param name="menuItems"/>
			</mth>
			<mth name="/plugins/HTML/HTMLPlugin.java:default.HTMLPlugin.register(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/HTML/HTMLPlugin.java:default.HTMLPlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/HTML/HTMLPlugin.java:default.HTMLPlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/HTMLPlugin.java:default.HTMLPlugin.stop()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/IndenterOptionPane.java:default">
		<class name="/plugins/HTML/IndenterOptionPane.java:default.IndenterOptionPane" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<field name="maxLineWidth" access="priv" jdoc=""/>
			<mth name="/plugins/HTML/IndenterOptionPane.java:default.IndenterOptionPane.IndenterOptionPane()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/IndenterOptionPane.java:default.IndenterOptionPane.save()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/NextTag.java:default">
		<class name="/plugins/HTML/NextTag.java:default.NextTag" intfc="n" abs="n" inn="n" sloc="53" jdoc="">
			<field name="lastTag" access="priv" jdoc=""/>
			<mth name="/plugins/HTML/NextTag.java:default.NextTag.NextTag()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/NextTag.java:default.NextTag.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/NextTag.java:default.NextTag.seekTag(String, int, int)" access="priv" jdoc="">
				<param name="in"/>
				<param name="index"/>
				<param name="offset"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/PreviousTag.java:default">
		<class name="/plugins/HTML/PreviousTag.java:default.PreviousTag" intfc="n" abs="n" inn="n" sloc="50" jdoc="">
			<mth name="/plugins/HTML/PreviousTag.java:default.PreviousTag.PreviousTag()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/PreviousTag.java:default.PreviousTag.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/PreviousTag.java:default.PreviousTag.seekTag(String, int)" access="priv" jdoc="">
				<param name="in"/>
				<param name="index"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/Tag.java:default">
		<class name="/plugins/HTML/Tag.java:default.Tag" intfc="n" abs="n" inn="n" sloc="68" jdoc="">
			<field name="name" access="priv" jdoc=""/>
			<field name="empty" access="priv" jdoc=""/>
			<field name="attributes" access="priv" jdoc=""/>
			<mth name="/plugins/HTML/Tag.java:default.Tag.Tag(String, boolean)" access="pub" jdoc="">
				<param name="name"/>
				<param name="empty"/>
			</mth>
			<mth name="/plugins/HTML/Tag.java:default.Tag.isEmpty()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/Tag.java:default.Tag.attributesCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/Tag.java:default.Tag.addAttribute(Attribute)" access="pub" jdoc="">
				<param name="attr"/>
			</mth>
			<mth name="/plugins/HTML/Tag.java:default.Tag.getClosingTag()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/Tag.java:default.Tag.getOpeningTag()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/Tag.java:default.Tag.getFullTag()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/Tag.java:default.Tag.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/TagsCompletion.java:default">
		<class name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion" intfc="n" abs="n" inn="n" sloc="222" jdoc="">
			<comm cntt="friendly"/>
			<comm cntt="friendly"/>
			<field name="popup" access="priv" jdoc=""/>
			<field name="registeredAreas" access="priv" jdoc=""/>
			<field name="tagsList" access="pub" jdoc=""/>
			<field name="entitiesList" access="pub" jdoc=""/>
			<const name="delimiters" access="pub" jdoc=""/>
			<const name="endDelimiters" access="pub" jdoc=""/>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.unregisterTextArea(JextTextArea)" access="pub" jdoc="">
				<param name="textArea"/>
			</mth>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.registerTextArea(JextTextArea)" access="pub" jdoc="">
				<param name="textArea"/>
			</mth>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.jextEventFired(JextEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.keyPressed(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.getWord(JextTextArea)" access="priv" jdoc="">
				<param name="textArea"/>
			</mth>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.showCompleteTagList(JextTextArea)" access="priv" jdoc="">
				<param name="textArea"/>
			</mth>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.loadEntitiesList()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.loadTagsList()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.buildEntitiesList(String)" access="pub" jdoc="">
				<param name="entity"/>
			</mth>
			<mth name="/plugins/HTML/TagsCompletion.java:default.TagsCompletion.buildTagsList(String)" access="pub" jdoc="">
				<param name="tag"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/TagsCompletionOptionPane.java:default">
		<class name="/plugins/HTML/TagsCompletionOptionPane.java:default.TagsCompletionOptionPane" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<field name="expandFullTag" access="priv" jdoc=""/>
			<field name="activateTool" access="priv" jdoc=""/>
			<field name="xhtml" access="priv" jdoc=""/>
			<mth name="/plugins/HTML/TagsCompletionOptionPane.java:default.TagsCompletionOptionPane.TagsCompletionOptionPane()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/TagsCompletionOptionPane.java:default.TagsCompletionOptionPane.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/TagsCompletionOptionPane.java:default.TagsCompletionOptionPane.save()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/TagsListHandler.java:default">
		<class name="/plugins/HTML/TagsListHandler.java:default.TagsListHandler" intfc="n" abs="n" inn="n" sloc="40" jdoc="">
			<field name="tag" access="priv" jdoc=""/>
			<field name="empty" access="priv" jdoc=""/>
			<field name="name" access="priv" jdoc=""/>
			<field name="value" access="priv" jdoc=""/>
			<mth name="/plugins/HTML/TagsListHandler.java:default.TagsListHandler.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="aname"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/plugins/HTML/TagsListHandler.java:default.TagsListHandler.startElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/HTML/TagsListHandler.java:default.TagsListHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/HTML/TagsListHandler.java:default.TagsListHandler.startDocument()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/TagsListReader.java:default">
		<class name="/plugins/HTML/TagsListReader.java:default.TagsListReader" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<mth name="/plugins/HTML/TagsListReader.java:default.TagsListReader.TagsListReader()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/TagsListReader.java:default.TagsListReader.read(InputStream, String)" access="pub" jdoc="">
				<comm cntt="Should NEVER happend !"/>
				<param name="fileName"/>
				<param name="file"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/ToAccents.java:default">
		<class name="/plugins/HTML/ToAccents.java:default.ToAccents" intfc="n" abs="n" inn="n" sloc="84" jdoc="">
			<mth name="/plugins/HTML/ToAccents.java:default.ToAccents.ToAccents()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/ToAccents.java:default.ToAccents.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/ToAccents.java:default.ToAccents.doAccents(String)" access="priv" jdoc="">
				<param name="html"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HTML/ToEntities.java:default">
		<class name="/plugins/HTML/ToEntities.java:default.ToEntities" intfc="n" abs="n" inn="n" sloc="48" jdoc="">
			<mth name="/plugins/HTML/ToEntities.java:default.ToEntities.ToEntities()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HTML/ToEntities.java:default.ToEntities.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HTML/ToEntities.java:default.ToEntities.doEntities(String)" access="priv" jdoc="">
				<comm cntt="case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;eacute;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;egrave;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;ecirc;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;euml;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;agrave;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;acirc;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;auml;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;icirc;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;iuml;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;ugrave;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;uuml;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;ucirc;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;ocirc;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;ouml;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;ccedil;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;szlig;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;Auml;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;Ouml;&amp;quot;); break; case &amp;apos;�&amp;apos;: buf.append(&amp;quot;&amp;Uuml;&amp;quot;); break;"/>
				<param name="html"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/AutoExpander.java:default">
		<class name="/plugins/HyperTyper/AutoExpander.java:default.AutoExpander" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<mth name="/plugins/HyperTyper/AutoExpander.java:default.AutoExpander.AutoExpander()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/AutoExpander.java:default.AutoExpander.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/HyperTyperAction.java:default">
		<class name="/plugins/HyperTyper/HyperTyperAction.java:default.HyperTyperAction" intfc="n" abs="n" inn="n" sloc="281" jdoc="Performs the action bound to the keystroke for expanding a shorthand. &amp;lt;P&amp;gt; It could maintain a list of all Jext Text Areas that it has been associated with, to avoid duplicating extra calls to add key bindings, but that would require a WeakReference to prevent this handler from keeping those removed areas around, which would pin us to JDK 1.2.">
			<comm cntt="HyperTyper delimiters for finding between-spaces"/>
			<comm cntt="Should this be a property?"/>
			<comm cntt="end HyperTyper action!"/>
			<const name="delimiters" access="pub" jdoc=""/>
			<const name="SPACE" access="pub" jdoc=""/>
			<const name="DEFAULT_KEY_BIND" access="priv" jdoc=""/>
			<const name="PROP_NAME" access="prot" jdoc=""/>
			<const name="PROP_KEYBIND" access="prot" jdoc=""/>
			<const name="PROP_ERROR_MESSAGE" access="prot" jdoc=""/>
			<const name="PROP_ERROR_TITLE" access="prot" jdoc=""/>
			<const name="IS_REMOVE_BINDING_IMPLEMENTED" access="priv" jdoc=""/>
			<field name="htMap" access="priv" jdoc=""/>
			<field name="originalKeyAction" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperAction.java:default.HyperTyperAction.HyperTyperAction(HyperTyperMapping)" access="pub" jdoc="Constructor to make the HyperTyper action.">
				<comm cntt="setup the initial key handler"/>
				<comm cntt="Hack:"/>
				<comm cntt="don&amp;apos;t forget to do it with the very first Jext Area"/>
				<param name="htMap"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperAction.java:default.HyperTyperAction.newFileAdded(JextTextArea)" access="pub" jdoc="Called when a new file was added to the window. This may mean a new text area.">
				<comm cntt="reset all the properties, I guess."/>
				<param name="area"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperAction.java:default.HyperTyperAction.setKeyBinding(String)" access="pub" jdoc="Set this action&amp;apos;s key binding! &amp;lt;P&amp;gt; This routine may need to be changed in the future - it only extracts a single action handler from the default text area; it doesn&amp;apos;t consider multiple text areas for restoring the original bindings.">
				<comm cntt="not a well formed keystroke"/>
				<comm cntt="the original property is bad, so set it to the default"/>
				<comm cntt="this does require an actual binding, though"/>
				<param name="bind"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperAction.java:default.HyperTyperAction.addKeyBinding(String, ActionListener)" access="prot" jdoc="Adds the given binding to all Jext text areas. Should only be called when the key binding has changed.">
				<param name="bind"/>
				<param name="action"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperAction.java:default.HyperTyperAction.removeKeyBinding(String)" access="prot" jdoc="Removes the given binding from all Jext text areas.">
				<comm cntt="If not implemented, but above is true, this throws"/>
				<comm cntt="a not-yet-implemented exception."/>
				<param name="bind"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperAction.java:default.HyperTyperAction.getInputHandlers()" access="prot" jdoc="Retrieve a list of every single known Jext instance&amp;apos;s text area&amp;apos;s input handler.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperAction.java:default.HyperTyperAction.actionPerformed(ActionEvent)" access="pub" jdoc="The HyperTyper text-finder and replacer. To perform proper indention, we need to do incremental outputting of text. &amp;lt;P&amp;gt; This method is overly complex, and should be broken up. @author Romain Guy, Matt Albrecht">
				<comm cntt=""/>
				<comm cntt="First, discover which sequence the user wants."/>
				<comm cntt=""/>
				<comm cntt="case caret is placed on a word"/>
				<comm cntt=""/>
				<comm cntt="Expand the text"/>
				<comm cntt=""/>
				<comm cntt="could just trim but we only want to treat spaces, not other whitespace chars."/>
				<comm cntt="end if expanded ends with a space and next char is also a space"/>
				<comm cntt="avoid computing this operation all the other times"/>
				<comm cntt="0 = not set"/>
				<comm cntt="1 = set"/>
				<comm cntt="2 = set &amp; indent once"/>
				<comm cntt="by default, the caret position is at the end of the"/>
				<comm cntt="expanded text."/>
				<comm cntt="Only set the caret the first time"/>
				<comm cntt="This is a disputable check."/>
				<comm cntt="don&amp;apos;t do indent on next line!"/>
				<comm cntt="put the proper tabbing after the new-line"/>
				<comm cntt="but only if we are not on the first line"/>
				<comm cntt="In order to indent correctly,"/>
				<comm cntt="we need to put the so-far text"/>
				<comm cntt="into the document."/>
				<comm cntt="So increment the incremental inserting"/>
				<comm cntt="position counter"/>
				<comm cntt="and start the buffer over clean"/>
				<comm cntt="this is a JDK1.2 call - so 86 it."/>
				<comm cntt="_buf.delete( 0, _buf.length() );"/>
				<comm cntt="and instead use a JDK1.1 call; here we need to create a new buffer"/>
				<comm cntt="and indent"/>
				<comm cntt="Now we need to increment the"/>
				<comm cntt="incremental inserting position counter"/>
				<comm cntt="by the indention amount."/>
				<comm cntt="Adjust the caret position to"/>
				<comm cntt="reflect the insertion, if it has just been"/>
				<comm cntt="set."/>
				<comm cntt="perform a final insert, if we&amp;apos;re not on the first line"/>
				<comm cntt="possibly adjust the caret position"/>
				<comm cntt="set the caret position correctly,"/>
				<comm cntt="without going past the end of the file."/>
				<comm cntt="do nothing"/>
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/HyperTyperHotkey.java:default">
		<class name="/plugins/HyperTyper/HyperTyperHotkey.java:default.HyperTyperHotkey" intfc="n" abs="n" inn="n" sloc="115" jdoc="Creates a fast-key sequence, using the selected text as the expanded part, if given.">
			<comm cntt="delay initialization until necessary"/>
			<const name="PROP_NAME" access="prot" jdoc=""/>
			<const name="PROP_TITLE" access="prot" jdoc=""/>
			<const name="PROP_EXPANDED_LABEL" access="prot" jdoc=""/>
			<const name="PROP_ENTRY_FIELD" access="prot" jdoc=""/>
			<const name="PROP_USE_TRANSIENT" access="prot" jdoc=""/>
			<const name="PROP_USE_PERSISTENT" access="prot" jdoc=""/>
			<const name="TRANS" access="prot" jdoc=""/>
			<const name="PERSIS" access="prot" jdoc=""/>
			<field name="htMap" access="priv" jdoc=""/>
			<field name="expandedArea" access="priv" jdoc=""/>
			<field name="fullPanel" access="priv" jdoc=""/>
			<field name="scrollArea" access="priv" jdoc=""/>
			<field name="whichIsSelected" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperHotkey.java:default.HyperTyperHotkey.HyperTyperHotkey(HyperTyperMapping)" access="pub" jdoc="">
				<param name="htm"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperHotkey.java:default.HyperTyperHotkey.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="Get the selected text"/>
				<comm cntt="lazy-load components"/>
				<comm cntt="use the same font as the editor"/>
				<comm cntt="now, we allow no selection!"/>
				<comm cntt="Add an editable field for changing the selected text"/>
				<comm cntt="CLOSED_OPTION;"/>
				<comm cntt="If there is not an array of option buttons:"/>
				<comm cntt="clicked cancel"/>
				<comm cntt="get the expanded text from the dialog&amp;apos;s text area"/>
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperHotkey.java:default.HyperTyperHotkey.isTransientSelected()" access="priv" jdoc="helper method">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/HyperTyperMapping.java:default">
		<class name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping" intfc="n" abs="n" inn="n" sloc="54" jdoc="Controlls the access to the different kinds of known sequence sets; in particular, the persistent and transient sets.">
			<comm cntt="key is shorthand, value is plain text; both persist and transient"/>
			<comm cntt="Vector of Sequences; expanded text is escaped."/>
			<const name="FAST_TYPER_NAME" access="priv" jdoc=""/>
			<field name="translateMap" access="priv" jdoc=""/>
			<field name="persistList" access="priv" jdoc=""/>
			<field name="transientList" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping.HyperTyperMapping()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping.save()" access="pub" jdoc="Saves all persistant mappings to the Jext properties.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping.getExpandedText(String)" access="pub" jdoc="Retrieves the expanded text from the given shorthand. This text may be extracted from either the persistent store or the transient store.">
				<param name="shorthand"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping.getEscapedExpandedText(String)" access="pub" jdoc="Retrieves the expanded text from the given shorthand as an escape sequence. This text may be extracted from either the persistent store or the transient store.">
				<param name="shorthand"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping.getPersistentMappings()" access="pub" jdoc="Get all persistent mappings.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping.getTransientMappings()" access="pub" jdoc="Get all transient mappings.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping.shutdown()" access="pub" jdoc="Shutdown the fast typer.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping.sequenceAdded(SequenceChangedEvent)" access="pub" jdoc="">
				<param name="sce"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMapping.java:default.HyperTyperMapping.sequenceRemoved(SequenceChangedEvent)" access="pub" jdoc="">
				<param name="sce"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default">
		<class name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid" intfc="n" abs="n" inn="n" sloc="100" jdoc="GUI for handling the display of a mapping set.">
			<const name="PROP_TITLE" access="priv" jdoc=""/>
			<const name="PROP_COL1" access="priv" jdoc=""/>
			<const name="PROP_COL2" access="priv" jdoc=""/>
			<const name="PROP_MOVE_BUTTON" access="priv" jdoc=""/>
			<const name="PROP_MOVE_BUTTON_ACCEL" access="priv" jdoc=""/>
			<const name="PROP_DEL_BUTTON" access="priv" jdoc=""/>
			<const name="PROP_DEL_BUTTON_ACCEL" access="priv" jdoc=""/>
			<field name="table" access="priv" jdoc=""/>
			<field name="model" access="priv" jdoc=""/>
			<field name="htsl" access="priv" jdoc=""/>
			<field name="otherList" access="priv" jdoc=""/>
			<field name="propertyBase" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid.HyperTyperMappingGrid(HyperTyperSequenceList, HyperTyperSequenceList, String)" access="pub" jdoc="">
				<param name="htsl"/>
				<param name="otherList"/>
				<param name="propertyBase"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid.sequenceAdded(SequenceChangedEvent)" access="pub" jdoc="">
				<param name="sce"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid.sequenceRemoved(SequenceChangedEvent)" access="pub" jdoc="">
				<param name="sce"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid.construct()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid.getSelectedRow()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid.getSelectedShorthand()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid.getSelectedSequence()" access="pub" jdoc="">
			</mth>
		<class name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid$TyperTableModel" intfc="n" abs="n" inn="y" sloc="87" jdoc="">
			<field name="tempShorthand" access="priv" jdoc=""/>
			<field name="tempExpanded" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid$TyperTableModel.TyperTableModel()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid$TyperTableModel.getColumnCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid$TyperTableModel.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid$TyperTableModel.getValueAt(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid$TyperTableModel.isCellEditable(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid$TyperTableModel.getColumnName(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperMappingGrid.java:default.HyperTyperMappingGrid$TyperTableModel.setValueAt(Object, int, int)" access="pub" jdoc="">
				<comm cntt="last entry - used for creating a new entry."/>
				<comm cntt="make this a new entry"/>
				<comm cntt="else, keep the mapping deleted"/>
				<comm cntt="don&amp;apos;t delete the mapping if the length is &amp;lt;= 0"/>
				<param name="value"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/HyperTyperObjectManager.java:default">
		<class name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager" intfc="n" abs="n" inn="n" sloc="112" jdoc="The Object Manager HyperTyper class handles the &amp;quot;what&amp;quot; of object storage and life-cycle maintenance. &amp;lt;P&amp;gt; This manager keeps track of objects that need to be created each time, or that are singletons. It also lazy-loads as much as possible for singletons.">
			<comm cntt="Plugin helpers - these are one per plugin"/>
			<comm cntt="Support for plugin helpers"/>
			<comm cntt="these are one per plugin as well"/>
			<comm cntt="----------------------------"/>
			<comm cntt="Static Methods"/>
			<const name="PROP_NAME" access="prot" jdoc=""/>
			<const name="PROP_PERSIST" access="prot" jdoc=""/>
			<const name="PROP_TRANSIENT" access="prot" jdoc=""/>
			<field name="htHotkey" access="priv" jdoc=""/>
			<field name="htWindow" access="priv" jdoc=""/>
			<field name="htMap" access="priv" jdoc=""/>
			<field name="htOption" access="priv" jdoc=""/>
			<field name="htAction" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.HyperTyperObjectManager()" access="pub" jdoc="">
				<comm cntt="do nothing"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.getMapping()" access="pub" jdoc="Retrieves the singleton mapping handler.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.getAction()" access="pub" jdoc="Retrieves the singleton action handler.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.getHotkey()" access="pub" jdoc="Retrives the singleton hotkey dialog.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.getWindowGUI()" access="pub" jdoc="Retrieves the singleton mapping window editor.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.getOptionPane()" access="pub" jdoc="Retrieves the singleton option pane.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.getPersistentGrid()" access="pub" jdoc="Retrieves an instance of a Mapping Grid editor for persistent maps.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.getTransientGrid()" access="pub" jdoc="Retrieves an instance of a Mapping Grid editor for transient maps.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.stop()" access="pub" jdoc="Kills all Objects.">
				<comm cntt="Shutdown the dynamic data correctly"/>
				<comm cntt="and close the window"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.toOnOffString(javax.swing.JCheckBox)" access="pub" jdoc="Converts a checkbox to an on off string for properties purposes.">
				<param name="cb"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.isPropertyOn(String)" access="pub" jdoc="Checks of the given property name is &amp;quot;on&amp;quot; or &amp;quot;off&amp;quot;, and returns true or false, respectively.">
				<param name="propertyName"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperObjectManager.java:default.HyperTyperObjectManager.getProperty(String)" access="pub" jdoc="Returns the value of the given property name, as set in the Jext properties. If the value is null, an error message is generated, and an empty string is returned.">
				<param name="name"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/HyperTyperOption.java:default">
		<class name="/plugins/HyperTyper/HyperTyperOption.java:default.HyperTyperOption" intfc="n" abs="n" inn="n" sloc="89" jdoc="Option pane for controlling basic settings for the HyperTyper">
			<comm cntt="selected option states"/>
			<comm cntt="Support for plugins"/>
			<comm cntt="Code added for the new Jext3.2pre1; it enables the caching of the option panes(and doesn&amp;apos;t hurt"/>
			<comm cntt="for previous releases of Jext, even if for this plugin it isn&amp;apos;t important)."/>
			<const name="PROP_NAME" access="prot" jdoc=""/>
			<const name="PROP_TITLE" access="prot" jdoc=""/>
			<const name="PROP_KEYBIND" access="prot" jdoc=""/>
			<const name="PROP_KEYBINDING_LABEL" access="prot" jdoc=""/>
			<const name="PROP_WIN_AUTOSTART_STATE" access="prot" jdoc=""/>
			<const name="PROP_WIN_AUTOSTART_LABEL" access="prot" jdoc=""/>
			<const name="PROP_PERSIST_TAB_AUTOSTART_STATE" access="prot" jdoc=""/>
			<const name="PROP_PERSIST_TAB_AUTOSTART_LABEL" access="prot" jdoc=""/>
			<const name="PROP_TRANSIENT_TAB_AUTOSTART_STATE" access="prot" jdoc=""/>
			<const name="PROP_TRANSIENT_TAB_AUTOSTART_LABEL" access="prot" jdoc=""/>
			<field name="autoExpand" access="priv" jdoc=""/>
			<field name="winAutoStart" access="priv" jdoc=""/>
			<field name="persistTabAutoStart" access="priv" jdoc=""/>
			<field name="transTabAutoStart" access="priv" jdoc=""/>
			<field name="keyBinding" access="priv" jdoc=""/>
			<field name="htAct" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperOption.java:default.HyperTyperOption.HyperTyperOption(HyperTyperAction)" access="pub" jdoc="">
				<comm cntt="the initial action keybinding is done in the action itself."/>
				<param name="htAct"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperOption.java:default.HyperTyperOption.getAction()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperOption.java:default.HyperTyperOption.save()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperOption.java:default.HyperTyperOption.construct()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperOption.java:default.HyperTyperOption.isCacheable()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperOption.java:default.HyperTyperOption.load()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/HyperTyperPlugin.java:default">
		<class name="/plugins/HyperTyper/HyperTyperPlugin.java:default.HyperTyperPlugin" intfc="n" abs="n" inn="n" sloc="70" jdoc="The Plugin HyperTyper class handles the &amp;quot;when&amp;quot; adjustments of state - i.e. it handles the registering of event listening.">
			<const name="PROP_NAME" access="prot" jdoc=""/>
			<const name="PROP_TITLE" access="prot" jdoc=""/>
			<const name="PROP_KEYBIND" access="prot" jdoc=""/>
			<const name="PROP_MENU" access="prot" jdoc=""/>
			<field name="htWindowNotStarted" access="priv" jdoc=""/>
			<field name="htOMan" access="pub" jdoc=""/>
			<field name="autoExpand" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperPlugin.java:default.HyperTyperPlugin.isAutoExpandOn()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperPlugin.java:default.HyperTyperPlugin.HyperTyperPlugin()" access="pub" jdoc="Default constructor.">
				<comm cntt="do nothing"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperPlugin.java:default.HyperTyperPlugin.start()" access="pub" jdoc="Called when the plugin is to initialize itself.">
				<comm cntt="add controls"/>
				<comm cntt="Jext.addAction( );"/>
				<comm cntt="Jext.addAction( );"/>
				<comm cntt="Starting up the KeyBinding for the HyperTyperAction is in"/>
				<comm cntt="the Option pane, since it is in charge of changing it"/>
				<comm cntt="if the user modifies the options."/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperPlugin.java:default.HyperTyperPlugin.stop()" access="pub" jdoc="Called when the plugin is to shutdown.">
				<comm cntt="Shutdown the dynamic data correctly"/>
				<comm cntt="and close the window"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperPlugin.java:default.HyperTyperPlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<comm cntt="make sure to create pane on demand, not on creation"/>
				<param name="parent"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperPlugin.java:default.HyperTyperPlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="Add a submenu menus.addElement(GUIUtilities.loadMenu(&amp;quot;menu_name&amp;quot;); Add an item items.addElement(GUIUtilities.loadMenuItem(&amp;quot;action_name&amp;quot;); &amp;lt;p&amp;gt; This method allows to do a lot of other stuffs as you can use the Jext instance known as &amp;apos;parent&amp;apos; in method body to do something totally different &amp;lt;P&amp;gt; This is called on every new window instance.">
				<comm cntt="Add the Jext Listener to this window"/>
				<comm cntt="give the action a signal of a new file"/>
				<comm cntt="delay start of hyper typer window until the first Jext window"/>
				<comm cntt="has been created."/>
				<comm cntt="open autostart window."/>
				<comm cntt="window is Jext instance independent."/>
				<comm cntt="Check if a tab should be inserted"/>
				<comm cntt="test if we need to add the window&amp;apos;s transient tag to the"/>
				<comm cntt="Jext window&amp;apos;s gui."/>
				<param name="parent"/>
				<param name="menus"/>
				<param name="items"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperPlugin.java:default.HyperTyperPlugin.jextEventFired(JextEvent)" access="pub" jdoc="Tests to see if a new TextArea has been added; if so, fire all pending events in associated objects. Inherited from JextListener.">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/HyperTyperSequenceList.java:default">
		<class name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList" intfc="n" abs="n" inn="n" sloc="216" jdoc="">
			<comm cntt="Vector of Sequences; expanded text is escaped."/>
			<field name="list" access="priv" jdoc=""/>
			<field name="listeners" access="priv" jdoc=""/>
			<field name="prefix" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.HyperTyperSequenceList(String)" access="pub" jdoc="">
				<param name="propertyPrefix"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.addSequenceChangedListener(SequenceChangedListener)" access="pub" jdoc="Adds a new sequence changed listener. After being added, it is sent the list of currently known sequences.">
				<param name="scl"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.removeSequenceChangedListener(SequenceChangedListener)" access="pub" jdoc="Removes an existing registered sequence changed listener.">
				<param name="scl"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.getSequenceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.getSequenceAt(int)" access="pub" jdoc="Retrieve a sequence at the given index.">
				<param name="index"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.init()" access="pub" jdoc="Loads all settings from the properties list.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.save()" access="pub" jdoc="Saves all persistant sequences to the Jext properties.">
				<comm cntt="check if mappings have been initialized yet"/>
				<comm cntt="overwrite existing entries"/>
				<comm cntt="remove all others"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.getMappings()" access="pub" jdoc="Get vector of all persistent mappings, as an escape sequence.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.addMapping(String, String)" access="pub" jdoc="Sets a persistent mapping, where the expanded text is an escape sequence.">
				<param name="shorthand"/>
				<param name="expanded"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.addMapping(Sequence)" access="pub" jdoc="Sets a persistent mapping, where the expanded text is an escape sequence.">
				<comm cntt="if the shorthand is already defined, then remove it."/>
				<param name="seq"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.addPlainMapping(String, String)" access="pub" jdoc="Sets a persistent mapping, where the expanded text is a plain text.">
				<param name="shorthand"/>
				<param name="expanded"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.removeMapping(String)" access="pub" jdoc="Removes the given shorthand mapping from the persistent or transient list, depending where it is currently stored.">
				<comm cntt="Sequence .equals() also works if a string is compared to it;"/>
				<comm cntt="if it&amp;apos;s seq.equals( string ), but not the other way."/>
				<param name="shorthand"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.removeAllMappings()" access="pub" jdoc="Remove all mappings, both persistent and transient.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.shutdown()" access="pub" jdoc="Shutdown the list.">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.escapeToPlain(String)" access="pub" jdoc="Converts an escape-encoded text string into plain text.">
				<param name="value"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.plainToEscape(String)" access="pub" jdoc="Converts plain text strings into an escape-encoded text string.">
				<param name="value"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.fireSequenceAdded(Sequence, int)" access="prot" jdoc="Fires a mapping was added">
				<param name="seq"/>
				<param name="index"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperSequenceList.java:default.HyperTyperSequenceList.fireSequenceRemoved(Sequence, int)" access="prot" jdoc="Fires a mapping was removed">
				<param name="seq"/>
				<param name="index"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/HyperTyperWindowGUI.java:default">
		<class name="/plugins/HyperTyper/HyperTyperWindowGUI.java:default.HyperTyperWindowGUI" intfc="n" abs="n" inn="n" sloc="93" jdoc="Combined the Plugin and Option Pane together for better control of the toolbar. To speed up initial start time, the actual GUI isn&amp;apos;t constructed until it is needed.">
			<comm cntt="this field is only valid while the grids are null,"/>
			<comm cntt="for lazy-loading purposes"/>
			<const name="PROP_NAME" access="prot" jdoc=""/>
			<const name="PROP_TITLE" access="prot" jdoc=""/>
			<const name="PROP_WIDTH" access="prot" jdoc=""/>
			<const name="PROP_HEIGHT" access="prot" jdoc=""/>
			<const name="PROP_POSX" access="prot" jdoc=""/>
			<const name="PROP_POSY" access="prot" jdoc=""/>
			<const name="DEFAULT_HEIGHT" access="priv" jdoc=""/>
			<const name="DEFAULT_WIDTH" access="priv" jdoc=""/>
			<const name="DEFAULT_POSX" access="priv" jdoc=""/>
			<const name="DEFAULT_POSY" access="priv" jdoc=""/>
			<field name="win" access="priv" jdoc=""/>
			<field name="frame" access="priv" jdoc=""/>
			<field name="persistentGrid" access="priv" jdoc=""/>
			<field name="transientGrid" access="priv" jdoc=""/>
			<field name="htOMan" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/HyperTyperWindowGUI.java:default.HyperTyperWindowGUI.HyperTyperWindowGUI(HyperTyperObjectManager)" access="pub" jdoc="Create the GUI reference. However, we need to lazy-load the grids to speed up start time.">
				<param name="htOMan"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperWindowGUI.java:default.HyperTyperWindowGUI.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperWindowGUI.java:default.HyperTyperWindowGUI.shutdown()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperWindowGUI.java:default.HyperTyperWindowGUI.constructWindow()" access="prot" jdoc="">
				<comm cntt="lazy-load the grids"/>
				<comm cntt="no longer need htOMan"/>
			</mth>
			<mth name="/plugins/HyperTyper/HyperTyperWindowGUI.java:default.HyperTyperWindowGUI.getIntProperty(String)" access="pub" jdoc="">
				<param name="propName"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/Sequence.java:default">
		<class name="/plugins/HyperTyper/Sequence.java:default.Sequence" intfc="n" abs="n" inn="n" sloc="50" jdoc="Creates a fast-key sequence, using the selected text as the expanded part. The expanded text may be changed, but not the shorthand text.">
			<comm cntt="public void setShorthand(String shorthand) { this.shorthand = shorthand; }"/>
			<field name="shorthand" access="priv" jdoc=""/>
			<field name="expanded" access="priv" jdoc=""/>
			<mth name="/plugins/HyperTyper/Sequence.java:default.Sequence.Sequence()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/Sequence.java:default.Sequence.Sequence(String, String)" access="pub" jdoc="">
				<param name="shorthand"/>
				<param name="expanded"/>
			</mth>
			<mth name="/plugins/HyperTyper/Sequence.java:default.Sequence.getShorthand()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/Sequence.java:default.Sequence.getExpanded()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/HyperTyper/Sequence.java:default.Sequence.setExpanded(String)" access="pub" jdoc="">
				<param name="expanded"/>
			</mth>
			<mth name="/plugins/HyperTyper/Sequence.java:default.Sequence.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/plugins/HyperTyper/Sequence.java:default.Sequence.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/SequenceChangedEvent.java:default">
		<class name="/plugins/HyperTyper/SequenceChangedEvent.java:default.SequenceChangedEvent" intfc="n" abs="n" inn="n" sloc="18" jdoc="">
			<field name="sequenceList" access="pub" jdoc=""/>
			<field name="index" access="pub" jdoc=""/>
			<field name="seq" access="pub" jdoc=""/>
			<mth name="/plugins/HyperTyper/SequenceChangedEvent.java:default.SequenceChangedEvent.SequenceChangedEvent(HyperTyperSequenceList, int, Sequence)" access="pub" jdoc="">
				<param name="sequenceList"/>
				<param name="index"/>
				<param name="seq"/>
			</mth>
			<mth name="/plugins/HyperTyper/SequenceChangedEvent.java:default.SequenceChangedEvent.clone()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/HyperTyper/SequenceChangedListener.java:default">
		<class name="/plugins/HyperTyper/SequenceChangedListener.java:default.SequenceChangedListener" intfc="y" abs="n" inn="n" sloc="5" jdoc="">
			<mth name="/plugins/HyperTyper/SequenceChangedListener.java:default.SequenceChangedListener.sequenceAdded(SequenceChangedEvent)" access="pub" jdoc="">
				<param name="sce"/>
			</mth>
			<mth name="/plugins/HyperTyper/SequenceChangedListener.java:default.SequenceChangedListener.sequenceRemoved(SequenceChangedEvent)" access="pub" jdoc="">
				<param name="sce"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/BackStab.java:default">
		<class name="/plugins/Java/BackStab.java:default.BackStab" intfc="n" abs="n" inn="n" sloc="40" jdoc="BackStab subclasses UML.Element and stabs it in the back by giving away the secret of its line number to whoever asks.">
			<mth name="/plugins/Java/BackStab.java:default.BackStab.BackStab(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/Java/BackStab.java:default.BackStab.BackStab(UML.Element)" access="priv" jdoc="">
				<param name="elm"/>
			</mth>
			<mth name="/plugins/Java/BackStab.java:default.BackStab.fromElement(UML.Element)" access="pub" jdoc="">
				<param name="elm"/>
			</mth>
			<mth name="/plugins/Java/BackStab.java:default.BackStab.getLine()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/BackStab.java:default.BackStab.getLine(UML.Element)" access="pub" jdoc="">
				<param name="elm"/>
			</mth>
			<mth name="/plugins/Java/BackStab.java:default.BackStab.compareTo(Object)" access="pub" jdoc="">
				<comm cntt="end if line numbers are equal"/>
				<comm cntt="end else"/>
				<param name="o"/>
			</mth>
			<mth name="/plugins/Java/BackStab.java:default.BackStab.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/Beautifier.java:default">
		<class name="/plugins/Java/Beautifier.java:default.Beautifier" intfc="n" abs="n" inn="n" sloc="61" jdoc="">
			<field name="prefLineLength" access="priv" jdoc=""/>
			<mth name="/plugins/Java/Beautifier.java:default.Beautifier.Beautifier()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Beautifier.java:default.Beautifier.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/BeautifierOptions.java:default">
		<class name="/plugins/Java/BeautifierOptions.java:default.BeautifierOptions" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<field name="breakBracket" access="priv" jdoc=""/>
			<field name="indentSwitch" access="priv" jdoc=""/>
			<field name="prefLineLength" access="priv" jdoc=""/>
			<field name="settingsInfo" access="priv" jdoc=""/>
			<mth name="/plugins/Java/BeautifierOptions.java:default.BeautifierOptions.BeautifierOptions()" access="pub" jdoc="">
				<comm cntt="new Color(205, 205, 205));"/>
			</mth>
			<mth name="/plugins/Java/BeautifierOptions.java:default.BeautifierOptions.save()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/BrowserLauncher.java:default">
		<class name="/plugins/Java/BrowserLauncher.java:default.BrowserLauncher" intfc="n" abs="n" inn="n" sloc="364" jdoc="BrowserLauncher is a class that provides one static method, openURL, which opens the default web browser for the current user of the system to the given URL. It may support other protocols depending on the system -- mailto, ftp, etc. -- but that has not been rigorously tested and is not guaranteed to work. &amp;lt;p&amp;gt; Yes, this is platform-specific code, and yes, it may rely on classes on certain platforms that are not part of the standard JDK. What we&amp;apos;re trying to do, though, is to take something that&amp;apos;s frequently desirable but inherently platform-specific -- opening a default browser -- and allow programmers (you, for example) to do so without worrying about dropping into native code or doing anything else similarly evil. &amp;lt;p&amp;gt; Anyway, this code is completely in Java and will run on all JDK 1.1-compliant systems without modification or a need for additional libraries. All classes that are required on certain platforms to allow this to run are dynamically loaded at runtime via reflection and, if not found, will not cause this to do anything other than returning an error when opening the browser. &amp;lt;p&amp;gt; There are certain system requirements for this class, as it&amp;apos;s running through Runtime.exec(), which is Java&amp;apos;s way of making a native system call. Currently, this requires that a Macintosh have a Finder which supports the GURL event, which is true for Mac OS 8.0 and 8.1 systems that have the Internet Scripting AppleScript dictionary installed in the Scripting Additions folder in the Extensions folder (which is installed by default as far as I know under Mac OS 8.0 and 8.1), and for all Mac OS 8.5 and later systems. On Windows, it only runs under Win32 systems (Windows 95, 98, and NT 4.0, as well as later versions of all). On other systems, this drops back from the inherently platform-sensitive concept of a default browser and simply attempts to launch Netscape via a shell command. &amp;lt;p&amp;gt; This code is Copyright 1999-2001 by Eric Albert (ejalbert@cs.stanford.edu) and may be redistributed or modified in any form without restrictions as long as the portion of this comment from this paragraph through the end of the comment is not removed. The author requests that he be notified of any application, applet, or other binary that makes use of this code, but that&amp;apos;s more out of curiosity than anything and is not required. This software includes no warranty. The author is not repsonsible for any loss of data or functionality or any adverse or unexpected effects of using this software. &amp;lt;p&amp;gt; Credits: &amp;lt;br&amp;gt;Steven Spencer, JavaWorld magazine (&amp;lt;a href=&amp;quot;http: www.javaworld.com javaworld javatips jw-javatip66.html&amp;quot;&amp;gt;Java Tip 66&amp;lt; a&amp;gt;) &amp;lt;br&amp;gt;Thanks also to Ron B. Yeh, Eric Shapiro, Ben Engber, Paul Teitlebaum, Andrea Cantatore, Larry Barowski, Trevor Bedzek, Frank Miedrich, and Ron Rabakukk @author Eric Albert (&amp;lt;a href=&amp;quot;mailto:ejalbert@cs.stanford.edu&amp;quot;&amp;gt;ejalbert@cs.stanford.edu&amp;lt; a&amp;gt;) @version 1.4b1 (Released June 20, 2001)">
			<comm cntt="Assume that all 2.x versions of MRJ work the same. MRJ 2.1 actually"/>
			<comm cntt="works via Runtime.exec() and 2.2 supports that but has an openURL() method"/>
			<comm cntt="as well that we currently ignore."/>
			<comm cntt="Assume that all 3.1 and later versions of MRJ work the same."/>
			<comm cntt="if we haven&amp;apos;t hit any errors yet"/>
			<field name="jvm" access="priv" jdoc="The Java virtual machine that we are running on. Actually, in most cases we only care about the operating system, but some operating systems require us to switch on the VM."/>
			<field name="browser" access="priv" jdoc="The browser for the system"/>
			<field name="loadedWithoutErrors" access="priv" jdoc="Caches whether any classes, methods, and fields that are not part of the JDK and need to be dynamically loaded at runtime loaded successfully. &amp;lt;p&amp;gt; Note that if this is &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt;, &amp;lt;code&amp;gt;openURL()&amp;lt; code&amp;gt; will always return an IOException."/>
			<field name="mrjFileUtilsClass" access="priv" jdoc="The com.apple.mrj.MRJFileUtils class"/>
			<field name="mrjOSTypeClass" access="priv" jdoc="The com.apple.mrj.MRJOSType class"/>
			<field name="aeDescClass" access="priv" jdoc="The com.apple.MacOS.AEDesc class"/>
			<field name="aeTargetConstructor" access="priv" jdoc="The &amp;lt;init&amp;gt;(int) method of com.apple.MacOS.AETarget"/>
			<field name="appleEventConstructor" access="priv" jdoc="The &amp;lt;init&amp;gt;(int, int, int) method of com.apple.MacOS.AppleEvent"/>
			<field name="aeDescConstructor" access="priv" jdoc="The &amp;lt;init&amp;gt;(String) method of com.apple.MacOS.AEDesc"/>
			<field name="findFolder" access="priv" jdoc="The findFolder method of com.apple.mrj.MRJFileUtils"/>
			<field name="getFileCreator" access="priv" jdoc="The getFileCreator method of com.apple.mrj.MRJFileUtils"/>
			<field name="getFileType" access="priv" jdoc="The getFileType method of com.apple.mrj.MRJFileUtils"/>
			<field name="openURL" access="priv" jdoc="The openURL method of com.apple.mrj.MRJFileUtils"/>
			<field name="makeOSType" access="priv" jdoc="The makeOSType method of com.apple.MacOS.OSUtils"/>
			<field name="putParameter" access="priv" jdoc="The putParameter method of com.apple.MacOS.AppleEvent"/>
			<field name="sendNoReply" access="priv" jdoc="The sendNoReply method of com.apple.MacOS.AppleEvent"/>
			<field name="kSystemFolderType" access="priv" jdoc="Actually an MRJOSType pointing to the System Folder on a Macintosh"/>
			<field name="keyDirectObject" access="priv" jdoc="The keyDirectObject AppleEvent parameter type"/>
			<field name="kAutoGenerateReturnID" access="priv" jdoc="The kAutoGenerateReturnID AppleEvent code"/>
			<field name="kAnyTransactionID" access="priv" jdoc="The kAnyTransactionID AppleEvent code"/>
			<field name="linkage" access="priv" jdoc="The linkage object required for JDirect 3 on Mac OS X."/>
			<const name="JDirect_MacOSX" access="priv" jdoc="The framework to reference on Mac OS X"/>
			<const name="MRJ_2_0" access="priv" jdoc="JVM constant for MRJ 2.0"/>
			<const name="MRJ_2_1" access="priv" jdoc="JVM constant for MRJ 2.1 or later"/>
			<const name="MRJ_3_0" access="priv" jdoc="JVM constant for Java on Mac OS X 10.0 (MRJ 3.0)"/>
			<const name="MRJ_3_1" access="priv" jdoc="JVM constant for MRJ 3.1"/>
			<const name="WINDOWS_NT" access="priv" jdoc="JVM constant for any Windows NT JVM"/>
			<const name="WINDOWS_9x" access="priv" jdoc="JVM constant for any Windows 9x JVM"/>
			<const name="OTHER" access="priv" jdoc="JVM constant for any other platform"/>
			<const name="FINDER_TYPE" access="priv" jdoc="The file type of the Finder on a Macintosh. Hardcoding &amp;quot;Finder&amp;quot; would keep non-U.S. English systems from working properly."/>
			<const name="FINDER_CREATOR" access="priv" jdoc="The creator code of the Finder on a Macintosh, which is needed to send AppleEvents to the application."/>
			<const name="GURL_EVENT" access="priv" jdoc="The name for the AppleEvent type corresponding to a GetURL event."/>
			<const name="FIRST_WINDOWS_PARAMETER" access="priv" jdoc="The first parameter that needs to be passed into Runtime.exec() to open the default web browser on Windows."/>
			<const name="SECOND_WINDOWS_PARAMETER" access="priv" jdoc="The second parameter for Runtime.exec() on Windows."/>
			<const name="THIRD_WINDOWS_PARAMETER" access="priv" jdoc="The third parameter for Runtime.exec() on Windows. This is a &amp;quot;title&amp;quot; parameter that the command line expects. Setting this parameter allows URLs containing spaces to work."/>
			<const name="NETSCAPE_REMOTE_PARAMETER" access="priv" jdoc="The shell parameters for Netscape that opens a given URL in an already-open copy of Netscape on many command-line systems."/>
			<const name="NETSCAPE_OPEN_PARAMETER_START" access="priv" jdoc=""/>
			<const name="NETSCAPE_OPEN_PARAMETER_END" access="priv" jdoc=""/>
			<field name="errorMessage" access="priv" jdoc="The message from any exception thrown throughout the initialization process."/>
			<mth name="/plugins/Java/BrowserLauncher.java:default.BrowserLauncher.BrowserLauncher()" access="priv" jdoc="This class should be never be instantiated; this just ensures so.">
			</mth>
			<mth name="/plugins/Java/BrowserLauncher.java:default.BrowserLauncher.loadClasses()" access="priv" jdoc="Called by a static initializer to load any classes, fields, and methods required at runtime to locate the user&amp;apos;s web browser. @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if all intialization succeeded &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; if any portion of the initialization failed">
			</mth>
			<mth name="/plugins/Java/BrowserLauncher.java:default.BrowserLauncher.locateBrowser()" access="priv" jdoc="Attempts to locate the default web browser on the local system. Caches results so it only locates the browser once for each use of this class per JVM instance. @return The browser for the system. Note that this may not be what you would consider to be a standard web browser; instead, it&amp;apos;s the application that gets called to open the default web browser. In some cases, this will be a non-String object that provides the means of calling the default browser.">
				<comm cntt="Don&amp;apos;t set browser = appleEvent because then the next time we call"/>
				<comm cntt="locateBrowser(), we&amp;apos;ll get the same AppleEvent, to which we&amp;apos;ll already have"/>
				<comm cntt="added the relevant parameter. Instead, regenerate the AppleEvent every time."/>
				<comm cntt="There&amp;apos;s probably a way to do this better; if any has any ideas, please let"/>
				<comm cntt="me know."/>
				<comm cntt="Avoid a FilenameFilter because that can&amp;apos;t be stopped mid-list"/>
				<comm cntt="We&amp;apos;re looking for a file with a creator code of &amp;apos;MACS&amp;apos; and"/>
				<comm cntt="a type of &amp;apos;FNDR&amp;apos;. Only requiring the type results in non-Finder"/>
				<comm cntt="applications being picked up on certain Mac OS 9 systems,"/>
				<comm cntt="especially German ones, and sending a GURL event to those"/>
				<comm cntt="applications results in a logout under Multiple Users."/>
				<comm cntt="Actually the Finder, but that&amp;apos;s OK"/>
				<comm cntt="Return something non-null"/>
			</mth>
			<mth name="/plugins/Java/BrowserLauncher.java:default.BrowserLauncher.openURL(String)" access="pub" jdoc="Attempts to open the default web browser to the given URL. @param url The URL to open @throws IOException If the web browser could not be located or does not run">
				<comm cntt="Encourage it to get disposed if it was created"/>
				<comm cntt="Ditto"/>
				<comm cntt="Ignore the return value; the URL was launched successfully"/>
				<comm cntt="regardless of what happens here."/>
				<comm cntt="Add quotes around the URL to allow ampersands and other special"/>
				<comm cntt="characters to work."/>
				<comm cntt="This avoids a memory leak on some versions of Java on Windows."/>
				<comm cntt="That&amp;apos;s hinted at in &amp;lt;http: developer.java.sun.com developer qow archive 68 &amp;gt;."/>
				<comm cntt="Assume that we&amp;apos;re on Unix and that Netscape is installed"/>
				<comm cntt="First, attempt to open the URL in a currently running session of Netscape"/>
				<comm cntt="if Netscape was not open"/>
				<comm cntt="This should never occur, but if it does, we&amp;apos;ll try the simplest thing possible"/>
				<param name="url"/>
			</mth>
			<mth name="/plugins/Java/BrowserLauncher.java:default.BrowserLauncher.ICStart(int[], int)" access="priv" jdoc="Methods required for Mac OS X. The presence of native methods does not cause any problems on other platforms.">
				<param name="instance"/>
				<param name="signature"/>
			</mth>
			<mth name="/plugins/Java/BrowserLauncher.java:default.BrowserLauncher.ICStop(int[])" access="priv" jdoc="">
				<param name="instance"/>
			</mth>
			<mth name="/plugins/Java/BrowserLauncher.java:default.BrowserLauncher.ICLaunchURL(int, byte[], byte[], int, int[], int[])" access="priv" jdoc="">
				<param name="instance"/>
				<param name="hint"/>
				<param name="data"/>
				<param name="len"/>
				<param name="selectionStart"/>
				<param name="selectionEnd"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/ClassBrowser.java:default">
		<class name="/plugins/Java/ClassBrowser.java:default.ClassBrowser" intfc="n" abs="n" inn="n" sloc="349" jdoc="A simple class browser for the BeanShell desktop.">
			<comm cntt="fully qualified classname"/>
			<field name="frame" access="pub" jdoc=""/>
			<field name="apiButton" access="pub" jdoc=""/>
			<field name="iframe" access="pub" jdoc=""/>
			<field name="packages" access="pub" jdoc=""/>
			<field name="plist" access="pub" jdoc=""/>
			<field name="classlist" access="pub" jdoc=""/>
			<field name="mlist" access="pub" jdoc=""/>
			<field name="conslist" access="pub" jdoc=""/>
			<field name="selectedPackage" access="pub" jdoc=""/>
			<field name="selectedClass" access="pub" jdoc=""/>
			<field name="methodLine" access="pub" jdoc=""/>
			<field name="packagesList" access="pub" jdoc=""/>
			<field name="classesList" access="pub" jdoc=""/>
			<field name="methodList" access="pub" jdoc=""/>
			<field name="consList" access="pub" jdoc=""/>
			<field name="tree" access="pub" jdoc=""/>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.ClassBrowser()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.split(String, String)" access="pub" jdoc="">
				<param name="s"/>
				<param name="delim"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.splitClassname(String)" access="pub" jdoc="">
				<comm cntt="top level class"/>
				<param name="classname"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.addClass(String)" access="pub" jdoc="">
				<param name="classname"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.addJar(String)" access="pub" jdoc="">
				<comm cntt="Vector v=new Vector();"/>
				<comm cntt="v.addElement(name);"/>
				<param name="jarname"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.sortMethods(Method[])" access="pub" jdoc="Convenient wrapper for QuickSort of an array of Method objects @param methods the Method array to be sorted">
				<param name="methods"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.sortMethods(Method, int, int)" access="pub" jdoc="QuickSort an array of Strings. @param a Methods to be sorted @param lo0 Lower bound @param hi0 Higher bound">
				<param name="a"/>
				<param name="lo0"/>
				<param name="hi0"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.swap(Method, int, int)" access="pub" jdoc="Swaps two Method objects. @param a The array to be swapped @param i First Method index @param j Second Method index">
				<param name="a"/>
				<param name="i"/>
				<param name="j"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.toSortedList(Vector)" access="pub" jdoc="">
				<param name="v"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.setClist(String)" access="pub" jdoc="">
				<comm cntt="setMlist( (String)classlist.getModel().getElementAt(0) );"/>
				<param name="packagename"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.parseMethods(Method[])" access="pub" jdoc="">
				<param name="methods"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.getPublicMethods(Method[])" access="pub" jdoc="">
				<param name="methods"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.setMlist(String)" access="pub" jdoc="">
				<param name="classname"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.setConslist(Class)" access="pub" jdoc="">
				<param name="clas"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.setMethodLine(Object)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.setTree(Class)" access="pub" jdoc="">
				<param name="clas"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.labeledPane(JComponent, String)" access="pub" jdoc="">
				<param name="comp"/>
				<param name="label"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.init()" access="pub" jdoc="">
				<comm cntt="do we have the core classes?"/>
				<comm cntt="try some standard locations"/>
				<comm cntt="give it a preferred height"/>
				<comm cntt="bottompanel.setPreferredSize(new java.awt.Dimension(150, 150));"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.main(String[])" access="pub" jdoc="">
				<comm cntt="warning...Jext.getProperties doesn&amp;apos;t work when running w this driver"/>
				<comm cntt="f.pack();"/>
				<param name="args"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.setFrame(JFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.setFrame(JInternalFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.valueChanged(TreeSelectionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.valueChanged(ListSelectionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.driveToClass(String)" access="pub" jdoc="">
				<param name="classname"/>
			</mth>
			<mth name="/plugins/Java/ClassBrowser.java:default.ClassBrowser.toFront()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/ClassBrowserGUI.java:default">
		<class name="/plugins/Java/ClassBrowserGUI.java:default.ClassBrowserGUI" intfc="n" abs="n" inn="n" sloc="20" jdoc="">
			<mth name="/plugins/Java/ClassBrowserGUI.java:default.ClassBrowserGUI.ClassBrowserGUI()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/ClassBrowserGUI.java:default.ClassBrowserGUI.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/ClassBrowserOptions.java:default">
		<class name="/plugins/Java/ClassBrowserOptions.java:default.ClassBrowserOptions" intfc="n" abs="n" inn="n" sloc="14" jdoc="">
			<field name="defaultDocURL" access="priv" jdoc=""/>
			<mth name="/plugins/Java/ClassBrowserOptions.java:default.ClassBrowserOptions.ClassBrowserOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/ClassBrowserOptions.java:default.ClassBrowserOptions.save()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/InsertClassName.java:default">
		<class name="/plugins/Java/InsertClassName.java:default.InsertClassName" intfc="n" abs="n" inn="n" sloc="154" jdoc="InsertClassName inserts the name of the current class into a java source file.">
			<field name="root" access="pub" jdoc=""/>
			<field name="view" access="pub" jdoc=""/>
			<field name="ls" access="pub" jdoc=""/>
			<field name="parser" access="pub" jdoc=""/>
			<field name="fileName" access="pub" jdoc=""/>
			<field name="textArea" access="pub" jdoc=""/>
			<mth name="/plugins/Java/InsertClassName.java:default.InsertClassName.InsertClassName()" access="pub" jdoc="default constructor">
			</mth>
			<mth name="/plugins/Java/InsertClassName.java:default.InsertClassName.actionPerformed(ActionEvent)" access="pub" jdoc="Performs the InsertClassName action. @param evt the &amp;lt;CODE&amp;gt;ActionEvent&amp;lt; CODE&amp;gt; that kicks off this shindig.">
				<comm cntt="end try"/>
				<comm cntt="end catch"/>
				<comm cntt="I make no pretense--the next several lines were ripped directly from various"/>
				<comm cntt="portions of the JBrowse plugin so if you want comments look there!"/>
				<comm cntt="end if parser uses JavaTokenMarker"/>
				<comm cntt="end else"/>
				<comm cntt="end if no classes or interfaces were found."/>
				<comm cntt="end if"/>
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Java/InsertClassName.java:default.InsertClassName.getClassName()" access="pub" jdoc="Returns the class name! @return the class name.">
				<comm cntt="sort by line number"/>
				<comm cntt="loop through found classes backward..."/>
				<comm cntt="finding opening brace of class def so can find closing brace"/>
				<comm cntt="end if endComment &amp;gt;= beginComment"/>
				<comm cntt="end while not found opening brace"/>
				<comm cntt="end try to assign endPos to ending brace"/>
				<comm cntt="end catch"/>
				<comm cntt="try to expand area if possible..."/>
				<comm cntt="end if opening brace is first in the document"/>
				<comm cntt="end if closing brace is the last in the document"/>
				<comm cntt="end if endEndLine &amp;gt; next line comment"/>
				<comm cntt="end if endPos &amp;lt; text.length()"/>
				<comm cntt="end if lastJavadoc &amp;gt; last closing brace"/>
				<comm cntt="end if startPos &amp;gt; 0"/>
				<comm cntt="end if startPos &amp;lt;= caretPos &amp;lt;= endPos"/>
				<comm cntt="end for i..."/>
			</mth>
			<mth name="/plugins/Java/InsertClassName.java:default.InsertClassName.getClassArray()" access="priv" jdoc="">
				<comm cntt="end if bs is a class or an interface"/>
				<comm cntt="end if"/>
				<comm cntt="end while treeEnum has more elements"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/JBrowse.java:default">
		<class name="/plugins/Java/JBrowse.java:default.JBrowse" intfc="n" abs="n" inn="n" sloc="174" jdoc="The class that defines the non-modal dialog window that provides the gui for the JBrowse plugin. @author George Latkiewicz @version 1.0.1 - Nov. 16, 1999">
			<comm cntt="JFrame"/>
			<comm cntt="public class attributes"/>
			<comm cntt="public instance attributes"/>
			<comm cntt="private instance attributes"/>
			<comm cntt="passed by activator"/>
			<comm cntt="passed by activator"/>
			<comm cntt="passed by activator"/>
			<comm cntt="passed by activator"/>
			<comm cntt="set on JBrowse.TreePane.init(),"/>
			<comm cntt="set on JBrowse.TreePane.init()"/>
			<comm cntt="status bar"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="JBrowse(JBrowse.Activator): &amp;lt;init&amp;gt;"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="actionPerformed(ActionEvent): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="setPreferredSize(): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="showResults(JBrowseParser.Results): void"/>
			<comm cntt="========================================================================="/>
			<comm cntt="public class JBrowse.TreePane extends JPanel"/>
			<comm cntt="========================================================================="/>
			<comm cntt="public static interface JBrowse.Activator"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="========================================================================="/>
			<comm cntt="static class JBrowse.OptionDialog"/>
			<const name="VER_NUM" access="pub" jdoc=""/>
			<field name="results" access="pub" jdoc=""/>
			<field name="frame" access="priv" jdoc=""/>
			<field name="props" access="priv" jdoc=""/>
			<field name="parser" access="priv" jdoc=""/>
			<field name="umlTree" access="priv" jdoc=""/>
			<field name="fileName" access="priv" jdoc=""/>
			<field name="treeModel" access="priv" jdoc=""/>
			<field name="root" access="priv" jdoc=""/>
			<field name="parseBtn" access="priv" jdoc=""/>
			<field name="resizeBtn" access="priv" jdoc=""/>
			<field name="configBtn" access="priv" jdoc=""/>
			<field name="statusPanel" access="pub" jdoc=""/>
			<field name="classLabel" access="pub" jdoc=""/>
			<field name="interfaceLabel" access="pub" jdoc=""/>
			<field name="attributeLabel" access="pub" jdoc=""/>
			<field name="methodLabel" access="pub" jdoc=""/>
			<field name="errorLabel" access="pub" jdoc=""/>
			<field name="topPanel" access="pub" jdoc=""/>
			<field name="treePane" access="priv" jdoc=""/>
			<field name="optionDialog" access="priv" jdoc=""/>
			<field name="options" access="priv" jdoc=""/>
			<field name="filterOpt" access="priv" jdoc=""/>
			<field name="displayOpt" access="priv" jdoc=""/>
			<field name="optionListener" access="priv" jdoc=""/>
			<field name="hasJavaFileExtension" access="priv" jdoc=""/>
			<field name="scpTreePane" access="pub" jdoc=""/>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse.JBrowse(JBrowse.Activator)" access="pub" jdoc="This method creates a new instance of JBrowse GUI and Parsing engine. @param">
				<comm cntt="third option of false (i.e. non-modal) is the default for JDialog constructor"/>
				<comm cntt="super(activator.getOwner(), &amp;quot;JBrowse&amp;quot;, false);"/>
				<comm cntt="super(&amp;quot;JBrowse&amp;quot;); for a JFrame"/>
				<comm cntt="i.e. the associated editor view, if present"/>
				<comm cntt="if (frame != null) {"/>
				<comm cntt="Image pluginIcon = org.gjt.sp.jedit.GUIUtilities.getPluginIcon();"/>
				<comm cntt="if (pluginIcon != null) {"/>
				<comm cntt="setIconImage( pluginIcon );"/>
				<comm cntt="}"/>
				<comm cntt="}"/>
				<comm cntt="URL url = getClass().getResource(&amp;quot;StructIcon.gif&amp;quot;);"/>
				<comm cntt="if (url != null) {"/>
				<comm cntt="setIconImage( (new ImageIcon(url)).getImage() );"/>
				<comm cntt="}"/>
				<comm cntt="Add tree pane to center of content pane"/>
				<comm cntt="Connect to the optionPane&amp;apos;s options"/>
				<comm cntt="Configure Parser"/>
				<comm cntt="create the ChangeListener for this JBrowse session, this"/>
				<comm cntt="is the means by which this session is notified of any changes"/>
				<comm cntt="to the current option values."/>
				<comm cntt="Display or hide the status bar"/>
				<comm cntt="Reload the tree (if necessary)"/>
				<comm cntt="there are nodes below the root, therefore need"/>
				<comm cntt="to reload"/>
				<comm cntt="Update the display , if necessary (without reloading)"/>
				<comm cntt="there are nodes below the root, therefore update"/>
				<comm cntt="of the display is necessary"/>
				<comm cntt="treeModel.updateVisibleChildren(root);"/>
				<comm cntt="umlTree.updateVisible(options);"/>
				<comm cntt="stateChanged(ChangeEvent): void"/>
				<comm cntt="Determine size and position of the GUI"/>
				<comm cntt="Dimension screen = getToolkit().getScreenSize(); pack(); setPreferredSize(); setLocation((screen.width - getSize().width) 2, (screen.height - getSize().height) 2); show();"/>
				<param name="activator"/>
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse.parseNow()" access="priv" jdoc="">
				<comm cntt="Set Wait Cursor"/>
				<comm cntt="set model to null to speed up"/>
				<comm cntt="Set Default Cursor"/>
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse.jextEventFired(JextEvent)" access="pub" jdoc="">
				<comm cntt="evt.getWhat() == JextEvent.BATCH_MODE_UNSET ||"/>
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse.getDisplayOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse.getOptionListener()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="check if first time, init as required"/>
				<comm cntt="Determine size and position of the OptionDialog"/>
				<comm cntt="???1.1 for 1.2 replace getLocation().x with getX()"/>
				<comm cntt="i.e. won&amp;apos;t fit at right so..."/>
				<comm cntt="i.e. won&amp;apos;t fit at left either so overlap at right end"/>
				<comm cntt="left of"/>
				<comm cntt="right of"/>
				<comm cntt="Repaint the JBrowse Dialog, required to eliminate"/>
				<comm cntt="any contamination from the OptionDialog (really!)"/>
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse.setPreferredSize()" access="pub" jdoc="">
				<comm cntt="current internal frame"/>
				<comm cntt="Set vertical scrollbar to visible, if it should be"/>
				<comm cntt="Set width to preferred width based on view and scroll bar"/>
				<comm cntt="i.e. 15 = scpTreePane.getVerticalScrollBar().getSize().width;"/>
				<comm cntt="Adjust width for status panel, if visible"/>
				<comm cntt="Adjust width for top panel"/>
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse.showResults(JBrowseParser.Results)" access="pub" jdoc="This method should be called after every parse. It updates the text of the status bar&amp;apos;s labels to the results counts, displays the error indicator (if appropriate) and then calls umlTree.display() to reload the tree.">
				<comm cntt="System.out.println(&amp;quot;showResults for options: &amp;quot; + options);"/>
				<comm cntt="Update Status Bar"/>
				<comm cntt="Update Parse Error Indicator"/>
				<comm cntt="% log(7, this, &amp;quot;DONE. (&amp;quot; + curTokenLine + &amp;quot; lines, &amp;quot;"/>
				<comm cntt="% + tokenCount + &amp;quot; tokens.)\n&amp;quot;"/>
				<comm cntt="% + &amp;quot;\n Classes: &amp;quot; + results.getClassCount"/>
				<comm cntt="% + &amp;quot;\n Interfaces: &amp;quot; + results.getInterfaceCount"/>
				<comm cntt="% + &amp;quot;\n Object Attributes: &amp;quot; + results.getObjAttrCount"/>
				<comm cntt="% + &amp;quot;\nPrimitive Attributes: &amp;quot; + results.getPrimAttrCount"/>
				<comm cntt="% + &amp;quot;\n Methods: &amp;quot; + results.getMethodCount"/>
				<comm cntt="%"/>
				<comm cntt="% + &amp;quot;\n\n Errors: &amp;quot; + results.geterrorCount"/>
				<comm cntt="% + &amp;quot;\n\n Final state was: &amp;quot; + parseState + &amp;quot; &amp;quot; + parseSubState"/>
				<comm cntt="% + &amp;quot;\n Brace Count: &amp;quot; + methodBraceCount"/>
				<comm cntt="% + &amp;quot;\n curElementStartPos: &amp;quot; + curElementStartPos"/>
				<comm cntt="% + &amp;quot;\n memberMod: &amp;quot; + memberMod"/>
				<comm cntt="% + &amp;quot;\n memberType: &amp;quot; + memberType"/>
				<comm cntt="% + &amp;quot;\n memberName: &amp;quot; + memberName );"/>
				<comm cntt="if (results != null) - required until File parser is implemented (???)"/>
				<param name="results"/>
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse.getPropertyAccessor()" access="pub" jdoc="">
			</mth>
		<class name="/plugins/Java/JBrowse.java:default.JBrowse$TreePane" intfc="n" abs="n" inn="y" sloc="100" jdoc="This class defines the JPanel that provides the gui content of the JBrowse dialog (the actual tree display).">
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="TreePane(String): &amp;lt;init&amp;gt;"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="init(): void"/>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$TreePane.TreePane(String)" access="pub" jdoc="Creates a new JBrowse.TreePane. This is called in the in the JBrowse constructor. @param name The internal name">
				<comm cntt="Define and add JButtons for Action Panel"/>
				<comm cntt="Error Indicator"/>
				<comm cntt="errorLabel.setToolTipText();"/>
				<comm cntt="Build Top Panel for BorderLayout"/>
				<param name="title"/>
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$TreePane.init()" access="priv" jdoc="The initialization process for the TreePane, called as the last step of the constructor.">
				<comm cntt="JBrowse.this.getRootPane().setDefaultButton(parseBtn);"/>
				<comm cntt="Status Panel"/>
				<comm cntt="Setup Tree"/>
				<comm cntt="get fileName"/>
				<comm cntt="set root node to file name"/>
				<comm cntt="if (!fileName.toUpperCase().endsWith(&amp;quot;.JAVA&amp;quot;) ) {"/>
				<comm cntt="N.B. some JDK&amp;apos;s (1.1.x) will not compile += for a reference"/>
				<comm cntt="to a private member of an enclosing class."/>
				<comm cntt="get tree model and tree"/>
				<comm cntt="setDefaultCloseOperation(DISPOSE_ON_CLOSE);"/>
			</mth>
		</class>
		<class name="/plugins/Java/JBrowse.java:default.JBrowse$Activator" intfc="y" abs="n" inn="y" sloc="7" jdoc="">
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$Activator.getOwner()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$Activator.getPropertyAccessor()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$Activator.getJBrowseParser()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$Activator.getUMLTree()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/Java/JBrowse.java:default.JBrowse$OptionDialog" intfc="n" abs="n" inn="y" sloc="59" jdoc="">
			<comm cntt="private members"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="OptionDialog(JBrowse, String): &amp;lt;init&amp;gt;"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="--------------------------------------------------------------------"/>
			<comm cntt="reInit(): void"/>
			<comm cntt="--------------------------------------------------------------------"/>
			<comm cntt="actionPerformed(ActionEvent): void"/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="optionPane" access="pub" jdoc=""/>
			<field name="btnSetAsDefaults" access="priv" jdoc=""/>
			<field name="btnRestoreDefaults" access="priv" jdoc=""/>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$OptionDialog.OptionDialog(Frame, JBrowse, String)" access="pub" jdoc="">
				<comm cntt="parent.addWindowListener(new WindowAdapter() { public void windowClosed(WindowEvent e) { dispose(); } } );"/>
				<comm cntt="addKeyListener(this);"/>
				<comm cntt="addWindowListener(this);"/>
				<param name="jparent"/>
				<param name="parent"/>
				<param name="title"/>
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$OptionDialog.getOptions()" access="pub" jdoc="Returns the option object associated with this OptionDialog&amp;apos;s JBrowseOptionPane.">
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$OptionDialog.setOptions()" access="pub" jdoc="Sets the state of the option object associated with this JBrowse session&amp;apos;s JBrowseOptionPane to that pane&amp;apos;s current state as specified by its GUI.">
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$OptionDialog.reInit()" access="pub" jdoc="">
				<comm cntt="set optionPane GUI state to the inital model (as defined in properties)"/>
				<comm cntt="Synchronize Options object and JBrowseOptionPane to property values."/>
			</mth>
			<mth name="/plugins/Java/JBrowse.java:default.JBrowse$OptionDialog.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="Display or hide the status bar"/>
				<param name="evt"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/Java/JBrowseLineParser.java:default">
		<class name="/plugins/Java/JBrowseLineParser.java:default.JBrowseLineParser" intfc="n" abs="n" inn="n" sloc="923" jdoc="The class that implemnts a JBrowseParser for Java Source Code via a JBrowseParser.LineSource. @author George Latkiewicz @version 1.0.1 - Nov. 16, 1999">
			<comm cntt="public class attributes"/>
			<comm cntt="public instance attributes"/>
			<comm cntt="private instance attributes"/>
			<comm cntt="set on JBrowse.TreePane.init(),"/>
			<comm cntt="set on JBrowse.TreePane.init(),"/>
			<comm cntt="Parse State"/>
			<comm cntt="Counters"/>
			<comm cntt="only count tokens returned by TokenSource"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="JBrowseLineParser(View): &amp;lt;init&amp;gt;"/>
			<comm cntt="isReady(): boolean"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="parse(): JBrowseParser.Results"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="insertAsNode(UML.Element, int, UMLTree.Node, int): UMLTree.Node"/>
			<const name="VER_NUM" access="pub" jdoc=""/>
			<field name="results" access="pub" jdoc=""/>
			<field name="ls" access="priv" jdoc=""/>
			<field name="fileName" access="priv" jdoc=""/>
			<field name="expectedTopLevelName" access="priv" jdoc=""/>
			<field name="nodeStack" access="pub" jdoc=""/>
			<field name="root" access="priv" jdoc=""/>
			<field name="options" access="priv" jdoc=""/>
			<field name="filterOpt" access="priv" jdoc=""/>
			<field name="displayOpt" access="priv" jdoc=""/>
			<field name="parseState" access="pub" jdoc=""/>
			<field name="parseSubState" access="pub" jdoc=""/>
			<field name="tokenCount" access="pub" jdoc=""/>
			<field name="curTokenLine" access="pub" jdoc=""/>
			<field name="curTokenPos" access="pub" jdoc=""/>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.JBrowseLineParser.JBrowseLineParser(JBrowseParser.LineSource)" access="pub" jdoc="This method creates a new instance of JBrowse GUI and Parsing engine. @param ls JBrowseParser.LineSource that will provide the source to be parsed.">
				<param name="ls"/>
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.JBrowseLineParser.getSourceName()" access="pub" jdoc="Returns the String that represents the name associated with the current JBrowseParser.LineSource (e.g. the fileName associated with the current buffer), or null if the JBrowseParser.LineSource is not currently associated with a source.">
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.JBrowseLineParser.usesJavaTokenMarker()" access="pub" jdoc="Returns &amp;lt;CODE&amp;gt;true&amp;lt; CODE&amp;gt; if the &amp;lt;CODE&amp;gt;JEditTextArea&amp;lt; CODE&amp;gt; to which this &amp;lt;CODE&amp;gt;JBrowseLineParser&amp;lt; CODE&amp;gt; is tied uses a &amp;lt;CODE&amp;gt;JavaTokenMarker&amp;lt; CODE&amp;gt;.">
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.JBrowseLineParser.setOptions(Options)" access="pub" jdoc="">
				<param name="options"/>
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.JBrowseLineParser.setRootNode(UMLTree.Node)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.JBrowseLineParser.isReady()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.JBrowseLineParser.parse()" access="pub" jdoc="The method that preforms the actual parsing. This is the method which builds the tree model that reflects the heirarchical structure of the Java code in the current LineSource.">
				<comm cntt="reset result counters to 0"/>
				<comm cntt="reset the LineSource to the beginning of the buffer"/>
				<comm cntt="Set initial Parse State"/>
				<comm cntt="Set initial counts"/>
				<comm cntt="only count tokens returned by TokenSource"/>
				<comm cntt="Parsing Attributes"/>
				<comm cntt="Get fileName and TokenSource"/>
				<comm cntt="TokenSource ts = new TokenSource(ls, JBrowse.debugLevel );"/>
				<comm cntt="parsing attributes"/>
				<comm cntt="method return type or attribute type"/>
				<comm cntt="set when extends keyword found"/>
				<comm cntt="set when implements keyword found"/>
				<comm cntt="set when extends class interface name found (but no comma)"/>
				<comm cntt="set when implements interface name found (but no comma)"/>
				<comm cntt="set when throws keyword found"/>
				<comm cntt="set when throws class interface name found (but no comma)"/>
				<comm cntt="may be necessary if we end in a comment"/>
				<comm cntt="-----------------------"/>
				<comm cntt="HEADER - &amp;lt;any substate&amp;gt;"/>
				<comm cntt="-----------------------"/>
				<comm cntt="fall into ParseState.POST_HEADER processing"/>
				<comm cntt="i.e. log only if not already logged for this line."/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="suppress repeats"/>
				<comm cntt="fall into ParseState.POST_HEADER processing"/>
				<comm cntt="i.e. log only if not already logged for this line."/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="suppress repeats"/>
				<comm cntt="if - else if for HEADER - &amp;lt;any substate&amp;gt;"/>
				<comm cntt="if (ParseState == ParseState.HEADER)"/>
				<comm cntt="----------------------------"/>
				<comm cntt="POST_HEADER - &amp;lt;any substate&amp;gt;"/>
				<comm cntt="----------------------------"/>
				<comm cntt="these tokens should put me in a class interface and lead me to its body"/>
				<comm cntt="} else if (token.equals(&amp;quot;native&amp;quot;) ) { n a for class interface"/>
				<comm cntt="mod = RWModifier.setNative(mod);"/>
				<comm cntt="} else if (token.equals(&amp;quot;private&amp;quot;) ) { n a for class interface"/>
				<comm cntt="mod = RWModifier.setPrivate(mod);"/>
				<comm cntt="} else if (token.equals(&amp;quot;protected&amp;quot;) ) { n a for class interface"/>
				<comm cntt="mod = RWModifier.setProtected(mod);"/>
				<comm cntt="} else if (token.equals(&amp;quot;static&amp;quot;) ) { n a for class interface"/>
				<comm cntt="mod = RWModifier.setStatic(mod);"/>
				<comm cntt="n a for class interface"/>
				<comm cntt="} else if (token.equals(&amp;quot;transient&amp;quot;) ) { n a for class interface"/>
				<comm cntt="mod = RWModifier.setTransient(mod);"/>
				<comm cntt="} else if (token.equals(&amp;quot;volatile&amp;quot;) ) { n a for class interface"/>
				<comm cntt="mod = RWModifier.setVolatile(mod);"/>
				<comm cntt="identifier found (not modifier)"/>
				<comm cntt="where &amp;quot;class&amp;quot; &amp;quot;interface&amp;quot; not yet specified"/>
				<comm cntt="if (className == null)"/>
				<comm cntt="non-identifier token where name not yet found"/>
				<comm cntt="non-identifier token where name not yet found"/>
				<comm cntt="i.e. isJavaIdentifierStart()"/>
				<comm cntt="Determine node type and insert"/>
				<comm cntt="Create and insert class interface node"/>
				<comm cntt="Check if TopLevel is OK"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="assume first public found is the intended anyway"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="Check if TopLevel is OK"/>
				<comm cntt="Setup for next state, if required"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="entering package member body"/>
				<comm cntt="if (className != null)"/>
				<comm cntt="i.e. log only if not already logged for this line."/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="suppress repeats"/>
				<comm cntt="if - else if for POST_HEADER - SCANNING"/>
				<comm cntt="----------------------------"/>
				<comm cntt="PACKAGE MEMBER - POST_NAME"/>
				<comm cntt="----------------------------"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue by falling into body"/>
				<comm cntt="entering package member body"/>
				<comm cntt="implements extends what indentifier"/>
				<comm cntt="expect more implements interfaces"/>
				<comm cntt="phrase before &amp;apos;,&amp;apos; not OK"/>
				<comm cntt="unexpected token"/>
				<comm cntt="if-else if by token"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue by skipping to beginning of body"/>
				<comm cntt="Determine node type and insert"/>
				<comm cntt="Create and insert class interface node"/>
				<comm cntt="entering package member body"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="skip and continue scanning"/>
				<comm cntt="if (badFlag)"/>
				<comm cntt="end of code block for PACKAGE MEMBER - POST_NAME"/>
				<comm cntt="------------------------------"/>
				<comm cntt="PACKAGE_MEMBER - BODY"/>
				<comm cntt="------------------------------"/>
				<comm cntt="n.b. cannot re-set the others here, may be a list of attributes."/>
				<comm cntt="these tokens should put me in a method and lead me to its parms"/>
				<comm cntt="attribute only"/>
				<comm cntt="attribute only"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue by skipping to &amp;quot;;&amp;quot;"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="Skip and continue"/>
				<comm cntt="if (memberType == null) else if..."/>
				<comm cntt="assume empty statement"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue"/>
				<comm cntt="assume this is an attribute"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue as if name was specified"/>
				<comm cntt="Create and Insert Attribute Node"/>
				<comm cntt="more should follow"/>
				<comm cntt="more may follow, so skip until &amp;quot;;&amp;quot; or &amp;quot;,&amp;quot;"/>
				<comm cntt="more should follow, so maintain type but clear name"/>
				<comm cntt="&amp;quot;;&amp;quot; assume found so fall into prepare for next element"/>
				<comm cntt="prepare for next element"/>
				<comm cntt="end of else if for attributes"/>
				<comm cntt="attribute"/>
				<comm cntt="attribute or method"/>
				<comm cntt="unexpected"/>
				<comm cntt="unexpected token"/>
				<comm cntt="handle constructors"/>
				<comm cntt="the expected value for constructors"/>
				<comm cntt="Check if constructor is appropriate"/>
				<comm cntt="Report missing name or misspelled constructor"/>
				<comm cntt="the expected value for constructors"/>
				<comm cntt="Operation Node"/>
				<comm cntt="Create Operation Node"/>
				<comm cntt="Insert Operation Node"/>
				<comm cntt="Interface methods can&amp;apos;t be native static synchronized final private protected"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="Abstract methods can&amp;apos;t be native static synchronized final private"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="Setup for next state"/>
				<comm cntt="if there are any parameters signal that next token is start of first"/>
				<comm cntt="if ( !resetFlag )"/>
				<comm cntt="static block or object block"/>
				<comm cntt="pop parent from stack"/>
				<comm cntt="nodeStack.pop();"/>
				<comm cntt="Unexpected token"/>
				<comm cntt="if - else if for PACKAGE_MEMBER - BODY"/>
				<comm cntt="Unexpected token"/>
				<comm cntt="increment count"/>
				<comm cntt="attempt to continue by ignoring"/>
				<comm cntt="Create error node as daughter of parent"/>
				<comm cntt="Create error node as sister of parent"/>
				<comm cntt="if (badFlag) for PACKAGE_MEMBER - BODY"/>
				<comm cntt="------------------------------"/>
				<comm cntt="PACKAGE_MEMBER - OP_PARMS"/>
				<comm cntt="------------------------------"/>
				<comm cntt="Attempt to add the parameter"/>
				<comm cntt="insure parameter identifier not missing"/>
				<comm cntt="Create error node (as sister of parent) and increment count"/>
				<comm cntt="attempt to continue as if an identifier for the parameter was found."/>
				<comm cntt="insure closing &amp;apos;]&amp;apos; not missing"/>
				<comm cntt="create error node (as sister of parent) and increment count"/>
				<comm cntt="attempt to continue as if &amp;quot;]&amp;quot; was found."/>
				<comm cntt="Add the parameter"/>
				<comm cntt="i.e. parmType not specified"/>
				<comm cntt="insure &amp;apos;,&amp;apos; was not superfluous"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue as if superfluous &amp;quot;,&amp;quot; was not there."/>
				<comm cntt="if (! &amp;quot;&amp;quot;.equals(parmType) )"/>
				<comm cntt="Handle for end or more parameters ( &amp;apos;)&amp;apos; vs. &amp;apos;,&amp;apos;)"/>
				<comm cntt="Prepare for next parameter"/>
				<comm cntt="if there are any more args signal that next token is type"/>
				<comm cntt="i.e. token is &amp;quot;)&amp;quot;"/>
				<comm cntt="insure was not preceded by a superfluous &amp;apos;,&amp;apos;"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue as if superfluous &amp;quot;,&amp;quot; was not there."/>
				<comm cntt="( &amp;apos;)&amp;apos; vs. &amp;apos;,&amp;apos;)"/>
				<comm cntt="Assume Parameter type or formal name"/>
				<comm cntt="type"/>
				<comm cntt="create error node and increment count"/>
				<comm cntt="attempt to continue as if &amp;quot;]&amp;quot; was found."/>
				<comm cntt="formal name"/>
				<comm cntt="then check that next token is &amp;quot;]&amp;quot;"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue as if &amp;quot;]&amp;quot; was found."/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue (i.e. ignore)"/>
				<comm cntt="if - else if for PACKAGE_MEMBER - OP_PARMS"/>
				<comm cntt="------------------------------"/>
				<comm cntt="PACKAGE_MEMBER - OP_POST_PARMS"/>
				<comm cntt="------------------------------"/>
				<comm cntt="Parameter list finished, parse throws clause"/>
				<comm cntt="and Determine Next State"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue by falling into body"/>
				<comm cntt="handle method with no body"/>
				<comm cntt="error"/>
				<comm cntt="pop off stack"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="if-else for &amp;quot;}&amp;quot; or &amp;quot;;&amp;quot;"/>
				<comm cntt="expect more throws classes interfaces"/>
				<comm cntt="phrase before &amp;apos;,&amp;apos; not OK"/>
				<comm cntt="implements extends what indentifier"/>
				<comm cntt="unexpected token"/>
				<comm cntt="if-else if by token for PACKAGE_MEMBER - OP_POST_PARMS"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="attempt to continue by skipping to beginning of body"/>
				<comm cntt="entering operation body"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="returning to package member body"/>
				<comm cntt="if (badFlag)"/>
				<comm cntt="end of code block for PACKAGE MEMBER - OP_POST_PARMS"/>
				<comm cntt="------------------------------"/>
				<comm cntt="PACKAGE_MEMBER - OP_BODY"/>
				<comm cntt="------------------------------"/>
				<comm cntt="return to body of this method&amp;apos;s container"/>
				<comm cntt="if - else if for PACKAGE_MEMBER - OP_BODY"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="if...else if by parseState &amp; parseSubState"/>
				<comm cntt="log every token at end of loop!"/>
				<comm cntt="% JBrowse.log(12, this, &amp;quot;(&amp;quot; + tokenCount + &amp;quot;) &amp;quot; + parseState + &amp;quot; &amp;quot;"/>
				<comm cntt="% + parseSubState + &amp;quot; &amp;quot; + curTokenLine + &amp;quot;-&amp;quot; + curTokenPos"/>
				<comm cntt="% + &amp;quot;:&amp;quot; + token);"/>
				<comm cntt="Unterminated multi-line comment, String or char expression"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="% msgStr = &amp;quot;Caught java.util.EmptyStackException: &amp;quot; + e.getMessage();"/>
				<comm cntt="end try-catch"/>
				<comm cntt="Report Final Errors"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="Show only this error"/>
				<comm cntt="Create error node and increment count"/>
				<comm cntt="if no package members found"/>
				<comm cntt="end if alpha sort methods"/>
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.JBrowseLineParser.insertAsNode(UML.Element, int, UMLTree.Node)" access="priv" jdoc="">
				<comm cntt="% JBrowse.log(12, this, &amp;quot;Inserting node: &amp;quot; + e.toString(displayOpt)"/>
				<comm cntt="% + &amp;quot;\n\tParent Node: &amp;quot; + parentNode);"/>
				<comm cntt="Insert Node"/>
				<comm cntt="line below is faster than: treeModel.insertNodeInto(node, parentNode, index);"/>
				<comm cntt="% JBrowse.log(10, this, &amp;quot;Inserted node: &amp;quot; + e.toString(displayOpt) );"/>
				<param name="e"/>
				<param name="pos"/>
				<param name="parentNode"/>
			</mth>
		</class>
		<class name="/plugins/Java/JBrowseLineParser.java:default.ParseState" intfc="n" abs="n" inn="n" sloc="20" jdoc="">
			<comm cntt="use POSSIBLE_VALUES to build an iterator"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<const name="HEADER" access="pub" jdoc=""/>
			<const name="POST_HEADER" access="pub" jdoc=""/>
			<const name="PACKAGE_MEMBER" access="pub" jdoc=""/>
			<const name="POSSIBLE_VALUES" access="pub" jdoc=""/>
			<field name="label" access="prot" jdoc=""/>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.ParseState.ParseState(String)" access="priv" jdoc="">
				<param name="label"/>
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.ParseState.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.ParseState.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/Java/JBrowseLineParser.java:default.ParseSubState" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<comm cntt="HEADER"/>
			<comm cntt="POST_HEADER"/>
			<comm cntt="PACKAGE_MEMBER"/>
			<comm cntt="use POSSIBLE_VALUES to build an iterator"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<const name="PACKAGE" access="pub" jdoc=""/>
			<const name="POST_PACKAGE" access="pub" jdoc=""/>
			<const name="IMPORT" access="pub" jdoc=""/>
			<const name="SCANNING" access="pub" jdoc=""/>
			<const name="POST_NAME" access="pub" jdoc=""/>
			<const name="BODY" access="pub" jdoc=""/>
			<const name="OP_PARMS" access="pub" jdoc=""/>
			<const name="OP_POST_PARMS" access="pub" jdoc=""/>
			<const name="OP_BODY" access="pub" jdoc=""/>
			<const name="POSSIBLE_VALUES" access="pub" jdoc=""/>
			<field name="label" access="prot" jdoc=""/>
			<field name="parentState" access="prot" jdoc=""/>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.ParseSubState.ParseSubState(String, ParseState)" access="priv" jdoc="">
				<param name="label"/>
				<param name="parentState"/>
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.ParseSubState.getParentState()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.ParseSubState.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/plugins/Java/JBrowseLineParser.java:default.ParseSubState.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/JBrowseOptionPane.java:default">
		<class name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane" intfc="n" abs="n" inn="n" sloc="333" jdoc="">
			<comm cntt="protected members"/>
			<comm cntt="protected GridBagLayout gridBag; it is inherited now!"/>
			<comm cntt="protected int y; it is inherited now!"/>
			<comm cntt="private state"/>
			<comm cntt="private gui components"/>
			<comm cntt="general options"/>
			<comm cntt="private JextCheckBox cbxUseFrame;"/>
			<comm cntt="filter options"/>
			<comm cntt="display options"/>
			<comm cntt="Options object"/>
			<comm cntt="Property Accessor"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="public JBrowseOptionPane(): &amp;lt;init&amp;gt;"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="public JBrowseOptionPane(String): &amp;lt;init&amp;gt;"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="actionPerformed(ActionEvent): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="load(): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="initGui(): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="initModel(): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="save(): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="refreshDisplayOptions(int index): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="setOptions(): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="addComponent(Component): void"/>
			<comm cntt="========================================================================="/>
			<comm cntt="static class OptionPanel extends JPanel"/>
			<field name="isInitGui" access="pub" jdoc="The number of components already added to the layout manager."/>
			<field name="isInitModel" access="pub" jdoc=""/>
			<field name="cbxStatusBar" access="priv" jdoc=""/>
			<field name="cbxShowAttributes" access="priv" jdoc=""/>
			<field name="cbxShowPrimitives" access="priv" jdoc=""/>
			<field name="cbxShowGeneralizations" access="priv" jdoc=""/>
			<field name="cbxShowThrows" access="priv" jdoc=""/>
			<field name="cmbTopLevelVis" access="priv" jdoc=""/>
			<field name="cmbMemberVis" access="priv" jdoc=""/>
			<field name="topLevelVisIndex" access="priv" jdoc=""/>
			<field name="memberVisIndex" access="priv" jdoc=""/>
			<field name="cbxShowArguments" access="priv" jdoc=""/>
			<field name="cbxShowArgumentNames" access="priv" jdoc=""/>
			<field name="cbxShowNestedName" access="priv" jdoc=""/>
			<field name="cbxShowIconKeywords" access="priv" jdoc=""/>
			<field name="cbxShowMiscMod" access="priv" jdoc=""/>
			<field name="cbxAlphaSort" access="priv" jdoc=""/>
			<field name="cbxShowLineNum" access="priv" jdoc=""/>
			<field name="cmbStyle" access="priv" jdoc=""/>
			<field name="styleIndex" access="priv" jdoc=""/>
			<field name="cbxVisSymbols" access="priv" jdoc=""/>
			<field name="cbxAbstractItalic" access="priv" jdoc=""/>
			<field name="cbxStaticUlined" access="priv" jdoc=""/>
			<field name="cbxTypeIsSuffixed" access="priv" jdoc=""/>
			<field name="options" access="priv" jdoc=""/>
			<field name="filterOpt" access="priv" jdoc=""/>
			<field name="displayOpt" access="priv" jdoc=""/>
			<field name="props" access="priv" jdoc=""/>
			<field name="batchUpdate" access="priv" jdoc=""/>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.JBrowseOptionPane()" access="pub" jdoc="">
				<comm cntt="super(); setName(&amp;quot;jbrowse&amp;quot;);"/>
				<comm cntt="setup display from property values"/>
				<comm cntt="set GUI to model (as defined in Options object)"/>
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.JBrowseOptionPane(String)" access="pub" jdoc="">
				<comm cntt="It is the instantiating code&amp;apos;s responsibility to call:"/>
				<comm cntt="initGui(), initModel(), and setOptions() before displaying"/>
				<param name="title"/>
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.getPropertyAccessor()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.setPropertyAccessor(PropertyAccessor)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.isInitGui()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.isInitModel()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.actionPerformed(ActionEvent)" access="pub" jdoc="Update options object to reflect the action by triggering the appropriate ChangeEvent.">
				<comm cntt="General Options"/>
				<comm cntt="} else if (source == cbxUseFrame) {"/>
				<comm cntt="newSource = options;"/>
				<comm cntt="Filter Options"/>
				<comm cntt="Display Style Options"/>
				<comm cntt="All other (i.e. display) options"/>
				<comm cntt="Update Option object to reflect new GUI state."/>
				<comm cntt="Forward event, if there is a listener"/>
				<comm cntt="getParent().setCursor(new Cursor(Cursor.WAIT_CURSOR));"/>
				<comm cntt="getParent().setCursor(new Cursor(Cursor.DEFAULT_CURSOR));"/>
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.load()" access="pub" jdoc="Sets this OptionPane&amp;apos;s options object to the state specified by the the OptionPane&amp;apos;s associated PropertyAccessor.">
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.initGui()" access="pub" jdoc="Setup the GUI (with no current state). This should only be called once in the constructor for this JBrowseOptionPane.">
				<comm cntt="------------"/>
				<comm cntt="Tile, the Option Panel Label"/>
				<comm cntt="------------"/>
				<comm cntt="---------------"/>
				<comm cntt="General Options"/>
				<comm cntt="---------------"/>
				<comm cntt="OptionPanel generalPanel = new OptionPanel();"/>
				<comm cntt="TitledBorder generalBorder = new TitledBorder(new BevelBorder(BevelBorder.LOWERED),"/>
				<comm cntt="&amp;quot; &amp;quot; + props.getProperty(&amp;quot;options.jbrowse.generalOptions&amp;quot;) + &amp;quot; &amp;quot;,"/>
				<comm cntt="TitledBorder.CENTER, TitledBorder.TOP);"/>
				<comm cntt="generalPanel.setBorder(new CompoundBorder(generalBorder, new EmptyBorder(0, 3, 0, 1)));"/>
				<comm cntt="if ( &amp;quot;jbrowse&amp;quot;.equals(getName()) ) {"/>
				<comm cntt="cbxUseFrame = new JextCheckBox("/>
				<comm cntt="props.getProperty(&amp;quot;options.jbrowse.useFrame&amp;quot;));"/>
				<comm cntt="generalPanel.add(cbxUseFrame);"/>
				<comm cntt="cbxUseFrame.addActionListener(this);"/>
				<comm cntt="}"/>
				<comm cntt="---------------"/>
				<comm cntt="Filter Options"/>
				<comm cntt="---------------"/>
				<comm cntt="Attributes"/>
				<comm cntt="Primitive Attributes"/>
				<comm cntt="Generalizations"/>
				<comm cntt="Throws"/>
				<comm cntt="Visibility Level"/>
				<comm cntt="Top-Level Visibility Options"/>
				<comm cntt="Member-Level Visibility Options"/>
				<comm cntt="----------------"/>
				<comm cntt="Display Options"/>
				<comm cntt="----------------"/>
				<comm cntt="Arguments"/>
				<comm cntt="Argument Names"/>
				<comm cntt="qualify nested class interface names"/>
				<comm cntt="class interface modifiers"/>
				<comm cntt="misc. detail modifiers"/>
				<comm cntt="Alpha Sort Methods"/>
				<comm cntt="Line Numbers"/>
				<comm cntt="Display Style"/>
				<comm cntt="Custom Display Style Options"/>
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.initModel()" access="pub" jdoc="This method sets the GUI representation of the model to the state specified by the current option object&amp;apos;s state.">
				<comm cntt="General Options"/>
				<comm cntt="cbxUseFrame.getModel().setSelected( options.getUseFrame() );"/>
				<comm cntt="Filter Options"/>
				<comm cntt="Display Options"/>
				<comm cntt="Set enabled disabled on showArgumentNames, showPrimitives checkboxes"/>
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.save()" access="pub" jdoc="The method called by the File-&amp;gt;Plugin Options save button for setting the JBrowse plugin options for all future sessions. It saves the current view state to the associated property values.">
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.refreshDisplayOptions(int)" access="priv" jdoc="Set the enabled and selected index state of all the display options that are dependant on the cmbStyle control. The state to be set to is determined by the passed styleIndex value. This method is called on init() and upon each change to the sytleIndex via its associated cmbStyle JComboBox.">
				<comm cntt="UML"/>
				<comm cntt="Java"/>
				<comm cntt="Custom"/>
				<comm cntt="error, unknown style index"/>
				<param name="styleIndex"/>
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.getOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.setOptions()" access="pub" jdoc="The method that sets the option object&amp;apos;s state to reflect the values specified by the current state of the JBrowseOptionPane.">
				<comm cntt="General Options"/>
				<comm cntt="options.setUseFrame( cbxUseFrame.getModel().isSelected() );"/>
				<comm cntt="Filter Options"/>
				<comm cntt="Display Options"/>
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane.addComponent(Component)" access="prot" jdoc="">
				<param name="comp"/>
			</mth>
		<class name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane$OptionPanel" intfc="n" abs="n" inn="y" sloc="38" jdoc="This class is used to for panels that require a gridBag layout for placement into (for example) an OptionPane.">
			<comm cntt="protected members"/>
			<field name="gridBag" access="prot" jdoc="The layout manager."/>
			<field name="y" access="prot" jdoc="The number of components already added to the layout manager."/>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane$OptionPanel.OptionPanel()" access="pub" jdoc="Creates a new option pane. @param name The internal name">
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane$OptionPanel.addComponent(String, Component)" access="prot" jdoc="Adds a labeled component to the option pane. @param label The label @param comp The component">
				<param name="label"/>
				<param name="comp"/>
			</mth>
			<mth name="/plugins/Java/JBrowseOptionPane.java:default.JBrowseOptionPane$OptionPanel.addComponent(Component)" access="prot" jdoc="Adds a component to the option pane. @param comp The component">
				<param name="comp"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/Java/JBrowseParser.java:default">
		<class name="/plugins/Java/JBrowseParser.java:default.JBrowseParser" intfc="y" abs="n" inn="n" sloc="9" jdoc="The interface that all JBrowse parsers must implement, independent of how they obtain their data and the type of source that parser analyzes.">
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="this should latter throw a parser not ready exception."/>
			<comm cntt="========================================================================="/>
			<comm cntt="static class JBrowseParser.Results"/>
			<comm cntt="============================================================================="/>
			<comm cntt="static interface JBrowseParser.LineSource"/>
			<const name="MISSING_LABEL" access="pub" jdoc=""/>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser.parse()" access="pub" jdoc="The method that preforms the actual parsing. This is the method which builds the tree model that reflects the heirarchical structure of the Java code that the parser has been configured to analyze.">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser.setOptions(Options)" access="pub" jdoc="">
				<param name="options"/>
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser.getSourceName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser.setRootNode(UMLTree.Node)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser.isReady()" access="pub" jdoc="">
			</mth>
		<class name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results" intfc="n" abs="n" inn="y" sloc="50" jdoc="">
			<comm cntt="Parse Counters"/>
			<comm cntt="Top-level (non-nested) public class interface (or null)"/>
			<comm cntt="Accessor Methods"/>
			<comm cntt="Increment"/>
			<field name="classCount" access="priv" jdoc=""/>
			<field name="interfaceCount" access="priv" jdoc=""/>
			<field name="methodCount" access="priv" jdoc=""/>
			<field name="objAttrCount" access="priv" jdoc=""/>
			<field name="primAttrCount" access="priv" jdoc=""/>
			<field name="errorCount" access="priv" jdoc=""/>
			<field name="topLevelPath" access="priv" jdoc=""/>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.getClassCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.getInterfaceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.getMethodCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.getObjAttrCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.getPrimAttrCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.getErrorCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.getTopLevelPath()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.setErrorCount(int)" access="pub" jdoc="">
				<param name="count"/>
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.setTopLevelPath(TreePath)" access="pub" jdoc="">
				<param name="path"/>
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.incClassCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.incInterfaceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.incMethodCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.incObjAttrCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.incPrimAttrCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.incErrorCount()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$Results.reset()" access="pub" jdoc="This method resets all the result variables to their initial state, i.e. all counts to 0, in anticipation of performing a new parse which will use the result object to count what it finds.">
			</mth>
		</class>
		<class name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$LineSource" intfc="y" abs="n" inn="y" sloc="9" jdoc="">
			<comm cntt="Returns the total number of lines in the associated line source"/>
			<comm cntt="remove from the interface ???"/>
			<comm cntt="Returns the lines with the specified index from the associated line source,"/>
			<comm cntt="or null if the index is out of range."/>
			<comm cntt="Returns the offset of this line from the start"/>
			<comm cntt="Returns the name for this LineSource (e.g. file name)"/>
			<comm cntt="Setup to become a newly initialized LineSource for the current buffer"/>
			<comm cntt="Returns an object representing the position in the source"/>
			<comm cntt="represented by the integer argument (offset)"/>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$LineSource.getTotalLines()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$LineSource.isExhausted()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$LineSource.getLine(int)" access="pub" jdoc="">
				<param name="lineIndex"/>
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$LineSource.getStartOffset()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$LineSource.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$LineSource.reset()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowseParser.java:default.JBrowseParser$LineSource.createPosition(int)" access="pub" jdoc="">
				<param name="offset"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/Java/JBrowsePlugin.java:default">
		<class name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin" intfc="n" abs="n" inn="n" sloc="16" jdoc="This class implements the JEdit&amp;apos;s Plugin interface for the JBrowse plugin.">
			<comm cntt="public class attributes"/>
			<comm cntt="Plugin interface"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="start(): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="========================================================================="/>
			<comm cntt="static class JBrowsePlugin.OpenAction"/>
			<comm cntt="========================================================================="/>
			<comm cntt="========================================================================="/>
			<comm cntt="public static class JBrowsePlugin.PropAccessor"/>
			<comm cntt="========================================================================="/>
			<comm cntt="static class TreeEventAdapter implements TreeSelectionListener"/>
			<const name="VER_NUM" access="pub" jdoc=""/>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="Newly created views call this method of each plugin in turn. The default implementation does nothing, but most plugins will want to override it to add instances of &amp;lt;code&amp;gt;javax.swing.JMenu&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;javax.swing.JMenuItem&amp;lt; code&amp;gt; to the appropriate vectors. The menus and menu items can be created dynamically by the plugin, but the preferred way is to use the methods of the &amp;lt;code&amp;gt;GUIUtilities&amp;lt; code&amp;gt; class.">
				<param name="view"/>
				<param name="menus"/>
				<param name="menuItems"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="This allows plugins to add their own option pane to the &amp;lt;code&amp;gt;OptionsDialog&amp;lt; code&amp;gt;.">
				<comm cntt="GLK ! 800 600 screens won&amp;apos;t like that !!"/>
				<comm cntt="parent.addOptionPane(new OptPane());"/>
				<param name="parent"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin.stop()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin.getName()" access="pub" jdoc="">
			</mth>
		<class name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$OpenAction" intfc="n" abs="n" inn="y" sloc="50" jdoc="">
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="actionPerformed(ActionEvent): void"/>
			<comm cntt="JBrowse.Activator interface"/>
			<field name="b" access="pub" jdoc=""/>
			<field name="view" access="pub" jdoc=""/>
			<field name="parser" access="pub" jdoc=""/>
			<field name="umlTree" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="savedCursor" access="pub" jdoc=""/>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$OpenAction.OpenAction()" access="pub" jdoc="">
				<comm cntt="identify prefix to .label property for menu"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$OpenAction.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="Loading properties"/>
				<comm cntt="Obtain the view for this jEdit session"/>
				<comm cntt="Set Wait Cursor"/>
				<comm cntt="Build a JEditLineSource as the JBrowseParser.LineSource for this instance"/>
				<comm cntt="Build a parser for this JBrowseParser.LineSource"/>
				<comm cntt="Create a UMLTree for this Plug-in instance"/>
				<comm cntt="Build and Add a TreeEventAdapter for this umlTree"/>
				<comm cntt="Build and Display a JBrowse GUI with this OpenAction as its Activator"/>
				<comm cntt="System.out.println(e.getMessage());"/>
				<comm cntt="System.out.println(e.toString());"/>
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$OpenAction.getOwner()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$OpenAction.getPropertyAccessor()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$OpenAction.getJBrowseParser()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$OpenAction.getUMLTree()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$OptPane" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<comm cntt="implements OptionPane it&amp;apos;s now implemented in JBrowseOptionPane"/>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$OptPane.getComponent()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$PropAccessor" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$PropAccessor.getProperty(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$PropAccessor.getProperty(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="def"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$PropAccessor.getProperty(String, Object[])" access="pub" jdoc="">
				<param name="name"/>
				<param name="args"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$PropAccessor.setProperty(String, String)" access="pub" jdoc="">
				<comm cntt="void???"/>
				<param name="name"/>
				<param name="value"/>
			</mth>
		</class>
		<class name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$TreeEventAdapter" intfc="n" abs="n" inn="y" sloc="71" jdoc="">
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="TreeEventAdapter(UMLTree, JEditLineSource): &amp;lt;init&amp;gt;"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="mouseClicked(MouseEvent): void"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="valueChanged(TreeSelectionEvent): void"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<field name="umlTree" access="pub" jdoc=""/>
			<field name="ls" access="pub" jdoc=""/>
			<field name="view" access="pub" jdoc=""/>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$TreeEventAdapter.TreeEventAdapter(UMLTree, JEditLineSource, JextFrame)" access="pub" jdoc="">
				<param name="umlTree"/>
				<param name="ls"/>
				<param name="view"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$TreeEventAdapter.mouseClicked(MouseEvent)" access="pub" jdoc="">
				<comm cntt="Only required to supplement valueChanged(TreeSelectionEvent evt)"/>
				<comm cntt="when mouse clicked on same node."/>
				<comm cntt="Check if view buffer matches tree buffer"/>
				<param name="e"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$TreeEventAdapter.valueChanged(TreeSelectionEvent)" access="pub" jdoc="">
				<comm cntt="Check if view buffer matches tree buffer"/>
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$TreeEventAdapter.setPosition(UMLTree.Node)" access="priv" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JBrowsePlugin$TreeEventAdapter.verifyBuffer()" access="priv" jdoc="">
				<comm cntt="Check if view buffer matches tree buffer"/>
				<comm cntt="view.getToolkit().beep();"/>
			</mth>
		</class>
		</class>
		<class name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource" intfc="n" abs="n" inn="n" sloc="69" jdoc="Implements the functionality specified by the LineSource interface using the set of lines made availble by a jEdit view and adds a method to return the StartOffset.">
			<comm cntt="jEdit specific"/>
			<comm cntt="jEdit specific"/>
			<comm cntt="jEdit specific"/>
			<comm cntt="last line that was read"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="JEditLineSource(View): &amp;lt;init&amp;gt;"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="reset(): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="getLine(int): String"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="this is specific to a JEditLineSource, should get rid of it ???"/>
			<field name="view" access="priv" jdoc=""/>
			<field name="buffer" access="priv" jdoc=""/>
			<field name="map" access="priv" jdoc=""/>
			<field name="lineElement" access="priv" jdoc=""/>
			<field name="name" access="priv" jdoc=""/>
			<field name="start" access="priv" jdoc=""/>
			<field name="lastLine" access="priv" jdoc=""/>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource.JEditLineSource(JextFrame)" access="pub" jdoc="">
				<param name="view"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource.reset()" access="pub" jdoc="Setup to become a newly initialized LineSource for the current buffer.">
				<comm cntt="end if File == null"/>
				<comm cntt="end else"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource.createPosition(int)" access="pub" jdoc="">
				<comm cntt="% JBrowse.log(1, this, &amp;quot;BadLocationException thrown in exception handler of method createPosition().&amp;quot;);"/>
				<param name="offs"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource.getLine(int)" access="pub" jdoc="">
				<comm cntt="??? Note this should be cleaned up. Currently rely on returning"/>
				<comm cntt="null when source is exhausted. Should actually throw exception in"/>
				<comm cntt="the second case. Probably should have an indexed line source vs. sequential"/>
				<comm cntt="line source. The second would only allow calls to getNextLine and it"/>
				<comm cntt="would keep track of the line number for the client."/>
				<comm cntt="Sanity check"/>
				<comm cntt="% JBrowse.log(4, this, &amp;quot;Argument to getLine() is bad: &amp;quot; + lineIndex);"/>
				<comm cntt="source has been exhaused"/>
				<comm cntt="Sanity check"/>
				<comm cntt="% JBrowse.log(1, this, &amp;quot;Element returned by getElement() is null&amp;quot;);"/>
				<comm cntt="System.exit(0); ??? should throw an exception here"/>
				<comm cntt="% JBrowse.log(1, this, &amp;quot;BadLocationException thrown in getLine(int) method.&amp;quot;);"/>
				<param name="lineIndex"/>
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource.isExhausted()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource.getStartOffset()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource.getTotalLines()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JBrowsePlugin.java:default.JEditLineSource.getTextArea()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/JSBeautifier.java:default">
		<class name="/plugins/Java/JSBeautifier.java:default.JSBeautifier" intfc="n" abs="n" inn="n" sloc="734" jdoc="&amp;lt;code&amp;gt; JSBeautifier &amp;lt; code&amp;gt; (formerly called Beautifier) is a filter for automatic indentation of Java source code. Every line of the original source file should be sent one after the other as a String to the beautify(lineString) method, which returns an automatically indented version of the line it recieves, according to the data in the past lines recieved. Every time a JSBeautifier instance is to be reused for a new file, a call must first be made to its init() method. JSBeautifier can be used either as an object in a program or from the command line. When used from the command line, JSBeautifier can be used both as a filter from standard-input to standard-output, i.e.: [ home tald]$ java jstyle.JSBeautifier [flags] &amp;lt; sourceFile.java &amp;gt; resultingFile.java or as a filter to specifically named files, i.e: [ home tald]$ java jstyle.JSBeautifier [flags] File1.java File2.java File3.java When Giving JSBeautifier the name of a specific source file, output will be created to another file with the same name, BUT with an added suffix of &amp;quot;.js&amp;quot; Thus, a file named &amp;quot;File1.java&amp;quot; will be renamed to &amp;quot;File1.java.js&amp;quot; Flag options: -t (for tabs) -s# (for &amp;apos;#&amp;apos; spaces per indent, i.e.: -s2) -ib (add extra indentation to brackets) -fs (flush (i.e. don&amp;apos;t add extra indentation to) switch statements - ala Java Code Convention). -h (for help message) The current default setup is 4 spaces per indent, 1 space before every comment line Bug Reporting: 1. If anyone corrects a found bug, please send me an example source-file that creates the bug, and the corrected version of this file, so that I can post it. 2. Otherwise, please send me an example source-file cerating the bug, and the bug description, and i will do my best to correct the bug as soon as possible. Acknowledgments: - Thanks to Jim Watson for addition of the Help option !!! @author Tal Davidson &amp;lt;a href=mailto:davidsont@bigfoot.com&amp;gt;davidsont@bigfoot.com&amp;lt; a&amp;gt; @version 1.1.1, October 10th, 1998">
			<comm cntt="headers[] - an array of headers that require indentation"/>
			<comm cntt="nonParenHeaders[] - an array of headers that DONT require parenthesies after them"/>
			<comm cntt="preBlockStatements[] - an array of headers that exist within statements immediately preceding blocks"/>
			<comm cntt="assignmentOperators[] - an array of assignment operators"/>
			<comm cntt="nonAssignmentOperators[] - an array of non-assignment operators"/>
			<comm cntt="headerStack - a stack of the headers responsible for indentations of the current char"/>
			<comm cntt="tempStacks - a stack of Stacks. Each inner stack holds the current header-list in a { } block."/>
			<comm cntt="The innermost { } block&amp;apos;s stack sits at the top of the tempStacks."/>
			<comm cntt="blockParenDepthStack - stack of the number of parenthesies that are open when new NESTED BLOCKS are created."/>
			<comm cntt="blockStatementStack - stack of the states of &amp;apos;isInStatement&amp;apos; when new NESTED BLOCKS are created."/>
			<comm cntt="parenStatementStack - stack of the states of &amp;apos;isInStatement&amp;apos; when new NESTED PARENTHESIES are created."/>
			<comm cntt="inStatementIndentStack - stack of LOCATIONS of in-statement indents"/>
			<comm cntt="inStatementIndentStackSizeStack - stack of SIZES of inStatementIndentStack stacks"/>
			<comm cntt="parenIndentStack - stack of LOCATIONS of &amp;apos;(&amp;apos; or &amp;apos;[&amp;apos; chars"/>
			<comm cntt="bracketBlockStateStack - stack of types of nested &amp;apos;{&amp;apos; brackets."/>
			<comm cntt="Each element of the stack is either True (=the beginner of a block), or False (=the beginner of a"/>
			<comm cntt="static array)."/>
			<comm cntt="isSpecialChar - true if a there exists a &amp;apos;\&amp;apos; preceding the current chararacter."/>
			<comm cntt="i.e. \n, \t, \\, ..."/>
			<comm cntt="isInQuote - true when the current character is part of a quote (i.e. &amp;apos;g&amp;apos; or &amp;quot;ffff&amp;quot;)"/>
			<comm cntt="isInComment - true when current character is part of a comment"/>
			<comm cntt="isInCase - true if in middle of a case statement (inside a switch);"/>
			<comm cntt="isInQuestion - true if in the middle of a &amp;apos;? :&amp;apos; statement"/>
			<comm cntt="isInStatement - true when current character is a part of an ongoing statement"/>
			<comm cntt="isInClassHeader - true if inside a &amp;apos;class&amp;apos; statement"/>
			<comm cntt="isInClassHeaderTab - true if a special tab has been activated for the &amp;apos;class statement&amp;apos;"/>
			<comm cntt="switchIndent - true if switch blocks should have an additional internal indent."/>
			<comm cntt="bracketIndent - true if brackets should have an added indent."/>
			<comm cntt="quoteChar - the quote delimeter of a quote (&amp;apos; or &amp;quot;)"/>
			<comm cntt="commmentIndent - the number of spaces to indent when in a comment"/>
			<comm cntt="parenDepth - the depth of parenthesies around the current character"/>
			<comm cntt="indentString - the String to be used for every indentation"/>
			<comm cntt="- either a &amp;quot;\t&amp;quot; or a String of n spaces."/>
			<comm cntt="indentLength - the length of one indent unit."/>
			<comm cntt="blockTabCount - stores number of tabs to add to begining of line"/>
			<comm cntt="due to statements with INNER blocks inside open parenthesies."/>
			<comm cntt="get distance to the next non-white sspace, non-comment character in the line."/>
			<comm cntt="if no such character exists, return the length remaining to the end of the line."/>
			<field name="headers" access="priv" jdoc=""/>
			<field name="nonParenHeaders" access="priv" jdoc=""/>
			<field name="preBlockStatements" access="priv" jdoc=""/>
			<field name="assignmentOperators" access="priv" jdoc=""/>
			<field name="nonAssignmentOperators" access="priv" jdoc=""/>
			<field name="headerStack" access="priv" jdoc=""/>
			<field name="tempStacks" access="priv" jdoc=""/>
			<field name="blockParenDepthStack" access="priv" jdoc=""/>
			<field name="blockStatementStack" access="priv" jdoc=""/>
			<field name="parenStatementStack" access="priv" jdoc=""/>
			<field name="inStatementIndentStack" access="priv" jdoc=""/>
			<field name="inStatementIndentStackSizeStack" access="priv" jdoc=""/>
			<field name="parenIndentStack" access="priv" jdoc=""/>
			<field name="bracketBlockStateStack" access="priv" jdoc=""/>
			<field name="isSpecialChar" access="priv" jdoc=""/>
			<field name="isInQuote" access="priv" jdoc=""/>
			<field name="isInComment" access="priv" jdoc=""/>
			<field name="isInCase" access="priv" jdoc=""/>
			<field name="isInQuestion" access="priv" jdoc=""/>
			<field name="isInStatement" access="priv" jdoc=""/>
			<field name="isInClassHeader" access="priv" jdoc=""/>
			<field name="isInClassHeaderTab" access="priv" jdoc=""/>
			<field name="switchIndent" access="priv" jdoc=""/>
			<field name="bracketIndent" access="priv" jdoc=""/>
			<field name="quoteChar" access="priv" jdoc=""/>
			<field name="commentIndent" access="priv" jdoc=""/>
			<field name="parenDepth" access="priv" jdoc=""/>
			<field name="indentString" access="priv" jdoc=""/>
			<field name="indentLength" access="priv" jdoc=""/>
			<field name="blockTabCount" access="priv" jdoc=""/>
			<field name="statementTabCount" access="priv" jdoc=""/>
			<field name="leadingWhiteSpaces" access="priv" jdoc=""/>
			<field name="maxInStatementIndent" access="priv" jdoc=""/>
			<field name="prevNonSpaceCh" access="priv" jdoc=""/>
			<field name="currentNonSpaceCh" access="priv" jdoc=""/>
			<field name="currentHeader" access="priv" jdoc=""/>
			<field name="isInHeader" access="priv" jdoc=""/>
			<field name="immediatelyPreviousAssignmentOp" access="priv" jdoc=""/>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.main(String)" access="pub" jdoc="">
				<comm cntt="manage flags"/>
				<comm cntt="file-name"/>
				<param name="args"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.beautifyReader(BufferedReader, PrintWriter)" access="pub" jdoc="beautify input from inreader to outWriter @param inReader a BufferedReader from which to input original source code @param outWriter a PrintWriter to output beutified source code to @exception IOException">
				<comm cntt="beautify source code lines"/>
				<param name="inReader"/>
				<param name="outWriter"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.JSBeautifier()" access="pub" jdoc="JSBeautifier&amp;apos;s constructor.">
				<comm cntt="the default indentation of a JSBeautifier object is of 4 spaces per indent"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.init()" access="pub" jdoc="initiate the JSBeautifier. init() should be called every time a JSBeautifier object is to start beautifying a NEW source file.">
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.setTabIndentation()" access="pub" jdoc="ident using one tab per identation">
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.setSpaceIndentation(int)" access="pub" jdoc="ident a number of spaces for each identation. @param length number of spaces per indent.">
				<param name="length"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.setMaxInStatementIndetation(int)" access="pub" jdoc="set the maximum indentation between two lines in a multi-line statement. @param max maximum indentation length.">
				<param name="max"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.setBracketIndent(boolean)" access="pub" jdoc="set the state of the bracket indentation option. If true, brackets will be indented one additional indent. @param state state of option.">
				<param name="state"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.setSwitchIndent(boolean)" access="pub" jdoc="set the state of the switch indentation option. If true, blocks of &amp;apos;switch&amp;apos; statements will be indented one additional indent. @param state state of option.">
				<param name="state"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.beautify(String)" access="pub" jdoc="beautify a line of source code. every line of source code in a java source code file should be sent one after the other to the beautify method.">
				<comm cntt="true when the current character is in a comment (such as this line ...)"/>
				<comm cntt="the current character"/>
				<comm cntt="previous char"/>
				<comm cntt="the newly idented line is bufferd here"/>
				<comm cntt="number of indents before line"/>
				<comm cntt="last header found within line"/>
				<comm cntt="handle and remove white spaces around the line:"/>
				<comm cntt="If not in comment, first find out size of white space before line,"/>
				<comm cntt="so that possible comments starting in the line continue in"/>
				<comm cntt="relation to the preliminary white-space."/>
				<comm cntt="calculate preliminary indentation based on data from past lines"/>
				<comm cntt="is the switchIndent option is on, indent switch statements an additional indent."/>
				<comm cntt="if (isInStatement)"/>
				<comm cntt="if (!headerStack.isEmpty() &amp;&amp; !&amp;quot;{&amp;quot;.equals(headerStack.lastElement()))"/>
				<comm cntt="tabCount--;"/>
				<comm cntt="parse characters in the current line."/>
				<comm cntt="handle special characters (i.e. backslash+character such as \n, \t, ...)"/>
				<comm cntt="handle quotes (such as &amp;apos;x&amp;apos; and &amp;quot;Hello Dolly&amp;quot;)"/>
				<comm cntt="handle comments"/>
				<comm cntt="if we have reached this far then we are NOT in a comment or string of special character..."/>
				<comm cntt="handle parenthesies"/>
				<comm cntt="spaceTabCount-=indentLength;"/>
				<comm cntt="first, check if &amp;apos;{&amp;apos; is a block-opener or an static-array opener"/>
				<comm cntt="&amp;&amp; !inStatementIndentStack.isEmpty() - actually not needed"/>
				<comm cntt="parenIndentStack.push(new Integer(i+spaceTabCount));"/>
				<comm cntt="check if a header has been reached"/>
				<comm cntt="if we reached here, then this is a header..."/>
				<comm cntt="if a new block is opened, push a new stack into tempStacks to hold the"/>
				<comm cntt="future list of headers in the new block."/>
				<comm cntt="if (&amp;quot;{&amp;quot;.equals(headers[h]))"/>
				<comm cntt="tempStacks.push(new Stack());"/>
				<comm cntt="take care of the special case: &amp;apos;else if (...)&amp;apos;"/>
				<comm cntt="take care of &amp;apos;else&amp;apos;"/>
				<comm cntt="recreate the header list in headerStack up to the previous &amp;apos;if&amp;apos;"/>
				<comm cntt="from the temporary snapshot stored in lastTempStack."/>
				<comm cntt="If the above if is not true, i.e. no &amp;apos;if&amp;apos; before the &amp;apos;else&amp;apos;, then nothing beautiful will come out of this... I should think about inserting an Exception here to notify the caller of this..."/>
				<comm cntt="check if &amp;apos;while&amp;apos; closes a previous &amp;apos;do&amp;apos;"/>
				<comm cntt="recreate the header list in headerStack up to the previous &amp;apos;do&amp;apos;"/>
				<comm cntt="from the temporary snapshot stored in lastTempStack."/>
				<comm cntt="check if &amp;apos;catch&amp;apos; closes a previous &amp;apos;try&amp;apos; or &amp;apos;catch&amp;apos;"/>
				<comm cntt="recreate the header list in headerStack up to the previous &amp;apos;do&amp;apos;"/>
				<comm cntt="from the temporary snapshot stored in lastTempStack."/>
				<comm cntt="lastTempStack.pop();"/>
				<comm cntt="headerStack.push(&amp;quot;try&amp;quot;);"/>
				<comm cntt="if (parenDepth == 0)"/>
				<comm cntt="special handling of &amp;apos;case&amp;apos; statements"/>
				<comm cntt="so that brackets after the &amp;apos;:&amp;apos; will appear as block-openers"/>
				<comm cntt="from here on, treat char as &amp;apos;;&amp;apos;"/>
				<comm cntt="handle ends of statements"/>
				<comm cntt="first check if this &amp;apos;}&amp;apos; closes a previous block, or a static array..."/>
				<comm cntt="needed due to cases such as &amp;apos;}else{&amp;apos;, so that headers (&amp;apos;else&amp;apos; tn tih case) will be identified..."/>
				<comm cntt="else if (ch == &amp;apos;;&amp;apos; parenDepth == 0 )"/>
				<comm cntt="while (((Integer) inStatementIndentStackSizeStack.peek()).intValue() &amp;lt; inStatementIndentStack.size())"/>
				<comm cntt="inStatementIndentStack.pop();"/>
				<comm cntt="Create a temporary snapshot of the current block&amp;apos;s header-list in the uppermost inner stack in tempStacks, and clear the headerStack up to the begining of the block. Thus, the next future statement will think it comes one indent past the block&amp;apos;s &amp;apos;{&amp;apos; unless it specifically checks for a companion-header (such as a previous &amp;apos;if&amp;apos; for an &amp;apos;else&amp;apos; header) within the tempStacks, and recreates the temporary snapshot by manipulating the tempStacks."/>
				<comm cntt="PRECHECK if a &amp;apos;==&amp;apos; or &amp;apos;--&amp;apos; or &amp;apos;++&amp;apos; operator was reached."/>
				<comm cntt="If not, then register an indent IF an assignment operator was reached."/>
				<comm cntt="The precheck is important, so that statements such as &amp;apos;i--==2&amp;apos; are not recognized"/>
				<comm cntt="to have assignment operators (here, &amp;apos;-=&amp;apos;) in them . . ."/>
				<comm cntt="the above two lines do the same as the next since all listed non Assignment operators are 2 chars long... if (nonAssignmentOperators[n].length() &amp;gt; 1) { outBuffer.append(nonAssignmentOperators[n].substring(1)); i += nonAssignmentOperators[n].length() - 1; }"/>
				<comm cntt="handle special cases of unindentation:"/>
				<comm cntt="if &amp;apos;{&amp;apos; doesn&amp;apos;t follow an immediately previous &amp;apos;{&amp;apos; in the headerStack (but rather another header such as &amp;quot;for&amp;quot; or &amp;quot;if&amp;quot;, then unindent it by one indentation relative to its block."/>
				<comm cntt="take care of extra bracket indentatation option..."/>
				<comm cntt="finally, insert indentations into begining of line"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.registerInStatementIndent(String, int, int, boolean, boolean)" access="priv" jdoc="">
				<comm cntt="while (nextNonWSChar &amp;lt; remainingCharNum &amp;&amp; (line.charAt(i+nextNonWSChar) == &amp;apos; &amp;apos; || line.charAt(i+nextNonWSChar) == &amp;apos;\t&amp;apos;) ) nextNonWSChar++;"/>
				<comm cntt="if indent is around the last char in the line, indent instead 2 spaces from the previous indent"/>
				<comm cntt="indentLength"/>
				<comm cntt="2"/>
				<comm cntt="else if (!isLineInStatement &amp;&amp; i + nextNonWSChar &amp;lt; 8)"/>
				<comm cntt="inStatementIndent = 8 + spaceTabCount;"/>
				<param name="line"/>
				<param name="i"/>
				<param name="spaceTabCount"/>
				<param name="isLineInStatement"/>
				<param name="updateParenStack"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.getNextProgramCharDistance(String, int)" access="priv" jdoc="">
				<param name="line"/>
				<param name="i"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.isLegalNameChar(char)" access="priv" jdoc="">
				<param name="ch"/>
			</mth>
			<mth name="/plugins/Java/JSBeautifier.java:default.JSBeautifier.findLegalHeader(String, int, String)" access="priv" jdoc="">
				<comm cntt="first check that this is a header and not the begining of a longer word..."/>
				<param name="line"/>
				<param name="i"/>
				<param name="possibleHeaders"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/JSFormatter.java:default">
		<class name="/plugins/Java/JSFormatter.java:default.JSFormatter" intfc="n" abs="n" inn="n" sloc="686" jdoc="">
			<comm cntt="headers[] - an array of headers that require indentation"/>
			<comm cntt="parenHeaders[] - an array of the headers that require parenthesies after them, i.e. while (...)"/>
			<comm cntt="current parsed-line buffer"/>
			<comm cntt="parts of previous line that haven&amp;apos;t been parsed yet"/>
			<comm cntt="true if a char of type &amp;apos;\X&amp;apos; (i.e. &amp;apos;\n&amp;apos;...)"/>
			<comm cntt="true if in quote"/>
			<comm cntt="true if in comment"/>
			<comm cntt="---not currently used."/>
			<comm cntt="---not currently used."/>
			<comm cntt="---not currently used."/>
			<comm cntt="true if a parenthesis statement is expected (i.e. right after a &amp;apos;while&amp;apos; header...)"/>
			<comm cntt="true if current formatted line has reached its end."/>
			<comm cntt="hint for checking if a &amp;apos;{&amp;apos; has been reached"/>
			<comm cntt="hint for checking if a &amp;apos;}&amp;apos; has been reached"/>
			<comm cntt="Does the formatter request a new line? This should be checked only if we have a new line to actually give the formatter via the format(line) method."/>
			<comm cntt="Does formatter have more formatted lines in its belly? This should be called only after there are no more original lines to send the formatter. Until false, the new formatted lines can be retreived by calling the format method with an empty string, i.e. format(&amp;quot;&amp;quot;);"/>
			<comm cntt="Format the original line sent. Actually, the returned String is the next parsed line that is ready, and may be a part of a formerly sent original line"/>
			<field name="headers" access="priv" jdoc=""/>
			<field name="parenHeaders" access="priv" jdoc=""/>
			<field name="nonParenHeaders" access="priv" jdoc=""/>
			<field name="statementHeaders" access="priv" jdoc=""/>
			<field name="longOperators" access="priv" jdoc=""/>
			<field name="closingHeaders" access="priv" jdoc=""/>
			<field name="beautifier" access="pub" jdoc=""/>
			<field name="lineBreaker" access="priv" jdoc=""/>
			<field name="outBuffer" access="priv" jdoc=""/>
			<field name="tempLine" access="priv" jdoc=""/>
			<field name="openingStack" access="priv" jdoc=""/>
			<field name="parenDepthsStack" access="priv" jdoc=""/>
			<field name="bracketBlockStateStack" access="priv" jdoc=""/>
			<field name="quoteChar" access="priv" jdoc=""/>
			<field name="parenDepth" access="priv" jdoc=""/>
			<field name="leadingWhiteSpaces" access="priv" jdoc=""/>
			<field name="currentHeader" access="priv" jdoc=""/>
			<field name="isInHeader" access="priv" jdoc=""/>
			<field name="isSpecialChar" access="priv" jdoc=""/>
			<field name="isInQuote" access="priv" jdoc=""/>
			<field name="isInComment" access="priv" jdoc=""/>
			<field name="isBlockNeeded" access="priv" jdoc=""/>
			<field name="isSpecialBlock" access="priv" jdoc=""/>
			<field name="isCloseSpecialBlock" access="priv" jdoc=""/>
			<field name="isParenNeeded" access="priv" jdoc=""/>
			<field name="isNewLineNeeded" access="priv" jdoc=""/>
			<field name="checkBlockOpen" access="priv" jdoc=""/>
			<field name="checkBlockClose" access="priv" jdoc=""/>
			<field name="checkIf" access="priv" jdoc=""/>
			<field name="checkClosingHeader" access="priv" jdoc=""/>
			<field name="foundOrigLineBreak" access="priv" jdoc=""/>
			<field name="isInQuestion" access="priv" jdoc=""/>
			<field name="isSummarized" access="priv" jdoc=""/>
			<field name="isInBracketOpen" access="priv" jdoc=""/>
			<field name="isInBracketClose" access="priv" jdoc=""/>
			<field name="isInClassStatement" access="priv" jdoc=""/>
			<field name="bracketBreak" access="priv" jdoc=""/>
			<field name="prevNonSpaceCh" access="priv" jdoc=""/>
			<field name="currentNonSpaceCh" access="priv" jdoc=""/>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.JSFormatter()" access="pub" jdoc="Constructor for JSFormatter">
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.init()" access="pub" jdoc="Initialize the formatter so that it is ready for the formation of a new file of source code.">
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.format(BufferedReader, PrintWriter)" access="pub" jdoc="Format source code that is read from inReader, and print the formatted result to outWriter. @param inReader a BufferedReader from which to input original source code @param outWriter a PrintWriter to output beutified source code to @exception IOException">
				<param name="inReader"/>
				<param name="outWriter"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.hasMoreFormattedLines()" access="pub" jdoc="Check if the formatter has more formatted lines to return. As long as there are more formatted lines to return, the caller should NOT call the method formatLine() with a new line of source code, but rather collect the current available formatted lines with the method nextFormattedLine(), i.e: while (formatter.hasMoreFormattedLines()) System.out.println(formatter.nextFormattedLine()">
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.formatLine(String)" access="pub" jdoc="format a line of source code. formatLine should NOT be called if there are still formatted lines ready to be collected. This can be checked with the method hasMoreFormattedLines() @param line a line of source code to be formatted.">
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.nextFormattedLine()" access="pub" jdoc="Get the next formatted line. This should be called ONLY after checking with the method hasMoreFormattedLines() that there actualy is a formatted line ready to be collected.">
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.summarize()" access="pub" jdoc="summarize() is to be called when there are no more lines of unformatted source code to be passed to the formatter.">
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.setBracketBreak(boolean)" access="pub" jdoc="">
				<param name="br"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.setBracketIndent(boolean)" access="pub" jdoc="">
				<param name="state"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.setSwitchIndent(boolean)" access="pub" jdoc="">
				<param name="state"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.setPreferredLineLength(int)" access="pub" jdoc="">
				<param name="length"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.setLineLengthDeviation(int)" access="pub" jdoc="">
				<param name="dev"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.setNestedConnection(boolean)" access="pub" jdoc="">
				<param name="nest"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.isNewLineRequested()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.hasMoreSummarizedLines()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.format(String)" access="pub" jdoc="">
				<comm cntt="true when the current character is in a comment (such as this line ...)"/>
				<comm cntt="the current character"/>
				<comm cntt="connect new unparsed line to former unparsed line."/>
				<comm cntt="remove the white-space around the current line"/>
				<comm cntt="line = line.trim();"/>
				<comm cntt="parse characters in the current line."/>
				<comm cntt="shouldPublish = false;"/>
				<comm cntt="&amp;apos;\n&amp;apos; exists when an empty line has been sent"/>
				<comm cntt="if (checkClosingHeader) { isDoubleBreak = true; checkClosingHeader = false; }"/>
				<comm cntt="if (foundOrigLineBreak)"/>
				<comm cntt="foundOrigLineBreak = false;"/>
				<comm cntt="&amp;apos;\r&amp;apos; exists at the connection points between original lines"/>
				<comm cntt="System.out.println(&amp;quot;found \\r at:&amp;quot; + i +&amp;quot; out of &amp;quot; + line.length());"/>
				<comm cntt="minimize white-space"/>
				<comm cntt="and remove spaces that come right after parenthesies..."/>
				<comm cntt="if (!isInComment &amp;&amp; !isInQuote &amp;&amp; (ch == &amp;apos; &amp;apos; || ch == &amp;apos;\t&amp;apos;))"/>
				<comm cntt="{"/>
				<comm cntt="if (prevCh != &amp;apos; &amp;apos; &amp;&amp; prevCh != &amp;apos;\t&amp;apos;)"/>
				<comm cntt="outBuffer.append(ch);"/>
				<comm cntt="continue;"/>
				<comm cntt="}"/>
				<comm cntt="called specifically AFTER white space is treated."/>
				<comm cntt="handle comments"/>
				<comm cntt="if we have reached here, then we are NOT in a comment"/>
				<comm cntt=""/>
				<comm cntt="outBuffer.append(&amp;apos; &amp;apos;);"/>
				<comm cntt="pop the opening header"/>
				<comm cntt=""/>
				<comm cntt="if (!isParenNeeded)"/>
				<comm cntt="handle special characters (i.e. backslash+character such as \n, \t, ...)"/>
				<comm cntt="handle quotes (such as &amp;apos;x&amp;apos; and &amp;quot;Hello Dolly&amp;quot;)"/>
				<comm cntt="handle parenthesies"/>
				<comm cntt="outBuffer.append(ch);"/>
				<comm cntt="continue;"/>
				<comm cntt="don&amp;apos;t do special parsing as long as parenthesies are open..."/>
				<comm cntt="if (parenDepth != 0) { outBuffer.append(ch); continue; }"/>
				<comm cntt="if (isNewLineNeeded &amp;&amp; !isParenNeeded) { isNewLineNeeded = false; i--; isBreakCalled = true; continue; }"/>
				<comm cntt="outBuffer.append(&amp;apos; &amp;apos;);"/>
				<comm cntt="isInCase)"/>
				<comm cntt="isInCase = false;"/>
				<comm cntt="first, check if &amp;apos;{&amp;apos; is a block-opener or an static-array opener"/>
				<comm cntt="if I have reached here, then I am in a block..."/>
				<comm cntt="outBuffer.append(&amp;apos; &amp;apos;);"/>
				<comm cntt="checkBlockClose = true;"/>
				<comm cntt="first check if this &amp;apos;}&amp;apos; closes a previous block, or a static array..."/>
				<comm cntt="treat &amp;apos;return&amp;apos; a an operator."/>
				<comm cntt="add space when a non-operator follows a closing parenthesis"/>
				<comm cntt="hide the operator"/>
				<comm cntt="since all long operators are 2 chars long..."/>
				<comm cntt="not &amp;apos;. &amp;apos;"/>
				<comm cntt="&amp;&amp; ch != &amp;apos;)&amp;apos; &amp;&amp; ch != &amp;apos;]&amp;apos;)"/>
				<comm cntt="default"/>
				<comm cntt="is this exception really needed??? - check if the above ?: solves the problem..."/>
				<comm cntt="outBuffer.append(&amp;quot; &amp;quot;);"/>
				<comm cntt="if (outString != null &amp;&amp; !&amp;quot;&amp;quot;.equals(outString)) { if (isInComment &amp;&amp; !isLineComment) { System.err.println(&amp;quot;In Block Comment: &amp;quot; + outString); StringBuffer s = new StringBuffer(outString); if (&amp;quot;\t&amp;quot;.equals(beautifier.getIndentString())) { int p = outString.indexOf(&amp;quot;\t &amp;quot;); if (p &amp;gt; -1) { s.delete(p, p + 4); s.insert(p, &amp;quot;\t &amp;quot;); } } outString = s.toString(); System.err.println(&amp;quot;After replace: &amp;quot; + outString); } }"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.appendSpace(StringBuffer)" access="priv" jdoc="">
				<param name="buf"/>
			</mth>
			<mth name="/plugins/Java/JSFormatter.java:default.JSFormatter.clearPaddingSpace(StringBuffer)" access="priv" jdoc="">
				<param name="buf"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/JSLineBreaker.java:default">
		<class name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker" intfc="n" abs="n" inn="n" sloc="342" jdoc="">
			<comm cntt="&amp;quot;!&amp;quot;,"/>
			<comm cntt="35"/>
			<comm cntt="() appears here so that it will not be cut in the middle..."/>
			<comm cntt="() appears here so that it will not be cut in the middle..."/>
			<comm cntt="() appears here so that it will not be cut in the middle..."/>
			<comm cntt="&amp;lt;--"/>
			<comm cntt="prefTable.put(&amp;quot;!&amp;quot;, new Integer(70));"/>
			<comm cntt="true when the current character is in a comment (such as this line ...)"/>
			<const name="BEFORE" access="priv" jdoc=""/>
			<const name="AFTER" access="priv" jdoc=""/>
			<field name="prefs" access="priv" jdoc=""/>
			<field name="prefTable" access="priv" jdoc=""/>
			<field name="brokenLineVector" access="priv" jdoc=""/>
			<field name="wsBuffer" access="priv" jdoc=""/>
			<field name="quoteChar" access="priv" jdoc=""/>
			<field name="isInQuote" access="priv" jdoc=""/>
			<field name="isInComment" access="priv" jdoc=""/>
			<field name="isNestedConnection" access="priv" jdoc=""/>
			<field name="isCut" access="priv" jdoc=""/>
			<field name="isLineComment" access="priv" jdoc=""/>
			<field name="parenDepth" access="priv" jdoc=""/>
			<field name="breakDepth" access="priv" jdoc=""/>
			<field name="preferredLineLength" access="priv" jdoc=""/>
			<field name="lineLengthDeviation" access="priv" jdoc=""/>
			<field name="previousLineBreak" access="priv" jdoc=""/>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.JSLineBreaker()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.init()" access="pub" jdoc="">
				<comm cntt="&amp;lt;------ 2"/>
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.setPreferredLineLength(int)" access="pub" jdoc="">
				<param name="length"/>
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.setLineLengthDeviation(int)" access="pub" jdoc="">
				<param name="dev"/>
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.setNestedConnection(boolean)" access="pub" jdoc="">
				<param name="nest"/>
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.breakLine(String)" access="pub" jdoc="">
				<comm cntt="the current character"/>
				<comm cntt="System.out.println(&amp;quot;line length: &amp;quot; + line.length() + &amp;quot; line: &amp;quot; + line );"/>
				<comm cntt="System.out.println(ch + &amp;quot; &amp;quot; + ws);"/>
				<comm cntt="System.out.println(ws);"/>
				<comm cntt="parse characters in the current line."/>
				<comm cntt="handle special characters (i.e. backslash+character such as \n, \t, ...)"/>
				<comm cntt="handle comments"/>
				<comm cntt="handle quotes (such as &amp;apos;x&amp;apos; and &amp;quot;Hello Dolly&amp;quot;)"/>
				<comm cntt="ch == &amp;apos;(&amp;apos;"/>
				<comm cntt="&amp;quot;)&amp;quot;.equals(key)"/>
				<comm cntt="&amp;lt;-----"/>
				<comm cntt="in future, think of: &amp;&amp; line.length()&amp;gt;i+10) (that was used in the past...)"/>
				<comm cntt="brokenLineBuffer.append(wsBuffer);"/>
				<comm cntt="if (isCut) brokenLineBuffer.append(&amp;quot; &amp;quot;); brokenLineBuffer.append(beforeCut); brokenLineVector.addElement(brokenLineBuffer.toString());"/>
				<comm cntt="previousAfterCut = outString.substring(cutWhere);"/>
				<comm cntt="lineBreakStack = new Stack();"/>
				<comm cntt="at end of line:"/>
				<comm cntt="brokenLineBuffer.append(wsBuffer);"/>
				<comm cntt="if (isCut) brokenLineBuffer.append(&amp;quot; &amp;quot;); brokenLineBuffer.append(outBuffer); brokenLineVector.addElement(brokenLineBuffer.toString());"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.registerLineBreak(Stack, LineBreak)" access="priv" jdoc="">
				<comm cntt="newBreak.dump();"/>
				<comm cntt="System.out.println(&amp;quot;for &amp;quot; + newBreak.breakStr); for (int s=0; s&amp;lt;lineBreakStack.size(); s++) ((LineBreak) lineBreakStack.elementAt(s)).dump(); System.out.println();"/>
				<param name="lineBreakStack"/>
				<param name="newBreak"/>
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.addBrokenLine(String, String, LineBreak, int, boolean)" access="priv" jdoc="">
				<comm cntt="&amp;&amp; brokenLine.length() &amp;gt; 0)"/>
				<comm cntt="dfds"/>
				<param name="whiteSpace"/>
				<param name="brokenLine"/>
				<param name="lineBreak"/>
				<param name="breakDepth"/>
				<param name="isCut"/>
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.compare(LineBreak, LineBreak)" access="priv" jdoc="">
				<param name="br1"/>
				<param name="br2"/>
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.hasMoreBrokenLines()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker.nextBrokenLine()" access="pub" jdoc="">
			</mth>
		<class name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker$LineBreak" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<field name="breakStr" access="pub" jdoc=""/>
			<field name="breakWhere" access="pub" jdoc=""/>
			<field name="breakDepth" access="pub" jdoc=""/>
			<field name="breakType" access="pub" jdoc=""/>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker$LineBreak.LineBreak(String, int, int, int)" access="pub" jdoc="">
				<param name="str"/>
				<param name="wh"/>
				<param name="dp"/>
				<param name="tp"/>
			</mth>
			<mth name="/plugins/Java/JSLineBreaker.java:default.JSLineBreaker$LineBreak.dump()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/Java/JavaPlugin.java:default">
		<class name="/plugins/Java/JavaPlugin.java:default.JavaPlugin" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<mth name="/plugins/Java/JavaPlugin.java:default.JavaPlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<comm cntt="menus.addElement(GUIUtilities.loadMenu(&amp;quot;java_menu&amp;quot;));"/>
				<param name="parent"/>
				<param name="menus"/>
				<param name="menuItems"/>
			</mth>
			<mth name="/plugins/Java/JavaPlugin.java:default.JavaPlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/Java/JavaPlugin.java:default.JavaPlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/JavaPlugin.java:default.JavaPlugin.stop()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/Options.java:default">
		<class name="/plugins/Java/Options.java:default.Options" intfc="n" abs="n" inn="n" sloc="143" jdoc="">
			<comm cntt="(WHAT to display)"/>
			<comm cntt="(HOW to display)"/>
			<comm cntt="Options(): &amp;lt;init&amp;gt;"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="load(PropertyAccessor props): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="save(PropertyAccessor props): void"/>
			<comm cntt="Accessor methods"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="Other Object methods"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="========================================================================="/>
			<comm cntt="class Options.Display implements Options.DisplayIro"/>
			<comm cntt="========================================================================="/>
			<comm cntt="interface Options.DisplayIro"/>
			<comm cntt="========================================================================="/>
			<comm cntt="class Options.Filter implements Options.FilterIro {"/>
			<comm cntt="========================================================================="/>
			<comm cntt="interface Options.FilterIro"/>
			<field name="showStatusBar" access="priv" jdoc=""/>
			<field name="filterOpt" access="priv" jdoc=""/>
			<field name="displayOpt" access="priv" jdoc=""/>
			<field name="listener" access="priv" jdoc=""/>
			<mth name="/plugins/Java/Options.java:default.Options.Options()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options.getListener()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options.load(PropertyAccessor)" access="pub" jdoc="The method that sets the option object&amp;apos;s state to reflect the values specified by the passed PropertyAccessor.">
				<comm cntt="General Options"/>
				<comm cntt="Filter Options"/>
				<comm cntt="Display Options"/>
				<param name="props"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options.save(PropertyAccessor)" access="pub" jdoc="The method that sets the passed PropertyAccessor&amp;apos;s state to reflect the current state of this Options object.">
				<comm cntt="General Options"/>
				<comm cntt="----------------"/>
				<comm cntt="Filter Options"/>
				<comm cntt="---------------"/>
				<comm cntt="Visibility Level"/>
				<comm cntt="Display Options"/>
				<comm cntt="----------------"/>
				<comm cntt="Display Style"/>
				<comm cntt="Custom Style Options"/>
				<param name="props"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options.getShowStatusBar()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options.setShowStatusBar(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options.getFilterOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options.getDisplayOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options.addChangeListener(ChangeListener)" access="pub" jdoc="This is the method that is called in order to associate the JBrowse session&amp;apos;s ChangeListener with this Option object.">
				<comm cntt="there can only be one at this time"/>
				<param name="listener"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options.toString()" access="pub" jdoc="">
			</mth>
		<class name="/plugins/Java/Options.java:default.Options$Display" intfc="n" abs="n" inn="y" sloc="111" jdoc="">
			<comm cntt="Display Style options (HOW)"/>
			<comm cntt="Accessor methods"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="toString(): String"/>
			<field name="showArguments" access="priv" jdoc=""/>
			<field name="showArgumentNames" access="priv" jdoc=""/>
			<field name="showNestedName" access="priv" jdoc=""/>
			<field name="showIconKeywords" access="priv" jdoc=""/>
			<field name="showMiscMod" access="priv" jdoc=""/>
			<field name="alphaSort" access="priv" jdoc=""/>
			<field name="showLineNum" access="priv" jdoc=""/>
			<field name="styleIndex" access="priv" jdoc=""/>
			<field name="visSymbols" access="priv" jdoc=""/>
			<field name="abstractItalic" access="priv" jdoc=""/>
			<field name="staticUlined" access="priv" jdoc=""/>
			<field name="typeIsSuffixed" access="priv" jdoc=""/>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getShowArguments()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getShowArgumentNames()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getShowNestedName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getShowIconKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getShowMiscMod()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getAlphaSort()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getShowLineNum()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getStyleIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getVisSymbols()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getAbstractItalic()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getStaticUlined()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getTypeIsSuffixed()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setShowArguments(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setShowArgumentNames(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setShowNestedName(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setShowIconKeywords(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setShowMiscMod(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setAlphaSort(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setShowLineNum(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setStyleIndex(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setVisSymbols(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setAbstractItalic(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setStaticUlined(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.setTypeIsSuffixed(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.getInverseOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Display.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/Java/Options.java:default.Options$DisplayIro" intfc="y" abs="n" inn="y" sloc="21" jdoc="Options.DisplayIro - Interface for Accessing Display options for JBrowse">
			<comm cntt="Display Style options (HOW)"/>
			<comm cntt="constants - for styleIndex"/>
			<comm cntt="Accessor methods"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<const name="STYLE_FIRST" access="pub" jdoc=""/>
			<const name="STYLE_UML" access="pub" jdoc=""/>
			<const name="STYLE_JAVA" access="pub" jdoc=""/>
			<const name="STYLE_CUSTOM" access="pub" jdoc=""/>
			<const name="STYLE_LAST" access="pub" jdoc=""/>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getShowArguments()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getShowArgumentNames()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getShowNestedName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getShowIconKeywords()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getShowMiscMod()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getAlphaSort()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getShowLineNum()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getStyleIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getVisSymbols()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getAbstractItalic()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getStaticUlined()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getTypeIsSuffixed()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$DisplayIro.getInverseOptions()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/Java/Options.java:default.Options$Filter" intfc="n" abs="n" inn="y" sloc="49" jdoc="">
			<comm cntt="Filter options (WHAT)"/>
			<comm cntt="Accessor methods"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="toString(): String"/>
			<field name="showAttributes" access="priv" jdoc=""/>
			<field name="showPrimitives" access="priv" jdoc=""/>
			<field name="showGeneralizations" access="priv" jdoc=""/>
			<field name="showThrows" access="priv" jdoc=""/>
			<field name="topLevelVisIndex" access="priv" jdoc=""/>
			<field name="memberVisIndex" access="priv" jdoc=""/>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.getShowAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.getShowPrimitives()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.getShowGeneralizations()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.getShowThrows()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.getTopLevelVisIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.getMemberVisIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.setShowAttributes(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.setShowPrimitives(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.setShowGeneralizations(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.setShowThrows(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.setTopLevelVisIndex(int)" access="pub" jdoc="">
				<param name="level"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.setMemberVisIndex(int)" access="pub" jdoc="">
				<param name="level"/>
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$Filter.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/Java/Options.java:default.Options$FilterIro" intfc="y" abs="n" inn="y" sloc="9" jdoc="FilterIro - Interface for Accessing Filter options for JBrowse">
			<comm cntt="Filter options (WHAT)"/>
			<comm cntt="Accessor methods"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<mth name="/plugins/Java/Options.java:default.Options$FilterIro.getShowAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$FilterIro.getShowPrimitives()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$FilterIro.getShowGeneralizations()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$FilterIro.getShowThrows()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$FilterIro.getTopLevelVisIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/Options.java:default.Options$FilterIro.getMemberVisIndex()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/Java/PropertyAccessor.java:default">
		<class name="/plugins/Java/PropertyAccessor.java:default.PropertyAccessor" intfc="y" abs="n" inn="n" sloc="6" jdoc="">
			<comm cntt="public void load(InputStream inStream) throws IOException;"/>
			<mth name="/plugins/Java/PropertyAccessor.java:default.PropertyAccessor.getProperty(String)" access="pub" jdoc="Fetches a property, returning null if it&amp;apos;s not defined. @param name The property">
				<param name="name"/>
			</mth>
			<mth name="/plugins/Java/PropertyAccessor.java:default.PropertyAccessor.getProperty(String, String)" access="pub" jdoc="Fetches a property, returning the default value if it&amp;apos;s not defined. @param name The property @param def The default value">
				<param name="name"/>
				<param name="def"/>
			</mth>
			<mth name="/plugins/Java/PropertyAccessor.java:default.PropertyAccessor.getProperty(String, Object[])" access="pub" jdoc="Returns the property with the specified name, formatting it with the &amp;lt;code&amp;gt;java.text.MessageFormat.format()&amp;lt; code&amp;gt; method. @param name The property @param args The positional parameters">
				<param name="name"/>
				<param name="args"/>
			</mth>
			<mth name="/plugins/Java/PropertyAccessor.java:default.PropertyAccessor.setProperty(String, String)" access="pub" jdoc="Sets a property to a new value. @param name The property @param value The new value">
				<comm cntt="void???"/>
				<param name="name"/>
				<param name="value"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/RWModifier.java:default">
		<class name="/plugins/Java/RWModifier.java:default.RWModifier" intfc="n" abs="n" inn="n" sloc="202" jdoc="Read Write extension to java.lang.reflect.Modifier.">
			<comm cntt="for JDK 1.1.x (already in super for 1.2)"/>
			<comm cntt="custom extension to JDK Modifier spec."/>
			<comm cntt="nb associated token is: strictfp"/>
			<comm cntt="| STATIC except member classes"/>
			<comm cntt="nb associated token is: strictfp"/>
			<comm cntt="constants - for visibility indicies"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="Accessors - getters for RWModifier extensions"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="Accessors - set bit ON"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="Accessors - set bit ON OFF by parameter"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="static toString(int, Options.DisplayIro): String"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="static getVisLevelIndex(int): int"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="static getTopLevelVisIndex(int): int"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="static getMemberVisIndex(int): int"/>
			<const name="STRICT" access="priv" jdoc=""/>
			<const name="CLASS" access="priv" jdoc=""/>
			<const name="NO_MODIFIERS" access="priv" jdoc=""/>
			<const name="ALL_MODIFIERS" access="priv" jdoc="Defines the set of all valid modifiers."/>
			<const name="VALID_FOR_CLASS" access="priv" jdoc="defines the set of modifiers that are valid for a class or interface."/>
			<const name="INVALID_FOR_CONSTRUCTOR" access="priv" jdoc="defines the set of modifiers that are invalid for constructor methods."/>
			<const name="INVALID_FOR_ABSTRACT_METHOD" access="priv" jdoc="defines the set of modifiers that are invalid for a method that has been defined as abstract."/>
			<const name="INVALID_FOR_INTERFACE_METHOD" access="priv" jdoc="defines the set of modifiers that are invalid for a method defined in an interface."/>
			<const name="TOPLEVEL_VIS_PACKAGE" access="pub" jdoc=""/>
			<const name="TOPLEVEL_VIS_PUBLIC" access="pub" jdoc=""/>
			<const name="MEMBER_VIS_PRIVATE" access="pub" jdoc=""/>
			<const name="MEMBER_VIS_PACKAGE" access="pub" jdoc=""/>
			<const name="MEMBER_VIS_PROTECTED" access="pub" jdoc=""/>
			<const name="MEMBER_VIS_PUBLIC" access="pub" jdoc=""/>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.isStrict(int)" access="pub" jdoc="">
				<comm cntt="for JDK 1.1.x (already in super for 1.2)"/>
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.isClass(int)" access="pub" jdoc="">
				<comm cntt="custom extension to JDK Modifier spec."/>
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.isClassOrInterface(int)" access="pub" jdoc="">
				<comm cntt="custom extension to JDK Modifier spec."/>
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setClass(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setAbstract(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setFinal(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setInterface(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setNative(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setPrivate(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setProtected(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setPublic(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setStatic(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setStrict(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setSynchronized(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setTransient(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setVolatile(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setClass(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setAbstract(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setFinal(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setInterface(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setNative(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setPrivate(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setProtected(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setPublic(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setStatic(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setStrict(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setSynchronized(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setTransient(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.setVolatile(int, boolean)" access="pub" jdoc="">
				<param name="mod"/>
				<param name="setFlag"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.isValidForClass(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.isValidForConstructor(int)" access="pub" jdoc="Note: !isClassOrInterface(int mod) is assumed.">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.isValidInterfaceMethod(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.isValidAbstractMethod(int)" access="pub" jdoc="">
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.toString(int, Options.DisplayIro)" access="pub" jdoc="">
				<comm cntt="static abstract final volatile transient synchronized native strictfp"/>
				<param name="mod"/>
				<param name="displayOpt"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.getVisLevelIndex(int)" access="pub" jdoc="">
				<comm cntt="package"/>
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.getTopLevelVisIndex(int)" access="pub" jdoc="">
				<comm cntt="else if ( isProtected(mod) ) error"/>
				<comm cntt="else if ( isPrivate(mod) ) error"/>
				<comm cntt="package"/>
				<param name="mod"/>
			</mth>
			<mth name="/plugins/Java/RWModifier.java:default.RWModifier.getMemberVisIndex(int)" access="pub" jdoc="">
				<comm cntt="package"/>
				<param name="mod"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Java/TokenSource.java:default">
		<class name="/plugins/Java/TokenSource.java:default.TokenSource" intfc="n" abs="n" inn="n" sloc="201" jdoc="">
			<comm cntt="Private Attributes"/>
			<comm cntt="whitespace"/>
			<comm cntt="the current position within the tokenizer&amp;apos;s line"/>
			<comm cntt="(i.e. the position of the start of the current token.)"/>
			<comm cntt="offset of tokenizer&amp;apos;s line start from source line&amp;apos;s start."/>
			<comm cntt="set each time getNextToken() is called"/>
			<comm cntt="Accessor methods"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="TokenSource(): &amp;lt;init&amp;gt;"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="TokenSource(): &amp;lt;init&amp;gt;"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="getNextLine(): String"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="Returns next token, null if source is exhausted. Automatically skips"/>
			<comm cntt="white space, single and multi-line comments and strings."/>
			<comm cntt="getNextToken(): String"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="skipRestOfLine(): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="Skip subsequent tokens until the specified token is found (while taking"/>
			<comm cntt="into acount matching of parenthesis and braces) and then return true."/>
			<comm cntt="If the token is not found before the source is exhausted or unbalanced"/>
			<comm cntt="braces or parentheses are encountered return false."/>
			<comm cntt="skipUntil(String): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="Skip subsequent tokens until the a token is found that matches one of"/>
			<comm cntt="the tokens in the argument array (while taking into acount matching of"/>
			<comm cntt="parenthesis and braces) and then return the matched token."/>
			<comm cntt="If a match is not found before the source is exhausted or unbalanced"/>
			<comm cntt="braces or parentheses are encountered return null. If the passed array"/>
			<comm cntt="length == 0 also returns null."/>
			<comm cntt="skipUntil(Char[]): String"/>
			<comm cntt="========================================================================="/>
			<comm cntt="static class Exception"/>
			<field name="ls" access="priv" jdoc=""/>
			<const name="DELIM" access="priv" jdoc=""/>
			<field name="currentLineNum" access="priv" jdoc=""/>
			<field name="currentPos" access="priv" jdoc=""/>
			<field name="tokenizerOffset" access="priv" jdoc=""/>
			<field name="lineString" access="priv" jdoc=""/>
			<field name="currentToken" access="priv" jdoc=""/>
			<field name="st" access="priv" jdoc=""/>
			<field name="debugLevel" access="priv" jdoc=""/>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.getCurrentLineNum()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.getCurrentPos()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.getCurrentLine()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.TokenSource(JBrowseParser.LineSource)" access="pub" jdoc="Construct a TokenSource (with debugging off)">
				<param name="ls"/>
			</mth>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.TokenSource(JBrowseParser.LineSource, int)" access="pub" jdoc="Construct a TokenSource (with the specified debugging level)">
				<param name="ls"/>
				<param name="debugLevel"/>
			</mth>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.getNextLine()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.getNextToken()" access="pub" jdoc="">
				<comm cntt="update currentPos to after last token"/>
				<comm cntt="assume it will start on same line"/>
				<comm cntt="skip to next line with tokens"/>
				<comm cntt="handle the token"/>
				<comm cntt="% if appropriate display each token at this point"/>
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot; + currentLineNum + &amp;quot;-&amp;quot; + currentPos"/>
				<comm cntt="% + &amp;quot; (+&amp;quot; + tokenizerOffset + &amp;quot;) :&amp;quot; + currentToken);"/>
				<comm cntt="% }"/>
				<comm cntt="handle chars, find end of char"/>
				<comm cntt="to be precise should check if we do in fact define a single char ???,"/>
				<comm cntt="currently insures we have a valid string of chars."/>
				<comm cntt="% System.out.println(&amp;quot;ERROR: Line has unmatched &amp;apos;, will return &amp;apos; and attempt to continue.&amp;quot;);"/>
				<comm cntt="while (true)"/>
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;found string: &amp;quot; + currentToken);"/>
				<comm cntt="% }"/>
				<comm cntt="handle strings, find next unescaped double-quote (&amp;quot;)"/>
				<comm cntt="% System.out.println(&amp;quot;ERROR: Line has unmatched \&amp;quot;, will return \&amp;quot; and attempt to continue.&amp;quot;);"/>
				<comm cntt="while (true)"/>
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;found string: &amp;quot; + currentToken);"/>
				<comm cntt="% }"/>
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;\tchar at currentPos+tokenizerOffset+1 (&amp;quot; + (pos+1) + &amp;quot;) &amp;quot;"/>
				<comm cntt="% + lineString.charAt(pos+1)); debug"/>
				<comm cntt="% }"/>
				<comm cntt="check for &amp;apos; &amp;apos; or &amp;apos; &amp;apos; as next char on this line"/>
				<comm cntt="start of single line comment"/>
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;found single-line comment: &amp;quot; + lineString);"/>
				<comm cntt="% }"/>
				<comm cntt="prepare to get next token (on a subsequent line)"/>
				<comm cntt="start of mult-line comment"/>
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;found multi-line comment: &amp;quot; + lineString);"/>
				<comm cntt="% }"/>
				<comm cntt="find terminating &amp;quot; &amp;quot;"/>
				<comm cntt="skip lines until found"/>
				<comm cntt="not very nice, this may happen if we end with"/>
				<comm cntt="an unterminated comment."/>
				<comm cntt="will start tokenizer within this new line"/>
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;found end of multi-line comment.&amp;quot;);"/>
				<comm cntt="% }"/>
				<comm cntt="found at end of current line"/>
				<comm cntt="will start tokenizer on next line"/>
				<comm cntt="not very nice, this may happen if we end with"/>
				<comm cntt="a comment."/>
				<comm cntt="System.out.println(&amp;quot;warning: file ends with a multi-line comment.&amp;quot;);"/>
				<comm cntt="reconfigure tokenizer"/>
				<comm cntt="if"/>
				<comm cntt="if"/>
				<comm cntt="switch(c)"/>
				<comm cntt="if"/>
				<comm cntt="while (true)"/>
				<comm cntt="% System.out.println(&amp;quot;getNextToken() - returns: &amp;quot; + currentToken);"/>
			</mth>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.skipRestOfLine()" access="pub" jdoc="">
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;TokenSource.skipRestOfLine() called&amp;quot;);"/>
				<comm cntt="% }"/>
				<comm cntt="need to ensure that we have exhausted the last line"/>
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;Exhausting last line: &amp;quot;"/>
				<comm cntt="% + st.nextToken());"/>
				<comm cntt="% } else {"/>
				<comm cntt="% }"/>
				<comm cntt="% if (debugLevel &amp;gt;= 12) {"/>
				<comm cntt="% System.out.println(&amp;quot;Finished exhausting last line.&amp;quot;);"/>
				<comm cntt="% }"/>
			</mth>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.skipUntil(String)" access="pub" jdoc="">
				<comm cntt="% if (debugLevel &amp;gt; 7) {"/>
				<comm cntt="% System.out.println(&amp;quot;Skipped to &amp;apos;&amp;quot; + skipToToken + &amp;quot;&amp;apos;: &amp;quot;"/>
				<comm cntt="% + getCurrentLineNum() + &amp;quot;-&amp;quot; + getCurrentPos() );"/>
				<comm cntt="% }"/>
				<comm cntt="while"/>
				<comm cntt="% if (debugLevel &amp;gt; 0) {"/>
				<comm cntt="% System.out.println(&amp;quot;WARNING: failed to skip to &amp;apos;&amp;quot; + skipToToken"/>
				<comm cntt="% + &amp;quot;&amp;apos;: &amp;quot; + getCurrentLineNum() + &amp;quot;-&amp;quot; + getCurrentPos() );"/>
				<comm cntt="% }"/>
				<param name="skipToToken"/>
			</mth>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource.skipUntil(char[])" access="pub" jdoc="">
				<comm cntt="i.e. token found within balanced context"/>
				<comm cntt="while"/>
				<param name="skipToChars"/>
			</mth>
		<class name="/plugins/Java/TokenSource.java:default.TokenSource$Exception" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<const name="MESSAGE_UNTERM_COMMENT" access="pub" jdoc=""/>
			<const name="MESSAGE_STRING_EXPR" access="pub" jdoc=""/>
			<const name="MESSAGE_CHAR_EXPR" access="pub" jdoc=""/>
			<mth name="/plugins/Java/TokenSource.java:default.TokenSource$Exception.Exception(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/Java/UML.java:default">
		<class name="/plugins/Java/UML.java:default.UML" intfc="n" abs="n" inn="n" sloc="3" jdoc="">
		<class name="/plugins/Java/UML.java:default.UML$Type" intfc="n" abs="n" inn="y" sloc="32" jdoc="">
			<comm cntt="use POSSIBLE_VALUES to build an iterator"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<const name="CLASS" access="pub" jdoc=""/>
			<const name="INTERFACE" access="pub" jdoc=""/>
			<const name="INNER_CLASS" access="pub" jdoc=""/>
			<const name="METHOD" access="pub" jdoc=""/>
			<const name="ATTRIBUTE" access="pub" jdoc=""/>
			<const name="EXTENDS" access="pub" jdoc=""/>
			<const name="IMPLEMENTS" access="pub" jdoc=""/>
			<const name="THROWS" access="pub" jdoc=""/>
			<const name="ERROR" access="pub" jdoc=""/>
			<const name="POSSIBLE_VALUES" access="pub" jdoc=""/>
			<field name="label" access="prot" jdoc=""/>
			<field name="icon" access="prot" jdoc=""/>
			<mth name="/plugins/Java/UML.java:default.UML$Type.Type(String, ImageIcon)" access="priv" jdoc="">
				<param name="label"/>
				<param name="icon"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Type.getIcon()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Type.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/Java/UML.java:default.UML$Element" intfc="n" abs="n" inn="y" sloc="41" jdoc="">
			<comm cntt="The class which all elements that are to be displayed in a UMLTree"/>
			<comm cntt="must inherit from."/>
			<comm cntt="protected int canonicalMod = 0;"/>
			<comm cntt="??? later use canonical modifier"/>
			<field name="name" access="prot" jdoc=""/>
			<field name="type" access="prot" jdoc=""/>
			<field name="mod" access="prot" jdoc=""/>
			<field name="parent" access="prot" jdoc=""/>
			<field name="line" access="prot" jdoc=""/>
			<mth name="/plugins/Java/UML.java:default.UML$Element.Element(String, UML.Type, int, Element, int)" access="pub" jdoc="">
				<comm cntt="canonicalMod ="/>
				<param name="name"/>
				<param name="type"/>
				<param name="mod"/>
				<param name="parent"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.Element(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.getElementType()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.setElementType(UML.Type)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.getParentElement()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.setParentElement(Element)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.getParentElementType()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.setName(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.toString(Options.DisplayIro)" access="pub" jdoc="">
				<param name="displayOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.isVisible(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.isAbstract()" access="pub" jdoc="">
				<comm cntt="final"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.isStatic()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.isInterface()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Element.isClass()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/Java/UML.java:default.UML$PackageMember" intfc="n" abs="n" inn="y" sloc="22" jdoc="">
			<comm cntt="A top-level package member (i.e. class interface that is a"/>
			<comm cntt="direct member of a package)"/>
			<comm cntt="toString(Options.DisplayIro): String"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="isVisible(Options.FilterIro): boolean"/>
			<mth name="/plugins/Java/UML.java:default.UML$PackageMember.PackageMember(String, UML.Type, int, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="mod"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$PackageMember.toString(Options.DisplayIro)" access="pub" jdoc="">
				<param name="displayOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$PackageMember.isVisible(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
		</class>
		<class name="/plugins/Java/UML.java:default.UML$NestedMember" intfc="n" abs="n" inn="y" sloc="27" jdoc="">
			<comm cntt="A top-level package member (i.e. class interface that is a"/>
			<comm cntt="direct member of a package)"/>
			<comm cntt="toString(Options.DisplayIro): String"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="isVisible(Options.FilterIro): boolean"/>
			<mth name="/plugins/Java/UML.java:default.UML$NestedMember.NestedMember(String, UML.Type, int, Element, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="mod"/>
				<param name="parent"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$NestedMember.toString(Options.DisplayIro)" access="pub" jdoc="">
				<param name="displayOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$NestedMember.isVisible(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
		</class>
		<class name="/plugins/Java/UML.java:default.UML$Generalization" intfc="n" abs="n" inn="y" sloc="23" jdoc="">
			<comm cntt="A top-level package member (i.e. class interface that is a"/>
			<comm cntt="direct member of a package)"/>
			<comm cntt="toString(Options.DisplayIro): String"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="isVisible(Options.FilterIro): boolean"/>
			<mth name="/plugins/Java/UML.java:default.UML$Generalization.Generalization(String, UML.Type, Element, int)" access="pub" jdoc="">
				<comm cntt="(String name, UML.Type type, int mod, Element parent, int line)"/>
				<param name="name"/>
				<param name="type"/>
				<param name="parent"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Generalization.toString(Options.DisplayIro)" access="pub" jdoc="">
				<param name="displayOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Generalization.isVisible(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
		</class>
		<class name="/plugins/Java/UML.java:default.UML$Message" intfc="n" abs="n" inn="y" sloc="16" jdoc="">
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="toString(Options.DisplayIro): String"/>
			<mth name="/plugins/Java/UML.java:default.UML$Message.Message(String, UML.Type, Element, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="parent"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Message.isVisible(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Message.toString(Options.DisplayIro)" access="pub" jdoc="">
				<param name="displayOpt"/>
			</mth>
		</class>
		<class name="/plugins/Java/UML.java:default.UML$Operation" intfc="n" abs="n" inn="y" sloc="69" jdoc="">
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="isVisible(Options.FilterIro): boolean"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="listArgs(Options.DisplayIro): String"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="toString(Options.DisplayIro): String"/>
			<comm cntt="====================================================================="/>
			<comm cntt="class UML.Operation.Argument"/>
			<field name="returnType" access="priv" jdoc=""/>
			<field name="argList" access="priv" jdoc=""/>
			<field name="isConstructor" access="priv" jdoc=""/>
			<mth name="/plugins/Java/UML.java:default.UML$Operation.Operation(String, String, int, Element, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="returnType"/>
				<param name="mod"/>
				<param name="parent"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation.addArgument(String, String)" access="pub" jdoc="">
				<comm cntt="for JDK 1.2 can use argList.add(Object)"/>
				<param name="type"/>
				<param name="name"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation.isConstructor()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation.setConstructor(boolean)" access="pub" jdoc="">
				<param name="isConstructor"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation.isAbstract()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation.isBodyRequired()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation.isVisible(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation.listArgs(Options.DisplayIro)" access="pub" jdoc="">
				<comm cntt="for JDK 1.2 can use argList.get(int)"/>
				<comm cntt="for JDK 1.2 can use argList.get(int)"/>
				<comm cntt="for"/>
				<param name="displayOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation.toString(Options.DisplayIro)" access="pub" jdoc="">
				<param name="displayOpt"/>
			</mth>
		<class name="/plugins/Java/UML.java:default.UML$Operation$Argument" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<comm cntt="toString(Options.DisplayIro): String"/>
			<field name="type" access="priv" jdoc=""/>
			<field name="name" access="priv" jdoc=""/>
			<mth name="/plugins/Java/UML.java:default.UML$Operation$Argument.Argument(String, String)" access="pub" jdoc="">
				<param name="type"/>
				<param name="name"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation$Argument.toString(Options.DisplayIro)" access="pub" jdoc="">
				<param name="displayOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Operation$Argument.getType()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/plugins/Java/UML.java:default.UML$Throws" intfc="n" abs="n" inn="y" sloc="19" jdoc="">
			<comm cntt="A top-level package member (i.e. class interface that is a"/>
			<comm cntt="direct member of a package)"/>
			<comm cntt="toString(Options.DisplayIro): String"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="isVisible(Options.FilterIro): boolean"/>
			<mth name="/plugins/Java/UML.java:default.UML$Throws.Throws(String, Element, int)" access="pub" jdoc="">
				<comm cntt="(String name, UML.Type type, int mod, Element parent, int line)"/>
				<param name="name"/>
				<param name="parent"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Throws.toString(Options.DisplayIro)" access="pub" jdoc="">
				<param name="displayOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Throws.isVisible(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
		</class>
		<class name="/plugins/Java/UML.java:default.UML$Attribute" intfc="n" abs="n" inn="y" sloc="43" jdoc="">
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="isVisible(Options.FilterIro): boolean"/>
			<comm cntt="toString(): String"/>
			<comm cntt="toString(Options.DisplayIro): String"/>
			<field name="type" access="priv" jdoc=""/>
			<const name="PRIMITIVE_TYPES" access="pub" jdoc=""/>
			<mth name="/plugins/Java/UML.java:default.UML$Attribute.Attribute(String, String, int, Element, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="mod"/>
				<param name="parent"/>
				<param name="line"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Attribute.isAbstract()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Attribute.isPrimitive()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Attribute.isVisible(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Attribute.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UML.java:default.UML$Attribute.toString(Options.DisplayIro)" access="pub" jdoc="">
				<param name="displayOpt"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/Java/UMLTree.java:default">
		<class name="/plugins/Java/UMLTree.java:default.UMLTree" intfc="n" abs="n" inn="n" sloc="42" jdoc="">
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="UMLTree(TreeModel): &amp;lt;init&amp;gt;"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="display(TreeModel, Options, JBrowseParser.Results): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt=""/>
			<comm cntt="This updates only the nodes that are currently visible in the JTree."/>
			<comm cntt="This is the method that is called whenever the display options have"/>
			<comm cntt="changed on the currently parsed and displayed UMLTree."/>
			<comm cntt=""/>
			<comm cntt="public void updateVisible(Options options)"/>
			<comm cntt="{"/>
			<comm cntt="int lastRow = getRowCount() - 1;"/>
			<comm cntt="Model tm = (Model) getModel();"/>
			<comm cntt=""/>
			<comm cntt="if (lastRow &amp;gt; 200 ) {"/>
			<comm cntt="System.out.println(&amp;quot;Too many rows to update individually (&amp;quot; + lastRow + &amp;quot;) will reload.&amp;quot;);"/>
			<comm cntt="display(tm, options);"/>
			<comm cntt="return;"/>
			<comm cntt="}"/>
			<comm cntt=""/>
			<comm cntt="System.out.println(&amp;quot;getRowCount(): &amp;quot; + getRowCount() + &amp;quot;, getVisibleRowCount(): &amp;quot; + getVisibleRowCount());"/>
			<comm cntt="System.out.println(&amp;quot;Will update &amp;quot; + lastRow + &amp;quot; rows&amp;quot;);"/>
			<comm cntt=""/>
			<comm cntt="Options.FilterIro filterOpt = options.getFilterOptions();"/>
			<comm cntt="TreeNode parent = null;"/>
			<comm cntt="Object[] cChildren = new Object[1];"/>
			<comm cntt="int[] childIndices = new int[1];"/>
			<comm cntt=""/>
			<comm cntt="for (int i = 0; i &amp;lt;= lastRow; i++) {"/>
			<comm cntt=""/>
			<comm cntt="Node node = (Node) getPathForRow(i).getLastPathComponent();"/>
			<comm cntt=""/>
			<comm cntt="parent = node.getParent();"/>
			<comm cntt="int anIndex = node.getVisibleIndex(filterOpt);"/>
			<comm cntt=""/>
			<comm cntt="if(anIndex != -1) {"/>
			<comm cntt=""/>
			<comm cntt="i.e. is a visible child"/>
			<comm cntt="childIndices[0] = anIndex;"/>
			<comm cntt="cChildren[0] = node;"/>
			<comm cntt=""/>
			<comm cntt="tm.fireTreeNodesChanged(parent, childIndices, cChildren);"/>
			<comm cntt=""/>
			<comm cntt="tm.nodesChanged(parent, childIndices);"/>
			<comm cntt="}"/>
			<comm cntt="}"/>
			<comm cntt="} updateVisible(Node): void"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="updateVisibleToggled(Node): void"/>
			<comm cntt="========================================================================="/>
			<comm cntt="public class InvisibleTreeModel extends DefaultTreeModel"/>
			<comm cntt="========================================================================="/>
			<comm cntt="class UMLTree.Node extends DefaultMutableTreeNode"/>
			<comm cntt="========================================================================="/>
			<comm cntt="class UMLTree.CellRenderer extends DefaultTreeCellRenderer"/>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree.UMLTree()" access="pub" jdoc="Constructor for a UMLTree, automatically sets the new UMLTree&amp;apos;s associated UMLModel to null.">
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree.display(Model, Options, JBrowseParser.Results)" access="pub" jdoc="This is the method that is called whenever the results of a new parse need to be displayed, or when filter options have changed on the currently parsed and displayed UMLTree.">
				<param name="tm"/>
				<param name="options"/>
				<param name="results"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree.updateVisibleToggled(Options)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;updateVisibleToggled called for root path: &amp;quot; + aPath);"/>
				<comm cntt="System.out.println( aPath );"/>
				<param name="options"/>
			</mth>
		<class name="/plugins/Java/UMLTree.java:default.UMLTree$Model" intfc="n" abs="n" inn="y" sloc="38" jdoc="">
			<comm cntt="Overrides:"/>
			<comm cntt="getChild() &amp; getChildCount()"/>
			<comm cntt="Constructors"/>
			<comm cntt="Filter state accessors"/>
			<comm cntt="Overridded methods to provide InvisibleTreeModel behaviour"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt=""/>
			<comm cntt="This method updates the immediate children of the passed node. It works"/>
			<comm cntt="well but is very slow on large trees, you should seriously"/>
			<comm cntt="consider using the associated UMLTree&amp;apos;s updateVisible() method"/>
			<comm cntt="instead."/>
			<comm cntt=""/>
			<comm cntt="public void updateVisibleChildren(Node parent)"/>
			<comm cntt="{"/>
			<comm cntt="for(int i = 0; i &amp;lt; parent.getChildCount(filterOpt); i++ ) {"/>
			<comm cntt="Node child = parent.getChildAt(i, filterOpt);"/>
			<comm cntt="nodeChanged(child);"/>
			<comm cntt="if ( child.getChildCount(filterOpt) &amp;gt; 0 ) {"/>
			<comm cntt="updateChildren(child);"/>
			<comm cntt="}"/>
			<comm cntt="}"/>
			<comm cntt=""/>
			<comm cntt="} updateVisibleChildren(Node): void"/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt=""/>
			<comm cntt="This method updates all children of the passed node. That are not"/>
			<comm cntt="invisible (although they may not be in the curently displayed portion"/>
			<comm cntt="of the JTree."/>
			<comm cntt="It works well but is very slow on large trees, you should seriously"/>
			<comm cntt="consider using the associated UMLTree&amp;apos;s updateVisible() method"/>
			<comm cntt="instead."/>
			<comm cntt=""/>
			<comm cntt="public void updateVisibleChildren(Node parent)"/>
			<comm cntt="{"/>
			<comm cntt="for(int i = 0; i &amp;lt; parent.getChildCount(filterOpt); i++ ) {"/>
			<comm cntt="Node child = parent.getChildAt(i, filterOpt);"/>
			<comm cntt="nodeChanged(child);"/>
			<comm cntt="if ( child.getChildCount(filterOpt) &amp;gt; 0 ) {"/>
			<comm cntt="updateVisibleChildren(child);"/>
			<comm cntt="}"/>
			<comm cntt="}"/>
			<comm cntt=""/>
			<comm cntt="} updateVisibleChildren(Node): void"/>
			<field name="filterOpt" access="priv" jdoc=""/>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Model.Model(TreeNode)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Model.setFilterOptions(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Model.getFilterOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Model.fireTreeNodesChanged(TreeNode, int[], Object[])" access="pub" jdoc="">
				<param name="parent"/>
				<param name="childIndices"/>
				<param name="children"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Model.getChild(Object, int)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="index"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Model.getChildCount(Object)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Model.isLeaf(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
		</class>
		<class name="/plugins/Java/UMLTree.java:default.UMLTree$Node" intfc="n" abs="n" inn="y" sloc="176" jdoc="">
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="getPathFrom(Node): TreePath"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="public String getName() { implement later"/>
			<comm cntt="return userObject.toString();"/>
			<comm cntt="}"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="getVisibleIndex(int, Options.FilterIro): int"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="public int getVisibleIndex(Options.FilterIro filterOpt)"/>
			<comm cntt="{"/>
			<comm cntt="TreeNode parent = this.getParent();"/>
			<comm cntt="if(parent == null) return -1;"/>
			<comm cntt=""/>
			<comm cntt="int visibleIndex = -1;"/>
			<comm cntt="Enumeration enum = parent.children();"/>
			<comm cntt=""/>
			<comm cntt="while (enum.hasMoreElements()) {"/>
			<comm cntt="Node curNode = (Node) enum.nextElement();"/>
			<comm cntt="Object nodeObject = curNode.userObject;"/>
			<comm cntt="if ( ( (UML.Element) nodeObject).isVisible(filterOpt) ) {"/>
			<comm cntt="visibleIndex++;"/>
			<comm cntt="if (curNode == this) return visibleIndex;"/>
			<comm cntt="}"/>
			<comm cntt=""/>
			<comm cntt="if (curNode == this) return -1;"/>
			<comm cntt="}"/>
			<comm cntt=""/>
			<comm cntt="throw new ArrayIndexOutOfBoundsException(&amp;quot;index unmatched&amp;quot;);"/>
			<comm cntt=""/>
			<comm cntt="} getVisibleIndex(int, Options.FilterIro): int"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="getVisibleChildrenObject(Options.FilterIro): Object[]"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<comm cntt="---------------------------------------------------------------------"/>
			<field name="pos" access="priv" jdoc=""/>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.Node(UML.Element)" access="pub" jdoc="">
				<param name="userObject"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.Node(String)" access="pub" jdoc="">
				<param name="userObject"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.setPosition(Object)" access="pub" jdoc="">
				<param name="pos"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.getPosition()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.alphaSort()" access="pub" jdoc="">
				<comm cntt="end try"/>
				<comm cntt="end if class or interface"/>
				<comm cntt="end catch"/>
				<comm cntt="end for i . . ."/>
				<comm cntt="end for j . . ."/>
				<comm cntt="end if children != null &amp;&amp; children.size() &amp;gt; 0"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.getPathFrom(Node)" access="pub" jdoc="Returns the TreePath from the specified ancestor Node to this node.">
				<comm cntt="patch for jdk1.1"/>
				<comm cntt="pathList.add(curNode); jdk1.2 only ???"/>
				<comm cntt="for JDK 1.1"/>
				<comm cntt="for JDI 1.2"/>
				<comm cntt="return new TreePath( pathList.toArray() );"/>
				<param name="ancestor"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.isVisible(Options.FilterIro)" access="pub" jdoc="">
				<param name="filterOpt"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.getElement()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.getElementType()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.setName(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.getVisibleIndex(Options.FilterIro)" access="pub" jdoc="Returns visible index of the current node, or -1 if it is not visible based on the specified filter options.">
				<param name="filterOpt"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.getVisibleChildrenObject(Options.FilterIro)" access="pub" jdoc="Creates and returns a forward-order enumeration of this node&amp;apos;s visible children. @return an Enumeration of this node&amp;apos;s visible children">
				<param name="filterOpt"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.getChildAt(int, Options.FilterIro)" access="pub" jdoc="Returns the child of this node with the specified visible index based on the specified filter options.">
				<param name="index"/>
				<param name="filterOpt"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$Node.getChildCount(Options.FilterIro)" access="pub" jdoc="Returns a count of the number of visible children of this node based on the specified filter options.">
				<param name="filterOpt"/>
			</mth>
		</class>
		<class name="/plugins/Java/UMLTree.java:default.UMLTree$CellRenderer" intfc="n" abs="n" inn="y" sloc="66" jdoc="">
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean): Component"/>
			<comm cntt="-------------------------------------------------------------------------"/>
			<comm cntt="paintComponent(Graphics) void"/>
			<field name="standardFont" access="priv" jdoc=""/>
			<field name="italicFont" access="priv" jdoc=""/>
			<field name="isUnderlined" access="priv" jdoc=""/>
			<field name="options" access="priv" jdoc=""/>
			<field name="inverseOptions" access="priv" jdoc=""/>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$CellRenderer.CellRenderer(Options.DisplayIro)" access="pub" jdoc="">
				<param name="options"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$CellRenderer.getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)" access="pub" jdoc="">
				<comm cntt="label"/>
				<comm cntt="tips"/>
				<comm cntt="if ( options.getAbstractItalic() &amp;&amp; e.isAbstract() ) {"/>
				<comm cntt="lab.setFont( italicFont );"/>
				<comm cntt="tree.setFont( italicFont );"/>
				<comm cntt=""/>
				<comm cntt="} else {"/>
				<comm cntt="lab.setFont( standardFont );"/>
				<comm cntt="tree.setFont( standardFont );"/>
				<comm cntt="}"/>
				<comm cntt="icon"/>
				<comm cntt="for strings (e.g. root)"/>
				<param name="tree"/>
				<param name="value"/>
				<param name="sel"/>
				<param name="expanded"/>
				<param name="leaf"/>
				<param name="row"/>
				<param name="hasFocus"/>
			</mth>
			<mth name="/plugins/Java/UMLTree.java:default.UMLTree$CellRenderer.paintComponent(Graphics)" access="prot" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/KLNF/:com.incors.plaf">
		<class name="/plugins/KLNF/:com.incors.plaf.FastGradientPaint" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<field name="startColor" access="pub" jdoc=""/>
			<field name="endColor" access="pub" jdoc=""/>
			<field name="isVertical" access="pub" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaint.FastGradientPaint(Color, Color, boolean)" access="pub" jdoc="">
				<param name="sc"/>
				<param name="ec"/>
				<param name="isV"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaint.createContext(ColorModel, Rectangle, Rectangle2D, AffineTransform, RenderingHints)" access="pub" jdoc="">
				<param name="cm"/>
				<param name="r"/>
				<param name="r2d"/>
				<param name="xform"/>
				<param name="hints"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaint.getTransparency()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2" intfc="n" abs="n" inn="n" sloc="89" jdoc="">
			<comm cntt="constructors"/>
			<comm cntt="non static methods"/>
			<field name="myColor" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.ColorUIResource2(Color)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.ColorUIResource2(int, int, int)" access="pub" jdoc="">
				<param name="r"/>
				<param name="g"/>
				<param name="b"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.ColorUIResource2(int, int, int, int)" access="pub" jdoc="">
				<param name="r"/>
				<param name="g"/>
				<param name="b"/>
				<param name="a"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.ColorUIResource2(int)" access="pub" jdoc="">
				<param name="rgb"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.ColorUIResource2(int, boolean)" access="pub" jdoc="">
				<param name="rgba"/>
				<param name="hasalpha"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.ColorUIResource2(float, float, float)" access="pub" jdoc="">
				<param name="r"/>
				<param name="g"/>
				<param name="b"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.ColorUIResource2(float, float, float, float)" access="pub" jdoc="">
				<param name="r"/>
				<param name="g"/>
				<param name="b"/>
				<param name="alpha"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getRed()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getGreen()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getBlue()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getAlpha()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getRGB()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.brighter()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.darker()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.equals(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getRGBComponents(float[])" access="pub" jdoc="">
				<param name="compArray"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getRGBColorComponents(float[])" access="pub" jdoc="">
				<param name="compArray"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getComponents(float[])" access="pub" jdoc="">
				<param name="compArray"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getColorComponents(float[])" access="pub" jdoc="">
				<param name="compArray"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getComponents(ColorSpace, float[])" access="pub" jdoc="">
				<param name="cspace"/>
				<param name="compArray"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getColorComponents(ColorSpace, float[])" access="pub" jdoc="">
				<param name="cspace"/>
				<param name="compArray"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getColorSpace()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.createContext(ColorModel, Rectangle, Rectangle2D, AffineTransform, RenderingHints)" access="pub" jdoc="">
				<param name="cm"/>
				<param name="r"/>
				<param name="r2d"/>
				<param name="xform"/>
				<param name="hints"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.ColorUIResource2.getTransparency()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext" intfc="n" abs="n" inn="n" sloc="41" jdoc="">
			<field name="gradientCache" access="priv" jdoc=""/>
			<field name="recentInfos" access="priv" jdoc=""/>
			<field name="info" access="pub" jdoc=""/>
			<field name="parallelDevicePos" access="pub" jdoc=""/>
			<field name="gradient" access="pub" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext.FastGradientPaintContext(ColorModel, Rectangle, int, int, boolean)" access="pub" jdoc="">
				<comm cntt="System.out.println( &amp;quot;Storing gradient in cache. Info: &amp;quot; + info.toString() );"/>
				<param name="cm"/>
				<param name="r"/>
				<param name="sc"/>
				<param name="ec"/>
				<param name="ver"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext.dispose()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext.getColorModel()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext.getRaster(int, int, int, int)" access="pub" jdoc="">
				<param name="x"/>
				<param name="y"/>
				<param name="w"/>
				<param name="h"/>
			</mth>
		<class name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext$GradientInfo" intfc="n" abs="n" inn="y" sloc="17" jdoc="">
			<field name="model" access="pub" jdoc=""/>
			<field name="parallelLength" access="pub" jdoc=""/>
			<field name="startColor" access="pub" jdoc=""/>
			<field name="endColor" access="pub" jdoc=""/>
			<field name="isVertical" access="pub" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext$GradientInfo.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext$GradientInfo.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext$GradientInfo.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext$Gradient" intfc="n" abs="n" inn="y" sloc="51" jdoc="">
			<field name="info" access="pub" jdoc=""/>
			<field name="perpendicularLength" access="pub" jdoc=""/>
			<field name="raster" access="pub" jdoc=""/>
			<field name="childRasterCache" access="pub" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext$Gradient.Gradient(GradientInfo)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext$Gradient.getRaster(int, int, int)" access="priv" jdoc="">
				<comm cntt="System.out.println( &amp;quot;Storing child raster in cache. Position: &amp;quot; + Integer.toString(parallelPos) );"/>
				<param name="parallelPos"/>
				<param name="perpendicularLength"/>
				<param name="parallelLength"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext$Gradient.dispose()" access="pub" jdoc="">
				<comm cntt="raster = null;"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.FastGradientPaintContext$Gradient.createRaster(int)" access="priv" jdoc="">
				<param name="perpendicularLength"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/KLNF/:com.incors.plaf.kunststoff">
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffScrollButton" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffScrollButton.KunststoffScrollButton(int, int, boolean)" access="pub" jdoc="">
				<param name="direction"/>
				<param name="width"/>
				<param name="freeStanding"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffScrollButton.paint(Graphics)" access="pub" jdoc="Calls the super classes paint(Graphics g) method and then paints two gradients. The direction of the gradients depends on the direction of the scrollbar.">
				<comm cntt="paint reflection gradient"/>
				<comm cntt="paint shadow gradient"/>
				<param name="g"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI" intfc="n" abs="n" inn="n" sloc="45" jdoc="">
			<comm cntt="added by Thomas Auinger"/>
			<comm cntt="to solve a compiling problem"/>
			<comm cntt="end class PaletteListener"/>
			<field name="titlePane" access="priv" jdoc=""/>
			<field name="paletteListener" access="priv" jdoc=""/>
			<field name="FRAME_TYPE" access="priv" jdoc=""/>
			<field name="NORMAL_FRAME" access="priv" jdoc=""/>
			<field name="PALETTE_FRAME" access="priv" jdoc=""/>
			<field name="OPTION_DIALOG" access="priv" jdoc=""/>
			<field name="IS_PALETTE" access="prot" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI.KunststoffInternalFrameUI(JInternalFrame)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI.installUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI.uninstallUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI.createNorthPane(JInternalFrame)" access="prot" jdoc="">
				<param name="w"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI.setPalette(boolean)" access="pub" jdoc="">
				<param name="isPalette"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI.setFrameType(String)" access="priv" jdoc="">
				<param name="frameType"/>
			</mth>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI$PaletteListener" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameUI$PaletteListener.propertyChange(PropertyChangeEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffMenuBarUI" intfc="n" abs="n" inn="n" sloc="20" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffMenuBarUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffMenuBarUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<param name="g"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffComboBoxUI" intfc="n" abs="n" inn="n" sloc="12" jdoc="The KunststoffComboBoxUI is a little bit tricky, but it should work fine in most cases. It currently draws only correctly if the renderer of the combo box is an instance of &amp;lt;code&amp;gt;JComponent&amp;lt; code&amp;gt; and the background color is an instance of &amp;lt;code&amp;gt;ColorUIResource&amp;lt; code&amp;gt;. In a default &amp;lt;code&amp;gt;JComboBox&amp;lt; code&amp;gt; with a default renderer this should be the case.">
			<comm cntt="This inner class finally fixed a nasty bug with the combo box. Thanks to Matthew Philips for providing the bugfix. Thanks to Ingo Kegel for fixing two compiling issues for jikes."/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffComboBoxUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffComboBoxUI.createArrowButton()" access="prot" jdoc="Installs MyMetalComboBoxButton">
			</mth>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffComboBoxUI$MyMetalComboBoxButton" intfc="n" abs="n" inn="y" sloc="25" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffComboBoxUI$MyMetalComboBoxButton.MyMetalComboBoxButton(JComboBox, Icon, boolean, CellRendererPane, JList)" access="pub" jdoc="">
				<param name="cb"/>
				<param name="i"/>
				<param name="onlyIcon"/>
				<param name="pane"/>
				<param name="list"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffComboBoxUI$MyMetalComboBoxButton.paintComponent(Graphics)" access="pub" jdoc="">
				<comm cntt="remember to set the renderer opaque again"/>
				<param name="g"/>
			</mth>
		</class>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTextAreaUI" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="myComponent" access="prot" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTextAreaUI.KunststoffTextAreaUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTextAreaUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTextAreaUI.paintBackground(Graphics)" access="prot" jdoc="">
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<param name="g"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTableHeaderUI" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTableHeaderUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="h"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTableHeaderUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<comm cntt="we only draw the gradients if the component is opaque"/>
				<comm cntt="paint reflection"/>
				<comm cntt="paint shadow"/>
				<param name="g"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.GradientTheme" intfc="y" abs="n" inn="n" sloc="7" jdoc="Interface that provides methods for getting the colors for all gradients in the Kunststoff Look&amp;Feel. This interface can be implemented by subclasses of &amp;lt;code&amp;gt;javax.swing.plaf.metal.MetalTheme&amp;lt; code&amp;gt; to have a theme that provides standard colors as well as gradient colors.">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.GradientTheme.getComponentGradientColorReflection()" access="pub" jdoc="Returns the upper gradient color for components like JButton, JMenuBar, and JProgressBar. Will return &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if upper gradient should not be painted.">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.GradientTheme.getComponentGradientColorShadow()" access="pub" jdoc="Returns the lower gradient color for components like JButton, JMenuBar, and JProgressBar. Will return &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if lower gradient should not be painted.">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.GradientTheme.getTextComponentGradientColorReflection()" access="pub" jdoc="Returns the upper gradient color for text components like JTextField and JPasswordField. Will return &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if upper gradient should not be painted.">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.GradientTheme.getTextComponentGradientColorShadow()" access="pub" jdoc="Returns the lower gradient color for text components like JTextField and JPasswordField. Will return &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if lower gradient should not be painted.">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.GradientTheme.getBackgroundGradientShadow()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffProgressBarUI" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<comm cntt="Creates the UI"/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffProgressBarUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffProgressBarUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<comm cntt="if progress bar is vertical"/>
				<comm cntt="paint left gradient"/>
				<comm cntt="paint right gradient"/>
				<param name="g"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTreeUI" intfc="n" abs="n" inn="n" sloc="29" jdoc="">
			<comm cntt="This method replaces the metal expand- collaps-icons with some nicer ones."/>
			<field name="m_iconExpanded" access="prot" jdoc=""/>
			<field name="m_iconCollapsed" access="prot" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTreeUI.KunststoffTreeUI(JComponent)" access="pub" jdoc="">
				<param name="tree"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTreeUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="tree"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTreeUI.paintExpandControl(Graphics, Rectangle, Insets, Rectangle, TreePath, int, boolean, boolean, boolean)" access="prot" jdoc="">
				<comm cntt="super.paintExpandControl(g, clipBounds, insets, bounds, path, row, isExpanded, hasBeenExpanded, isLeaf);"/>
				<comm cntt="g.drawImage(m_iconExpanded.getImage(), (int)bounds.x-15, (int)bounds.y+5, null);"/>
				<comm cntt="g.drawImage(m_iconCollapsed.getImage(), (int)bounds.x-15, (int)bounds.y+5, null);"/>
				<param name="g"/>
				<param name="clipBounds"/>
				<param name="insets"/>
				<param name="bounds"/>
				<param name="path"/>
				<param name="row"/>
				<param name="isExpanded"/>
				<param name="hasBeenExpanded"/>
				<param name="isLeaf"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffListUI" intfc="n" abs="n" inn="n" sloc="58" jdoc="From version 2.0 the KunststoffListUI works with the DefaultListCellRenderer, which makes it really plug and play!">
			<comm cntt="We temporarily make the renderer transparent if the row is not selected"/>
			<comm cntt="and the renderer is a JComponent (like DefaultListCellRenderer) and the"/>
			<comm cntt="background color is a ColorUIResource (which means it probably has the"/>
			<comm cntt="original color assigned by the Look&amp;Feel)."/>
			<field name="isToolkitTrueColor" access="priv" jdoc=""/>
			<field name="colBg" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffListUI.KunststoffListUI(JComponent)" access="pub" jdoc="">
				<comm cntt="this will be needed for the decision if a big gradient or a small shadow"/>
				<comm cntt="should be painted. On 16-bit colors the big gradient looks awkward, therefore"/>
				<comm cntt="we will then paint a small shadow instead"/>
				<param name="list"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffListUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="list"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffListUI.update(Graphics, JComponent)" access="pub" jdoc="">
				<comm cntt="we will only paint the background if the background color is not null"/>
				<comm cntt="paint the background without gradient"/>
				<comm cntt="create the shadow color"/>
				<comm cntt="paint big horizontal gradient"/>
				<comm cntt="create faded shadow color"/>
				<comm cntt="paint shadow at top"/>
				<comm cntt="paint shadow at left"/>
				<param name="g"/>
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffListUI.paintCell(Graphics, int, Rectangle, ListCellRenderer, ListModel, ListSelectionModel, int)" access="prot" jdoc="">
				<param name="g"/>
				<param name="row"/>
				<param name="rowBounds"/>
				<param name="cellRenderer"/>
				<param name="dataModel"/>
				<param name="selModel"/>
				<param name="leadIndex"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTextFieldUI" intfc="n" abs="n" inn="n" sloc="28" jdoc="">
			<field name="myComponent" access="prot" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTextFieldUI.KunststoffTextFieldUI()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTextFieldUI.KunststoffTextFieldUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTextFieldUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTextFieldUI.paintBackground(Graphics)" access="prot" jdoc="">
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<param name="g"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameTitlePane" intfc="n" abs="n" inn="n" sloc="17" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameTitlePane.KunststoffInternalFrameTitlePane(JInternalFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffInternalFrameTitlePane.paintComponent(Graphics)" access="pub" jdoc="">
				<comm cntt="paint reflection"/>
				<comm cntt="paint shadow"/>
				<param name="g"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffUtilities" intfc="n" abs="n" inn="n" sloc="43" jdoc="Collection of methods often used in the Kunststoff Look&amp;Feel">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffUtilities.getTranslucentColor(Color, int)" access="pub" jdoc="Convenience method to create a translucent &amp;lt;code&amp;gt;Color&amp;lt; color&amp;gt;.">
				<param name="color"/>
				<param name="alpha"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffUtilities.getTranslucentColorUIResource(Color, int)" access="pub" jdoc="Convenience method to create a translucent &amp;lt;code&amp;gt;ColorUIResource&amp;lt; code&amp;gt;.">
				<param name="color"/>
				<param name="alpha"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffUtilities.drawGradient(Graphics, Color, Color, Rectangle, boolean)" access="pub" jdoc="Convenience method to draw a gradient on the specified rectangle">
				<param name="g"/>
				<param name="color1"/>
				<param name="color2"/>
				<param name="rect"/>
				<param name="isVertical"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffUtilities.drawGradient(Graphics, Color, Color, Rectangle, Rectangle, boolean)" access="pub" jdoc="Convenience method to draw a gradient. The first rectangle defines the drawing region, the second rectangle defines the size of the gradient.">
				<comm cntt="We are currently not using the FastGradientPaint to render this gradient, because we have to decide how"/>
				<comm cntt="we can use FastGradientPaint if rect and rect2 are different."/>
				<param name="g"/>
				<param name="color1"/>
				<param name="color2"/>
				<param name="rect"/>
				<param name="rect2"/>
				<param name="isVertical"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffUtilities.isToolkitTrueColor(Component)" access="pub" jdoc="Returns true if the display uses 24- or 32-bit color depth (= true color)">
				<param name="c"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffGradientTheme" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<comm cntt="gradient colors"/>
			<comm cntt="methods"/>
			<comm cntt="methods for getting gradient colors"/>
			<const name="componentGradientColorReflection" access="priv" jdoc=""/>
			<const name="componentGradientColorShadow" access="priv" jdoc=""/>
			<const name="textComponentGradientColorReflection" access="priv" jdoc=""/>
			<const name="textComponentGradientColorShadow" access="priv" jdoc=""/>
			<const name="backgroundGradientShadow" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffGradientTheme.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffGradientTheme.getComponentGradientColorReflection()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffGradientTheme.getComponentGradientColorShadow()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffGradientTheme.getTextComponentGradientColorReflection()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffGradientTheme.getTextComponentGradientColorShadow()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffGradientTheme.getBackgroundGradientShadow()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffCheckBoxUI" intfc="n" abs="n" inn="n" sloc="13" jdoc="">
			<const name="checkBoxUI" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffCheckBoxUI.KunststoffCheckBoxUI()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffCheckBoxUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffCheckBoxUI.installDefaults(AbstractButton)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.ModifiedDefaultListCellRenderer" intfc="n" abs="n" inn="n" sloc="11" jdoc="The only difference between this class and the DefaultListCellRenderer is that objects of this class are not opaque by default.">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.ModifiedDefaultListCellRenderer.getListCellRendererComponent(JList, Object, int, boolean, boolean)" access="pub" jdoc="">
				<param name="list"/>
				<param name="value"/>
				<param name="index"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffMenuUI" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffMenuUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffMenuUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<param name="g"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffToggleButtonUI" intfc="n" abs="n" inn="n" sloc="57" jdoc="">
			<const name="buttonUI" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffToggleButtonUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffToggleButtonUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<comm cntt="we only draw the gradients if the component is opaque"/>
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<comm cntt="if tool bar orientation is vertical"/>
				<comm cntt="paint left gradient"/>
				<comm cntt="paint right gradient"/>
				<comm cntt="if not in tool bar"/>
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<param name="g"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel" intfc="n" abs="n" inn="n" sloc="94" jdoc="The main class for the Kunststoff Look&amp;Feel.">
			<comm cntt="Thanks to Jonas Kilian for"/>
			<comm cntt="fixing the themes-bug"/>
			<comm cntt="getter methods for the gradient colors"/>
			<field name="gradientTheme" access="priv" jdoc=""/>
			<field name="isInstalled" access="priv" jdoc=""/>
			<field name="themeHasBeenSet" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.KunststoffLookAndFeel()" access="pub" jdoc="">
				<comm cntt="the next line was removed by Jens Niemeyer, jens@jensn.de, because it would"/>
				<comm cntt="cause a crash when using Sun Web Start"/>
				<comm cntt="super();"/>
				<comm cntt="install with the UIManager, if not done yet."/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.getID()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.isNativeLookAndFeel()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.isSupportedLookAndFeel()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.initClassDefaults(UIDefaults)" access="prot" jdoc="">
				<comm cntt="if you want a check box icon with gradients, just remove the comment from"/>
				<comm cntt="the following lines. We prefer the standard icon."/>
				<comm cntt="putDefault(table, &amp;quot;CheckBoxUI&amp;quot;); try { String className = &amp;quot;com.incors.plaf.kunststoff.KunststoffCheckBoxIcon&amp;quot;; table.put(&amp;quot;CheckBox.icon&amp;quot;, className); } catch (Exception ex) { ex.printStackTrace(); }"/>
				<param name="table"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.putDefault(UIDefaults, String)" access="prot" jdoc="">
				<param name="table"/>
				<param name="uiKey"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.createDefaultTheme()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.setCurrentGradientTheme(GradientTheme)" access="pub" jdoc="Sets the theme that defines the colors for gradients.">
				<param name="theme"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.setCurrentTheme(MetalTheme)" access="pub" jdoc="Sets the current color theme. This works exactly as with the MetalLookAndFeel. Note that for customizing the gradients the method setCurrentGradientTheme() must be used.">
				<param name="theme"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.initSystemColorDefaults(UIDefaults)" access="prot" jdoc="">
				<comm cntt="we made the color a bit darker because the were complaints about the color"/>
				<comm cntt="being very difficult to see"/>
				<param name="table"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.initComponentDefaults(UIDefaults)" access="prot" jdoc="">
				<comm cntt="will result in only one row of bumps"/>
				<param name="table"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.getComponentGradientColorReflection()" access="pub" jdoc="Returns the reflection color for a standard component (such as JButton).">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.getComponentGradientColorShadow()" access="pub" jdoc="Returns the shadow color for a standard component (such as JButton).">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.getTextComponentGradientColorReflection()" access="pub" jdoc="Returns the reflection color for a text component (such as JTextField).">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.getTextComponentGradientColorShadow()" access="pub" jdoc="Returns the reflection color for a text component (such as JTextField).">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffLookAndFeel.getBackgroundGradientShadow()" access="pub" jdoc="Returns the background shadow color for JList. In future we might also use this color for the background of JTree.">
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTabbedPaneUI" intfc="n" abs="n" inn="n" sloc="65" jdoc="">
			<comm cntt="Thanks to a contribution by Jamie LaScolea this method now works with multiple rows of tabs."/>
			<const name="SHADOW_WIDTH" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTabbedPaneUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTabbedPaneUI.installDefaults()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTabbedPaneUI.paintTab(Graphics, int, Rectangle[], int, Rectangle, Rectangle)" access="prot" jdoc="">
				<comm cntt="paint shadow that the selected tab throws on the next tab"/>
				<comm cntt="the following statement was added by Jamie LaScolea as a bug fix. Thanks Jamie!"/>
				<param name="g"/>
				<param name="tabPlacement"/>
				<param name="rects"/>
				<param name="tabIndex"/>
				<param name="iconRect"/>
				<param name="textRect"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTabbedPaneUI.paintTabBackground(Graphics, int, int, int, int, int, int, boolean)" access="prot" jdoc="">
				<param name="g"/>
				<param name="tabPlacement"/>
				<param name="tabIndex"/>
				<param name="x"/>
				<param name="y"/>
				<param name="w"/>
				<param name="h"/>
				<param name="isSelected"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffPasswordFieldUI" intfc="n" abs="n" inn="n" sloc="14" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffPasswordFieldUI.KunststoffPasswordFieldUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffPasswordFieldUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffPasswordFieldUI.getPropertyPrefix()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffPasswordFieldUI.create(Element)" access="pub" jdoc="">
				<param name="elem"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffButtonUI" intfc="n" abs="n" inn="n" sloc="57" jdoc="">
			<const name="buttonUI" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffButtonUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffButtonUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<comm cntt="we only paint the gradients if the button is opaque."/>
				<comm cntt="Thanks to Christoph Wilhelms for proposing this."/>
				<comm cntt="if tool bar orientation is horizontal"/>
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<comm cntt="if tool bar orientation is vertical"/>
				<comm cntt="paint left gradient"/>
				<comm cntt="paint right gradient"/>
				<comm cntt="if not in toolbar"/>
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<param name="g"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffCheckBoxIcon" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffCheckBoxIcon.paintIcon(Component, Graphics, int, int)" access="pub" jdoc="">
				<comm cntt="paint upper gradient"/>
				<comm cntt="paint lower gradient"/>
				<param name="c"/>
				<param name="g"/>
				<param name="x"/>
				<param name="y"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffToolBarUI" intfc="n" abs="n" inn="n" sloc="40" jdoc="">
			<const name="toolBarUI" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffToolBarUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffToolBarUI.paint(Graphics, JComponent)" access="pub" jdoc="">
				<comm cntt="paint upper (reflection) gradient"/>
				<comm cntt="paint lower (shadow) gradient"/>
				<comm cntt="is orientation is vertical"/>
				<comm cntt="paint left (reflection) gradient"/>
				<comm cntt="paint right (shadow) gradient"/>
				<param name="g"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffScrollBarUI" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffScrollBarUI.createUI(JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffScrollBarUI.createDecreaseButton(int)" access="prot" jdoc="">
				<param name="orientation"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffScrollBarUI.createIncreaseButton(int)" access="prot" jdoc="">
				<param name="orientation"/>
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffScrollBarUI.paintThumb(Graphics, JComponent, Rectangle)" access="prot" jdoc="Calls the super classes paint(Graphics g) method and then paints two gradients. The direction of the gradients depends on the direction of the scrollbar.">
				<comm cntt="colors for the reflection gradient"/>
				<comm cntt="colors for the shadow gradient"/>
				<comm cntt="rectangle for the reflection gradient"/>
				<comm cntt="rectangle for the shadow gradient"/>
				<comm cntt="the direction of the gradient is orthogonal to the direction of the scrollbar"/>
				<param name="g"/>
				<param name="c"/>
				<param name="thumbBounds"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTheme" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<comm cntt="primary colors"/>
			<comm cntt="secondary colors"/>
			<comm cntt="methods"/>
			<const name="primary1" access="priv" jdoc=""/>
			<const name="primary2" access="priv" jdoc=""/>
			<const name="primary3" access="priv" jdoc=""/>
			<const name="secondary1" access="priv" jdoc=""/>
			<const name="secondary2" access="priv" jdoc=""/>
			<const name="secondary3" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTheme.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTheme.getPrimary1()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTheme.getPrimary2()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTheme.getPrimary3()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTheme.getSecondary1()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTheme.getSecondary2()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.KunststoffTheme.getSecondary3()" access="prot" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes">
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme" intfc="n" abs="n" inn="n" sloc="76" jdoc="@author christophw @version">
			<comm cntt="primary colors"/>
			<comm cntt="secondary colors"/>
			<comm cntt="private final ColorUIResource secondary3 = new ColorUIResource(224, 224, 224);"/>
			<comm cntt="fonts"/>
			<const name="primary1" access="priv" jdoc=""/>
			<const name="primary2" access="priv" jdoc=""/>
			<const name="primary3" access="priv" jdoc=""/>
			<const name="secondary1" access="priv" jdoc=""/>
			<const name="secondary2" access="priv" jdoc=""/>
			<const name="secondary3" access="priv" jdoc=""/>
			<field name="controlFont" access="priv" jdoc=""/>
			<field name="menuFont" access="priv" jdoc=""/>
			<field name="windowTitleFont" access="priv" jdoc=""/>
			<field name="monospacedFont" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.KunststoffNotebookTheme()" access="pub" jdoc="Crates this Theme">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getControlTextFont()" access="pub" jdoc="The Font of Labels in many cases">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getMenuTextFont()" access="pub" jdoc="The Font of Menus and MenuItems">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getSystemTextFont()" access="pub" jdoc="The Font of Nodes in JTrees">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getUserTextFont()" access="pub" jdoc="The Font in TextFields, EditorPanes, etc.">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getWindowTitleFont()" access="pub" jdoc="The Font of the Title of JInternalFrames">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getPrimary1()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getPrimary2()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getPrimary3()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getSecondary1()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getSecondary2()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.getSecondary3()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffNotebookTheme.addCustomEntriesToTable(UIDefaults)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme" intfc="n" abs="n" inn="n" sloc="78" jdoc="@author christophw @version">
			<comm cntt="primary colors"/>
			<comm cntt="secondary colors"/>
			<comm cntt="private final ColorUIResource secondary3 = new ColorUIResource(224, 224, 224);"/>
			<comm cntt="fonts"/>
			<const name="primary1" access="priv" jdoc=""/>
			<const name="primary2" access="priv" jdoc=""/>
			<const name="primary3" access="priv" jdoc=""/>
			<const name="secondary1" access="priv" jdoc=""/>
			<const name="secondary2" access="priv" jdoc=""/>
			<const name="secondary3" access="priv" jdoc=""/>
			<field name="controlFont" access="priv" jdoc=""/>
			<field name="menuFont" access="priv" jdoc=""/>
			<field name="windowTitleFont" access="priv" jdoc=""/>
			<field name="monospacedFont" access="priv" jdoc=""/>
			<field name="textFont" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.KunststoffPresentationTheme()" access="pub" jdoc="Crates this Theme">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getControlTextFont()" access="pub" jdoc="The Font of Labels in many cases">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getMenuTextFont()" access="pub" jdoc="The Font of Menus and MenuItems">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getSystemTextFont()" access="pub" jdoc="The Font of Nodes in JTrees">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getUserTextFont()" access="pub" jdoc="The Font in TextFields, EditorPanes, etc.">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getWindowTitleFont()" access="pub" jdoc="The Font of the Title of JInternalFrames">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getPrimary1()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getPrimary2()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getPrimary3()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getSecondary1()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getSecondary2()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.getSecondary3()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffPresentationTheme.addCustomEntriesToTable(UIDefaults)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
		</class>
		<class name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffDesktopTheme" intfc="n" abs="n" inn="n" sloc="45" jdoc="@author christophw @version">
			<field name="controlFont" access="priv" jdoc=""/>
			<field name="menuFont" access="priv" jdoc=""/>
			<field name="windowTitleFont" access="priv" jdoc=""/>
			<field name="monospacedFont" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffDesktopTheme.KunststoffDesktopTheme()" access="pub" jdoc="Crates this Theme">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffDesktopTheme.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffDesktopTheme.getControlTextFont()" access="pub" jdoc="The Font of Labels in many cases">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffDesktopTheme.getMenuTextFont()" access="pub" jdoc="The Font of Menus and MenuItems">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffDesktopTheme.getSystemTextFont()" access="pub" jdoc="The Font of Nodes in JTrees">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffDesktopTheme.getUserTextFont()" access="pub" jdoc="The Font in TextFields, EditorPanes, etc.">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffDesktopTheme.getWindowTitleFont()" access="pub" jdoc="The Font of the Title of JInternalFrames">
			</mth>
			<mth name="/plugins/KLNF/:com.incors.plaf.kunststoff.themes.KunststoffDesktopTheme.addCustomEntriesToTable(UIDefaults)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/KLNF/JextKLNFTheme.java:default">
		<class name="/plugins/KLNF/JextKLNFTheme.java:default.JextKLNFTheme" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<const name="primary1" access="priv" jdoc=""/>
			<const name="primary2" access="priv" jdoc=""/>
			<const name="primary3" access="priv" jdoc=""/>
			<const name="secondary1" access="priv" jdoc=""/>
			<const name="secondary2" access="priv" jdoc=""/>
			<const name="secondary3" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/JextKLNFTheme.java:default.JextKLNFTheme.getPrimary1()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/JextKLNFTheme.java:default.JextKLNFTheme.getPrimary2()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/JextKLNFTheme.java:default.JextKLNFTheme.getPrimary3()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/JextKLNFTheme.java:default.JextKLNFTheme.getSecondary1()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/JextKLNFTheme.java:default.JextKLNFTheme.getSecondary2()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/JextKLNFTheme.java:default.JextKLNFTheme.getSecondary3()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/KLNF/KLNFOptionPane.java:default">
		<class name="/plugins/KLNF/KLNFOptionPane.java:default.KLNFOptionPane" intfc="n" abs="n" inn="n" sloc="14" jdoc="">
			<field name="enable" access="priv" jdoc=""/>
			<mth name="/plugins/KLNF/KLNFOptionPane.java:default.KLNFOptionPane.KLNFOptionPane()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/KLNFOptionPane.java:default.KLNFOptionPane.save()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/KLNF/KLNFPlugin.java:default">
		<class name="/plugins/KLNF/KLNFPlugin.java:default.KLNFPlugin" intfc="n" abs="n" inn="n" sloc="42" jdoc="KLNF is a plugin for the Jext java text editor. @author Romain Guy">
			<mth name="/plugins/KLNF/KLNFPlugin.java:default.KLNFPlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<comm cntt="creates menu items"/>
				<param name="parent"/>
				<param name="menus"/>
				<param name="menuItems"/>
			</mth>
			<mth name="/plugins/KLNF/KLNFPlugin.java:default.KLNFPlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<comm cntt="parent.addOptionPane(new KLNFOptionPane());"/>
				<param name="parent"/>
			</mth>
			<mth name="/plugins/KLNF/KLNFPlugin.java:default.KLNFPlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KLNF/KLNFPlugin.java:default.KLNFPlugin.getSkins()" access="pub" jdoc="">
				<comm cntt="these calls are needed because"/>
				<comm cntt="UIManager.put(&amp;quot;ClassLoader&amp;quot;, KLNFPlugin.class.getClassLoader());"/>
				<comm cntt="KunststoffLookAndFeel.setCurrentTheme(new JextKLNFTheme());"/>
				<comm cntt="UIManager.setLookAndFeel(new KunststoffLookAndFeel());"/>
			</mth>
			<mth name="/plugins/KLNF/KLNFPlugin.java:default.KLNFPlugin.stop()" access="pub" jdoc="">
				<comm cntt="stops the plugin"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/KeystrokeRecorder/KeystrokeRecorderPlugin.java:default">
		<class name="/plugins/KeystrokeRecorder/KeystrokeRecorderPlugin.java:default.KeystrokeRecorderPlugin" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<field name="aTrack" access="priv" jdoc=""/>
			<mth name="/plugins/KeystrokeRecorder/KeystrokeRecorderPlugin.java:default.KeystrokeRecorderPlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="optionsDialog"/>
			</mth>
			<mth name="/plugins/KeystrokeRecorder/KeystrokeRecorderPlugin.java:default.KeystrokeRecorderPlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KeystrokeRecorder/KeystrokeRecorderPlugin.java:default.KeystrokeRecorderPlugin.stop()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KeystrokeRecorder/KeystrokeRecorderPlugin.java:default.KeystrokeRecorderPlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="pluginsMenus"/>
				<param name="pluginsMenuItems"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/KeystrokeRecorder/Track.java:default">
		<class name="/plugins/KeystrokeRecorder/Track.java:default.Track" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<field name="keyStrokes" access="priv" jdoc=""/>
			<mth name="/plugins/KeystrokeRecorder/Track.java:default.Track.actionPerformed(ActionListener, String)" access="pub" jdoc="">
				<param name="listener"/>
				<param name="actionCommand"/>
			</mth>
			<mth name="/plugins/KeystrokeRecorder/Track.java:default.Track.erase()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/KeystrokeRecorder/Track.java:default.Track.play(JextTextArea)" access="pub" jdoc="">
				<comm cntt="end if debug"/>
				<param name="jextTextArea"/>
			</mth>
		<class name="/plugins/KeystrokeRecorder/Track.java:default.Track$Command" intfc="n" abs="n" inn="y" sloc="17" jdoc="">
			<field name="listener" access="priv" jdoc=""/>
			<field name="actionCommand" access="priv" jdoc=""/>
			<mth name="/plugins/KeystrokeRecorder/Track.java:default.Track$Command.Command(ActionListener, String)" access="pub" jdoc="">
				<param name="listener"/>
				<param name="actionCommand"/>
			</mth>
			<mth name="/plugins/KeystrokeRecorder/Track.java:default.Track$Command.run(JextTextArea)" access="pub" jdoc="">
				<param name="jextTextArea"/>
			</mth>
			<mth name="/plugins/KeystrokeRecorder/Track.java:default.Track$Command.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPBeautifier.java:default">
		<class name="/plugins/Php/src/PHPBeautifier.java:default.PHPBeautifier" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<mth name="/plugins/Php/src/PHPBeautifier.java:default.PHPBeautifier.PHPBeautifier()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBeautifier.java:default.PHPBeautifier.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPBeautifierBloc.java:default">
		<class name="/plugins/Php/src/PHPBeautifierBloc.java:default.PHPBeautifierBloc" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<mth name="/plugins/Php/src/PHPBeautifierBloc.java:default.PHPBeautifierBloc.PHPBeautifierBloc()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBeautifierBloc.java:default.PHPBeautifierBloc.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPBrowse.java:default">
		<class name="/plugins/Php/src/PHPBrowse.java:default.PHPBrowse" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<mth name="/plugins/Php/src/PHPBrowse.java:default.PHPBrowse.PHPBrowse()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowse.java:default.PHPBrowse.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="parent.removeJextListener(tPane.getComponentAt(tPane.indexOfTab(&amp;quot;PHP Browser&amp;quot;)));"/>
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPBrowseTab.java:default">
		<class name="/plugins/Php/src/PHPBrowseTab.java:default.PHPBrowseTab" intfc="n" abs="n" inn="n" sloc="108" jdoc="">
			<comm cntt="Lancement du traitement du thread"/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="browserTree" access="priv" jdoc=""/>
			<field name="browserTreeModel" access="priv" jdoc=""/>
			<field name="root" access="priv" jdoc=""/>
			<field name="thread" access="priv" jdoc=""/>
			<mth name="/plugins/Php/src/PHPBrowseTab.java:default.PHPBrowseTab.PHPBrowseTab(JextFrame)" access="pub" jdoc="">
				<comm cntt="Look"/>
				<comm cntt="Divers propri�t�s"/>
				<comm cntt="Ajout du treeview dans panneau"/>
				<comm cntt="On &amp;quot;thread&amp;quot; cette classe"/>
				<comm cntt="On lance l&amp;apos;analyse dans le thread"/>
				<param name="parent"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTab.java:default.PHPBrowseTab.jextEventFired(JextEvent)" access="pub" jdoc="">
				<comm cntt="Le textarea change ou on en ouvre selectionne un nouveau"/>
				<comm cntt="il ya un thread actif donc on l&amp;apos;arrete"/>
				<comm cntt="On lance l&amp;apos;execution d&amp;apos;un nouveau Thread - implicitement on execute la m�thode run()"/>
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTab.java:default.PHPBrowseTab.run()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTab.java:default.PHPBrowseTab.load(JextTextArea[])" access="pub" jdoc="">
				<param name="textAreas"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTab.java:default.PHPBrowseTab.valueChanged(TreeSelectionEvent)" access="pub" jdoc="">
				<comm cntt="Le fichier n&amp;apos;est pas le Fichier courant, donc on le cherche..."/>
				<comm cntt="On verifie que l&amp;apos;on a bien trouv� un fichier"/>
				<param name="tse"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTab.java:default.PHPBrowseTab.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPBrowseTabNode.java:default">
		<class name="/plugins/Php/src/PHPBrowseTabNode.java:default.PHPBrowseTabNode" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<comm cntt="Constructeur pour le Noeud racine"/>
			<comm cntt="Constructeur pour une feuille"/>
			<comm cntt="Constructeur pour une branche"/>
			<field name="name" access="priv" jdoc=""/>
			<field name="file" access="priv" jdoc=""/>
			<field name="line" access="priv" jdoc=""/>
			<field name="parentNode" access="priv" jdoc=""/>
			<mth name="/plugins/Php/src/PHPBrowseTabNode.java:default.PHPBrowseTabNode.PHPBrowseTabNode(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabNode.java:default.PHPBrowseTabNode.PHPBrowseTabNode(String, int, File, PHPBrowseTabNode)" access="pub" jdoc="">
				<param name="name"/>
				<param name="line"/>
				<param name="file"/>
				<param name="parentNode"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabNode.java:default.PHPBrowseTabNode.PHPBrowseTabNode(String, File, PHPBrowseTabNode)" access="pub" jdoc="">
				<param name="name"/>
				<param name="file"/>
				<param name="parentNode"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabNode.java:default.PHPBrowseTabNode.getLine()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabNode.java:default.PHPBrowseTabNode.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabNode.java:default.PHPBrowseTabNode.getFile()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPBrowseTabParser.java:default">
		<class name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser" intfc="n" abs="n" inn="n" sloc="65" jdoc="">
			<field name="parentNode" access="priv" jdoc=""/>
			<field name="root" access="priv" jdoc=""/>
			<field name="uneLigne" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.PHPBrowseTabParser(PHPBrowseTabNode, JextTextArea)" access="pub" jdoc="">
				<param name="root"/>
				<param name="textArea"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_AVANT()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_DEBUT()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_FIN_LIGNE()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_DEBUT_BLOC_CODE()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_FIN_BLOC_CODE()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_DEBUT_BLOC_CONDITION()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_FIN_BLOC_CONDITION()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_SEPARATEUR()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_ESPACE()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_DEBUT_PHP()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_FIN_PHP()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_KEYWORD_A()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_KEYWORD_B()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_KEYWORD_C()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_KEYWORD_D()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_FIN()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.P_APRES()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBrowseTabParser.java:default.PHPBrowseTabParser.parseLigne()" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;[&amp;gt;&amp;quot;+name+&amp;quot;&amp;lt;]\n&amp;quot;);"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPBufferPart.java:default">
		<class name="/plugins/Php/src/PHPBufferPart.java:default.PHPBufferPart" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<field name="debut" access="priv" jdoc=""/>
			<field name="fin" access="priv" jdoc=""/>
			<field name="type" access="priv" jdoc=""/>
			<mth name="/plugins/Php/src/PHPBufferPart.java:default.PHPBufferPart.PHPBufferPart(int, int, String)" access="pub" jdoc="">
				<param name="b"/>
				<param name="e"/>
				<param name="t"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPart.java:default.PHPBufferPart.getStart()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPart.java:default.PHPBufferPart.getEnd()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPart.java:default.PHPBufferPart.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPart.java:default.PHPBufferPart.getType()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPBufferPartList.java:default">
		<class name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList" intfc="n" abs="n" inn="n" sloc="76" jdoc="">
			<field name="tabPart" access="priv" jdoc=""/>
			<field name="nbPart" access="priv" jdoc=""/>
			<field name="maxPart" access="priv" jdoc=""/>
			<field name="unBloc" access="priv" jdoc=""/>
			<field name="debut" access="priv" jdoc=""/>
			<mth name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList.PHPBufferPartList(String)" access="pub" jdoc="">
				<comm cntt="P_AVANT();"/>
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList.getPartOffset(int)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList.getNbPart()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList.getPart()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList.addPart(int, int, String)" access="priv" jdoc="">
				<param name="b"/>
				<param name="e"/>
				<param name="t"/>
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList.P_AVANT()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList.P_DEBUT_PHP()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList.P_FIN_PHP()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPBufferPartList.java:default.PHPBufferPartList.P_APRES()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPComplete.java:default">
		<class name="/plugins/Php/src/PHPComplete.java:default.PHPComplete" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<mth name="/plugins/Php/src/PHPComplete.java:default.PHPComplete.PHPComplete()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPComplete.java:default.PHPComplete.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="On recupere la ligne courante"/>
				<comm cntt="On recupere la mot courant"/>
				<comm cntt="On affiche une popup"/>
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPCompleteList.java:default">
		<class name="/plugins/Php/src/PHPCompleteList.java:default.PHPCompleteList" intfc="n" abs="n" inn="n" sloc="40" jdoc="">
			<field name="functionsList" access="pub" jdoc=""/>
			<mth name="/plugins/Php/src/PHPCompleteList.java:default.PHPCompleteList.PHPCompleteList()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPCompleteList.java:default.PHPCompleteList.buildFunctionList(String)" access="pub" jdoc="">
				<comm cntt="On charge le fichier XML en m�moire"/>
				<comm cntt="On ne prend que certaine fonctions"/>
				<comm cntt="On fabrique un tableau"/>
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPCompleteList.java:default.PHPCompleteList.loadFunctionList()" access="priv" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPCompleteListHandler.java:default">
		<class name="/plugins/Php/src/PHPCompleteListHandler.java:default.PHPCompleteListHandler" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<field name="func" access="priv" jdoc=""/>
			<field name="lastvalue" access="priv" jdoc=""/>
			<mth name="/plugins/Php/src/PHPCompleteListHandler.java:default.PHPCompleteListHandler.startElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/Php/src/PHPCompleteListHandler.java:default.PHPCompleteListHandler.charData(char[], int, int)" access="pub" jdoc="">
				<param name="str"/>
				<param name="first"/>
				<param name="last"/>
			</mth>
			<mth name="/plugins/Php/src/PHPCompleteListHandler.java:default.PHPCompleteListHandler.endElement(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/plugins/Php/src/PHPCompleteListHandler.java:default.PHPCompleteListHandler.startDocument()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPCompletePopup.java:default">
		<class name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup" intfc="n" abs="n" inn="n" sloc="94" jdoc="">
			<comm cntt="End of patch"/>
			<field name="selfInput" access="priv" jdoc=""/>
			<field name="itemsList" access="priv" jdoc=""/>
			<field name="word" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<field name="truc" access="priv" jdoc=""/>
			<mth name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup.PHPCompletePopup(JextFrame, String)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="word"/>
			</mth>
			<mth name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup.caretUpdate(CaretEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup.dispose()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup.insertFunction()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup.finalize()" access="prot" jdoc="Patch -&amp;gt; Memory management improvements : it may help the garbage collector. -&amp;gt; Author : Julien Ponge (julien@izforge.com) -&amp;gt; Date : 23, May 2001">
			</mth>
		<class name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup$KeyHandler" intfc="n" abs="n" inn="y" sloc="81" jdoc="">
			<mth name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup$KeyHandler.keyTyped(KeyEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
			<mth name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup$KeyHandler.keyPressed(KeyEvent)" access="pub" jdoc="">
				<comm cntt="case KeyEvent.VK_SPACE:"/>
				<param name="evt"/>
			</mth>
		</class>
		<class name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup$MouseHandler" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<mth name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup$MouseHandler.mouseClicked(MouseEvent)" access="pub" jdoc="">
				<param name="me"/>
			</mth>
		</class>
		<class name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup$FunctionsCellRenderer" intfc="n" abs="n" inn="y" sloc="20" jdoc="">
			<mth name="/plugins/Php/src/PHPCompletePopup.java:default.PHPCompletePopup$FunctionsCellRenderer.getListCellRendererComponent(JList, Object, int, boolean, boolean)" access="pub" jdoc="">
				<param name="list"/>
				<param name="value"/>
				<param name="index"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPFunction.java:default">
		<class name="/plugins/Php/src/PHPFunction.java:default.PHPFunction" intfc="n" abs="n" inn="n" sloc="12" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="extension" access="pub" jdoc=""/>
			<field name="proto" access="pub" jdoc=""/>
			<field name="desc" access="pub" jdoc=""/>
			<field name="retour" access="pub" jdoc=""/>
			<mth name="/plugins/Php/src/PHPFunction.java:default.PHPFunction.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPIndent.java:default">
		<class name="/plugins/Php/src/PHPIndent.java:default.PHPIndent" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<mth name="/plugins/Php/src/PHPIndent.java:default.PHPIndent.createIndent(int, int)" access="pub" jdoc="">
				<param name="indent"/>
				<param name="max"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndent.java:default.PHPIndent.createAlign(int)" access="pub" jdoc="">
				<param name="nbspace"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPIndentHTML.java:default">
		<class name="/plugins/Php/src/PHPIndentHTML.java:default.PHPIndentHTML" intfc="n" abs="n" inn="n" sloc="145" jdoc="">
			<field name="buffer" access="pub" jdoc=""/>
			<field name="newbuf" access="pub" jdoc=""/>
			<field name="INDENT_SIZE" access="pub" jdoc=""/>
			<field name="indent" access="pub" jdoc=""/>
			<field name="MAX_LINE_WIDTH" access="pub" jdoc=""/>
			<field name="INDENT_ON_TAG" access="pub" jdoc=""/>
			<field name="lastWasTag" access="priv" jdoc=""/>
			<const name="TAG" access="priv" jdoc=""/>
			<const name="NULL" access="priv" jdoc=""/>
			<const name="CLOSING_TAG" access="priv" jdoc=""/>
			<mth name="/plugins/Php/src/PHPIndentHTML.java:default.PHPIndentHTML.PHPIndentHTML(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentHTML.java:default.PHPIndentHTML.setIndentSize(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentHTML.java:default.PHPIndentHTML.get()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentHTML.java:default.PHPIndentHTML.setMaxLineWidth(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentHTML.java:default.PHPIndentHTML.indent()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentHTML.java:default.PHPIndentHTML.onOneLine()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentHTML.java:default.PHPIndentHTML.indentTag(String)" access="priv" jdoc="">
				<param name="tag"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentHTML.java:default.PHPIndentHTML.parse(String)" access="priv" jdoc="">
				<param name="html"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPIndentPEAR.java:default">
		<class name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR" intfc="n" abs="n" inn="n" sloc="162" jdoc="">
			<comm cntt="Nombre maximun de bloc de parenthese imbriqu�e"/>
			<comm cntt="On est dans block inutile ( commentaire ou chaine de caract�res)"/>
			<comm cntt="On ajoute le caractere courant au buffer de sortie"/>
			<comm cntt="On ajoute un blanc apr�s le carctere courant"/>
			<comm cntt="On ajoute un retour � la ligne avant un block {"/>
			<comm cntt="On compte les sous blocs"/>
			<comm cntt="On m�morise le pr�c�dent nombre de sous blocs"/>
			<comm cntt="Pile m�morisant l&amp;apos;emplacement de la premiere parenth�se"/>
			<field name="TAILLE_PILE" access="priv" jdoc=""/>
			<field name="lastIndent" access="priv" jdoc=""/>
			<field name="nullblock" access="priv" jdoc=""/>
			<field name="amettre" access="priv" jdoc=""/>
			<field name="addspace" access="priv" jdoc=""/>
			<field name="addnewline" access="priv" jdoc=""/>
			<field name="indentBis" access="priv" jdoc=""/>
			<field name="lastIndentBis" access="priv" jdoc=""/>
			<field name="pileIndentBis" access="priv" jdoc=""/>
			<field name="uneLigne" access="priv" jdoc=""/>
			<field name="newbuf" access="pub" jdoc=""/>
			<field name="INDENT_SIZE" access="pub" jdoc=""/>
			<field name="indent" access="pub" jdoc=""/>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.PHPIndentPEAR(String)" access="pub" jdoc="">
				<comm cntt="P_AVANT();"/>
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.setIndentSize(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.get()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.parseLigne()" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Type[&amp;quot;+String.valueOf(getType())+&amp;quot;] Ligne[&amp;quot;+this.uneLigne.toString()+&amp;quot;]\n&amp;quot;);"/>
				<comm cntt="On vient de commencer donc on ajoute rien"/>
				<comm cntt="Un commentaire PHPDOC commence forcement par"/>
				<comm cntt="On est bien dans commentaire PHPDOC, donc un met un petit blanc"/>
				<comm cntt="On aligne l&amp;apos;�toile de fin de commentaire avec l&amp;apos;etoile de d�but"/>
				<comm cntt="On indent des blocs de code"/>
				<comm cntt="On aligne le contenu des parenth�ses"/>
				<comm cntt="On ajoute la ligne que l&amp;apos;on vient de traiter"/>
				<comm cntt="Sauvegarde les compteurs d&amp;apos;indentation"/>
				<comm cntt="On n&amp;apos;a pas trouv� la d�claration d&amp;apos;une fonction ou d&amp;apos;une classe"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.indent()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_AVANT()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_DEBUT()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_FIN_LIGNE()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_DEBUT_BLOC_CODE()" access="prot" jdoc="">
				<comm cntt="Si on vient de d�clarer une fonction ou d&amp;apos;une classe on saute une ligne"/>
				<comm cntt="Sinon on met juste un espace devant"/>
				<comm cntt="On compte"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_FIN_BLOC_CODE()" access="prot" jdoc="">
				<comm cntt="On D�compte"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_DEBUT_BLOC_CONDITION()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_FIN_BLOC_CONDITION()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_SEPARATEUR()" access="prot" jdoc="">
				<comm cntt="un espace derriere"/>
				<comm cntt="On n&amp;apos;a pas trouv� la d�caration d&amp;apos;une fonction ou d&amp;apos;une classe"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_ESPACE()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_DEBUT_PHP()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_KEYWORD_A()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_KEYWORD_B()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_KEYWORD_C()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_KEYWORD_D()" access="prot" jdoc="">
				<comm cntt="Nous sommes sur un op�rateur un seul espace devant"/>
				<comm cntt="si et seulement si il n&amp;apos;y en a d�j� pas"/>
				<comm cntt="et un seul derri�re"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_FIN()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPEAR.java:default.PHPIndentPEAR.P_APRES()" access="prot" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPIndentPHP.java:default">
		<class name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP" intfc="n" abs="n" inn="n" sloc="75" jdoc="">
			<field name="uneLigne" access="priv" jdoc=""/>
			<field name="newbuf" access="pub" jdoc=""/>
			<field name="INDENT_SIZE" access="pub" jdoc=""/>
			<field name="indent" access="pub" jdoc=""/>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.PHPIndentPHP(String)" access="pub" jdoc="">
				<comm cntt="P_AVANT();"/>
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.setIndentSize(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.get()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.countChar(String, char)" access="priv" jdoc="">
				<param name="s"/>
				<param name="c"/>
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.parseLigne()" access="priv" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.indent()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.P_AVANT()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.P_FIN_LIGNE()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.P_FIN()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndentPHP.java:default.PHPIndentPHP.P_APRES()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPIndenter.java:default">
		<class name="/plugins/Php/src/PHPIndenter.java:default.PHPIndenter" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<mth name="/plugins/Php/src/PHPIndenter.java:default.PHPIndenter.PHPIndenter()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndenter.java:default.PHPIndenter.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPIndenterBloc.java:default">
		<class name="/plugins/Php/src/PHPIndenterBloc.java:default.PHPIndenterBloc" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<mth name="/plugins/Php/src/PHPIndenterBloc.java:default.PHPIndenterBloc.PHPIndenterBloc()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPIndenterBloc.java:default.PHPIndenterBloc.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPModifier.java:default">
		<class name="/plugins/Php/src/PHPModifier.java:default.PHPModifier" intfc="n" abs="y" inn="n" sloc="17" jdoc="">
			<field name="mode" access="prot" jdoc=""/>
			<mth name="/plugins/Php/src/PHPModifier.java:default.PHPModifier.PHPModifier(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPModifier.java:default.PHPModifier.modifier(JextTextArea)" access="pub" jdoc="">
				<param name="textArea"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPModifierFichier.java:default">
		<class name="/plugins/Php/src/PHPModifierFichier.java:default.PHPModifierFichier" intfc="n" abs="n" inn="n" sloc="44" jdoc="">
			<mth name="/plugins/Php/src/PHPModifierFichier.java:default.PHPModifierFichier.PHPModifierFichier(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPModifierFichier.java:default.PHPModifierFichier.modifier(JextTextArea)" access="pub" jdoc="">
				<comm cntt="On d�coupe en partie (HTML et PHP)"/>
				<comm cntt="Pour chaque type de partie on implique une certaine m�thode de d�coupage"/>
				<comm cntt="System.out.println(machin[j].getType()+&amp;quot;[&amp;gt;&amp;quot;+textArea.getText(machin[j].getStart(), machin[j].getSize())+&amp;quot;&amp;lt;]\n&amp;quot;);"/>
				<param name="textArea"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPModifierSelection.java:default">
		<class name="/plugins/Php/src/PHPModifierSelection.java:default.PHPModifierSelection" intfc="n" abs="n" inn="n" sloc="62" jdoc="">
			<mth name="/plugins/Php/src/PHPModifierSelection.java:default.PHPModifierSelection.PHPModifierSelection(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPModifierSelection.java:default.PHPModifierSelection.modifier(JextTextArea)" access="pub" jdoc="">
				<comm cntt="D�coupage Total"/>
				<comm cntt="On regarde si la selection commence sur du HTML ou du PHP"/>
				<comm cntt="D�coupage de la selection"/>
				<comm cntt="On est d�ja dans du code PHP"/>
				<comm cntt="On est d�ja dans du code PHP"/>
				<param name="textArea"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPParser.java:default">
		<class name="/plugins/Php/src/PHPParser.java:default.PHPParser" intfc="n" abs="y" inn="n" sloc="352" jdoc="">
			<comm cntt="commentaire entre"/>
			<comm cntt="commentaire commencant par ou #"/>
			<comm cntt="commentaire type phpdoc"/>
			<comm cntt="Chaine de caracteres entre &amp;quot;&amp;quot;"/>
			<comm cntt="Chaine de caracteres entre &amp;apos;&amp;apos;"/>
			<comm cntt="entre {}"/>
			<comm cntt="entre ()"/>
			<comm cntt="entre &amp;lt;?php ?&amp;gt;"/>
			<comm cntt="Caract�re � analyser"/>
			<comm cntt="Indice Courant"/>
			<comm cntt="Indice Temporaire"/>
			<comm cntt="Nombre de carcteres Lu"/>
			<comm cntt="Longueur du buffer d&amp;apos;entree"/>
			<comm cntt="On est dans block inutile ( commentaire ou chaine de caract�res PHP)"/>
			<const name="T_COM1" access="prot" jdoc=""/>
			<const name="T_COM2" access="prot" jdoc=""/>
			<const name="T_COM3" access="prot" jdoc=""/>
			<const name="T_STR1" access="prot" jdoc=""/>
			<const name="T_STR2" access="prot" jdoc=""/>
			<const name="T_BLOC1" access="prot" jdoc=""/>
			<const name="T_BLOC2" access="prot" jdoc=""/>
			<const name="T_PHP" access="prot" jdoc=""/>
			<field name="inputstr" access="priv" jdoc=""/>
			<field name="typeblock" access="priv" jdoc=""/>
			<field name="c" access="priv" jdoc=""/>
			<field name="ind" access="priv" jdoc=""/>
			<field name="dni" access="priv" jdoc=""/>
			<field name="step" access="priv" jdoc=""/>
			<field name="len" access="priv" jdoc=""/>
			<field name="nullblock" access="priv" jdoc=""/>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_AVANT()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_DEBUT()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_FIN_LIGNE()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_DEBUT_BLOC_CODE()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_FIN_BLOC_CODE()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_DEBUT_BLOC_CONDITION()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_FIN_BLOC_CONDITION()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_SEPARATEUR()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_ESPACE()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_DEBUT_PHP()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_FIN_PHP()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_KEYWORD_A()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_KEYWORD_B()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_KEYWORD_C()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_KEYWORD_D()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_FIN()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.P_APRES()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.PHPParser(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.parse()" access="prot" jdoc="">
				<comm cntt="en attend la fin du traitement pour changer de type"/>
				<comm cntt="Debut d&amp;apos;un bloc PHP"/>
				<comm cntt="Analyse du code PHP"/>
				<comm cntt="Debut de Commentaires ?"/>
				<comm cntt="Fin de commentaire"/>
				<comm cntt="Fin de commentaire"/>
				<comm cntt="On permet l&amp;apos;interception de fin de ligne partout (m�me dans les commentaires) sauf"/>
				<comm cntt="dans les chaines de caract�res"/>
				<comm cntt="D�but d&amp;apos;une chaine de caract�res"/>
				<comm cntt="Fin d&amp;apos;une chaine de caract�res"/>
				<comm cntt="Debut d&amp;apos;une chaine de caract�res"/>
				<comm cntt="Fin d&amp;apos;une chaine de caract�res"/>
				<comm cntt="Debut d&amp;apos;un bloc de code"/>
				<comm cntt="Fin d&amp;apos;un bloc de code"/>
				<comm cntt="Debut d&amp;apos;une condition"/>
				<comm cntt="Fin d&amp;apos;une condition"/>
				<comm cntt="On ne fait rien"/>
				<comm cntt="Pseudo Fonction (language construct)"/>
				<comm cntt="Peut-�tre utilis� avec des parenth�ses � voir pour mieux faire ..."/>
				<comm cntt="On est dans de l&amp;apos;HTML"/>
				<comm cntt="System.out.println(&amp;quot;c[&amp;quot;+String.valueOf(c)+&amp;quot;] ind[&amp;quot;+String.valueOf(ind)+&amp;quot;] dni[&amp;quot;+String.valueOf(dni)+&amp;quot;] step[&amp;quot;+String.valueOf(step)+&amp;quot;] len[&amp;quot;+String.valueOf(len)+&amp;quot;]\n&amp;quot;);"/>
				<comm cntt="On change de type apres P_FIN afin de consid�rer les s�parateurs suivants } ) etc..."/>
				<comm cntt="comme faisant partie du type qui termine"/>
				<comm cntt="Si n�cessaire on avance un peu plus vite"/>
				<comm cntt="On retire 1 car le for ajoute 1"/>
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.set(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.get()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.getType()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.testType(int)" access="prot" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.setType(int)" access="priv" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.unsetType(int)" access="priv" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.getCharLu()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.getNbCharLu()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.getStrLu()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.getIndice()" access="prot" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.matchWord(int, int, String)" access="priv" jdoc="">
				<param name="ind1"/>
				<param name="ind2"/>
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.matchSeparator(int, int, String)" access="priv" jdoc="">
				<param name="ind1"/>
				<param name="ind2"/>
				<param name="s"/>
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.beginWithPHP()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPParser.java:default.PHPParser.beginWithHTML()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPPlugin.java:default">
		<class name="/plugins/Php/src/PHPPlugin.java:default.PHPPlugin" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<mth name="/plugins/Php/src/PHPPlugin.java:default.PHPPlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="menus"/>
				<param name="menuItems"/>
			</mth>
			<mth name="/plugins/Php/src/PHPPlugin.java:default.PHPPlugin.register(JextFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/Php/src/PHPPlugin.java:default.PHPPlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/Php/src/PHPPlugin.java:default.PHPPlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPPlugin.java:default.PHPPlugin.stop()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/Php/src/PHPQuickOpen.java:default">
		<class name="/plugins/Php/src/PHPQuickOpen.java:default.PHPQuickOpen" intfc="n" abs="n" inn="n" sloc="45" jdoc="">
			<mth name="/plugins/Php/src/PHPQuickOpen.java:default.PHPQuickOpen.PHPQuickOpen()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/Php/src/PHPQuickOpen.java:default.PHPQuickOpen.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="On cherche le nom du fichier"/>
				<comm cntt="Chemin relatif"/>
				<comm cntt="Chemin relatif"/>
				<comm cntt="Chemin absolue"/>
				<comm cntt="On ouvre le fichier"/>
				<param name="evt"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/PyBrowse/PyBrowsePlugin.java:default">
		<class name="/plugins/PyBrowse/PyBrowsePlugin.java:default.PyBrowsePlugin" intfc="n" abs="n" inn="n" sloc="10" jdoc="">
			<mth name="/plugins/PyBrowse/PyBrowsePlugin.java:default.PyBrowsePlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="menus"/>
				<param name="menuItems"/>
			</mth>
			<mth name="/plugins/PyBrowse/PyBrowsePlugin.java:default.PyBrowsePlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/PyBrowse/PyBrowsePlugin.java:default.PyBrowsePlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/PyBrowse/PyBrowsePlugin.java:default.PyBrowsePlugin.stop()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/WheelMouse/:sun.awt">
		<class name="/plugins/WheelMouse/:sun.awt.DrawingSurface" intfc="n" abs="n" inn="n" sloc="2" jdoc="">
		</class>
		<class name="/plugins/WheelMouse/:sun.awt.Win32DrawingSurface" intfc="n" abs="n" inn="n" sloc="5" jdoc="">
			<mth name="/plugins/WheelMouse/:sun.awt.Win32DrawingSurface.getHWnd()" access="pub" jdoc="">
				<comm cntt="TODO Auto-generated method stub"/>
			</mth>
		</class>
		<class name="/plugins/WheelMouse/:sun.awt.DrawingSurfaceInfo" intfc="n" abs="n" inn="n" sloc="9" jdoc="">
			<mth name="/plugins/WheelMouse/:sun.awt.DrawingSurfaceInfo.lock()" access="pub" jdoc="">
				<comm cntt="TODO Auto-generated method stub"/>
			</mth>
			<mth name="/plugins/WheelMouse/:sun.awt.DrawingSurfaceInfo.getSurface()" access="pub" jdoc="">
				<comm cntt="TODO Auto-generated method stub"/>
			</mth>
			<mth name="/plugins/WheelMouse/:sun.awt.DrawingSurfaceInfo.unlock()" access="pub" jdoc="">
				<comm cntt="TODO Auto-generated method stub"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/WheelMouse/JFrameEx.java:default">
		<class name="/plugins/WheelMouse/JFrameEx.java:default.JFrameEx" intfc="n" abs="n" inn="n" sloc="76" jdoc="">
			<comm cntt="This is undocumented, but works on JDK1.1.8, JDK1.2.2 and JDK1.3"/>
			<comm cntt="native entry point for subclassing the JFrame window"/>
			<comm cntt="native entry point for removing the hook."/>
			<comm cntt="this is the function which serves as a call back when"/>
			<comm cntt="a mouse wheel movement is detected."/>
			<field name="comp" access="priv" jdoc=""/>
			<mth name="/plugins/WheelMouse/JFrameEx.java:default.JFrameEx.setComponent(Component)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/plugins/WheelMouse/JFrameEx.java:default.JFrameEx.getHWND()" access="pub" jdoc="">
				<comm cntt="Get the drawing surface"/>
				<comm cntt="(comp.getPeer())).getDrawingSurfaceInfo()"/>
				<comm cntt="Get the Win32 specific information"/>
			</mth>
			<mth name="/plugins/WheelMouse/JFrameEx.java:default.JFrameEx.setHook(int)" access="pub" jdoc="">
				<param name="hwnd"/>
			</mth>
			<mth name="/plugins/WheelMouse/JFrameEx.java:default.JFrameEx.resetHook(int)" access="pub" jdoc="">
				<param name="hwnd"/>
			</mth>
			<mth name="/plugins/WheelMouse/JFrameEx.java:default.JFrameEx.notifyMouseWheel(short, short, long, long)" access="pub" jdoc="">
				<comm cntt="Convert screen coordinates to component specific offsets."/>
				<comm cntt="Find the embedded Swing component which should receive the scroll messages"/>
				<comm cntt="This prevents flashing on JScrollPane viewports"/>
				<comm cntt="Get the current value and set the new value depending on"/>
				<comm cntt="the direction of the mouse wheel."/>
				<comm cntt="Divide down to per line increment"/>
				<param name="fwKeys"/>
				<param name="zDelta"/>
				<param name="xPos"/>
				<param name="yPos"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/WheelMouse/WheelMouseOptionPane.java:default">
		<class name="/plugins/WheelMouse/WheelMouseOptionPane.java:default.WheelMouseOptionPane" intfc="n" abs="n" inn="n" sloc="45" jdoc="">
			<field name="cLineEnabled" access="priv" jdoc=""/>
			<field name="cImageEnabled" access="priv" jdoc=""/>
			<field name="tWheelMouseLineIncrement" access="priv" jdoc=""/>
			<mth name="/plugins/WheelMouse/WheelMouseOptionPane.java:default.WheelMouseOptionPane.WheelMouseOptionPane()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/WheelMouse/WheelMouseOptionPane.java:default.WheelMouseOptionPane.save()" access="pub" jdoc="Called when the options dialog&amp;apos;s `OK&amp;apos; button is pressed. This should save any properties saved in this option pane.">
			</mth>
		</class>
	</pkg>
	<pkg name="/plugins/WheelMouse/WheelMousePlugin.java:default">
		<class name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin" intfc="n" abs="n" inn="n" sloc="44" jdoc="">
			<comm cntt="Load the shared library for the native functions"/>
			<mth name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="optionsDialog"/>
			</mth>
			<mth name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin.addWheelMouseListener(Component)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin.removeWheelMouseListener(Component)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin.startListeningForOtherWindows()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="pluginsMenus"/>
				<param name="pluginsMenuItems"/>
			</mth>
			<mth name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin.stop()" access="pub" jdoc="">
			</mth>
		<class name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin$WindowAWTEvent" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<mth name="/plugins/WheelMouse/WheelMousePlugin.java:default.WheelMousePlugin$WindowAWTEvent.eventDispatched(AWTEvent)" access="pub" jdoc="">
				<param name="awtevt"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/plugins/XMLBrowse/XMLBrowsePlugin.java:default">
		<class name="/plugins/XMLBrowse/XMLBrowsePlugin.java:default.XMLBrowsePlugin" intfc="n" abs="n" inn="n" sloc="10" jdoc="">
			<mth name="/plugins/XMLBrowse/XMLBrowsePlugin.java:default.XMLBrowsePlugin.createMenuItems(JextFrame, Vector, Vector)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="menus"/>
				<param name="menuItems"/>
			</mth>
			<mth name="/plugins/XMLBrowse/XMLBrowsePlugin.java:default.XMLBrowsePlugin.createOptionPanes(OptionsDialog)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/plugins/XMLBrowse/XMLBrowsePlugin.java:default.XMLBrowsePlugin.start()" access="pub" jdoc="">
			</mth>
			<mth name="/plugins/XMLBrowse/XMLBrowsePlugin.java:default.XMLBrowsePlugin.stop()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/updating/ChoiceForm.java:default">
		<class name="/updating/ChoiceForm.java:default.ChoiceForm" intfc="n" abs="n" inn="n" sloc="118" jdoc="">
			<comm cntt="end method"/>
			<comm cntt="class DetailsTableModel extends AbstractTableModel { private PluginDesc plugin; public DetailsTableModel(PluginDesc plugin) { this.plugin = plugin; } private String[] names = { &amp;quot;Name&amp;quot;, &amp;quot;Version&amp;quot;, &amp;quot;Binary size&amp;quot;, &amp;quot;Source size&amp;quot;, &amp;quot;Description: &amp;quot; }; public int getColumnCount() { return 2; } public int getRowCount() { return 5; } public Object getValueAt(int row, int col) { if (col == 0) return names[row]; switch(row) { case 0: return plugin.getDisplayName(); case 1: return plugin.getRelease(); case 2: return new Integer(plugin.getBinSize()); case 3: return new Integer(plugin.getSrcSize()); case 4: return plugin.getDesc(); } return null; } public String getColumnName(int n) { return null; } public boolean isCellEditable(int row, int col) { return false; } }"/>
			<field name="plugTable" access="priv" jdoc=""/>
			<field name="rightPane" access="priv" jdoc=""/>
			<field name="downPane" access="priv" jdoc=""/>
			<field name="upPane" access="priv" jdoc=""/>
			<field name="mirrorsBox" access="priv" jdoc=""/>
			<field name="downBin" access="priv" jdoc=""/>
			<field name="downSrc" access="priv" jdoc=""/>
			<field name="install" access="priv" jdoc=""/>
			<field name="close" access="priv" jdoc=""/>
			<field name="details" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="plugins" access="priv" jdoc=""/>
			<field name="dataProvider" access="priv" jdoc=""/>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm.ChoiceForm()" access="pub" jdoc="">
				<comm cntt="data building part"/>
				<comm cntt="----GUI"/>
				<comm cntt="--Table and its scroller"/>
				<comm cntt="right panel"/>
				<comm cntt="down panel"/>
				<comm cntt="box = new BoxLayout(downPane, BoxLayout.X_AXIS); downPane.setLayout(box); downPane.add(Box.createHorizontalGlue());"/>
				<comm cntt="upper panel"/>
				<comm cntt="upPane.setLayout(new BorderLayout());"/>
				<comm cntt=", BorderLayout.WEST);"/>
				<comm cntt=", BorderLayout.EAST);"/>
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm.end()" access="priv" jdoc="">
				<comm cntt="to restart things quickly. To exit, the user must close the window with"/>
				<comm cntt="the title-bar button."/>
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm.getMirror()" access="priv" jdoc="">
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm.actionPerformed(ActionEvent)" access="pub" jdoc="">
				<comm cntt="so only one form is shown."/>
				<comm cntt="end for on rows"/>
				<comm cntt="end if (src == close)"/>
				<param name="ae"/>
			</mth>
		<class name="/updating/ChoiceForm.java:default.ChoiceForm$DownloadErrorNotify" intfc="n" abs="n" inn="y" sloc="15" jdoc="">
			<field name="name" access="priv" jdoc=""/>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$DownloadErrorNotify.DownloadErrorNotify(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$DownloadErrorNotify.run(Object, Throwable)" access="pub" jdoc="">
				<param name="result"/>
				<param name="excep"/>
			</mth>
		</class>
		<class name="/updating/ChoiceForm.java:default.ChoiceForm$DetailForm" intfc="n" abs="n" inn="y" sloc="76" jdoc="">
			<field name="plugin" access="priv" jdoc=""/>
			<field name="mainPane" access="priv" jdoc=""/>
			<field name="gridbag" access="priv" jdoc=""/>
			<field name="c" access="priv" jdoc=""/>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$DetailForm.DetailForm(PluginDesc, boolean)" access="pub" jdoc="">
				<param name="plugin"/>
				<param name="modal"/>
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$DetailForm.buildUI()" access="priv" jdoc="">
				<comm cntt="JTable table;"/>
				<comm cntt="getContentPane().add(new JLabel(&amp;quot;Name: &amp;quot; + plugin.getDisplayName())); getContentPane().add(new JLabel(&amp;quot;Version: &amp;quot; + plugin.getRelease())); getContentPane().add(new JLabel(&amp;quot;Binary size: &amp;quot; + plugin.getBinSize())); getContentPane().add(new JLabel(&amp;quot;Source size: &amp;quot; + plugin.getSrcSize())); getContentPane().add(new JLabel(&amp;quot;Description: &amp;quot; + plugin.getDesc()));"/>
				<comm cntt="table = new JTable(new DetailsTableModel(plugin)); table.setAlignmentX(CENTER_ALIGNMENT); TableColumn column = null; column = table.getColumnModel().getColumn(0); column.setPreferredWidth(90); column = table.getColumnModel().getColumn(1); column.setPreferredWidth(300);"/>
				<comm cntt="join the author names"/>
				<comm cntt="build the two HTML panes."/>
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$DetailForm.shortAdd(JComponent)" access="priv" jdoc="">
				<param name="comp"/>
			</mth>
		</class>
		<class name="/updating/ChoiceForm.java:default.ChoiceForm$PluginTableModel" intfc="n" abs="n" inn="y" sloc="24" jdoc="">
			<field name="names" access="priv" jdoc=""/>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$PluginTableModel.getColumnCount()" access="pub" jdoc="">
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$PluginTableModel.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$PluginTableModel.getValueAt(int, int)" access="pub" jdoc="">
				<comm cntt="case 4: return plugins[row].getBinUrl((String)mirrorsBox.getSelectedItem());"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$PluginTableModel.getColumnName(int)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/updating/ChoiceForm.java:default.ChoiceForm$PluginTableModel.isCellEditable(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/updating/PlugReader.java:default">
		<class name="/updating/PlugReader.java:default.PlugReader" intfc="n" abs="n" inn="n" sloc="102" jdoc="">
			<comm cntt="XML parsing part."/>
			<comm cntt=", files;"/>
			<field name="loaded" access="priv" jdoc=""/>
			<field name="plugins" access="priv" jdoc=""/>
			<field name="mirrors" access="priv" jdoc=""/>
			<field name="plugList" access="pub" jdoc=""/>
			<field name="authors" access="pub" jdoc=""/>
			<field name="deps" access="pub" jdoc=""/>
			<field name="mirrorList" access="pub" jdoc=""/>
			<field name="currPlugin" access="pub" jdoc=""/>
			<field name="currUrlTemplate" access="pub" jdoc=""/>
			<field name="content" access="pub" jdoc=""/>
			<field name="attribs" access="pub" jdoc=""/>
			<mth name="/updating/PlugReader.java:default.PlugReader.loadXml(Reader)" access="pub" jdoc="">
				<comm cntt="the parser throws ONLY this exception. So I can&amp;apos;t do"/>
				<comm cntt="anything else :-((( !"/>
				<param name="in"/>
			</mth>
			<mth name="/updating/PlugReader.java:default.PlugReader.getMirrors()" access="pub" jdoc="">
			</mth>
			<mth name="/updating/PlugReader.java:default.PlugReader.getPlugins()" access="pub" jdoc="">
			</mth>
			<mth name="/updating/PlugReader.java:default.PlugReader.buildFormatter(String)" access="priv" jdoc="">
				<param name="urlTempl"/>
			</mth>
			<mth name="/updating/PlugReader.java:default.PlugReader.startDocument()" access="pub" jdoc="">
				<comm cntt="files = new ArrayList(3);"/>
			</mth>
			<mth name="/updating/PlugReader.java:default.PlugReader.endDocument()" access="pub" jdoc="">
				<comm cntt="files = null;"/>
			</mth>
			<mth name="/updating/PlugReader.java:default.PlugReader.attribute(String, String, boolean)" access="pub" jdoc="">
				<param name="atName"/>
				<param name="value"/>
				<param name="isSpecified"/>
			</mth>
			<mth name="/updating/PlugReader.java:default.PlugReader.startElement(String)" access="pub" jdoc="">
				<param name="elname"/>
			</mth>
			<mth name="/updating/PlugReader.java:default.PlugReader.charData(char[], int, int)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
			<mth name="/updating/PlugReader.java:default.PlugReader.endElement(String)" access="pub" jdoc="">
				<param name="elname"/>
			</mth>
		</class>
	</pkg>
</java-project>