<?xml version="1.0" encoding="UTF-8"?>
<java-project id="default" name="sandmark-3.4" revision="sandmark-3.4">
	<pkg name="/:sandmark">
		<class name="/:sandmark.AppAlgorithm" intfc="y" abs="n" inn="n" sloc="1" jdoc="">
		</class>
		<class name="/:sandmark.Algorithm" intfc="n" abs="y" inn="n" sloc="45" jdoc="The Algorithm class encapsulates common characteristics of all Sandmark algorithms. Most of this information is about the description of the algorithm, while some of the information is about the algorithm&amp;apos;s interaction with other Sandmark algorithms (dependencies and interferrence). @author Kelly Heffner (&amp;lt;a href=&amp;quot;mailto:kheffner@cs.arizona.edu&amp;quot;&amp;gt;kheffner@cs.arizona.edu&amp;lt; a&amp;gt;)">
			<mth name="/:sandmark.Algorithm.getShortName()" access="pub" jdoc="Specifies this algorithm&amp;apos;s short name. A short name should be no longer than 20 characters, and contain capitalized space delimited words (i.e. title case). For example, an obfuscation that sets all of the fields in a jar file to public scoping should have a short name like &amp;quot;Set Fields Public&amp;quot;. @return the short name for this algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getLongName()" access="pub" jdoc="Specifies this algorithm&amp;apos;s long name. There is no limit on the size of the long name, but it should be in title case. @return the long name for this algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getAlgHTML()" access="pub" jdoc="Gives a description of what the algorithm does. This should not be a long description of what your code does, rather a brief description as to what effect it has on the program. For example, a good algorithm description would be &amp;quot;Set Fields Public changes the scope of all static and non-static fields to public.&amp;quot;; a bad algorithm description would be &amp;quot;Set Fields Public creates a BCEL object for each class and makes modifications to it, then stores it back into the jar file.&amp;quot; @return an HTML formatted description of what the algorithm does.">
			</mth>
			<mth name="/:sandmark.Algorithm.getAlgURL()" access="pub" jdoc="Specifies the URL of where the user can find more information about the algorithm. This URL should point to the help.html file in the doc directory where the algorithm resides, starting from the sandmark directory. For example, the URL for the static_template watermarking sample would be sandmark watermark static_template doc help.html @return a URL to the help.html file for the algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getConfigProperties()" access="pub" jdoc="Gets the ConfigProperties object which specifies the parameters for this run of the algorithm. It must be non-null and properly parented. See ConfigProperties for details. @return the parameters for this run of the algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getAuthor()" access="pub" jdoc="Specifies the author of the algorithm. @return the name of the author of the algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getAuthorEmail()" access="pub" jdoc="Specifies the email address author of the algorithm. @return the email address of the author of the algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getDescription()" access="pub" jdoc="Specifies what this algorithm does, briefly. This description is displayed to the user in the log of execution in Sandmark. @return a brief description of the algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getReferences()" access="pub" jdoc="Specifies any references that discuss the ideas in this algorithm. @return a list of references">
			</mth>
			<mth name="/:sandmark.Algorithm.getMutations()" access="pub" jdoc="Specifies the types of modifications that the algorithm makes. For more information see &amp;lt;code&amp;gt;ModificationProperty&amp;lt; code&amp;gt;. @return a list of mutations that this algorithm may do on the code">
			</mth>
			<mth name="/:sandmark.Algorithm.getPrerequisites()" access="pub" jdoc="Specifies a list of properties of algorithms that must be run on the target code before this algorithm is run. See &amp;lt;code&amp;gt;RequisiteProperty&amp;lt; code&amp;gt; for more details. This method should only be overridden if the algorithm has prerequisites. @return a list of prerequisites for this algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getPostrequisites()" access="pub" jdoc="Specifies a list of properties of algorithms that must be run on the target code after this algorithm is run. See &amp;lt;code&amp;gt;RequisiteProperty&amp;lt; code&amp;gt; for more details. This method should only be overridden if the algorithm has postrequisites. @return a list of postrequisites for this algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getPresuggestions()" access="pub" jdoc="Specifies a list of properties of algorithms that should be run on the target code before this algorithm is run, &amp;lt;i&amp;gt;but are not necessary&amp;lt; i&amp;gt;. See &amp;lt;code&amp;gt;RequisiteProperty&amp;lt; code&amp;gt; for more details. This method should only be overridden if the algorithm has a nonempty set of pre-suggestions. @return a list of suggested algorithm properties to run before this algorithm.">
			</mth>
			<mth name="/:sandmark.Algorithm.getPostsuggestions()" access="pub" jdoc="Specifies a list of properties of algorithms that should be run on the target code after this algorithm is run, &amp;lt;i&amp;gt;but are not necessary&amp;lt; i&amp;gt;. See &amp;lt;code&amp;gt;RequisiteProperty&amp;lt; code&amp;gt; for more details. This method should only be overridden if the algorithm has a nonempty set of post-suggestions. @return a list of suggested algorithm properties to run after this algorithm.">
			</mth>
			<mth name="/:sandmark.Algorithm.getPreprohibited()" access="pub" jdoc="Specifies a list of properties of algorithms that cannot be run on the target code before this algorithm is run. See &amp;lt;code&amp;gt;RequisiteProperty&amp;lt; code&amp;gt; for more details. This method should only be overridden if there is a nonempty set of prohibited algorithms. @return a list of prohibited algorithms to run before this algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.getPostprohibited()" access="pub" jdoc="Specifies a list of properties of algorithms that cannot be run on the target code after this algorithm is run. See &amp;lt;code&amp;gt;RequisiteProperty&amp;lt; code&amp;gt; for more details. This method should only be overridden if there is a nonempty set of prohibited algorithms. @return a list of prohibited algorithms to run after this algorithm">
			</mth>
			<mth name="/:sandmark.Algorithm.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.MethodAlgorithm" intfc="y" abs="n" inn="n" sloc="1" jdoc="">
		</class>
		<class name="/:sandmark.Console" intfc="n" abs="n" inn="n" sloc="43" jdoc="The sandmark.Console class presents a graphical interface to the SandMark system. @author Christian Collberg @version 1.0">
			<comm cntt="--------------------------------------------------------------"/>
			<comm cntt="Utils"/>
			<comm cntt="--------------------------------------------------------------"/>
			<const name="versionString" access="pub" jdoc=""/>
			<field name="sConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.Console.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.Console.getHelpURL()" access="pub" jdoc="Get the URL for the Help page for Sandmark @return url for help page">
			</mth>
			<mth name="/:sandmark.Console.constructOutputFileName(String, String)" access="pub" jdoc="Construct a new filename based on the &amp;apos;input&amp;apos; filename. If the input filename is xxxx.jar, then the output filename becomes xxxx_suffix.jar. If the output filename already exists, no change is made. @param output The output filename. @param input The input filename. @param suffix The string added to the filename. Should not contain the &amp;quot;_&amp;quot;.">
				<param name="in"/>
				<param name="suf"/>
			</mth>
			<mth name="/:sandmark.Console.sanityCheck()" access="pub" jdoc="Experimental method that checks that the basic requirements for running Sandmark have been met I am a little torn about whether to do all the tests and say all the ways in which current installation will fail or report the first failure and quit because its likely that fixing the first fixes them all.">
			</mth>
		</class>
		<class name="/:sandmark.ClassAlgorithm" intfc="y" abs="n" inn="n" sloc="1" jdoc="">
		</class>
		<class name="/:sandmark.Constants" intfc="n" abs="n" inn="n" sloc="45" jdoc="">
			<const name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.Constants.majorVersion()" access="pub" jdoc="Return the major version number.">
			</mth>
			<mth name="/:sandmark.Constants.minorVersion()" access="pub" jdoc="Return the minor version number.">
			</mth>
			<mth name="/:sandmark.Constants.subMinorVersion()" access="pub" jdoc="Return the sub-minor version number.">
			</mth>
			<mth name="/:sandmark.Constants.nickName()" access="pub" jdoc="Return the nickname. Past names: &amp;lt;pre&amp;gt; 3.3: Xavier 3.4: Mystique &amp;lt; pre&amp;gt; Future names: &amp;lt;pre&amp;gt; Archangel Beast Cyclops Emma Frost Iceman Jean Grey Juggernaut Magneto Nightcrawler Sentinels Storm Wolverine Cablee Changeling Banshee Cannonball Colossus Dazzler Psylocke Bishop Forge Thunderbird I Chamber Havok Jubilee Emma Frost Longshot Gambit Maggott Magneto Lifeguard Marrow Polaris Shadowcat Northstar Sunfire Phoenix Rogue Stacy X Storm Thunderbird III Wolverine &amp;lt; pre&amp;gt; See also &amp;lt;a href=&amp;quot;http: www.marveldirectory.com teams xmen.htm&amp;quot;&amp;gt; Marvel Directory &amp;lt; a&amp;gt;">
			</mth>
			<mth name="/:sandmark.Constants.versionString()" access="pub" jdoc="Return the version number as a string.">
			</mth>
			<mth name="/:sandmark.Constants.longVersionString()" access="pub" jdoc="Return the version number as a string, including the nickname.">
			</mth>
			<mth name="/:sandmark.Constants.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.callgraph">
		<class name="/:sandmark.analysis.callgraph.ApplicationCFG" intfc="n" abs="n" inn="n" sloc="126" jdoc="This class is an application-wide control flow graph. Its nodes are BasicBlocks, with the exception of 3 special nodes that are just placeholder Objects. This class computes the callgraph of an application and uses that to determine inter-procedural control flow edges of the application-wide CFG. There are 3 special nodes: JAVA_LIB_SOURCE_BLOCK, JAVA_LIB_BODY_BLOCK, and JAVA_LIB_SINK_BLOCK. These represent the source, body, and sink of any java library method, respectively. Any time an application basic block B calls a java library method, the edges (B, JAVA_LIB_SOURCE_BLOCK) and (JAVA_LIB_SINK_BLOCK, B) are added. Similarly, for any method M that could be called by a java library method, the edges (JAVA_LIB_BODY_BLOCK, M.source) and (M.sink, JAVA_LIB_BODY_BLOCK) are added. In addition, the following edges are always present: (JAVA_LIB_SOURCE_BLOCK, JAVA_LIB_BODY_BLOCK), (JAVA_LIB_BODY_BLOCK, JAVA_LIB_SINK_BLOCK)">
			<const name="JAVA_LIB_SOURCE_BLOCK" access="pub" jdoc=""/>
			<const name="JAVA_LIB_BODY_BLOCK" access="pub" jdoc=""/>
			<const name="JAVA_LIB_SINK_BLOCK" access="pub" jdoc=""/>
			<field name="app" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.callgraph.ApplicationCFG.ApplicationCFG(sandmark.program.Application)" access="pub" jdoc="Initialize and build the application CFG for the given application.">
				<param name="APP"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.ApplicationCFG.build()" access="priv" jdoc="">
				<comm cntt="(JAVA_LIB_METHOD, method)"/>
				<comm cntt="(method, JAVA_LIB_METHOD)"/>
				<comm cntt="change the fallthrough and exception edges"/>
				<comm cntt="(method, method)"/>
				<comm cntt="change the fallthrough and exception edges"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.ApplicationCFG.getBlock(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="Returns the basic block that contains the given handle or null if it is not found.">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.ApplicationCFG.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.callgraph.CallGraph" intfc="n" abs="n" inn="n" sloc="192" jdoc="This class is a graph of method calls within an application. The nodes of this graph will be all the sandmark.program.Method objects in every class of the application. The edges represent the fact that one method calls (or might call) another. That is, there will be an edge from M1 to M2 if there is some invoke instruction in M1 that could invoke M2. All the edges of this graph are CallGraphEdges, and each one contains the handles of the instructions where the invoke was performed. That is, if there is an edge E=(M1,M2), then E will also contain all the instruction handles in M1 that might invoke M2. Since the only nodes in this graph are methods defined in the given application, no java library methods are represented. Therefore whenever a method makes a call that might invoke a java library method, there is an edge from that method to the static constant object JAVA_LIB_METHOD (which is just an Object, and not a sandmark.program.Method). Also, if any method in the application overrides a java library method, then it could potentially be invoked by some other java library method via dynamic method invocation. Thus, for each such method M there will be an edge (JAVA_LIB_METHOD, M) in the graph, which contains no instruction handles.">
			<const name="JAVA_LIB_METHOD" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.callgraph.CallGraph.CallGraph(CallGraph)" access="pub" jdoc="">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraph.CallGraph(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="I&amp;apos;ve put in the nodes, now build the edges"/>
				<comm cntt="check to see if I override any library method"/>
				<comm cntt="(and hence might be called by a library method)"/>
				<comm cntt="check to see what other methods I call"/>
				<comm cntt="exactly one edge should satisfy this test"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraph.callerSubgraph(sandmark.program.Method)" access="pub" jdoc="This returns a new CallGraph that is a subgraph of the original, which contains only &amp;apos;method&amp;apos; and all other nodes in the graph that have a path to &amp;apos;method&amp;apos; (i.e. all the methods that directly or indirectly invoke &amp;apos;method&amp;apos;)">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraph.getCallers(sandmark.program.Method)" access="pub" jdoc="Returns an iterator containing sandmark.program.Method objects, and possibly also the static constant JAVA_LIB_METHOD. (note that the method itself may be in this list, if it is recursive)">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraph.getCallees(sandmark.program.Method)" access="pub" jdoc="Returns an iterator containing sandmark.program.Method objects, and possibly also the static constant JAVA_LIB_METHOD. (note that the method itself may be in this list, if it is recursive)">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraph.getInvokeHandles(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="This will return a set of InstructionHandles of the invoke instructions where caller might invoke callee. (it just returns the contents of CallGraphEdge.getHandles() for the corresponding edge in the callgraph)">
				<comm cntt="exactly one edge should satisfy this test"/>
				<param name="caller"/>
				<param name="callee"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraph.getPotentialTargets(org.apache.bcel.generic.InvokeInstruction, sandmark.program.Class, sandmark.program.Application)" access="priv" jdoc="">
				<param name="invoke"/>
				<param name="referent"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraph.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.callgraph.CallGraphEdge" intfc="n" abs="n" inn="n" sloc="30" jdoc="This is an edge class used by CallGraph. In addition to storing a source and sink node, it stores a set of instruction handles. See the description of CallGraph for details.">
			<field name="sourceNode" access="priv" jdoc=""/>
			<field name="sinkNode" access="priv" jdoc=""/>
			<field name="handles" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.callgraph.CallGraphEdge.CallGraphEdge(CallGraphEdge)" access="pub" jdoc="">
				<param name="edge"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraphEdge.CallGraphEdge(Object, Object)" access="pub" jdoc="">
				<param name="source"/>
				<param name="sink"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraphEdge.sourceNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraphEdge.sinkNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraphEdge.addHandle(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraphEdge.getHandles()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.callgraph.CallGraphEdge.clone(Object, Object)" access="pub" jdoc="">
				<param name="source"/>
				<param name="sink"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.classhierarchy">
		<class name="/:sandmark.analysis.classhierarchy.ClassHierarchyException" intfc="n" abs="n" inn="n" sloc="7" jdoc="">
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchyException.ClassHierarchyException(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.classhierarchy.ClassHierarchy" intfc="n" abs="n" inn="n" sloc="562" jdoc="ClassHierarchy is a tree s.t. there exists an edge from class A to B iff B extends (or implements) A. For example, to retrieve all the subclasses of method with name S, you could define an: iterator: &amp;lt;code&amp;gt; it = this.breadthFirst((this.lookup(S))&amp;lt; code&amp;gt;. This iterator contains {@link sandmark.program.Class sandmark.program.Class} objects.">
			<comm cntt="Build the tree rooted in the class &amp;apos;className&amp;apos;. Assume that this is a &amp;apos;user-defined&amp;apos; class, i.e. one contained in the app object which can be loaded using Application Class."/>
			<comm cntt="Return true if this is an interface class."/>
			<comm cntt="Not sure why this is here but it creates MethodIDs from Methods..."/>
			<comm cntt="Querying the inheritance tree"/>
			<comm cntt="checks if method m is accessible from class cls"/>
			<comm cntt="checks if field f is accessible from class cls"/>
			<comm cntt="checks if the method is an instance initialization method"/>
			<comm cntt="Testing"/>
			<comm cntt="big slow test"/>
			<comm cntt="Call like this: &amp;gt; home collberg lib j2sdk1.4.0 bin java \ -classpath .:.. smextern3 BCEL.jar:.. smextern3 bloat-1.0.jar \ sandmark.analysis.classhierarchy.ClassHierarchy"/>
			<const name="DYNAMIC_INIT" access="priv" jdoc=""/>
			<const name="STATIC_INIT" access="priv" jdoc=""/>
			<field name="name2class" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.ClassHierarchy()" access="pub" jdoc="Null constructor, used for testing purposes.">
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.ClassHierarchy(sandmark.program.Application)" access="pub" jdoc="Build a class hierarchy tree from the classes in app. Any standard java classes (java. , etc) are also included if they can be loaded. Each node in the tree is a a class. Incoming edges represent parent classes, i.e. the superclass and any interface classes.">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.toDot()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.addApplication(sandmark.program.Application)" access="pub" jdoc="Adds the class files in the application app to this ClassHierarchy">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.addClass(sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Adding edge &amp;quot; + superClass + &amp;quot;-&amp;gt;&amp;quot; + cls);"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.lookup(String)" access="pub" jdoc="Return the class associated with this class name. @return The class object, if it is this hierarchy @throws ClassHierarchyException if the class is not in this hierarchy">
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.lookup(String, sandmark.program.Application)" access="pub" jdoc="">
				<param name="className"/>
				<param name="referent"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.isLibraryClass(sandmark.program.Class)" access="pub" jdoc="@return true if cls is an instance of {@link sandmark.program.LibraryClass sandmark.program.LibraryClass},">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.isInterface(sandmark.program.Class)" access="pub" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.getMethods(sandmark.program.Class)" access="pub" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.classExtends(sandmark.program.Class, sandmark.program.Class)" access="pub" jdoc="Return true of subClass extends (directly or indirectly) superClass. classExtends(A,A) returns true.">
				<param name="subClass"/>
				<param name="superClass"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.itAsList(java.util.Iterator)" access="priv" jdoc="">
				<param name="it"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.superClasses(sandmark.program.Class)" access="pub" jdoc="Return all the classes that subClass extends or implements, directly or indirectly. subClass is part of this list.">
				<param name="subClass"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.subClasses(sandmark.program.Class)" access="pub" jdoc="Return all the classes that inherit superClass, directly or indirectly. superClass is part of this list.">
				<param name="superClass"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.inheritanceChain(sandmark.program.Class)" access="pub" jdoc="Return all the classes that extend Class, directly or indirectly, or which Class extends, directly or indirectly. Class is part of this list.">
				<param name="Class"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.overrides(sandmark.util.MethodID, sandmark.util.MethodID)" access="pub" jdoc="Return true if subMethod overrides superMethod. They must have the same signature and name and subMethod must be in a class that extends superMethod, directly or indirectly. overrides(A,A) will return true.">
				<param name="subMethod"/>
				<param name="superMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.overloads(sandmark.util.MethodID, sandmark.util.MethodID)" access="pub" jdoc="Return true if subMethod overloads superMethod. They must have the same name, different signatures, and subMethod must be in a class that extends superMethod, directly or indirectly. overloads(A,A) will return false.">
				<param name="subMethod"/>
				<param name="superMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.overrides(sandmark.util.MethodID)" access="pub" jdoc="Return all methods overridden by subMethod. They must have the same signature and name and subMethod must be in a class that extends superMethod, directly or indirectly. overrides(A,A) will return true.">
				<param name="subMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.allOverrides(sandmark.util.MethodID)" access="pub" jdoc="Return all methods overridden by &amp;apos;method&amp;apos; or which it overrides. All methods must have the same signature and name and &amp;apos;method&amp;apos; must be in a class that extends the other methods, directly or indirectly, or vice versa. In other words, this method returns all the methods in the class hierarchy related to &amp;apos;method&amp;apos; through overriding.">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.allOverloads(sandmark.util.MethodID)" access="pub" jdoc="Return all methods overloaded by &amp;apos;method&amp;apos; or which it overloads. All methods must have the same name but a different signature from &amp;apos;method&amp;apos; must be in a class that extends the other methods, directly or indirectly, or vice versa. In other words, this method returns all the methods in the class hierarchy related to &amp;apos;method&amp;apos; through overloading.">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.methodRenameOK(sandmark.util.MethodID, String)" access="pub" jdoc="A convenience version of methodRenameOK(MethodID, MethodID) that is used to test to see if a new method name is ok, given that nothing else about the method changes. @param origMethod the method to rename @param newName the proposed new name @return true if new name does not cause any new conflicts.">
				<param name="origMethod"/>
				<param name="newName"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.methodRenameOK(sandmark.util.MethodID, sandmark.util.MethodID)" access="pub" jdoc="Return false if &amp;apos;origMethod&amp;apos; is special in some way, i.e. we cannot change its name or signature into &amp;apos;newMethod&amp;apos;. A method name signature change is illegal if the original method overrides some method (directly or indirectly) in the java. hierarchy; if the new signature overrides a method declared in a superclass. if the original method is a static or dynamic initializer. There may be other conditions as well, in particular related to whether a method is static or dynamic.">
				<param name="origMethod"/>
				<param name="newMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.overridesLibraryMethod(sandmark.util.MethodID)" access="pub" jdoc="Checks if the method overrides some library method (directly or indirectly) @param suspect the method in question @return true if the method overrides a method in a library">
				<param name="suspect"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.isSpecialMethod(sandmark.util.MethodID)" access="pub" jdoc="Checks if the method is a special java method, such as the main method, or an initializer. @param origMethod the method in question @return true if the method is special and should not be changed">
				<comm cntt="If a method is a static or dynamic initializer, it should not be valid to rename it to anything. Check added 2 21 2002 -Kelly Heffner"/>
				<comm cntt="do not allow renaming of the main method"/>
				<param name="origMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.getMethodsToRename(sandmark.util.MethodID)" access="pub" jdoc="Returns an array of methods that need to be changed if &amp;apos;origMethod&amp;apos; is renamed &amp;apos;newMethod&amp;apos;.">
				<param name="origMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.resolveMethodReference(sandmark.util.MethodID, sandmark.program.Class)" access="pub" jdoc="Resolves an unresolved symbolic reference from class c to a method specified in MethodID m. @param m method id specifying the method @param referent class that references the method @return the resolved method if found, null otherwise">
				<comm cntt="looks for the method in the interfaces if it hasn&amp;apos;t found it yet"/>
				<param name="m"/>
				<param name="referent"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.resolveInterfaceMethodReference(sandmark.util.MethodID, sandmark.program.Class)" access="pub" jdoc="">
				<param name="m"/>
				<param name="referent"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.resolveFieldReference(sandmark.util.FieldID, sandmark.program.Class)" access="pub" jdoc="">
				<param name="f"/>
				<param name="referent"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy._resolveFieldReference(sandmark.util.FieldID, sandmark.program.Class, sandmark.program.Class)" access="priv" jdoc="">
				<param name="f"/>
				<param name="container"/>
				<param name="referent"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.isAccessible(sandmark.program.Method, sandmark.program.Class)" access="priv" jdoc="">
				<param name="m"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.isAccessible(sandmark.program.Field, sandmark.program.Class)" access="priv" jdoc="">
				<param name="f"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.findInvokeSpecialTarget(sandmark.util.MethodID, sandmark.program.Class)" access="pub" jdoc="Finds the target method of the invokespecial instruction. @param mid methodID @param cls class where invokespecial is called from @return the target method">
				<param name="mid"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.isInstanceInitMethod(sandmark.program.Method)" access="priv" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.testExtends(sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.program.Class, sandmark.program.Class)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="subClass"/>
				<param name="superClass"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.testSuperClasses(sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.program.Class)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="subClass"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.testSubClasses(sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.program.Class)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="superClass"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.testInheritanceChain(sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.program.Class)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="Class"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.testOverrides(sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.util.MethodID, sandmark.util.MethodID)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="subMethod"/>
				<param name="superMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.testOverrides(sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.util.MethodID)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="subMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.testAllOverrides(sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.util.MethodID)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="subMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.testMethodRenameOK(sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.util.MethodID, sandmark.util.MethodID)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="origMethod"/>
				<param name="newMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.testGetMethodsToRename(sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.util.MethodID)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="origMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.test1()" access="pub" jdoc="">
				<comm cntt="for(int i = 0; i &amp;lt; c.getMethods().length; i++) System.out.println(c.getMethods()[i].getName() + &amp;quot;: &amp;quot; + c.getMethods()[i].getSignature());"/>
			</mth>
			<mth name="/:sandmark.analysis.classhierarchy.ClassHierarchy.main(String[])" access="pub" jdoc="">
				<comm cntt="System.out.println(ch.toDot());"/>
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.controlflowgraph">
		<class name="/:sandmark.analysis.controlflowgraph.NullNENullCallGenerator" intfc="n" abs="n" inn="n" sloc="308" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="mSrcCFG" access="priv" jdoc=""/>
			<field name="mDestMG" access="priv" jdoc=""/>
			<field name="mSrcMG" access="priv" jdoc=""/>
			<field name="mDestArgTypes" access="priv" jdoc=""/>
			<field name="mDestReturnType" access="priv" jdoc=""/>
			<field name="mSrcEdgeIsFallthrough" access="priv" jdoc=""/>
			<field name="mSrcEdgeCx" access="priv" jdoc=""/>
			<field name="mSrcCurrentMaxLocals" access="priv" jdoc=""/>
			<field name="mSrcEdge" access="priv" jdoc=""/>
			<field name="mFactory" access="priv" jdoc=""/>
			<field name="mTestBlock" access="priv" jdoc=""/>
			<field name="mCallBlock" access="priv" jdoc=""/>
			<field name="mRvPopBlock" access="priv" jdoc=""/>
			<field name="mRestoreAndGotoBlock" access="priv" jdoc=""/>
			<field name="mExceptionHandlerBlock" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.NullNENullCallGenerator.addPhantomCall(MethodCFG, Edge, MethodCFG)" access="pub" jdoc="">
				<param name="srcMethod"/>
				<param name="srcEdge"/>
				<param name="destMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.NullNENullCallGenerator.buildOpaquePredicate()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.NullNENullCallGenerator.buildCallBlock()" access="priv" jdoc="">
				<comm cntt="Put all the instructions into a block"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.NullNENullCallGenerator.buildRvPopBlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.NullNENullCallGenerator.buildRestoreAndGotoBlock()" access="priv" jdoc="">
				<comm cntt="If the edge that was chosen above was a targeted edge, not a fallthrough edge, change the target to the beginning of tthe call block, and insert a goto to jump the the original target after the call"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.NullNENullCallGenerator.buildExceptionHandlerBlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.NullNENullCallGenerator.insertBlocks(java.util.List)" access="priv" jdoc="">
				<comm cntt="mSrcCFG.printCFG();"/>
				<param name="newExceptions"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer" intfc="n" abs="n" inn="n" sloc="408" jdoc="A PositiveIntSyntheizer generates an integer function that works by maintaining the &amp;quot;hidden&amp;quot; invariant: its one variable always has a nonnegative value. The function argument is made non-negative using a randomly chosen code fragment. Basic block code fragments (also randomly chosen) preserve the invariant. Code can be generated to force a positive, negative, zero, or nonzero result, allowing use with an opaque predicate.">
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.generate(sandmark.util.newgraph.Graph, sandmark.program.Class, short)" access="pub" jdoc="Generates an integer function corresponding to the given graph. All graphs are acceptable. The generated code is guaranteed to return safely, without throwing an exception, provided that the graph contains at least one leaf node. (A leaf node produces a return. With no return, the code loops forever.)">
				<param name="g"/>
				<param name="clazz"/>
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.generate(sandmark.util.newgraph.Graph, sandmark.program.Class, java.lang.Object, java.util.Map)" access="prot" jdoc="">
				<param name="g"/>
				<param name="clazz"/>
				<param name="root"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.generate(sandmark.util.newgraph.Graph, sandmark.program.Class, java.lang.Object, java.util.Map, short)" access="prot" jdoc="Generates an integer function with a constraint on the returned result. The opcode argument is one of the org.apache.bcel.Constants values IFLT, IFLE, IFEQ, IFNE, IFGE, IFGT, or NOP. The generated code will ensure, for any passed argument, that the result value passes the test (takes the jump) indicated by the opcode. A NOP argument indicates a don&amp;apos;t-care situation where the result is unconstrained.">
				<param name="graph"/>
				<param name="clazz"/>
				<param name="root"/>
				<param name="nodeNumbers"/>
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.getExits(sandmark.util.newgraph.Graph, java.util.Map, sandmark.util.newgraph.Graph)" access="priv" jdoc="Generates a list, indexed by node number, of java.util.BitSet objects identifying acceptable jump targets. For each graph node, the nonzero bits (also indexed by node number) indicate those jump targets that lead to a return statement without traversing a back edge.">
				<comm cntt="if no outgoing edges"/>
				<comm cntt="it&amp;apos;s a return; add it"/>
				<comm cntt="multiple passes until done"/>
				<param name="graph"/>
				<param name="nodeNumbers"/>
				<param name="dftree"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.setIncoming(sandmark.util.newgraph.Graph, java.util.BitSet[], java.util.Vector, java.util.Map, sandmark.util.newgraph.Graph)" access="priv" jdoc="For each Node in v, checks every incoming edge, and adds the target node as an acceptable destination from the source if the edge is not a BACK edge. Returns a new vector of nodes for which new destinations were assigned.">
				<param name="graph"/>
				<param name="blist"/>
				<param name="v"/>
				<param name="nodeNumbers"/>
				<param name="dftree"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.prologue(org.apache.bcel.generic.InstructionList)" access="priv" jdoc="Generates prologue code that ensures that local variable 0 is non-negative. One of several possible prologues is chosen randomly.">
				<comm cntt="init handle"/>
				<comm cntt="load n"/>
				<comm cntt="keep in sync with number of cases"/>
				<comm cntt="convert to char, which zeros the top 16 bits"/>
				<comm cntt="AND a constant with the lower 11 bits"/>
				<comm cntt="(the double random calls bias towards 1-bits in the result)"/>
				<comm cntt="compute a large constant (max 30 bits) and AND it in"/>
				<comm cntt="clear the sign bit by ANDing with (-1 &amp;gt;&amp;gt;&amp;gt; 1)"/>
				<comm cntt="dup, shift right 31, XOR"/>
				<comm cntt="(on a ones-complement architecture this would be an ABS operation)"/>
				<comm cntt="isolate the sign bit and XOR it back in"/>
				<comm cntt="set the top two bits, then negate"/>
				<comm cntt="(need two bits to ensure that INEG produces a positive value)"/>
				<comm cntt="force negative via OR of a constant, then negate"/>
				<comm cntt="store new n (now n &amp;gt;= 0)"/>
				<param name="inslist"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.allNodes(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, short, sandmark.util.newgraph.Graph, java.lang.Object, java.util.BitSet[], java.util.Map)" access="priv" jdoc="Generates code for all nodes.">
				<param name="inslist"/>
				<param name="handles"/>
				<param name="opcode"/>
				<param name="graph"/>
				<param name="root"/>
				<param name="elist"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.genNode(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, short, sandmark.util.newgraph.Graph, java.util.BitSet[], java.lang.Object, java.lang.Object, java.util.Map)" access="priv" jdoc="Generates code for one node.">
				<param name="inslist"/>
				<param name="handles"/>
				<param name="opcode"/>
				<param name="graph"/>
				<param name="elist"/>
				<param name="thisNode"/>
				<param name="nextNode"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.bblock(CodeContext)" access="priv" jdoc="Generates a simple basic block chosen randomly from among several possibilities. All sequences preserve the sign bit of a nonnegative local variable 0. Try to do all this without collapsing all input values to zero. For example, that&amp;apos;s why we divide only by small values.">
				<comm cntt="load n"/>
				<comm cntt="keep in sync with number of cases"/>
				<comm cntt="set a randomly chosen bit (0 through 14)"/>
				<comm cntt="set probably two randomly chosen bits (0 through 14)"/>
				<comm cntt="set a randomly chosen bit (15 through 30)"/>
				<comm cntt="flip a randomly chosen bit (0 through 30)"/>
				<comm cntt="clear a randomly chosen bit (0 through 14)"/>
				<comm cntt="cast to char"/>
				<comm cntt="unsigned shift down by 1 to 4 bits (divide by 2 | 4 | 8 | 16)"/>
				<comm cntt="signed shift down by 1 to 4 bits (divide by 2 | 4 | 8 | 16)"/>
				<comm cntt="divide by a randomly chosen small constant"/>
				<comm cntt="reduce modulo a randomly chosen constant"/>
				<comm cntt="mask off the low N bits, then add in a constant"/>
				<comm cntt="divide by small n, then multiply by n-1"/>
				<comm cntt="multiply by 3 4 or 7 8 by subtracting 1 4 or 1 8 of self"/>
				<comm cntt="multiply by a constant, then unsigned shift 1 to ensure positive"/>
				<comm cntt="store new n (now n &amp;gt;= 0)"/>
				<param name="cx"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.genReturn(CodeContext, short)" access="priv" jdoc="Generates a return expression that makes the given opcode take a jump.">
				<comm cntt="nothing more needed"/>
				<param name="cx"/>
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.genIf(CodeContext, org.apache.bcel.generic.InstructionHandle, sandmark.util.newgraph.Graph, java.util.BitSet, java.lang.Object, java.lang.Object, java.util.Map)" access="priv" jdoc="Generates a conditional jump. If the first out-edge of thisNode is not to nextNode, then the jump reflects that edge. Otherwise, the jump reflects the second out-edge of thisNode.">
				<comm cntt="ensure jump taken"/>
				<comm cntt="ensure jump not taken"/>
				<comm cntt="doesn&amp;apos;t matter"/>
				<param name="cx"/>
				<param name="handles"/>
				<param name="graph"/>
				<param name="exits"/>
				<param name="thisNode"/>
				<param name="nextNode"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.genSwitch(CodeContext, org.apache.bcel.generic.InstructionHandle, sandmark.util.newgraph.Graph, java.util.BitSet, java.lang.Object, java.util.Map)" access="priv" jdoc="Generates a TABLESWITCH instruction.">
				<param name="cx"/>
				<param name="handles"/>
				<param name="graph"/>
				<param name="exits"/>
				<param name="thisNode"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.PositiveIntSynthesizer.main(String[])" access="pub" jdoc="Test driver; see ControlFlowSynthesizer.test.">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.RegisterAllocator" intfc="n" abs="n" inn="n" sloc="133" jdoc="">
			<comm cntt="we must precolor the nodes that cannot move to another register"/>
			<field name="ig" access="pub" jdoc=""/>
			<field name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.RegisterAllocator.RegisterAllocator(sandmark.analysis.interference.InterferenceGraph)" access="pub" jdoc="">
				<param name="ig"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.RegisterAllocator.allocate(boolean)" access="pub" jdoc="">
				<param name="fullAllocation"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.RegisterAllocator.colorGraph(java.util.ArrayList, boolean)" access="priv" jdoc="">
				<comm cntt="create a list of uncolored nodes"/>
				<comm cntt="System.out.println(&amp;quot;the node is: &amp;quot; + n);"/>
				<comm cntt="make sure the node has not yet been colored"/>
				<comm cntt="keep track of which colors have been assigned to the nodes"/>
				<comm cntt="conflicting with the node"/>
				<comm cntt="System.out.println(&amp;quot;the color &amp;quot; + s.color + &amp;quot; has been used&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;skipping a node because &amp;quot; + web.getIndex() + &amp;quot; is free&amp;quot;);"/>
				<comm cntt="Find the next available color"/>
				<comm cntt="Wide variables need two colors"/>
				<comm cntt="System.out.println(&amp;quot;color selected: &amp;quot; + i);"/>
				<comm cntt="System.out.println(&amp;quot;color selected: &amp;quot; + i);"/>
				<param name="nodes"/>
				<param name="fullAllocation"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.RegisterAllocator.preColor(java.util.ArrayList, java.util.Hashtable)" access="priv" jdoc="">
				<param name="nodes"/>
				<param name="colors"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.RegisterAllocator.isMovable(sandmark.analysis.defuse.DUWeb)" access="priv" jdoc="">
				<param name="web"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.RegisterAllocator.isWide(sandmark.analysis.defuse.DUWeb)" access="priv" jdoc="">
				<param name="web"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.RegisterAllocator.assignLocalVariables(java.util.ArrayList, java.util.Hashtable)" access="priv" jdoc="">
				<param name="nodes"/>
				<param name="colors"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.RegisterAllocator.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.TopoMaintainingCallGenerator" intfc="n" abs="n" inn="n" sloc="148" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="mSrcCFG" access="priv" jdoc=""/>
			<field name="mDestMG" access="priv" jdoc=""/>
			<field name="mSrcMG" access="priv" jdoc=""/>
			<field name="mDestArgTypes" access="priv" jdoc=""/>
			<field name="mDestReturnType" access="priv" jdoc=""/>
			<field name="mSrcEdgeCx" access="priv" jdoc=""/>
			<field name="mSrcCurrentMaxLocals" access="priv" jdoc=""/>
			<field name="mSrcEdge" access="priv" jdoc=""/>
			<field name="mFactory" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.TopoMaintainingCallGenerator.addPhantomCall(MethodCFG, Edge, MethodCFG)" access="pub" jdoc="">
				<param name="srcMethod"/>
				<param name="srcEdge"/>
				<param name="destMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.TopoMaintainingCallGenerator.generateCall(java.util.ArrayList)" access="priv" jdoc="">
				<param name="instrs"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.TopoMaintainingCallGenerator.generateRvPop(java.util.ArrayList)" access="priv" jdoc="">
				<param name="instrs"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.TopoMaintainingCallGenerator.generateRestore(java.util.ArrayList)" access="priv" jdoc="">
				<param name="instrs"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.TopoMaintainingCallGenerator.insertCode(java.util.ArrayList)" access="priv" jdoc="">
				<param name="instrs"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.ExceptionEdge" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<field name="mCEGs" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.ExceptionEdge.ExceptionEdge(Object, Object, org.apache.bcel.generic.CodeExceptionGen)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
				<param name="ceg"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ExceptionEdge.ExceptionEdge(Object, Object, org.apache.bcel.generic.CodeExceptionGen)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
				<param name="cegs"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ExceptionEdge.exception()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ExceptionEdge.clone(Object, Object)" access="pub" jdoc="">
				<param name="source"/>
				<param name="sink"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.MinimalSynthesizer" intfc="n" abs="n" inn="n" sloc="192" jdoc="A simple code generator designed to minimize output size without reordering nodes. &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; A node with no out-edges produces a RETURN instruction. &amp;lt;LI&amp;gt; A node with one out-edge produces a GOTO instruction, or an ICONST_0 POP pair if fallthrough suffices. &amp;lt;LI&amp;gt; A node with two out-edges, including one fall-through, produces ICONST_0 and IFNE. &amp;lt;LI&amp;gt; All other cases produce ICONST_0 and TABLESWITCH. &amp;lt; UL&amp;gt; If there is a leaf node (RETURN instruction) reachable from the root node, the generated code will be safely executable. If there is no leaf node, the generated code will loop forever.">
			<mth name="/:sandmark.analysis.controlflowgraph.MinimalSynthesizer.generate(sandmark.util.newgraph.Graph, sandmark.program.Class, java.lang.Object, java.util.Map)" access="prot" jdoc="Generates a void no-argument method corresponding to the given graph. All graphs are acceptable; no IllegalArgumentException is thrown.">
				<param name="graph"/>
				<param name="clazz"/>
				<param name="root"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MinimalSynthesizer.getExits(sandmark.util.newgraph.Graph, java.util.Map)" access="priv" jdoc="Generates a list, indexed by node number, of preferred jump targets. For each graph node, the corresponding list entry is a node leading (by shortest path) to a return.">
				<comm cntt="if no outgoing edges"/>
				<comm cntt="it&amp;apos;s a return; add it"/>
				<comm cntt="multiple passes until done"/>
				<param name="graph"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MinimalSynthesizer.setIncoming(sandmark.util.newgraph.Graph, java.lang.Object[], java.util.Vector, java.util.Map)" access="priv" jdoc="For each Node in v, checks every incoming edge, and adds the node from v as the preferred target if the source node does not already have one. Returns a new vector of nodes for which targets were assigned.">
				<param name="graph"/>
				<param name="elist"/>
				<param name="v"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MinimalSynthesizer.allNodes(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, sandmark.util.newgraph.Graph, java.lang.Object, java.lang.Object[], java.util.Map)" access="priv" jdoc="Generates code for all nodes.">
				<param name="inslist"/>
				<param name="handles"/>
				<param name="graph"/>
				<param name="root"/>
				<param name="exits"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MinimalSynthesizer.genNode(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, sandmark.util.newgraph.Graph, java.lang.Object[], java.lang.Object, java.lang.Object, java.util.Map)" access="priv" jdoc="Generates code for one node.">
				<param name="inslist"/>
				<param name="handles"/>
				<param name="graph"/>
				<param name="exits"/>
				<param name="thisNode"/>
				<param name="nextNode"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MinimalSynthesizer.genIfNE(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, sandmark.util.newgraph.Graph, java.lang.Object, java.lang.Object, java.lang.Object, java.util.Map)" access="priv" jdoc="Generates a conditional jump. If the first out-edge of thisNode is not to nextNode, then the jump reflects that edge. Otherwise, the jump reflects the second out-edge of thisNode.">
				<param name="inslist"/>
				<param name="handles"/>
				<param name="h"/>
				<param name="graph"/>
				<param name="thisNode"/>
				<param name="nextNode"/>
				<param name="prefNode"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MinimalSynthesizer.genSwitch(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, sandmark.util.newgraph.Graph, java.lang.Object, java.lang.Object, java.util.Map)" access="priv" jdoc="Generates a TABLESWITCH instruction.">
				<comm cntt="already entered as default"/>
				<param name="inslist"/>
				<param name="handles"/>
				<param name="h"/>
				<param name="graph"/>
				<param name="thisNode"/>
				<param name="prefNode"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MinimalSynthesizer.main(String[])" access="pub" jdoc="Test driver; see ControlFlowSynthesizer.test.">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.EmptyMethodException" intfc="n" abs="n" inn="n" sloc="8" jdoc="">
			<mth name="/:sandmark.analysis.controlflowgraph.EmptyMethodException.EmptyMethodException()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.EmptyMethodException.EmptyMethodException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.VoidMethodSynthesizer" intfc="n" abs="y" inn="n" sloc="15" jdoc="A VoidMethodSynthesizer generates code having a control structure that matches a supplied graph. The generated code is a static void method with no arguments.">
			<mth name="/:sandmark.analysis.controlflowgraph.VoidMethodSynthesizer.makeMethod(org.apache.bcel.generic.InstructionList, sandmark.program.Class)" access="prot" jdoc="Creates a MethodGen for a public static void no-argument method with a random name.">
				<comm cntt="access flags"/>
				<comm cntt="return type"/>
				<comm cntt="argument types"/>
				<comm cntt="argument names"/>
				<comm cntt="random method name"/>
				<comm cntt="instruction list"/>
				<param name="inslist"/>
				<param name="clazz"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.CallGenerator" intfc="y" abs="n" inn="n" sloc="3" jdoc="">
			<mth name="/:sandmark.analysis.controlflowgraph.CallGenerator.addPhantomCall(MethodCFG, Edge, MethodCFG)" access="pub" jdoc="">
				<param name="srcMethod"/>
				<param name="srcEdge"/>
				<param name="destMethod"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.CallingCallGenerator" intfc="n" abs="n" inn="n" sloc="285" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="mSrcCFG" access="priv" jdoc=""/>
			<field name="mDestMG" access="priv" jdoc=""/>
			<field name="mSrcMG" access="priv" jdoc=""/>
			<field name="mDestArgTypes" access="priv" jdoc=""/>
			<field name="mDestReturnType" access="priv" jdoc=""/>
			<field name="mSrcEdgeIsFallthrough" access="priv" jdoc=""/>
			<field name="mSrcEdgeCx" access="priv" jdoc=""/>
			<field name="mSrcCurrentMaxLocals" access="priv" jdoc=""/>
			<field name="mSrcEdge" access="priv" jdoc=""/>
			<field name="mFactory" access="priv" jdoc=""/>
			<field name="mCallBlock" access="priv" jdoc=""/>
			<field name="mRvPopBlock" access="priv" jdoc=""/>
			<field name="mRestoreAndGotoBlock" access="priv" jdoc=""/>
			<field name="mExceptionHandlerBlock" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.CallingCallGenerator.addPhantomCall(MethodCFG, Edge, MethodCFG)" access="pub" jdoc="">
				<param name="srcMethod"/>
				<param name="srcEdge"/>
				<param name="destMethod"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CallingCallGenerator.buildCallBlock()" access="priv" jdoc="">
				<comm cntt="Put all the instructions into a block"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CallingCallGenerator.buildRvPopBlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CallingCallGenerator.buildRestoreAndGotoBlock()" access="priv" jdoc="">
				<comm cntt="If the edge that was chosen above was a targeted edge, not a fallthrough edge, change the target to the beginning of tthe call block, and insert a goto to jump the the original target after the call"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CallingCallGenerator.buildExceptionHandlerBlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CallingCallGenerator.insertBlocks(java.util.List)" access="priv" jdoc="">
				<comm cntt="mSrcCFG.printCFG();"/>
				<param name="newExceptions"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.BasicBlock" intfc="n" abs="n" inn="n" sloc="79" jdoc="BasicBlock represents a basic block in a control flow graph. Some of the ideas in this class are based upon the BLOAT project from Purdue. Written by Ginger Myles, 6 6 02.">
			<comm cntt="This block&amp;apos;s list of instructions"/>
			<comm cntt=""/>
			<field name="instructions" access="pub" jdoc=""/>
			<field name="fallthroughTo" access="pub" jdoc=""/>
			<field name="fallthroughFrom" access="pub" jdoc=""/>
			<field name="graph" access="pub" jdoc=""/>
			<field name="mBlockNum" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.BasicBlock(MethodCFG)" access="pub" jdoc="">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.graph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.setFallthrough(BasicBlock)" access="pub" jdoc="">
				<param name="fallthrough"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.fallthrough()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.fallthroughFrom()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.getIH()" access="pub" jdoc="Returns the instruction handler associated with this block. @return The instruction handle.">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.getLastInstruction()" access="pub" jdoc="Returns the instruction handler associated with the last instruction in the block. @return The instruction handle.">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.containsIH(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="searchHandle"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.addInst(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="Adds an instruction to this basic block&amp;apos;s instruction list.">
				<param name="inst"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.getInstList()" access="pub" jdoc="Returns this blocks instruction list. @return The instruction list.">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.toString(int)" access="pub" jdoc="Returns a string representation of the block.">
				<param name="limit"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.getLongLabel()" access="pub" jdoc="">
				<comm cntt=".replaceAll(&amp;quot;\n&amp;quot;,&amp;quot;\\l&amp;quot;);"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock.getShortLabel()" access="pub" jdoc="">
				<comm cntt=".replaceAll(&amp;quot;\n&amp;quot;,&amp;quot;\\l&amp;quot;);"/>
			</mth>
		<class name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList" intfc="n" abs="n" inn="y" sloc="91" jdoc="">
			<field name="BB" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.BBArrayList(BasicBlock)" access="pub" jdoc="">
				<param name="bb"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.add(int, Object)" access="pub" jdoc="">
				<param name="index"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.add(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.addAll(java.util.Collection)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.addAll(int, java.util.Collection)" access="pub" jdoc="">
				<param name="index"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.clear()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.remove(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.removeRange(int, int)" access="prot" jdoc="">
				<param name="fromIndex"/>
				<param name="toIndex"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.set(int, Object)" access="pub" jdoc="">
				<param name="index"/>
				<param name="element"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.remove(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.removeAll(java.util.Collection)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.BasicBlock$BBArrayList.retainAll(java.util.Collection)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.SimpleGotoSynthesizer" intfc="n" abs="n" inn="n" sloc="49" jdoc="A simple code generator using conditional and unconditional branches. Each graph node yields a NOP instruction followed by zero or more conditional branches and then an unconditional branch. This is a little too naive because sandmark.analysis.controlflowgraph.MethodCFG counts a series of gotos as multiple basic blocks. A leaf node of the graph produces a RETURN.">
			<mth name="/:sandmark.analysis.controlflowgraph.SimpleGotoSynthesizer.generate(sandmark.util.newgraph.Graph, sandmark.program.Class, java.lang.Object, java.util.Map)" access="prot" jdoc="Generates a void no-argument method corresponding to the given graph. All graphs are acceptable; no IllegalArgumentException is thrown.">
				<param name="graph"/>
				<param name="clazz"/>
				<param name="root"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.SimpleGotoSynthesizer.addJumps(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, sandmark.util.newgraph.Graph, java.lang.Object, java.util.Map)" access="priv" jdoc="Generates the jumps from each node.">
				<comm cntt="if nothing was generated"/>
				<param name="inslist"/>
				<param name="handles"/>
				<param name="graph"/>
				<param name="root"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.SimpleGotoSynthesizer.main(String[])" access="pub" jdoc="Test driver.">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.SimpleSwitchSynthesizer" intfc="n" abs="n" inn="n" sloc="64" jdoc="A simple code generator using TABLESWITCH instructions. A leaf node produces a RETURN. The resulting code is obviously artificial.">
			<mth name="/:sandmark.analysis.controlflowgraph.SimpleSwitchSynthesizer.generate(sandmark.util.newgraph.Graph, sandmark.program.Class, java.lang.Object, java.util.Map)" access="prot" jdoc="Generates a void no-argument method corresponding to the given graph. All graphs are acceptable; no IllegalArgumentException is thrown.">
				<param name="graph"/>
				<param name="clazz"/>
				<param name="root"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.SimpleSwitchSynthesizer.genNodes(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, sandmark.util.newgraph.Graph, java.lang.Object, java.util.Map)" access="priv" jdoc="Generates the code for each node in turn.">
				<param name="inslist"/>
				<param name="handles"/>
				<param name="graph"/>
				<param name="root"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.SimpleSwitchSynthesizer.genSwitch(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, java.util.Vector)" access="priv" jdoc="Generates a TABLESWITCH instruction given a Vector of InstructionHandles. If the Vector is empty, generates a RETURN instead.">
				<param name="inslist"/>
				<param name="h"/>
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.SimpleSwitchSynthesizer.main(String[])" access="pub" jdoc="Test driver.">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.MethodCFG" intfc="n" abs="n" inn="n" sloc="542" jdoc="">
			<field name="dominator" access="priv" jdoc=""/>
			<field name="postDominator" access="priv" jdoc=""/>
			<field name="method" access="pub" jdoc=""/>
			<field name="source" access="pub" jdoc=""/>
			<field name="sink" access="pub" jdoc=""/>
			<field name="maxLocals" access="pub" jdoc=""/>
			<field name="mBlockCounter" access="prot" jdoc=""/>
			<field name="instr2bb" access="pub" jdoc=""/>
			<field name="sClassNameToParentClassName" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.MethodCFG(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.MethodCFG(sandmark.program.Method, boolean)" access="pub" jdoc="">
				<comm cntt="first we have to identify the leaders"/>
				<param name="method"/>
				<param name="exceptionsMatter"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.removeUnreachable()" access="pub" jdoc="Removes all nodes that are not reachable from the source.">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.graphChanged()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.method()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.basicBlockIterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.maxLocals()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.setMaxLocals(int)" access="pub" jdoc="">
				<param name="newMaxLocals"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getBlockList()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.isInScope(int, BasicBlock)" access="pub" jdoc="@deprecated">
				<comm cntt="org.apache.bcel.classfile.LocalVariableTable lvt ="/>
				<comm cntt="method.getLocalVariableTable();"/>
				<comm cntt="System.out.println(&amp;quot;local variable table &amp;quot; + lvt);"/>
				<comm cntt="org.apache.bcel.classfile.LocalVariable lv ="/>
				<comm cntt="lvt.getLocalVariable(index);"/>
				<comm cntt="int length = lv.getLength();"/>
				<param name="checkIndex"/>
				<param name="bb"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getBlock(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="searchHandle"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.buildBlocks(org.apache.bcel.generic.InstructionList, java.util.ArrayList)" access="priv" jdoc="">
				<comm cntt="End of block is the instruction before the next leader,"/>
				<comm cntt="or if there is no next leader, then the last instruction"/>
				<param name="il"/>
				<param name="leaders"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.buildEdges(org.apache.bcel.generic.CodeExceptionGen[], java.util.ArrayList)" access="priv" jdoc="">
				<comm cntt="sandmark.analysis.classhierarchy.ClassHierarchy ch ="/>
				<comm cntt="method.getApplication().getHierarchy();"/>
				<comm cntt="add egde between this block and the target block"/>
				<comm cntt="find the block that is the target block"/>
				<comm cntt="add egde between this block and the next block"/>
				<comm cntt="add an edge to the target of the jsr"/>
				<comm cntt="add edge to the target of the goto"/>
				<comm cntt="add edges to all targets of the tableswitch or lookupswitch"/>
				<comm cntt="get default target and add edge"/>
				<comm cntt="get the rest of the targets and add the edges"/>
				<comm cntt="System.out.println(&amp;quot;This handle: &amp;quot; + thisHandle);"/>
				<comm cntt="returns connect to the sink"/>
				<comm cntt="have to search to find the physical successors of the jsr"/>
				<comm cntt="added 8-31-02"/>
				<comm cntt="do not connect to next block!"/>
				<comm cntt="connect with the next block, if there is one"/>
				<param name="exceptions"/>
				<param name="blockList"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.newBlock()" access="pub" jdoc="Creates a new BasicBlock with the next available label.">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.addBlock(BasicBlock)" access="pub" jdoc="">
				<param name="bb"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.printCFG()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.source()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.sink()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getBackedges()" access="pub" jdoc="Returns a list of blocks where the edge between slot 0 and slot 1 is a back edge, the edge between slot 2 and slot 3 is a back edge, etc.">
				<comm cntt="found a backedge"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.identifyLeaders(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.CodeExceptionGen, boolean)" access="priv" jdoc="">
				<comm cntt="make the first instruction a leader"/>
				<comm cntt="get position of next instruction"/>
				<comm cntt="get handle of target of if or goto instruction"/>
				<comm cntt="add handle to target list so that we can make all of the targets"/>
				<comm cntt="into leaders at the end."/>
				<comm cntt="get position of next instruction"/>
				<comm cntt="get handle of target of jsr instruction"/>
				<comm cntt="add handle to target list so that we can make all of the targets"/>
				<comm cntt="into leaders at the end."/>
				<comm cntt="get the handle of the physical successor of the jsr instruction"/>
				<comm cntt="this handle is where the jsr will return to from the RET."/>
				<comm cntt="get position of next instruction"/>
				<comm cntt="get handles of target of either a tableswitch or a lookupswitch"/>
				<comm cntt="loop through targets adding the handler to the leaders"/>
				<comm cntt="Code in preparation for reduction in nodes and edges java.lang.Class thrownExceptions[] = ((org.apache.bcel.generic.ExceptionThrower)instruction).getExceptions(); for(int i = 0 ; i &amp;lt; thrownExceptions.length ; i++) for(int k = 0 ; k &amp;lt; exceptions.length ; k++) if(isSuperclassOf(thrownExceptions[i].getName(), exceptions[k].getCatchType().getClassName()) || isSuperclassOf(exceptions[k].getCatchType().getClassName(), thrownExceptions[i].getName())) mayBeCaught = true;"/>
				<param name="il"/>
				<param name="exceptions"/>
				<param name="exceptionsMatter"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.rewriteInstructionList()" access="pub" jdoc="">
				<comm cntt="We insert a NOP and then delete it at the end because otherwise, in some cases, all the instructions in the method magically disappear."/>
				<comm cntt="Visit a block if it has not been visited and"/>
				<comm cntt="it is not the fallthrough block of another block"/>
				<comm cntt="this is a new bugfix to get rid of spurious instructions that"/>
				<comm cntt="do not appear in any BB (untested! may be buggy)"/>
				<comm cntt="END OF FIX"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getPreOrderIndex(BasicBlock)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getPostOrderIndex(BasicBlock)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getPreOrder()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getPostOrder()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.buildDominator(boolean)" access="priv" jdoc="">
				<param name="reverse"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.dominates(BasicBlock, BasicBlock)" access="pub" jdoc="">
				<param name="dominator"/>
				<param name="dominatee"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.postDominates(BasicBlock, BasicBlock)" access="pub" jdoc="">
				<param name="postDominator"/>
				<param name="postDominatee"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getDominator(BasicBlock)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getPostDominator(BasicBlock)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getDominators(BasicBlock)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.getPostDominators(BasicBlock)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.edgeIsFallthrough(BasicBlock, BasicBlock)" access="pub" jdoc="">
				<param name="src"/>
				<param name="sink"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG.hashCode()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.analysis.controlflowgraph.MethodCFG$BasicBlockIterator" intfc="n" abs="n" inn="y" sloc="31" jdoc="">
			<field name="it" access="priv" jdoc=""/>
			<field name="o" access="priv" jdoc=""/>
			<field name="needNext" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG$BasicBlockIterator.BasicBlockIterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG$BasicBlockIterator.getNext()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG$BasicBlockIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG$BasicBlockIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.MethodCFG$BasicBlockIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.IntFuncSynthesizer" intfc="n" abs="y" inn="n" sloc="43" jdoc="An IntFuncSynthesizer generates code having a control structure that matches a supplied graph. The generated code is a static int(int) method -- an integer function of one argument.">
			<comm cntt="probability of choosing a longer instruction than necessary"/>
			<comm cntt="unspecialized load store instructions"/>
			<field name="VERBOSE_CHANCE" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.IntFuncSynthesizer.makeFunc(org.apache.bcel.generic.InstructionList, sandmark.program.Class)" access="pub" jdoc="Creates a MethodGen for a public static int(int) method with a random name.">
				<comm cntt="access flags"/>
				<comm cntt="return type"/>
				<comm cntt="argument types"/>
				<comm cntt="argument names"/>
				<comm cntt="random method name"/>
				<param name="inslist"/>
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.IntFuncSynthesizer.genLoad(CodeContext, int)" access="pub" jdoc="Generates either ILOAD_n or ILOAD n. If both are possible, chooses the longer form with probability VERBOSE_CHANCE.">
				<param name="cx"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.IntFuncSynthesizer.genStore(CodeContext, int)" access="pub" jdoc="Generates either ISTORE_n or ISTORE n. If both are possible, chooses the longer form with probability VERBOSE_CHANCE.">
				<param name="cx"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.IntFuncSynthesizer.genPush(CodeContext, int)" access="pub" jdoc="Generates ICONST, BIPUSH, or SIPUSH to load a small constant value.">
				<param name="cx"/>
				<param name="v"/>
			</mth>
		<class name="/:sandmark.analysis.controlflowgraph.IntFuncSynthesizer$ILOAD_UNSPEC" intfc="n" abs="n" inn="y" sloc="6" jdoc="">
			<mth name="/:sandmark.analysis.controlflowgraph.IntFuncSynthesizer$ILOAD_UNSPEC.ILOAD_UNSPEC(int)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.IntFuncSynthesizer$ISTORE_UNSPEC" intfc="n" abs="n" inn="y" sloc="6" jdoc="">
			<mth name="/:sandmark.analysis.controlflowgraph.IntFuncSynthesizer$ISTORE_UNSPEC.ISTORE_UNSPEC(int)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.ProgramCFG" intfc="n" abs="n" inn="n" sloc="94" jdoc="">
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.ProgramCFG(java.util.Collection)" access="pub" jdoc="">
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.addNode(BasicBlock, MethodCFG)" access="pub" jdoc="">
				<param name="block"/>
				<param name="cfg"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.buildNameMap(java.util.Collection)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;mapping &amp;quot; + methodName +"/>
				<comm cntt="&amp;quot; to cfg for &amp;quot; + cfg.methodGen());"/>
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.addNodes(java.util.Hashtable)" access="priv" jdoc="">
				<param name="methodNameToCFG"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.addCallEdges(java.util.Hashtable)" access="priv" jdoc="">
				<param name="methodNameToCFG"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.fieldOrMethodName(MethodCFG)" access="pub" jdoc="">
				<param name="cfg"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.fieldOrMethodName(sandmark.program.Method)" access="pub" jdoc="">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.fieldOrMethodName(sandmark.program.Field)" access="pub" jdoc="">
				<param name="field"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.fieldOrMethodName(org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.fieldOrMethodName(org.apache.bcel.generic.FieldGenOrMethodGen, String)" access="pub" jdoc="">
				<param name="fm"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.fieldOrMethodName(org.apache.bcel.generic.FieldOrMethod, org.apache.bcel.generic.ConstantPoolGen)" access="pub" jdoc="">
				<param name="fm"/>
				<param name="cpg"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ProgramCFG.fieldOrMethodName(String, String, String)" access="pub" jdoc="">
				<param name="className"/>
				<param name="fieldOrMethodName"/>
				<param name="signature"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.CodeContext" intfc="n" abs="n" inn="n" sloc="41" jdoc="A CodeContext encapsulates an InstructionHandle and an InstructionList to simplify the generation of sequences of code. Instance methods of the CodeContext update the InstructionHandle (the &amp;quot;code pointer&amp;quot;) when called to insert or append new instructions in the underlying InstructionList.">
			<field name="inslist" access="priv" jdoc=""/>
			<field name="handle" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.CodeContext.CodeContext(org.apache.bcel.generic.InstructionList)" access="pub" jdoc="Constructs a CodeContext for the given InstructionList and initializes the code pointer to null.">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CodeContext.CodeContext(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="Constructs a CodeContext for the given InstructionList and initializes the code pointer to the given value.">
				<param name="l"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CodeContext.getHandle()" access="pub" jdoc="Returns the code pointer.">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CodeContext.getHandle(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="Sets the code pointer.">
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CodeContext.append(org.apache.bcel.generic.Instruction)" access="pub" jdoc="Appends an instruction at the code pointer, and updates it.">
				<param name="ins"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CodeContext.insert(org.apache.bcel.generic.Instruction)" access="pub" jdoc="Inserts an instruction at the code pointer, and updates it.">
				<param name="ins"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.CodeContext.toString()" access="pub" jdoc="Returns a concise string representation of this CodeContext.">
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.FallthroughEdge" intfc="n" abs="n" inn="n" sloc="5" jdoc="">
			<mth name="/:sandmark.analysis.controlflowgraph.FallthroughEdge.FallthroughEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.Edge" intfc="n" abs="n" inn="n" sloc="14" jdoc="">
			<field name="mSrc" access="priv" jdoc=""/>
			<field name="mDest" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.Edge.Edge(Object, Object)" access="pub" jdoc="">
				<param name="src"/>
				<param name="dest"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.Edge.src()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.Edge.dest()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.controlflowgraph.ControlFlowSynthesizer" intfc="n" abs="y" inn="n" sloc="104" jdoc="Family of classes that generate code to match a control flow graph. The parent class also contains utility functions and a random number stream for use by subclasses.">
			<comm cntt="instance random number stream"/>
			<field name="rng" access="prot" jdoc=""/>
			<mth name="/:sandmark.analysis.controlflowgraph.ControlFlowSynthesizer.ControlFlowSynthesizer()" access="prot" jdoc="Constructs a new ControlFlowSynthesizer with its own private random number stream initialized from the Math.random stream.">
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ControlFlowSynthesizer.setSeed(long)" access="pub" jdoc="Sets the random number seed to force reproducible behavior.">
				<param name="seed"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ControlFlowSynthesizer.randomIn(int, int)" access="prot" jdoc="Returns a random r such that m &amp;lt;= r &amp;lt;= n.">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ControlFlowSynthesizer.generate(sandmark.util.newgraph.Graph, sandmark.program.Class)" access="pub" jdoc="Generates a method that corresponds to the given graph. Some concrete implementations may require specific graph forms and throw java.lang.IllegalArgumentException for an unacceptable graph. &amp;lt;P&amp;gt; The abstract">
				<param name="g"/>
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ControlFlowSynthesizer.getNodeNumbers(sandmark.util.newgraph.Graph, java.lang.Object)" access="prot" jdoc="">
				<param name="g"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ControlFlowSynthesizer.generate(sandmark.util.newgraph.Graph, sandmark.program.Class, java.lang.Object, java.util.Map)" access="prot" jdoc="">
				<param name="g"/>
				<param name="clazz"/>
				<param name="root"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ControlFlowSynthesizer.makeNOPs(org.apache.bcel.generic.InstructionList, sandmark.util.newgraph.Graph, java.lang.Object, java.util.Map)" access="pub" jdoc="Traverses a graph and creates a NOP instruction for each node, returning an array of handles indexed by node numbers. Because these are 1-based, there is an extra handle[0] left null.">
				<param name="inslist"/>
				<param name="graph"/>
				<param name="root"/>
				<param name="nodeNumbers"/>
			</mth>
			<mth name="/:sandmark.analysis.controlflowgraph.ControlFlowSynthesizer.test(String[])" access="pub" jdoc="Tests this synthesizer using a radix-encoded watermark. Called from static main methods in concrete subclasses. &amp;lt;P&amp;gt; Usage: java classname [-r] [watermark [classname]] &amp;lt;BR&amp;gt; -r specifies randomized (irreproducible) behavior &amp;lt;BR&amp;gt; watermark is the string to encode; the default is &amp;quot;31416&amp;quot; &amp;lt;BR&amp;gt; classname, if present, causes generation of a .class file">
				<comm cntt="make a simple graph"/>
				<comm cntt="turn the graph into a CFG"/>
				<comm cntt="if -r option not specified"/>
				<comm cntt="force reproducible behavior"/>
				<comm cntt="print it out"/>
				<comm cntt="dump classfile if requested"/>
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.defuse">
		<class name="/:sandmark.analysis.defuse.InstructionDefWrapper" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<field name="ih" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.defuse.InstructionDefWrapper.InstructionDefWrapper(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="ih"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.InstructionDefWrapper.getIH()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.InstructionDefWrapper.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.InstructionDefWrapper.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.InstructionDefWrapper.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.InstructionDefWrapper.setIndex(int)" access="prot" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.InstructionDefWrapper.generatedByStart()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.ThisDefWrapper" intfc="n" abs="n" inn="n" sloc="16" jdoc="">
			<mth name="/:sandmark.analysis.defuse.ThisDefWrapper.ThisDefWrapper()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ThisDefWrapper.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ThisDefWrapper.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ThisDefWrapper.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ThisDefWrapper.setIndex(int)" access="prot" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ThisDefWrapper.generatedByStart()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.DUWeb" intfc="n" abs="n" inn="n" sloc="129" jdoc="">
			<field name="mDefs" access="priv" jdoc=""/>
			<field name="mUses" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.defuse.DUWeb.DUWeb()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.addUse(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="use"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.addDef(DefWrapper)" access="pub" jdoc="">
				<param name="def"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.addNode(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.removeNode(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.defs()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.uses()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.compareTo(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.setIndex(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.getIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.getLongLabel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DUWeb.getShortLabel()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.IHComparator" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<mth name="/:sandmark.analysis.defuse.IHComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.IHComparator.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.DefComparator" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<mth name="/:sandmark.analysis.defuse.DefComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.DefComparator.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.ReachingDefs" intfc="n" abs="n" inn="n" sloc="397" jdoc="">
			<field name="mFindUninitializedVars" access="priv" jdoc=""/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="HACK_AROUND_JVM_VERIFICATION_BUG" access="priv" jdoc=""/>
			<field name="mDefToInt" access="priv" jdoc=""/>
			<field name="mBBToInfo" access="priv" jdoc=""/>
			<field name="mUses" access="priv" jdoc=""/>
			<field name="mCFG" access="priv" jdoc=""/>
			<field name="mCachedDef" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.ReachingDefs(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.ReachingDefs(sandmark.program.Method, boolean)" access="pub" jdoc="">
				<param name="method"/>
				<param name="findUninitialized"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.findUninitializedVars()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.isUse(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.isDef(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.uses()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.uses(DefWrapper)" access="pub" jdoc="">
				<param name="def"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.defs()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.defs(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="use"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.defs(int, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="lvnum"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.bitsToDefs(java.util.BitSet, int)" access="pub" jdoc="">
				<param name="bits"/>
				<param name="lvnum"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.defUseWebs()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.findUses()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.findAndNumberDefs(boolean)" access="priv" jdoc="">
				<param name="findUninitialized"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.compute()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.calcPartialBlockInfo(sandmark.analysis.controlflowgraph.BasicBlock, org.apache.bcel.generic.InstructionHandle, java.util.Set)" access="priv" jdoc="">
				<param name="bb"/>
				<param name="lastIH"/>
				<param name="defSets"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.calcPartialBlockInfo(sandmark.analysis.controlflowgraph.BasicBlock, org.apache.bcel.generic.InstructionHandle, java.util.Set, java.util.Hashtable)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;finding defset for &amp;quot; + ih + &amp;quot; with index &amp;quot; + lvindex);"/>
				<param name="bb"/>
				<param name="lastIH"/>
				<param name="defSets"/>
				<param name="useInfo"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.initializeBBInfo(java.util.Iterator, java.util.Set)" access="priv" jdoc="">
				<param name="basicBlocks"/>
				<param name="defSets"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.collectDefsByLVIndex()" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;adding &amp;quot; + ih + &amp;quot; to &amp;quot; + set + &amp;quot; for lv &amp;quot; + si.getIndex());"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.merge(DUWeb, DUWeb)" access="priv" jdoc="">
				<param name="gr"/>
				<param name="subGr"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		<class name="/:sandmark.analysis.defuse.ReachingDefs$CachedDef" intfc="n" abs="n" inn="y" sloc="6" jdoc="">
			<field name="ih" access="pub" jdoc=""/>
			<field name="defs" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.defuse.ReachingDefs$CachedDef.CachedDef(org.apache.bcel.generic.InstructionHandle, java.util.BitSet)" access="pub" jdoc="">
				<param name="i"/>
				<param name="bs"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.analysis.defuse.BBInfo" intfc="n" abs="n" inn="n" sloc="10" jdoc="">
			<field name="out" access="pub" jdoc=""/>
			<field name="gen" access="pub" jdoc=""/>
			<field name="kill" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.defuse.BBInfo.BBInfo(java.util.BitSet, java.util.BitSet)" access="pub" jdoc="">
				<param name="gen"/>
				<param name="kill"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.UseInfo" intfc="n" abs="n" inn="n" sloc="9" jdoc="">
			<field name="kill" access="pub" jdoc=""/>
			<field name="gen" access="pub" jdoc=""/>
			<field name="blockEffectOnly" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.defuse.UseInfo.UseInfo(java.util.BitSet, java.util.BitSet)" access="pub" jdoc="">
				<param name="gen"/>
				<param name="kill"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.UninitializedDefWrapper" intfc="n" abs="n" inn="n" sloc="6" jdoc="">
			<mth name="/:sandmark.analysis.defuse.UninitializedDefWrapper.UninitializedDefWrapper(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.UninitializedDefWrapper.generatedByStart()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.ParamDefWrapper" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="paramListIndex" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.defuse.ParamDefWrapper.ParamDefWrapper(int, int, org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="paramListIndex"/>
				<param name="lvIndex"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ParamDefWrapper.getParamListIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ParamDefWrapper.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ParamDefWrapper.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.ParamDefWrapper.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ParamDefWrapper.setIndex(int)" access="prot" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.ParamDefWrapper.generatedByStart()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.StoreDefWrapper" intfc="n" abs="n" inn="n" sloc="6" jdoc="">
			<mth name="/:sandmark.analysis.defuse.StoreDefWrapper.StoreDefWrapper(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="ih"/>
				<param name="type"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.DefWrapper" intfc="n" abs="y" inn="n" sloc="17" jdoc="">
			<field name="lvIndex" access="priv" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.defuse.DefWrapper.DefWrapper(int, org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="lvIndex"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.DefWrapper.getIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DefWrapper.setIndex(int)" access="prot" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.DefWrapper.getWidth()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DefWrapper.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.defuse.DefWrapper.generatedByStart()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.defuse.IncDefWrapper" intfc="n" abs="n" inn="n" sloc="8" jdoc="">
			<mth name="/:sandmark.analysis.defuse.IncDefWrapper.IncDefWrapper(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.defuse.IncDefWrapper.getIncInstruction()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.dependencygraph">
		<class name="/:sandmark.analysis.dependencygraph.DependencyGraph" intfc="n" abs="n" inn="n" sloc="54" jdoc="A directed graph with field and method names as nodes and edges from referrers to referees.">
			<mth name="/:sandmark.analysis.dependencygraph.DependencyGraph.DependencyGraph(java.util.Collection, java.util.Collection)" access="pub" jdoc="">
				<param name="fields"/>
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.analysis.dependencygraph.DependencyGraph.nodeName(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.initialized">
		<class name="/:sandmark.analysis.initialized.Initialized" intfc="n" abs="n" inn="n" sloc="48" jdoc="">
			<field name="mRD" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.initialized.Initialized.Initialized(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.initialized.Initialized.Initialized(sandmark.analysis.defuse.ReachingDefs)" access="pub" jdoc="">
				<param name="rd"/>
			</mth>
			<mth name="/:sandmark.analysis.initialized.Initialized.initializedAt(int, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="lvnum"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.initialized.Initialized.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.interference">
		<class name="/:sandmark.analysis.interference.InterferenceGraph" intfc="n" abs="n" inn="n" sloc="47" jdoc="">
			<mth name="/:sandmark.analysis.interference.InterferenceGraph.InterferenceGraph(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.interference.InterferenceGraph.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.liveness">
		<class name="/:sandmark.analysis.liveness.Liveness" intfc="n" abs="n" inn="n" sloc="170" jdoc="">
			<field name="HACK_AROUND_JVM_VERIFICATION_BUG" access="priv" jdoc=""/>
			<field name="mBBToInfo" access="priv" jdoc=""/>
			<field name="mUseToInt" access="priv" jdoc=""/>
			<field name="mCFG" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.liveness.Liveness.Liveness(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.liveness.Liveness.liveAt(sandmark.analysis.defuse.DUWeb, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="web"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.liveness.Liveness.findUses(org.apache.bcel.generic.InstructionList)" access="priv" jdoc="">
				<param name="il"/>
			</mth>
			<mth name="/:sandmark.analysis.liveness.Liveness.compute()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.liveness.Liveness.calcPartialBlockInfo(sandmark.analysis.controlflowgraph.BasicBlock, org.apache.bcel.generic.InstructionHandle, java.util.Set)" access="priv" jdoc="">
				<param name="bb"/>
				<param name="lastIH"/>
				<param name="usesByIndex"/>
			</mth>
			<mth name="/:sandmark.analysis.liveness.Liveness.numberUses(java.util.Set)" access="priv" jdoc="">
				<param name="uses"/>
			</mth>
			<mth name="/:sandmark.analysis.liveness.Liveness.initializeBlocks(java.util.Set)" access="priv" jdoc="">
				<param name="uses"/>
			</mth>
			<mth name="/:sandmark.analysis.liveness.Liveness.collectUsesByIndex(java.util.Set)" access="priv" jdoc="">
				<param name="uses"/>
			</mth>
			<mth name="/:sandmark.analysis.liveness.Liveness.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.liveness.BBInfo" intfc="n" abs="n" inn="n" sloc="10" jdoc="">
			<field name="out" access="pub" jdoc=""/>
			<field name="gen" access="pub" jdoc=""/>
			<field name="kill" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.liveness.BBInfo.BBInfo(java.util.BitSet, java.util.BitSet)" access="pub" jdoc="">
				<param name="gen"/>
				<param name="kill"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.slicingtools">
		<class name="/:sandmark.analysis.slicingtools.BackwardMethodSlice" intfc="n" abs="n" inn="n" sloc="229" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="DEBUG_KILL" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.slicingtools.BackwardMethodSlice.BackwardMethodSlice(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, boolean)" access="pub" jdoc="">
				<param name="method"/>
				<param name="startHandle"/>
				<param name="staticSlice"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.BackwardMethodSlice.computeStaticSlice()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.BackwardMethodSlice.computeDynamicSlice()" access="prot" jdoc="">
				<comm cntt="needs to throw a not implemented exception"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.BackwardMethodSlice.computeGen(AnalysisBlock)" access="prot" jdoc="Computes the gen of a basic block. The gen is the set of definitions generated by the block.">
				<comm cntt="end for"/>
				<comm cntt="end if"/>
				<param name="aBlock"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.BackwardMethodSlice.computeKill(AnalysisBlock)" access="prot" jdoc="Computes the kill of a basic block. The kill is the set of definitions killed by the block.">
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<param name="aBlock"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.BackwardMethodSlice.computeReachingDefs()" access="prot" jdoc="">
				<comm cntt="initialization step. For each block in the cfg set in to 0 and out to gen."/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end while"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.BackwardMethodSlice.computeTransitiveClosure()" access="prot" jdoc="">
				<comm cntt="ablock.getIn();"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end while"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.BackwardMethodSlice.identifyControlPredicates()" access="priv" jdoc="">
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end if"/>
				<comm cntt="for"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.slicingtools.ForwardMethodSlice" intfc="n" abs="n" inn="n" sloc="219" jdoc="">
			<comm cntt="PRIVATE METHODS"/>
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="DEBUG_GEN" access="pub" jdoc=""/>
			<field name="DEBUG_KILL" access="pub" jdoc=""/>
			<field name="DEBUG_USES" access="pub" jdoc=""/>
			<field name="DEBUG_CLOSURE" access="pub" jdoc=""/>
			<field name="DEBUG_SORT" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.slicingtools.ForwardMethodSlice.ForwardMethodSlice(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, boolean)" access="pub" jdoc="Constructor.">
				<param name="method"/>
				<param name="startHandle"/>
				<param name="staticSlice"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.ForwardMethodSlice.computeStaticSlice()" access="prot" jdoc="Computes the static slice of a method starting at the startHandle.">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.ForwardMethodSlice.computeDynamicSlice()" access="prot" jdoc="Computes the dynamic slice of a method starting at the startHandle.">
				<comm cntt="needs to throw a not implemented exception."/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.ForwardMethodSlice.computeGen(AnalysisBlock)" access="prot" jdoc="Computes the gen of a basic block. The gen is the set of all uses in the block.">
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end if"/>
				<param name="aBlock"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.ForwardMethodSlice.computeKill(AnalysisBlock)" access="prot" jdoc="Computes the kill of a basic block. The kill is the set of all uses that are killed by the block.">
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end if"/>
				<param name="aBlock"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.ForwardMethodSlice.computeReachableUses()" access="priv" jdoc="">
				<comm cntt="initialization step. For each block in the cfg set in to gen and out to 0."/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end while"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.ForwardMethodSlice.computeTransitiveClosure()" access="prot" jdoc="">
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end while"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.slicingtools.AnalysisBlock" intfc="n" abs="n" inn="n" sloc="49" jdoc="">
			<field name="in" access="priv" jdoc=""/>
			<field name="out" access="priv" jdoc=""/>
			<field name="gen" access="priv" jdoc=""/>
			<field name="kill" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.AnalysisBlock(sandmark.util.newexprtree.MethodExprTree, sandmark.util.newexprtree.ExprTreeBlock)" access="pub" jdoc="">
				<param name="met"/>
				<param name="block"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.getIn()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.getOut()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.getGen()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.getKill()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.setIn(java.util.ArrayList)" access="pub" jdoc="">
				<param name="in"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.setOut(java.util.ArrayList)" access="pub" jdoc="">
				<param name="out"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.setGen(java.util.ArrayList)" access="pub" jdoc="">
				<param name="gen"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.setKill(java.util.ArrayList)" access="pub" jdoc="">
				<param name="kill"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.getBB()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.AnalysisBlock.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.slicingtools.MethodSlice" intfc="n" abs="y" inn="n" sloc="157" jdoc="">
			<comm cntt="list of blocks in the cfg"/>
			<comm cntt="list of analysis blocks in the cfg"/>
			<comm cntt="list of instruction handles that comprise slice"/>
			<comm cntt="list of local variables in the slice"/>
			<comm cntt="PRIVATE METHODS"/>
			<comm cntt="PUBLIC METHODS"/>
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="method" access="pub" jdoc=""/>
			<field name="met" access="pub" jdoc=""/>
			<field name="startHandle" access="pub" jdoc=""/>
			<field name="lv" access="pub" jdoc=""/>
			<field name="metBlockList" access="pub" jdoc=""/>
			<field name="analysisBlockList" access="pub" jdoc=""/>
			<field name="slice" access="pub" jdoc=""/>
			<field name="affectedVars" access="pub" jdoc=""/>
			<field name="lvIndex" access="pub" jdoc=""/>
			<field name="analysisBlockMap" access="pub" jdoc=""/>
			<field name="startBlock" access="pub" jdoc=""/>
			<field name="sliceTrees" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.MethodSlice(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<comm cntt="make sure the startHandle is valid"/>
				<comm cntt="get the methodExprTree"/>
				<comm cntt="need to find the exprtreeblock that contains the startHandle"/>
				<comm cntt="cast all of the ExprTreeBlocks to AnalysisBlocks"/>
				<param name="method"/>
				<param name="startHandle"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.computeStaticSlice()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.computeDynamicSlice()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.computeGen(AnalysisBlock)" access="prot" jdoc="">
				<param name="aBlock"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.computeKill(AnalysisBlock)" access="prot" jdoc="">
				<param name="aBlock"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.computeTransitiveClosure()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.setSlice()" access="prot" jdoc="sets the list of instruction handles that comprise the slice.">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.sortSliceTrees()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.computeAffectedVars()" access="prot" jdoc="Computes the list of local variables that are in the slice.">
				<comm cntt="int index = lvi.getIndex();"/>
				<comm cntt="Integer intIndex = new Integer(index);"/>
				<comm cntt="if(!affectedVars.contains(intIndex))"/>
				<comm cntt="affectedVars.add(intIndex);"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.compare(java.util.ArrayList, java.util.ArrayList)" access="prot" jdoc="">
				<param name="current"/>
				<param name="newone"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.computeUnion(java.util.ArrayList, java.util.ArrayList)" access="prot" jdoc="">
				<comm cntt="compute the union of the two arrayLists"/>
				<param name="list1"/>
				<param name="list2"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.computeDifference(java.util.ArrayList, java.util.ArrayList)" access="prot" jdoc="">
				<comm cntt="subtract all elements in list2 from list1"/>
				<param name="list1"/>
				<param name="list2"/>
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.getSlice()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.slicingtools.MethodSlice.getAffectedVars()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.analysis.stacksimulator">
		<class name="/:sandmark.analysis.stacksimulator.ReferenceData" intfc="n" abs="n" inn="n" sloc="25" jdoc="Encapsulates all non-primitive data. @author Kelly Heffner (kheffner@cs.arizona.edu)">
			<field name="myRefType" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.ReferenceData.ReferenceData(org.apache.bcel.generic.ReferenceType, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="Constructs a referencial data object. If you are not sure what type this data is, use org.apache.bcel.generic.Type.OBJECT. @param ref the type of the object @param h the instruction handle for the instruction that created this object">
				<param name="ref"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReferenceData.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReferenceData.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReferenceData.equals(Object)" access="pub" jdoc="Defined by equality method of the superclass. In addition, a reference data is equal iff the signatures of its type are equal.">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReferenceData.undefinedVersion()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.ReplaceVarContext" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<field name="c" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="lvcount" access="priv" jdoc=""/>
			<field name="data" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceVarContext.ReplaceVarContext(Context, int, StackData[])" access="pub" jdoc="">
				<param name="c"/>
				<param name="index"/>
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceVarContext.getStackSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceVarContext.getLocalVariableCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceVarContext.getStackAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceVarContext.getLocalVariableAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceVarContext.depth()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.UninitializedReferenceData" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<mth name="/:sandmark.analysis.stacksimulator.UninitializedReferenceData.UninitializedReferenceData(org.apache.bcel.generic.ObjectType, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="t"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.UninitializedReferenceData.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.UninitializedReferenceData.undefinedVersion()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.UninitializedReferenceData.initialize(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="h"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.ReturnaddressData" intfc="n" abs="n" inn="n" sloc="28" jdoc="">
			<field name="target" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.ReturnaddressData.ReturnaddressData(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="h"/>
				<param name="_target"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReturnaddressData.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReturnaddressData.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReturnaddressData.getTarget()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReturnaddressData.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReturnaddressData.undefinedVersion()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.MergeContext" intfc="n" abs="n" inn="n" sloc="65" jdoc="">
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="stack" access="priv" jdoc=""/>
			<field name="locals" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.MergeContext.MergeContext(Context, Context)" access="pub" jdoc="">
				<comm cntt="merge the two stacks into one stack"/>
				<param name="c1"/>
				<param name="c2"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.MergeContext.getStackSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.MergeContext.getLocalVariableCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.MergeContext.getStackAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.MergeContext.getLocalVariableAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.MergeContext.depth()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.PushContext" intfc="n" abs="n" inn="n" sloc="35" jdoc="">
			<field name="c" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="size" access="priv" jdoc=""/>
			<field name="data" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.PushContext.PushContext(Context, int, StackData[])" access="pub" jdoc="">
				<param name="c"/>
				<param name="index"/>
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PushContext.getStackSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PushContext.getLocalVariableCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PushContext.getStackAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PushContext.getLocalVariableAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PushContext.depth()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.Context" intfc="n" abs="y" inn="n" sloc="173" jdoc="">
			<comm cntt="checks to see if &amp;apos;this&amp;apos; is a subcontext of &amp;apos;c&amp;apos;"/>
			<field name="stack" access="pub" jdoc=""/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.Context.Context()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.replaceVariable(StackData[], int)" access="pub" jdoc="">
				<param name="data"/>
				<param name="slot"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.replaceVariable(StackData, int)" access="pub" jdoc="">
				<param name="data"/>
				<param name="slot"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.clearStack()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.push(StackData[])" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.push(StackData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.pushAt(int, StackData[])" access="pub" jdoc="">
				<param name="index"/>
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.pushAt(int, StackData)" access="pub" jdoc="">
				<param name="index"/>
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.pop()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.replaceStack(StackData[], int)" access="pub" jdoc="">
				<param name="data"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.initializeTop(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.getStackSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.getLocalVariableCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.getStackAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.getLocalVariableAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.depth()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.maybeConsolidate(Context)" access="pub" jdoc="">
				<param name="cx"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.consolidate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.isSubcontextOf(Context)" access="pub" jdoc="">
				<comm cntt="check to see if the stack is a subset of the other stack"/>
				<comm cntt="maybe should add a &amp;quot;if contains undefined&amp;quot; found= true?"/>
				<comm cntt="check to see if the local variables are a subset of the other"/>
				<comm cntt="local variables"/>
				<comm cntt="maybe should add a &amp;quot;if contains undefined&amp;quot; found = true?"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.merge(Context)" access="pub" jdoc="">
				<param name="other"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.undefinedVersion()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.Context.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.UndefinedContext" intfc="n" abs="n" inn="n" sloc="41" jdoc="">
			<field name="stack" access="priv" jdoc=""/>
			<field name="locals" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.UndefinedContext.UndefinedContext(Context)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.UndefinedContext.getStackSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.UndefinedContext.getLocalVariableCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.UndefinedContext.getStackAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.UndefinedContext.getLocalVariableAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.UndefinedContext.depth()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.CaughtExceptionData" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<field name="exception" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.CaughtExceptionData.CaughtExceptionData(org.apache.bcel.generic.ReferenceType, org.apache.bcel.generic.CodeExceptionGen)" access="pub" jdoc="">
				<param name="ref"/>
				<param name="ceg"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CaughtExceptionData.getExceptionHandler()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CaughtExceptionData.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CaughtExceptionData.undefinedVersion()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.StackSimulator" intfc="n" abs="n" inn="n" sloc="1823" jdoc="StackSimulator is a utility that performs a conservative evaluation of a method, and enumerates all possible contexts that an instruction could be executed in. The simulator tracks the local variable table and execution stack for a method, but does not attempt to track anything else. Unreachable instructions will NOT be simulated, and the context for such instructions will be empty (i.e. an EmptyContext) @author Kelly Heffner (kheffner@cs.arizona.edu)">
			<comm cntt="hashes the leader (handle) of each block to its incoming Context"/>
			<comm cntt="hashes each block to its list (ArrayList) of incoming edges"/>
			<comm cntt="hashes each block to its list (ArrayList) of incoming blocks"/>
			<comm cntt="set of JSRs (handles) that have been simulated"/>
			<comm cntt="(unreachable JSRs will NOT be in this set)"/>
			<comm cntt="helper method to simulate StackInstructions"/>
			<comm cntt="helper method to simulate ArithmeticInstructions"/>
			<comm cntt="helper method to simulate ConversionInstructions"/>
			<comm cntt="helper method to simulate ArrayInstructions"/>
			<comm cntt="helper method to simulate ComparisonInstructions"/>
			<field name="ih2c" access="priv" jdoc=""/>
			<field name="bb2edges" access="priv" jdoc=""/>
			<field name="bb2incoming" access="priv" jdoc=""/>
			<field name="methodCFG" access="priv" jdoc=""/>
			<field name="mMaxLocals" access="priv" jdoc=""/>
			<field name="myCpg" access="priv" jdoc=""/>
			<field name="seenjsrs" access="priv" jdoc=""/>
			<const name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.StackSimulator(sandmark.analysis.controlflowgraph.MethodCFG)" access="pub" jdoc="Constructs a simulator for a method represented by some method control flow graph. @param methodCFG the cfg for the method">
				<param name="methodCFG"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.StackSimulator(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.getInitialContext()" access="priv" jdoc="This method sets the initial context on entry to the method (i.e. incoming from the source). This method should only be called once ever.">
				<comm cntt="now set args"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.getInstructionContext(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="Returns the context information for a given instruction. This is the context that this instruction would be executed in (ie the &amp;lt;i&amp;gt;incoming&amp;lt; i&amp;gt; context. @param ih the instruction handle query @return the context that this instruction would execute in">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.getInstructionContext(org.apache.bcel.generic.InstructionHandle, boolean)" access="pub" jdoc="Starts with the incoming BB context and executes instructions up to the given instruction. It will execute ih iff before==false.">
				<param name="ih"/>
				<param name="before"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.simulate(sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.stacksimulator.Context)" access="priv" jdoc="Collects contextual information for one basic block of the control flow graph. @param block a basic block @param incomingContext the context for the first instruction in this block">
				<comm cntt="programmer&amp;apos;s note: this method has been converted from a recursive algorithm"/>
				<comm cntt="to a stack-based algorithm cuz the call stack got too large."/>
				<comm cntt="if we&amp;apos;ve seen this context before, skip it"/>
				<comm cntt="otherwise, merge them"/>
				<comm cntt="while we simulate this block, we must save every context that has changes to the local variables. if there are any exception handlers around this block, we must simulate these contexts in them."/>
				<comm cntt="bitvector for which handlers this block is inside"/>
				<comm cntt="if this instruction changes a local variable, simulate it in any handlers"/>
				<comm cntt="do the actual simulation of the instruction"/>
				<comm cntt="if the last instruction was a store, then I don&amp;apos;t need to simulate"/>
				<comm cntt="the context afterward in any handlers"/>
				<comm cntt="now i have done the effect of this block on my context"/>
				<comm cntt="must treat RETs specially... cannot follow branch edges out of them,"/>
				<comm cntt="because they will be wrong. successors of RETs are those instructions"/>
				<comm cntt="after JSRs in &amp;apos;seenjsrs&amp;apos; that have the right target."/>
				<comm cntt="recursively process all known successors"/>
				<comm cntt="FIX!!!"/>
				<comm cntt="now recursively process all successor blocks"/>
				<comm cntt="stop infinite recursion for loops"/>
				<comm cntt="FIX!!"/>
				<comm cntt="for each different local variable context inside a try-catch, simulate"/>
				<comm cntt="it on the handler block"/>
				<comm cntt="prevent infinite recursion"/>
				<comm cntt="System.out.println(&amp;quot;Adding exception handler&amp;quot;);"/>
				<comm cntt="FIX!!!"/>
				<comm cntt="this is done to preserve the same order that"/>
				<comm cntt="the old recursive method would have done"/>
				<comm cntt="end of while stack nonempty"/>
				<param name="initialBlock"/>
				<param name="initialIncomingContext"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.activeHandlers(org.apache.bcel.generic.CodeExceptionGen[], org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="Returns the set of exception handlers that are active at the given instruction. @return a BitSet of active handlers (parallel to &amp;apos;handlers&amp;apos; array)">
				<param name="handlers"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.execute(org.apache.bcel.generic.InstructionHandle, sandmark.analysis.stacksimulator.Context)" access="priv" jdoc="Simulates the execution of an instruction in the current context. Does not modify the incoming context, returns the outgoing context @param instH the instruction handle for the instruction to simulate @param context the incoming context for this instruction">
				<comm cntt="do nothing"/>
				<comm cntt="push label"/>
				<comm cntt="remove object ref"/>
				<comm cntt="ANEWARRAY will report getType as the element type,"/>
				<comm cntt="MULTIANEWARRAY will give the full array type"/>
				<comm cntt="&amp;gt;^..^&amp;lt; -mew!"/>
				<comm cntt="object ref"/>
				<comm cntt="no break here on purpose!"/>
				<comm cntt="value for put"/>
				<comm cntt="object ref"/>
				<comm cntt="no break here on purpose!"/>
				<comm cntt="pop the arguments"/>
				<comm cntt="then push on the result"/>
				<comm cntt="System.out.println(&amp;quot;!!!!!!! Cannot determine local variable type!!!!!!!!!&amp;quot;);"/>
				<comm cntt="ReturnaddressData"/>
				<comm cntt="DO NOTHING"/>
				<comm cntt="DO NOTHING"/>
				<param name="instH"/>
				<param name="context"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.doStack(org.apache.bcel.generic.InstructionHandle, sandmark.analysis.stacksimulator.Context)" access="priv" jdoc="">
				<comm cntt="Adding stuff here to make it work ...zach"/>
				<comm cntt="form2"/>
				<comm cntt="form 1"/>
				<comm cntt="done fixing it..i hope"/>
				<comm cntt="otherwise, push both 1 byters"/>
				<comm cntt="two one byte members"/>
				<param name="instH"/>
				<param name="context"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.doArithmetic(org.apache.bcel.generic.InstructionHandle, sandmark.analysis.stacksimulator.Context)" access="priv" jdoc="">
				<comm cntt="change this if statement, its ugly."/>
				<comm cntt="double negation"/>
				<comm cntt="float negation"/>
				<comm cntt="int negation"/>
				<comm cntt="long negation"/>
				<comm cntt="add doubles"/>
				<comm cntt="divide doubles"/>
				<comm cntt="multiply doubles"/>
				<comm cntt="mod doubles"/>
				<comm cntt="subtract doubles"/>
				<comm cntt="add floats"/>
				<comm cntt="divide floats"/>
				<comm cntt="multiply floats"/>
				<comm cntt="mod floats"/>
				<comm cntt="subtract floats"/>
				<comm cntt="integer add"/>
				<comm cntt="integer bitwise and"/>
				<comm cntt="integer div"/>
				<comm cntt="look out for div by 0"/>
				<comm cntt="integer multiply"/>
				<comm cntt="integer bitwise or"/>
				<comm cntt="integer mod"/>
				<comm cntt="int shift left logical - shifts value 2 by value 1"/>
				<comm cntt="int shift right"/>
				<comm cntt="int subtraction (phew)"/>
				<comm cntt="int unsigned shift right"/>
				<comm cntt="int exclusive bitwise or"/>
				<comm cntt="long add"/>
				<comm cntt="long bitwise and"/>
				<comm cntt="long div"/>
				<comm cntt="long multiply"/>
				<comm cntt="long bitwise or"/>
				<comm cntt="long mod"/>
				<comm cntt="long shift left logical - shifts value 2 by value 1"/>
				<comm cntt="long shift right"/>
				<comm cntt="long subtraction (phew)"/>
				<comm cntt="long unsigned shift right"/>
				<comm cntt="long exclusive bitwise or"/>
				<param name="instH"/>
				<param name="context"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.doConversion(org.apache.bcel.generic.InstructionHandle, sandmark.analysis.stacksimulator.Context)" access="priv" jdoc="">
				<param name="ih"/>
				<param name="context"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.doArray(org.apache.bcel.generic.InstructionHandle, sandmark.analysis.stacksimulator.Context)" access="priv" jdoc="">
				<comm cntt="this will only happen if there were no array types and all"/>
				<comm cntt="the types were Type.NULL"/>
				<comm cntt="System.out.println(&amp;quot;@@@@@@@@@@@ Cannot determine array type:&amp;quot;+type+&amp;quot; @@@@@@@@@@@@@@@@@@@&amp;quot;);"/>
				<param name="ih"/>
				<param name="context"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.doComparison(sandmark.analysis.stacksimulator.Context, java.lang.Number, boolean, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<comm cntt="If value2 is greater than value1, the integer 1 is pushed onto the stack. If value1 is greater than value2, the integer -1 is pushed onto the stack. (G)If either number is NaN, the integer 1 is pushed onto the stack. (L) If either number is NaN, the integer -1 is pushed onto the stack. +0.0 and -0.0 are treated as equal."/>
				<comm cntt="I know its weird, but according to the Jasmin instruction spec, http: mrl.nyu.edu ~meyer jvmref , cmpl is the same as cmpg"/>
				<param name="context"/>
				<param name="NaNValue"/>
				<param name="NaN"/>
				<param name="instH"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.getDataForType(org.apache.bcel.generic.Type, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="dataType"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.apply(sandmark.program.Application)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Doing method &amp;quot;+className+&amp;quot;.&amp;quot;+methods[i].getName()+methods[i].getSignature());"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.apply(sandmark.program.Method, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.main(String[])" access="pub" jdoc="For testing purposes only">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackSimulator.doLoad(sandmark.analysis.stacksimulator.StackData[], java.lang.reflect.Constructor, java.lang.reflect.Constructor, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<comm cntt="InstanciationException, IllegalAccessException,"/>
				<comm cntt="ClassNotFoundException, NoSuchMethodExeption..."/>
				<param name="temp"/>
				<param name="withValue"/>
				<param name="withOutValue"/>
				<param name="instH"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.PopContext" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<field name="c" access="priv" jdoc=""/>
			<field name="size" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.PopContext.PopContext(Context)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PopContext.getStackSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PopContext.getLocalVariableCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PopContext.getStackAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PopContext.getLocalVariableAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PopContext.depth()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.StackData" intfc="n" abs="y" inn="n" sloc="23" jdoc="StackData is the superclass of all first class data elements. @author Kelly Heffner (kheffner@cs.arizona.edu)">
			<field name="myHandle" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.StackData.StackData(org.apache.bcel.generic.InstructionHandle)" access="prot" jdoc="">
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackData.getSize()" access="pub" jdoc="Specifies the size of this object on the operand stack. @return the size of the object in bytes, 1 or 2.">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackData.getType()" access="pub" jdoc="Specifies the type of the data. @return a type object which is the type (or a superclass of the type) for the data object">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackData.equals(Object)" access="pub" jdoc="Tests for equality between any two data elements. Two StackData objects are equal iff they have the same instruction handle as their creation point. (subclasses have more restrictions for equality) @param o the object to test equality against @throws java.lang.ClassCastException if o is not an instance of StackData">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackData.getInstruction()" access="pub" jdoc="Specifies the instruction handle for the instruction that placed this object on the stack.">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackData.undefinedVersion()" access="pub" jdoc="Returns the same type of stack data as this instance, without any definition. For example, an IntData object would return a new IntData object that has undefined value when undefinedVersion is called. @return A similar instance to this object, with no definition data">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.StackData.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.ArrayReferenceData" intfc="n" abs="n" inn="n" sloc="41" jdoc="">
			<field name="myLength" access="priv" jdoc=""/>
			<field name="theLengthData" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.ArrayReferenceData.ArrayReferenceData(org.apache.bcel.generic.ReferenceType, org.apache.bcel.generic.InstructionHandle, sandmark.analysis.stacksimulator.PrimitiveData)" access="pub" jdoc="">
				<param name="ref"/>
				<param name="h"/>
				<param name="length"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ArrayReferenceData.ArrayReferenceData(org.apache.bcel.generic.ReferenceType, int, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="ref"/>
				<param name="length"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ArrayReferenceData.getLength()" access="pub" jdoc="Returns the length of this array if defined. @return the array length, else a negative value">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ArrayReferenceData.getLengthData()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ArrayReferenceData.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ArrayReferenceData.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.IntData" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<mth name="/:sandmark.analysis.stacksimulator.IntData.IntData(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.IntData.IntData(int, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.IntData.IntData(Number, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.IntData.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.IntData.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.IntData.undefinedVersion()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.CompositeIntData" intfc="n" abs="n" inn="n" sloc="40" jdoc="">
			<field name="myOp1" access="priv" jdoc=""/>
			<field name="myOp2" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeIntData.CompositeIntData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeIntData.CompositeIntData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, int, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeIntData.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeIntData.getOp1()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeIntData.getOp2()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.LongData" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<mth name="/:sandmark.analysis.stacksimulator.LongData.LongData(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.LongData.LongData(long, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.LongData.LongData(Number, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.LongData.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.LongData.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.LongData.undefinedVersion()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.BooleanData" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<mth name="/:sandmark.analysis.stacksimulator.BooleanData.BooleanData(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.BooleanData.BooleanData(boolean, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.BooleanData.BooleanData(Number, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.BooleanData.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.BooleanData.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.BooleanData.undefinedVersion()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.DoubleData" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<mth name="/:sandmark.analysis.stacksimulator.DoubleData.DoubleData(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.DoubleData.DoubleData(double, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.DoubleData.DoubleData(Number, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.DoubleData.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.DoubleData.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.DoubleData.undefinedVersion()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.FloatData" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<mth name="/:sandmark.analysis.stacksimulator.FloatData.FloatData(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.FloatData.FloatData(float, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.FloatData.FloatData(Number, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.FloatData.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.FloatData.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.FloatData.undefinedVersion()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.CompositeBooleanData" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<field name="myOp1" access="priv" jdoc=""/>
			<field name="myOp2" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeBooleanData.CompositeBooleanData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeBooleanData.CompositeBooleanData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, boolean, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeBooleanData.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.CompositeLongData" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<field name="myOp1" access="priv" jdoc=""/>
			<field name="myOp2" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeLongData.CompositeLongData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeLongData.CompositeLongData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, long, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeLongData.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.CompositeDoubleData" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<field name="myOp1" access="priv" jdoc=""/>
			<field name="myOp2" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeDoubleData.CompositeDoubleData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeDoubleData.CompositeDoubleData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, double, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeDoubleData.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.CompositeFloatData" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<field name="myOp1" access="priv" jdoc=""/>
			<field name="myOp2" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeFloatData.CompositeFloatData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeFloatData.CompositeFloatData(sandmark.analysis.stacksimulator.PrimitiveData, sandmark.analysis.stacksimulator.PrimitiveData, float, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="op1"/>
				<param name="op2"/>
				<param name="value"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.CompositeFloatData.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.PrimitiveData" intfc="n" abs="y" inn="n" sloc="50" jdoc="">
			<field name="myValue" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.PrimitiveData.PrimitiveData(java.lang.Number, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="n"/>
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PrimitiveData.PrimitiveData(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PrimitiveData.getSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PrimitiveData.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PrimitiveData.isComposite()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PrimitiveData.hasDefinedValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PrimitiveData.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PrimitiveData.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.PrimitiveData.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.ClearStackContext" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<field name="c" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.ClearStackContext.ClearStackContext(Context)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ClearStackContext.getStackSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ClearStackContext.getLocalVariableCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ClearStackContext.getStackAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ClearStackContext.getLocalVariableAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ClearStackContext.depth()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.ReplaceStackContext" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<field name="c" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="size" access="priv" jdoc=""/>
			<field name="data" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceStackContext.ReplaceStackContext(Context, int, StackData[])" access="pub" jdoc="">
				<param name="c"/>
				<param name="index"/>
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceStackContext.getStackSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceStackContext.getLocalVariableCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceStackContext.getStackAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceStackContext.getLocalVariableAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.ReplaceStackContext.depth()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.analysis.stacksimulator.EmptyContext" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<field name="lvcount" access="priv" jdoc=""/>
			<mth name="/:sandmark.analysis.stacksimulator.EmptyContext.EmptyContext(int)" access="pub" jdoc="">
				<param name="lvcount"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.EmptyContext.getStackSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.EmptyContext.getLocalVariableCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.EmptyContext.getStackAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.EmptyContext.getLocalVariableAt(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.analysis.stacksimulator.EmptyContext.depth()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.birthmark">
		<class name="/:sandmark.birthmark.GeneralBirthmark" intfc="n" abs="y" inn="n" sloc="1" jdoc="">
		</class>
		<class name="/:sandmark.birthmark.BirthmarkException" intfc="n" abs="n" inn="n" sloc="5" jdoc="">
			<mth name="/:sandmark.birthmark.BirthmarkException.BirthmarkException(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.StaticClassBirthmark" intfc="n" abs="y" inn="n" sloc="4" jdoc="">
			<mth name="/:sandmark.birthmark.StaticClassBirthmark.calculate(StaticClassBirthMarkParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.Birthmark" intfc="n" abs="n" inn="n" sloc="61" jdoc="">
			<comm cntt="Describe what obfuscation is."/>
			<comm cntt="public static void runBirthmark(sandmark.program.Application app1, sandmark.program.Application app2, java.util.Properties props, sandmark.Algorithm alg) throws Exception{ try{ if(alg instanceof sandmark.birthmark.DynamicBirthmark){ ((sandmark.birthmark.DynamicBirthmark)alg).calculate(app1, app2, props); }else if(alg instanceof sandmark.birthmark.StaticClassBirthmark){ ((sandmark.birthmark.StaticClassBirthmark)alg).calculate(app1, app2, props); } sandmark.util.Log.message(0, &amp;quot;Done calculating birthmark percentage&amp;quot;); }catch(BirthmarkException e){ e.printStackTrace(); sandmark.util.Log.message(0, &amp;quot;Birthmark calculation failed&amp;quot;); } }"/>
			<field name="props" access="pub" jdoc=""/>
			<field name="app1" access="pub" jdoc=""/>
			<field name="app2" access="pub" jdoc=""/>
			<field name="ht" access="pub" jdoc=""/>
			<field name="allBirthmarkNames" access="priv" jdoc=""/>
			<field name="shortNameToClassName" access="priv" jdoc=""/>
			<field name="classNameToInstance" access="priv" jdoc=""/>
			<field name="sConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.birthmark.Birthmark.getDynamicBirthmarkByName(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.birthmark.Birthmark.getDynamicBirthmarkByShortName(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.birthmark.Birthmark.getBirthmarkInstance(String)" access="priv" jdoc="">
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.birthmark.Birthmark.getAllBirthmarkNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.Birthmark.calculate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.Birthmark.getProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.Birthmark.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the About page for Birthmark @return HTML code for the about page">
			</mth>
			<mth name="/:sandmark.birthmark.Birthmark.getHelpURL()" access="pub" jdoc="Get the URL of the Help page for Obfuscate @return url for the help page">
			</mth>
			<mth name="/:sandmark.birthmark.Birthmark.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.birthmark.DynamicBirthmark" intfc="n" abs="y" inn="n" sloc="4" jdoc="">
			<mth name="/:sandmark.birthmark.DynamicBirthmark.calculate(DynamicBirthMarkParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.DynamicBirthMarkParameters" intfc="n" abs="n" inn="n" sloc="49" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="suspect" access="pub" jdoc=""/>
			<field name="original" access="pub" jdoc=""/>
			<field name="suspectFile" access="pub" jdoc=""/>
			<field name="originalFile" access="pub" jdoc=""/>
			<field name="suspectArgv" access="pub" jdoc=""/>
			<field name="originalArgv" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.DynamicBirthMarkParameters.DynamicBirthMarkParameters()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.DynamicBirthMarkParameters.createConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.DynamicBirthMarkParameters.buildParameters(sandmark.util.ConfigProperties, sandmark.program.Application)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="input"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.StaticClassBirthMarkParameters" intfc="n" abs="n" inn="n" sloc="27" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="original" access="pub" jdoc=""/>
			<field name="suspect" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.StaticClassBirthMarkParameters.StaticClassBirthMarkParameters()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.StaticClassBirthMarkParameters.buildProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.StaticClassBirthMarkParameters.buildParams(sandmark.util.ConfigProperties, sandmark.program.Application)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="app"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.birthmark.fieldvalues">
		<class name="/:sandmark.birthmark.fieldvalues.CVFVPair" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<field name="initValue" access="priv" jdoc=""/>
			<field name="type" access="priv" jdoc=""/>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFVPair.CVFVPair(String, String)" access="pub" jdoc="">
				<param name="initValue"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFVPair.getInitValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFVPair.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFVPair.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFVPair.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFVPair.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.birthmark.fieldvalues.CVFV" intfc="n" abs="n" inn="n" sloc="87" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.calculate(sandmark.birthmark.StaticClassBirthMarkParameters)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;similarity: &amp;quot; + similarity);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.birthmark.fieldvalues.CVFV.main(String[])" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;similarity: &amp;quot; + cvfv.calculate(cls1, cls2));"/>
				<param name="argv"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.birthmark.inheritstruct">
		<class name="/:sandmark.birthmark.inheritstruct.IS" intfc="n" abs="n" inn="n" sloc="87" jdoc="">
			<const name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.IS()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.calculate(sandmark.birthmark.StaticClassBirthMarkParameters)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;orig: &amp;quot; + origMark);"/>
				<comm cntt="System.out.println(&amp;quot;suspect: &amp;quot; + suspectMark);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.getBirthmarks(sandmark.program.Class)" access="priv" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.birthmark.inheritstruct.IS.main(String[])" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;similarity: &amp;quot; + is.calculate(cls1, cls2));"/>
				<param name="argv"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.birthmark.methodcalls">
		<class name="/:sandmark.birthmark.methodcalls.MethodComparator" intfc="n" abs="n" inn="n" sloc="20" jdoc="">
			<comm cntt="public boolean equals(Object o){ sandmark.program.Method m = (sandmark.program.Method)o; int thisListLength = 0; int mListLength = 0; if(this.getInstructionList() != null) thisListLength = this.getInstructionList().getLength(); if(m.getInstructionList() != null) mListLength = m.getInstructionList().getLength(); if(this.getSignature().equals(m.getSignature()) &amp;&amp; thisListLength == mListLength) return true; else return false; }"/>
			<mth name="/:sandmark.birthmark.methodcalls.MethodComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.methodcalls.SMCTriple" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<field name="methodName" access="priv" jdoc=""/>
			<field name="className" access="priv" jdoc=""/>
			<field name="signature" access="priv" jdoc=""/>
			<mth name="/:sandmark.birthmark.methodcalls.SMCTriple.SMCTriple(String, String, String)" access="pub" jdoc="">
				<param name="methodName"/>
				<param name="className"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMCTriple.getMethodName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMCTriple.getClassName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMCTriple.getSignature()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMCTriple.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMCTriple.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMCTriple.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.birthmark.methodcalls.SMC" intfc="n" abs="n" inn="n" sloc="109" jdoc="">
			<const name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.SMC()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.calculate(sandmark.birthmark.StaticClassBirthMarkParameters)" access="pub" jdoc="">
				<comm cntt="for(int i = 0; i &amp;lt; origBirthmarks.size(); i++){"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.findValidMethodCalls(sandmark.program.Method[])" access="priv" jdoc="">
				<comm cntt="if the method call is in our set of well-known classes"/>
				<comm cntt="then we want to add it to the birthmarks"/>
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.birthmark.methodcalls.SMC.main(String[])" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;similarity: &amp;quot; + smc.calculate(cls1, cls2));"/>
				<param name="argv"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.birthmark.usedclasses">
		<class name="/:sandmark.birthmark.usedclasses.UC" intfc="n" abs="n" inn="n" sloc="143" jdoc="">
			<const name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.usedclasses.UC.UC()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.calculate(sandmark.birthmark.StaticClassBirthMarkParameters)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;orig: &amp;quot; + origMark);"/>
				<comm cntt="System.out.println(&amp;quot;suspect: &amp;quot; + suspectMark);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getBirthmarks(sandmark.program.Class)" access="priv" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getCPEntries(java.util.TreeSet, sandmark.program.Class)" access="priv" jdoc="">
				<param name="birthmarks"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getMethodSigEntries(java.util.TreeSet, sandmark.program.Class)" access="priv" jdoc="">
				<comm cntt="method return type"/>
				<comm cntt="method argument types"/>
				<param name="birthmarks"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getFieldEntries(java.util.TreeSet, sandmark.program.Class)" access="priv" jdoc="">
				<param name="birthmarks"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.getClassName(org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.birthmark.usedclasses.UC.main(String[])" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;similarity: &amp;quot; + uc.calculate(cls1, cls2));"/>
				<param name="argv"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.birthmark.util">
		<class name="/:sandmark.birthmark.util.KnownClassesManager" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<const name="KNOWNCLASSES" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.util.KnownClassesManager.isKnownClass(String)" access="pub" jdoc="">
				<comm cntt="Package prefix"/>
				<comm cntt="Package suffix"/>
				<comm cntt="Class name"/>
				<param name="className"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.birthmark.windows">
		<class name="/:sandmark.birthmark.windows.Window" intfc="n" abs="n" inn="n" sloc="20" jdoc="">
			<field name="prev" access="pub" jdoc=""/>
			<field name="opcode" access="pub" jdoc=""/>
			<field name="mHash" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.windows.Window.Window(Window, int)" access="pub" jdoc="">
				<param name="p"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.birthmark.windows.Window.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.Window.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.Window.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.windows.WindowState" intfc="n" abs="n" inn="n" sloc="81" jdoc="">
			<field name="mWindows" access="pub" jdoc=""/>
			<field name="mFilter" access="pub" jdoc=""/>
			<field name="mCurrentWindows" access="pub" jdoc=""/>
			<field name="mWindowCount" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.windows.WindowState.WindowState(int, String)" access="pub" jdoc="">
				<param name="n"/>
				<param name="filterFile"/>
			</mth>
			<mth name="/:sandmark.birthmark.windows.WindowState.clear()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.WindowState.collect(org.apache.bcel.generic.InstructionHandle, boolean)" access="pub" jdoc="">
				<param name="ih"/>
				<param name="emptyStack"/>
			</mth>
			<mth name="/:sandmark.birthmark.windows.WindowState.getWindows()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.WindowState.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.WindowState.parseFilter(String)" access="priv" jdoc="">
				<param name="file"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.windows.SlidingWindow" intfc="n" abs="n" inn="n" sloc="124" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.SlidingWindow()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.calculate(sandmark.birthmark.StaticClassBirthMarkParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.computeBirthmark(sandmark.program.Class, int)" access="priv" jdoc="">
				<param name="cls"/>
				<param name="windowSize"/>
			</mth>
			<mth name="/:sandmark.birthmark.windows.SlidingWindow.main(String[])" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;similarity: &amp;quot; + sw.calculate(cls1, cls2));"/>
				<param name="argv"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.birthmark.wpp">
		<class name="/:sandmark.birthmark.wpp.TracePoint" intfc="n" abs="n" inn="n" sloc="42" jdoc="This class represents the location of an annotation point in the code. &amp;lt;P&amp;gt; All fields are public, but should be treated as read-only.">
			<field name="location" access="pub" jdoc="The source location of a Annotate.mark(Arg) call."/>
			<mth name="/:sandmark.birthmark.wpp.TracePoint.TracePoint(sandmark.util.ByteCodeLocation)" access="pub" jdoc="">
				<param name="location"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.TracePoint.equals(Object)" access="pub" jdoc="Compare for equality. @param b object to compare to">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.TracePoint.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.TracePoint.toString()" access="pub" jdoc="Format the data in an easy to parse form.">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.TracePoint.toString(TracePoint[])" access="pub" jdoc="Format the data for easy reading.">
				<param name="pts"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.TracePoint.write(String, TracePoint[])" access="pub" jdoc="">
				<param name="traceFileName"/>
				<param name="tracePoints"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.TracePoint.read(String)" access="pub" jdoc="">
				<param name="traceFileName"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.WPP" intfc="n" abs="n" inn="n" sloc="324" jdoc="">
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="IN" access="priv" jdoc=""/>
			<field name="OUT" access="priv" jdoc=""/>
			<field name="tracer" access="pub" jdoc=""/>
			<field name="annotationPoints" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.WPP.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.calculate(sandmark.birthmark.DynamicBirthMarkParameters)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;stopped tracing&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;end tracing&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;got hash codes&amp;quot;);"/>
				<comm cntt="runSequitur on trace 1"/>
				<comm cntt="System.out.println(&amp;quot;starting sequitur&amp;quot;);"/>
				<comm cntt="get a topological sort of the nodes in the graph"/>
				<comm cntt="runSequitur on trace 2"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.startTracing(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.endTracing()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.stopTracing()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.buildDag(String)" access="priv" jdoc="">
				<comm cntt="parse the rules"/>
				<comm cntt="construct the DAG"/>
				<comm cntt="first add all of the nodes to the graph"/>
				<comm cntt="now we need to add each edge"/>
				<comm cntt="int numEdges = 0;"/>
				<comm cntt="numEdges++;"/>
				<param name="rules"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.topoSort(sandmark.util.newgraph.MutableGraph)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;new roots&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;root: &amp;quot; + r);"/>
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.findSubgraphIsomorphism(java.util.ArrayList, java.util.ArrayList, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph)" access="priv" jdoc="">
				<param name="origList"/>
				<param name="suspectList"/>
				<param name="origDAG"/>
				<param name="suspectDAG"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.getDegree(DAGNode, sandmark.util.newgraph.MutableGraph, int)" access="priv" jdoc="">
				<param name="n"/>
				<param name="graph"/>
				<param name="direction"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.getEdgeCount(sandmark.util.newgraph.MutableGraph)" access="priv" jdoc="">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.WPP.main(String[])" access="pub" jdoc="">
				<comm cntt="java.util.Properties props = new java.util.Properties();"/>
				<comm cntt="props.setProperty(&amp;quot;Arguments&amp;quot;,"/>
				<comm cntt="&amp;quot;_213_javac&amp;quot;);"/>
				<comm cntt="&amp;quot;40 &amp;lt; cs wmark mylesg smtest3 tests hard decode cipher.txt&amp;quot;);"/>
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.rule" intfc="n" abs="n" inn="n" sloc="66" jdoc="">
			<comm cntt="Guard symbol to mark beginning"/>
			<comm cntt="and end of rule."/>
			<comm cntt="Counter keeps track of how many"/>
			<comm cntt="times the rule is used in the"/>
			<comm cntt="grammar."/>
			<comm cntt="The total number of rules."/>
			<comm cntt="The rule&amp;apos;s number."/>
			<comm cntt="Used for identification of"/>
			<comm cntt="non-terminals."/>
			<comm cntt="Index used for printing."/>
			<field name="theGuard" access="pub" jdoc=""/>
			<field name="count" access="pub" jdoc=""/>
			<field name="numRules" access="pub" jdoc=""/>
			<field name="number" access="pub" jdoc=""/>
			<field name="index" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.rule.rule()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.rule.first()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.rule.last()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.rule.getRules()" access="pub" jdoc="">
				<comm cntt="text.append(&amp;quot;Usage\tRule\n&amp;quot;);"/>
				<comm cntt="text.append(&amp;quot;Rule\n&amp;quot;);"/>
				<comm cntt="text.append(&amp;quot; &amp;quot;);"/>
				<comm cntt="text.append(currentRule.count);"/>
				<comm cntt="text.append(&amp;quot;\tR&amp;quot;);"/>
				<comm cntt="text.append((char)sym.value);"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.Annotate" intfc="n" abs="n" inn="n" sloc="57" jdoc="">
			<field name="app" access="priv" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.Annotate.Annotate(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Annotate.annotate()" access="pub" jdoc="">
				<comm cntt="iterate through the classes adding a reference to"/>
				<comm cntt="&amp;quot;sandmark.birthmark.wpp.Annotator&amp;quot;"/>
				<comm cntt="add a reference to &amp;quot;sandmark.birthmark.wpp.Annotator&amp;quot;"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Annotate.save(java.io.File)" access="pub" jdoc="">
				<param name="file"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Annotate.annotateCFGs(sandmark.program.Class, int)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;method: &amp;quot; + m.getName());"/>
				<comm cntt="System.out.println(bb.toString());"/>
				<comm cntt="System.out.println(&amp;quot;appended&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;inserted&amp;quot;);"/>
				<comm cntt="mil.redirectBranches(target, ih);"/>
				<comm cntt="System.out.println(&amp;quot;appended&amp;quot;);"/>
				<param name="cls"/>
				<param name="annoMethodRef"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.symbol" intfc="n" abs="y" inn="n" sloc="91" jdoc="">
			<const name="numTerminals" access="pub" jdoc=""/>
			<const name="prime" access="pub" jdoc=""/>
			<field name="theDigrams" access="pub" jdoc=""/>
			<field name="value" access="pub" jdoc=""/>
			<field name="p" access="pub" jdoc=""/>
			<field name="n" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.symbol.join(symbol, symbol)" access="pub" jdoc="Links two symbols together, removing any old digram from the hash table.">
				<param name="left"/>
				<param name="right"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.cleanUp()" access="pub" jdoc="Abstract method: cleans up for symbol deletion.">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.insertAfter(symbol)" access="pub" jdoc="Inserts a symbol after this one.">
				<param name="toInsert"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.deleteDigram()" access="pub" jdoc="Removes the digram from the hash table. Overwritten in sub class guard.">
				<comm cntt="Only delete digram if its exactly"/>
				<comm cntt="the stored one."/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.isGuard()" access="pub" jdoc="Returns true if this is the guard symbol. Overwritten in subclass guard.">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.isNonTerminal()" access="pub" jdoc="Returns true if this is a non-terminal. Overwritten in subclass nonTerminal.">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.check()" access="pub" jdoc="Checks a new digram. If it appears elsewhere, deals with it by calling match(), otherwise inserts it into the hash table. Overwritten in subclass guard.">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.substitute(rule)" access="pub" jdoc="Replace a digram with a non-terminal.">
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.match(symbol, symbol)" access="pub" jdoc="Deal with a matching digram.">
				<comm cntt="reuse an existing rule"/>
				<comm cntt="create a new rule"/>
				<comm cntt="Check for an underused rule."/>
				<param name="newD"/>
				<param name="matching"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.hashCode()" access="pub" jdoc="Produce the hashcode for a digram.">
				<comm cntt="Values in linear combination with two"/>
				<comm cntt="prime numbers."/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.symbol.equals(Object)" access="pub" jdoc="Test if two digrams are equal. WARNING: don&amp;apos;t use to compare two symbols.">
				<param name="obj"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.DAGNode" intfc="n" abs="n" inn="n" sloc="26" jdoc="@author Ginger Myles">
			<field name="myLabel" access="priv" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.DAGNode.DAGNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGNode.DAGNode(String)" access="pub" jdoc="Constructs a DAG Node with a given label.">
				<param name="label"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGNode.getLabel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGNode.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGNode.compare(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGNode.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.Tracer" intfc="n" abs="n" inn="n" sloc="69" jdoc="">
			<comm cntt="end inner class Breakpoint"/>
			<field name="annotatorClass" access="priv" jdoc=""/>
			<field name="list" access="priv" jdoc=""/>
			<field name="mExited" access="priv" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.Tracer.constructArgv(String, String, String, String)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;constructArgv:&amp;quot;);"/>
				<comm cntt="for(int i=0; i&amp;lt;argv.length; i++)"/>
				<comm cntt="System.out.println(argv[i]);"/>
				<param name="annoFileName"/>
				<param name="extraCP"/>
				<param name="mainClass"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Tracer.Tracer(String)" access="pub" jdoc="">
				<comm cntt="props.getProperty(&amp;quot;DWM_AA_AnnotatorClass&amp;quot;,"/>
				<comm cntt=");"/>
				<param name="argv"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Tracer.getTracePoints()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Tracer.STOP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Tracer.onProgramExit(com.sun.jdi.VirtualMachine)" access="prot" jdoc="">
				<param name="vm"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Tracer.waitForExit()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Tracer.exited()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.birthmark.wpp.Tracer$Breakpoint" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<mth name="/:sandmark.birthmark.wpp.Tracer$Breakpoint.Breakpoint(String, String)" access="pub" jdoc="">
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Tracer$Breakpoint.Action(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<comm cntt="new sandmark.util.ByteCodeLocation(caller.location.method,"/>
				<comm cntt="caller.location.lineNumber, caller.location.codeIndex);"/>
				<comm cntt="System.out.println(&amp;quot;location: &amp;quot; + location);"/>
				<comm cntt="sandmark.util.StackFrame[] stack = data.getCallStack();"/>
				<comm cntt="sandmark.util.StackFrame[] stack1 ="/>
				<comm cntt="sandmark.util.exec.MethodCallData.deleteIncompleteStackFrames(stack);"/>
				<comm cntt="for(int i=0; i &amp;lt; stack.length; i++){"/>
				<comm cntt="System.out.println(&amp;quot;in loop&amp;quot;);"/>
				<comm cntt="if(!list.contains(tracePoint)){"/>
				<comm cntt="}"/>
				<comm cntt="}"/>
				<param name="data"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.birthmark.wpp.guard" intfc="n" abs="n" inn="n" sloc="20" jdoc="">
			<field name="r" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.guard.guard(rule)" access="pub" jdoc="">
				<param name="theRule"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.guard.cleanUp()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.guard.isGuard()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.guard.deleteDigram()" access="pub" jdoc="">
				<comm cntt="Do nothing"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.guard.check()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.RunSequitur" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<field name="annotationPoints" access="pub" jdoc=""/>
			<field name="trace" access="pub" jdoc=""/>
			<field name="rules" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.RunSequitur.RunSequitur(String)" access="pub" jdoc="">
				<param name="trace"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.RunSequitur.RunSequitur(int[])" access="pub" jdoc="">
				<param name="annoPoints"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.RunSequitur.runSequitur()" access="pub" jdoc="">
				<comm cntt="Reset number of rules and Hashtable."/>
				<comm cntt="for (i=0; i &amp;lt; trace.length(); i++){"/>
				<comm cntt="firstRule.last().insertAfter(new terminal(trace.charAt(i)));"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.RunSequitur.getRules()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.RunSequitur.main(String[])" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.DAGEdge" intfc="n" abs="n" inn="n" sloc="35" jdoc="">
			<field name="edgeCount" access="priv" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.DAGEdge.DAGEdge(DAGNode, DAGNode)" access="pub" jdoc="">
				<param name="source"/>
				<param name="sink"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGEdge.getEdgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGEdge.increaseEdgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGEdge.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGEdge.compare(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.DAGEdge.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.Annotator" intfc="n" abs="n" inn="n" sloc="6" jdoc="">
			<mth name="/:sandmark.birthmark.wpp.Annotator.MARK()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.Annotator.sm$mark()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.nonTerminal" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<field name="r" access="pub" jdoc=""/>
			<mth name="/:sandmark.birthmark.wpp.nonTerminal.nonTerminal(rule)" access="pub" jdoc="">
				<param name="theRule"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.nonTerminal.clone()" access="prot" jdoc="Extra cloning method necessary so that count in the corresponding rule is increased.">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.nonTerminal.cleanUp()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.nonTerminal.isNonTerminal()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.birthmark.wpp.nonTerminal.expand()" access="pub" jdoc="This symbol is the last reference to its rule. The contents of the rule are substituted in its place.">
				<comm cntt="Necessary so that garbage collector"/>
				<comm cntt="can delete rule and guard."/>
			</mth>
		</class>
		<class name="/:sandmark.birthmark.wpp.terminal" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/:sandmark.birthmark.wpp.terminal.terminal(int)" access="pub" jdoc="">
				<param name="theValue"/>
			</mth>
			<mth name="/:sandmark.birthmark.wpp.terminal.cleanUp()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.config">
		<class name="/:sandmark.config.RequisiteProperty" intfc="n" abs="y" inn="n" sloc="3" jdoc="A RequisiteProperty encapsulates information about dependencies between each obfuscation and watermarking algorithm. There are various subclasses of RequisiteProperty to describe dependencies, such as naming a specific class via an &amp;lt;code&amp;gt;AlgorithmProperty&amp;lt; code&amp;gt; or describing a code mutation via a &amp;lt;code&amp;gt;ModificationProperty&amp;lt; code&amp;gt;. @author Kelly Heffner &amp;lt;a href=&amp;quot;mailto:kheffner@cs.arizona.edu&amp;quot;&amp;gt;kheffner@cs.arizona.edu&amp;lt; a&amp;gt;">
		</class>
		<class name="/:sandmark.config.ModificationProperty" intfc="n" abs="n" inn="n" sloc="84" jdoc="A ModificationProperty encapsulates information about dependencies between each obfuscation and watermarking algorithm. Specifically, it encapsulates a code mutation, like &amp;lt;code&amp;gt;I_CHANGE_FIELD_NAMES&amp;lt; code&amp;gt; represents the property that an algorithm modifies the names of the fields in the constant pool. It is essential that this information is consistent across all of sandmark, so this class has no public constructor. The only available modification properties are those listed in the static fields of this class. If there is a mutation not available that you would like added to ModificationProperty, please email &amp;lt;a href=&amp;quot;mailto:kheffner@cs.arizona.edu&amp;quot;&amp;gt;kheffner@cs.arizona.edu&amp;lt; a&amp;gt;. @author Kelly Heffner">
			<const name="I_PUBLICIZE_FIELDS" access="pub" jdoc="Any of the publicizing algorithms should have this property."/>
			<const name="I_PUBLICIZE_METHODS" access="pub" jdoc="Any of the publicizing algorithms should have this property."/>
			<const name="I_PUBLICIZE_CLASSES" access="pub" jdoc="Any of the publicizing algorithms should have this property."/>
			<const name="I_CHANGE_CONSTANT_POOL" access="pub" jdoc=""/>
			<const name="I_CHANGE_FIELD_TYPES" access="pub" jdoc=""/>
			<const name="I_CHANGE_FIELD_NAMES" access="pub" jdoc=""/>
			<const name="I_CHANGE_FIELD_SCOPES" access="pub" jdoc=""/>
			<const name="I_CHANGE_METHOD_NAMES" access="pub" jdoc=""/>
			<const name="I_CHANGE_METHOD_SIGNATURES" access="pub" jdoc=""/>
			<const name="I_CHANGE_METHOD_SCOPES" access="pub" jdoc=""/>
			<const name="I_CHANGE_METHOD_BODIES" access="pub" jdoc=""/>
			<const name="I_ADD_METHOD_CODE" access="pub" jdoc="Any algorithm that inserts code (of any form, whether it will ever execute or not) should have this property."/>
			<const name="I_REORDER_INSTRUCTIONS" access="pub" jdoc=""/>
			<const name="I_REMOVE_METHOD_CODE" access="pub" jdoc="Any algorithm that deletes code from a method should have this property."/>
			<const name="I_MODIFY_METHOD_CODE" access="pub" jdoc="Any algorithm that edits instructions (like the local variable number, or which constant number is referenced) should have this property."/>
			<const name="I_ADD_LOCAL_VARIABLES" access="pub" jdoc="Any algorithm that adds locals to the method(s) it runs on should have this property."/>
			<const name="I_CHANGE_LOCAL_VARIABLES" access="pub" jdoc=""/>
			<const name="I_CHANGE_CLASS_NAMES" access="pub" jdoc=""/>
			<const name="I_CHANGE_CLASS_SCOPES" access="pub" jdoc=""/>
			<const name="I_CHANGE_CLASS_CONTENTS" access="pub" jdoc=""/>
			<const name="I_ADD_CLASSES" access="pub" jdoc=""/>
			<const name="I_REMOVE_CLASSES" access="pub" jdoc=""/>
			<const name="I_ADD_METHODS" access="pub" jdoc=""/>
			<const name="I_REMOVE_METHODS" access="pub" jdoc=""/>
			<const name="I_ADD_FIELDS" access="pub" jdoc=""/>
			<const name="I_REMOVE_FIELDS" access="pub" jdoc=""/>
			<const name="I_OBFUSCATE_IDENTIFIERS" access="pub" jdoc=""/>
			<const name="THREAD_UNSAFE" access="pub" jdoc=""/>
			<const name="REFLECTION_UNSAFE" access="pub" jdoc=""/>
			<const name="PERFORMANCE_DEGRADE_HIGH" access="pub" jdoc=""/>
			<const name="PERFORMANCE_DEGRADE_MED" access="pub" jdoc=""/>
			<const name="PERFORMANCE_DEGRADE_LOW" access="pub" jdoc=""/>
			<const name="PERFORMANCE_DEGRADE_NONE" access="pub" jdoc=""/>
			<const name="p1" access="pub" jdoc=""/>
			<const name="p2" access="pub" jdoc=""/>
			<const name="p3" access="pub" jdoc=""/>
			<field name="myProp" access="priv" jdoc=""/>
			<mth name="/:sandmark.config.ModificationProperty.ModificationProperty(String)" access="priv" jdoc="Modification properties should have a descriptor string that has &amp;quot;prop:&amp;quot; as the start, to denote that they are mutation properties, and not a specific algorithm.">
				<param name="desc"/>
			</mth>
			<mth name="/:sandmark.config.ModificationProperty.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.config.AlgorithmProperty" intfc="n" abs="n" inn="n" sloc="29" jdoc="An AlgorithmProperty encapsulates information about dependencies between each obfuscation and watermarking algorithm. Specifically, it encapsulates another Sandmark algorithm that is a dependency. @author Kelly Heffner &amp;lt;a href=&amp;quot;mailto:kheffner@cs.arizona.edu&amp;quot;&amp;gt;kheffner@cs.arizona.edu&amp;lt; a&amp;gt;">
			<field name="myAlg" access="priv" jdoc=""/>
			<mth name="/:sandmark.config.AlgorithmProperty.AlgorithmProperty(sandmark.Algorithm)" access="pub" jdoc="Constructs an AlgorithmProperty from the specified Sandmark algorithm. @param alg an instance of a Sandmark algorithm">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.config.AlgorithmProperty.getAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.config.AlgorithmProperty.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.config.AlgorithmProperty.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.config.AlgorithmProperty.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.decompile">
		<class name="/:sandmark.decompile.Decompile" intfc="n" abs="n" inn="n" sloc="75" jdoc="">
			<comm cntt="Describe what optimize is."/>
			<field name="sConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.decompile.Decompile.decompile(sandmark.program.Application, String, String)" access="pub" jdoc="Decompiles the specified program. @param app the application to decompile @param classlist the specific class to decompile or empty string if you want to decompile the whole program @param classpath the classpath of external classes needed for decompilation or empty string">
				<param name="app"/>
				<param name="classlist"/>
				<param name="classpath"/>
			</mth>
			<mth name="/:sandmark.decompile.Decompile.getProperties()" access="pub" jdoc="">
				<comm cntt="{&amp;quot;DECOMP_JarInput&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;The jar-file to be decompiled.&amp;quot;, null,&amp;quot;F&amp;quot;, },"/>
				<comm cntt="{&amp;quot;DECOMP_Decompiler&amp;quot;, &amp;quot;jDecompile # %&amp;quot;, &amp;quot;The decompiler command line. &amp;quot; + &amp;quot;&amp;apos;%&amp;apos; is a placeholder for the (qualified) name of the class file. &amp;quot; + &amp;quot;&amp;apos;#&amp;apos; is a placeholder for the path to the unpacked jarfile.&amp;quot;, null,&amp;quot;S&amp;quot;, },"/>
			</mth>
			<mth name="/:sandmark.decompile.Decompile.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the About page for Decompile @return html code for the about page">
			</mth>
			<mth name="/:sandmark.decompile.Decompile.getHelpURL()" access="pub" jdoc="Get the URL of the Help page for Decompile @return url of the help page">
			</mth>
			<mth name="/:sandmark.decompile.Decompile.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.diff">
		<class name="/:sandmark.diff.LCS" intfc="n" abs="n" inn="n" sloc="71" jdoc="Uses dynamic programming to provide two static methods for the Longest Common Subsequence operation. @author Zach Heidepriem">
			<field name="C" access="pub" jdoc=""/>
			<field name="B" access="pub" jdoc=""/>
			<field name="m" access="pub" jdoc=""/>
			<field name="n" access="pub" jdoc=""/>
			<mth name="/:sandmark.diff.LCS.getLength(java.lang.Object[], java.lang.Object[])" access="pub" jdoc="Gets the length of the LCS of two sequences of objects, using the &amp;lt;code&amp;gt;equals&amp;lt; code&amp;gt; method @param X the first sequence to perform LCS on @param Y the second sequence to perform LCS on @return the length of the lcs">
				<comm cntt="This is the length of the LCS"/>
				<param name="X"/>
				<param name="Y"/>
			</mth>
			<mth name="/:sandmark.diff.LCS.getSubsequence(java.lang.Object[], java.lang.Object[])" access="pub" jdoc="Get the LCS of two sequences using the &amp;lt;code&amp;gt;equals()&amp;lt; code&amp;gt; method @param a the first sequence to perform LCS on @param b the second sequence to perform LCS on @return 2 vectors, each containing Integer objects containing indices of elements in the lcs of the respective arrays.">
				<comm cntt="The length of sequence X"/>
				<comm cntt="The length of sequence Y"/>
				<comm cntt="System.out.println(X[i] + &amp;quot;=?&amp;quot; + Y[j]);"/>
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.diff.LCS.getSubsequence(int[], int[])" access="pub" jdoc="Get the LCS of two sequences @param a the first sequence to perform LCS on @param b the second sequence to perform LCS on @return 2 vectors, each containing Integer objects containing indices of elements in the lcs of the respective arrays.">
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.diff.LCS.getLength(int[], int[])" access="pub" jdoc="Gets the length of the LCS of two sequences of objects, using the &amp;lt;code&amp;gt;equals&amp;lt; code&amp;gt; method @param a the first sequence to perform LCS on @param b the second sequence to perform LCS on @return the length of the lcs">
				<param name="a"/>
				<param name="b"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.DiffUtil" intfc="n" abs="n" inn="n" sloc="133" jdoc="A class that provide utilites to DiffAlgorithms @author Zach Heidepriem">
			<mth name="/:sandmark.diff.DiffUtil.cpToArray(org.apache.bcel.generic.ConstantPoolGen)" access="pub" jdoc="Converts a constant pool to an array of Strings @param cpg the constant pool to convert @return the constant pool copied into an array of Strings">
				<param name="cpg"/>
			</mth>
			<mth name="/:sandmark.diff.DiffUtil.methodsAreEqual(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="Determine if two method bodies are equal. @param a the first method @param b the second method @return true iff the input methods have identical bodies">
				<comm cntt="&amp;&amp; a.getName().equals(b.getName()) &amp;&amp; a.getClassName().equals(b.getClassName()) &amp;&amp; a.getSignature().equals(b.getSignature());"/>
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.diff.DiffUtil.classesAreEqual(sandmark.program.Class, sandmark.program.Class)" access="pub" jdoc="Determine if two classes are equal; i.e., the sets of method bodies are equivalent, and the sets of constants in the constant pools are equivalent. @param c1 the first class @param c2 the second class @return true iff the classes are equal">
				<param name="c1"/>
				<param name="c2"/>
			</mth>
			<mth name="/:sandmark.diff.DiffUtil.sameNames(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(m1.getSignature() + &amp;quot;|&amp;quot; + m1.getName() + &amp;quot;|&amp;quot; + m1.getClassName());"/>
				<comm cntt="System.out.println(m2.getSignature() + &amp;quot;|&amp;quot; + m2.getName() + &amp;quot;|&amp;quot; + m2.getClassName());"/>
				<param name="m1"/>
				<param name="m2"/>
			</mth>
			<mth name="/:sandmark.diff.DiffUtil.check(sandmark.program.Method, sandmark.program.Method, sandmark.diff.DiffOptions)" access="pub" jdoc="Determine if two methods should be compared based on a set of DiffOptions. @param m1 the first method @param m2 the second method @param options the options @return true iff the methods should be compared">
				<param name="m1"/>
				<param name="m2"/>
				<param name="options"/>
			</mth>
			<mth name="/:sandmark.diff.DiffUtil.check(sandmark.program.Class, sandmark.program.Class, sandmark.diff.DiffOptions)" access="pub" jdoc="Determine if two classes should be compared based on a set of DiffOptions. @param c1 the first class @param c2 the second class @param options the options @return true iff the classes should be compared">
				<param name="c1"/>
				<param name="c2"/>
				<param name="options"/>
			</mth>
			<mth name="/:sandmark.diff.DiffUtil.getOps(org.apache.bcel.generic.InstructionHandle[])" access="pub" jdoc="Put the opcodes of an array of InstructionHandles into an array @param instrs the instructions to put in the array @return an array of opcodes corresponding to the input instructions">
				<param name="instrs"/>
			</mth>
			<mth name="/:sandmark.diff.DiffUtil.getOpsAndArgs(org.apache.bcel.generic.InstructionHandle[])" access="pub" jdoc="Put the bytecode of an array of InstructionHandles into an int array @param instrs the instructions to put in the array @return an array of ints corresponding to the input instructions">
				<comm cntt="for iload_&amp;lt;n&amp;gt;"/>
				<comm cntt="if(op == 54) System.out.println(&amp;quot;istore: &amp;quot; + arg);"/>
				<comm cntt="Convert v to an array"/>
				<param name="instrs"/>
			</mth>
			<mth name="/:sandmark.diff.DiffUtil.pack(int, int)" access="pub" jdoc="">
				<param name="opcode"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.diff.DiffUtil.unpack(int)" access="priv" jdoc="">
				<param name="i"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.DiffAlgorithm" intfc="n" abs="y" inn="n" sloc="26" jdoc="A DiffAlgorithm will perform a comparison of any two jar files, reporting similarities and or differences. The algorithm can be applied by calling run() explicitly or creating a new thread: &amp;lt;code&amp;gt;new Thread(myAlgorithm).start()&amp;lt; code&amp;gt;. Once the thread has completed, call &amp;lt;code&amp;gt;getResults()&amp;lt; code&amp;gt;. @author Zach Heidepriem">
			<field name="app1" access="prot" jdoc=""/>
			<field name="app2" access="prot" jdoc=""/>
			<field name="options" access="prot" jdoc=""/>
			<field name="results" access="prot" jdoc=""/>
			<mth name="/:sandmark.diff.DiffAlgorithm.DiffAlgorithm(sandmark.program.Application, sandmark.program.Application, sandmark.diff.DiffOptions)" access="pub" jdoc="Construct a DiffAlgorithm @param a the first Application @param b the second Application @param o the set of DiffOptions to use when diffing">
				<param name="a"/>
				<param name="b"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.getName()" access="pub" jdoc="@return the name of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.getDescription()" access="pub" jdoc="@return a short description of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.getResults()" access="pub" jdoc="@return an array of Result objects generated by this algorithm.">
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.color(sandmark.diff.Result)" access="pub" jdoc="@param r the Result object to color @return a Coloring object generated by this algorithm for a given Result object">
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.run()" access="pub" jdoc="The run method creates and fills the results for this algorithm. After calling run(), call getResults() to retrieve the results.">
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.diff(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="Diff two given objects using this algorithm @param o1 the first object @param o2 the second object @return a Result object generated by this algorithm">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.getTaskLength()" access="pub" jdoc="@return a measure of the expected time to apply the algorithm. See &amp;lt;code&amp;gt;getCurrent()&amp;lt; code&amp;gt;">
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.getCurrent()" access="pub" jdoc="Intended to be called while &amp;lt;code&amp;gt;run()&amp;lt; code&amp;gt; is being run in a separate thread. @return a measure of how much diffing the alorithm has completed.">
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.stop()" access="pub" jdoc="Stop this from running">
			</mth>
			<mth name="/:sandmark.diff.DiffAlgorithm.toString()" access="pub" jdoc="@return the name of this algorithm">
			</mth>
		</class>
		<class name="/:sandmark.diff.DiffOptions" intfc="n" abs="n" inn="n" sloc="58" jdoc="A class for storing and accessing diff options. @author Zach Heidepriem">
			<field name="filter" access="priv" jdoc=""/>
			<field name="filterNames" access="priv" jdoc=""/>
			<field name="filterBodies" access="priv" jdoc=""/>
			<field name="ignoreLimit" access="priv" jdoc=""/>
			<field name="objectCompare" access="priv" jdoc=""/>
			<const name="COMPARE_ALL_PAIRS" access="pub" jdoc=""/>
			<const name="COMPARE_BY_NAME" access="pub" jdoc=""/>
			<mth name="/:sandmark.diff.DiffOptions.DiffOptions()" access="pub" jdoc="Create a new set of DiffOptions with default values: objectCompare = true ignoreLimit = 10 filter = .5 filterNames = false filterBodies = true">
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.getObjectCompare()" access="pub" jdoc="@return the comparison method, either COMPARE_ALL_PAIRS or COMPARE_BY_NAME">
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.setObjectCompare(int)" access="pub" jdoc="">
				<param name="comparisonMethod"/>
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.getFilter()" access="pub" jdoc="@return a value between 0-1 that determines which pairs of object are returned by an algorithm.">
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.setFilter(double)" access="pub" jdoc="">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.getFilterNames()" access="pub" jdoc="@return true if objects with the same name should be filtered out">
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.setFilterNames(boolean)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.getFilterBodies()" access="pub" jdoc="@return true if objects with the same data should be filtered out">
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.setFilterBodies(boolean)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.getIgnoreLimit()" access="pub" jdoc="@return the minimium size of method bodies that should be diffed">
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.setIgnoreLimit(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.diff.DiffOptions.toString()" access="pub" jdoc="@return a String representation of these options">
			</mth>
		</class>
		<class name="/:sandmark.diff.InstructionWrapper" intfc="n" abs="n" inn="n" sloc="173" jdoc="A wrapper class for BCEL&amp;apos;s Instruction class. Used by various diff algorithms. @author Zach Heidepriem">
			<field name="inst" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="argtype" access="pub" jdoc=""/>
			<const name="BIPUSH" access="pub" jdoc=""/>
			<const name="SIPUSH" access="pub" jdoc=""/>
			<const name="DCONST" access="pub" jdoc=""/>
			<const name="FCONST" access="pub" jdoc=""/>
			<const name="ICONST" access="pub" jdoc=""/>
			<const name="LCONST" access="pub" jdoc=""/>
			<const name="BranchInstruction" access="pub" jdoc=""/>
			<const name="CPInstruction" access="pub" jdoc=""/>
			<const name="LocalVariableInstruction" access="pub" jdoc=""/>
			<const name="RET" access="pub" jdoc=""/>
			<const name="CP_INDEX" access="pub" jdoc=""/>
			<const name="LV_INDEX" access="pub" jdoc=""/>
			<const name="CONST" access="pub" jdoc=""/>
			<const name="OFFSET" access="pub" jdoc=""/>
			<const name="ILOAD" access="priv" jdoc=""/>
			<const name="ILOAD_0" access="priv" jdoc=""/>
			<const name="ILOAD_1" access="priv" jdoc=""/>
			<const name="ILOAD_2" access="priv" jdoc=""/>
			<const name="ILOAD_3" access="priv" jdoc=""/>
			<const name="ISTORE" access="priv" jdoc=""/>
			<const name="ISTORE_0" access="priv" jdoc=""/>
			<const name="ISTORE_1" access="priv" jdoc=""/>
			<const name="ISTORE_2" access="priv" jdoc=""/>
			<const name="ISTORE_3" access="priv" jdoc=""/>
			<const name="DLOAD" access="priv" jdoc=""/>
			<const name="DLOAD_0" access="priv" jdoc=""/>
			<const name="DLOAD_1" access="priv" jdoc=""/>
			<const name="DLOAD_2" access="priv" jdoc=""/>
			<const name="DLOAD_3" access="priv" jdoc=""/>
			<const name="DSTORE" access="priv" jdoc=""/>
			<const name="DSTORE_0" access="priv" jdoc=""/>
			<const name="DSTORE_1" access="priv" jdoc=""/>
			<const name="DSTORE_2" access="priv" jdoc=""/>
			<const name="DSTORE_3" access="priv" jdoc=""/>
			<const name="FLOAD" access="priv" jdoc=""/>
			<const name="FLOAD_0" access="priv" jdoc=""/>
			<const name="FLOAD_1" access="priv" jdoc=""/>
			<const name="FLOAD_2" access="priv" jdoc=""/>
			<const name="FLOAD_3" access="priv" jdoc=""/>
			<const name="FSTORE" access="priv" jdoc=""/>
			<const name="FSTORE_0" access="priv" jdoc=""/>
			<const name="FSTORE_1" access="priv" jdoc=""/>
			<const name="FSTORE_2" access="priv" jdoc=""/>
			<const name="FSTORE_3" access="priv" jdoc=""/>
			<const name="LLOAD" access="priv" jdoc=""/>
			<const name="LLOAD_0" access="priv" jdoc=""/>
			<const name="LLOAD_1" access="priv" jdoc=""/>
			<const name="LLOAD_2" access="priv" jdoc=""/>
			<const name="LLOAD_3" access="priv" jdoc=""/>
			<const name="LSTORE" access="priv" jdoc=""/>
			<const name="LSTORE_0" access="priv" jdoc=""/>
			<const name="LSTORE_1" access="priv" jdoc=""/>
			<const name="LSTORE_2" access="priv" jdoc=""/>
			<const name="LSTORE_3" access="priv" jdoc=""/>
			<mth name="/:sandmark.diff.InstructionWrapper.getInst()" access="pub" jdoc="">
				<comm cntt="System.out.println(inst);"/>
			</mth>
			<mth name="/:sandmark.diff.InstructionWrapper.getOpcode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.InstructionWrapper.InstructionWrapper(org.apache.bcel.generic.Instruction)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.diff.InstructionWrapper.getArgType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.InstructionWrapper.getConstArg()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.InstructionWrapper.getOffset()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.InstructionWrapper.getLVIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.InstructionWrapper.getCPIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.InstructionWrapper.setIndex(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.Monitorable" intfc="y" abs="n" inn="n" sloc="5" jdoc="An interface for providing status updates while a DiffAlgorithm is running. @author Zach Heidepriem">
			<mth name="/:sandmark.diff.Monitorable.getTaskLength()" access="pub" jdoc="@return An arbitrary value that represents the expected running time for the task.">
			</mth>
			<mth name="/:sandmark.diff.Monitorable.getCurrent()" access="pub" jdoc="@return A number between 0 and getTaskLength() that represents how much of the task has been completed.">
			</mth>
			<mth name="/:sandmark.diff.Monitorable.stop()" access="pub" jdoc="Stop this from running">
			</mth>
		</class>
		<class name="/:sandmark.diff.Coloring" intfc="n" abs="n" inn="n" sloc="42" jdoc="A class to store line numbers associated with &amp;quot;colors.&amp;quot; @author Zach Heidepriem">
			<field name="v" access="priv" jdoc=""/>
			<const name="DEFAULT" access="pub" jdoc=""/>
			<field name="title" access="priv" jdoc=""/>
			<mth name="/:sandmark.diff.Coloring.Coloring(int, String)" access="pub" jdoc="Construct a coloring @param size the number of lines this Coloring object will hold @param s the title of this Coloring object">
				<param name="size"/>
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.diff.Coloring.getTitle()" access="pub" jdoc="@return the title of this object">
			</mth>
			<mth name="/:sandmark.diff.Coloring.add(String)" access="pub" jdoc="Add a line with default color to this coloring @param s the String to add">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.diff.Coloring.add(String, int)" access="pub" jdoc="Add a line to the end of this coloring @param s the String to add @param color the color associated with line">
				<param name="s"/>
				<param name="color"/>
			</mth>
			<mth name="/:sandmark.diff.Coloring.add(int, String, int)" access="pub" jdoc="Add a line to this coloring @param line the line number @param s the String to add @param color the color associated with line">
				<param name="line"/>
				<param name="s"/>
				<param name="color"/>
			</mth>
			<mth name="/:sandmark.diff.Coloring.add(int, String)" access="pub" jdoc="Adds a line with default color @param line the line number @param s the String to add">
				<param name="line"/>
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.diff.Coloring.getColor(int)" access="pub" jdoc="@param line the line number to get @return the color associated with line">
				<comm cntt="System.out.println(line + &amp;quot; &amp;quot; + v.size());"/>
				<comm cntt="System.out.println(&amp;quot;bad index, using default color&amp;quot;);"/>
				<param name="line"/>
			</mth>
			<mth name="/:sandmark.diff.Coloring.get(int)" access="pub" jdoc="@param line the line number to get @return the String associated with line">
				<param name="line"/>
			</mth>
			<mth name="/:sandmark.diff.Coloring.toString()" access="pub" jdoc="@return a String representation of this Coloring">
			</mth>
			<mth name="/:sandmark.diff.Coloring.size()" access="pub" jdoc="@return the capacity of this Coloring">
			</mth>
		<class name="/:sandmark.diff.Coloring$Line" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="s" access="priv" jdoc=""/>
			<field name="color" access="priv" jdoc=""/>
			<mth name="/:sandmark.diff.Coloring$Line.Line(String, int)" access="pub" jdoc="">
				<param name="str"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.diff.Coloring$Line.getColor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.Coloring$Line.getString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.diff.Result" intfc="n" abs="n" inn="n" sloc="27" jdoc="A Diff result contains two objects with the associated similarity of between the two objects. @author Zach Heidepriem">
			<field name="object1" access="pub" jdoc=""/>
			<field name="object2" access="pub" jdoc=""/>
			<field name="similarity" access="pub" jdoc=""/>
			<mth name="/:sandmark.diff.Result.Result(sandmark.program.Object, sandmark.program.Object, double)" access="pub" jdoc="@param a the first object in this Result @param b the second object in this Result @param sim the similarity between a and b">
				<param name="a"/>
				<param name="b"/>
				<param name="sim"/>
			</mth>
			<mth name="/:sandmark.diff.Result.getObject1()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.Result.getObject2()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.Result.getSimilarity()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.Result.compareTo(Object)" access="pub" jdoc="The natural ordering of Results is descending by similarity.">
				<param name="o"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.diff.classdiff">
		<class name="/:sandmark.diff.classdiff.ConstPoolDiff" intfc="n" abs="n" inn="n" sloc="48" jdoc="A class diff algorithm that performs a literal comparison of constant pools @author Zach Heidepriem">
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.diff.classdiff.ConstPoolDiff.ConstPoolDiff(sandmark.program.Application, sandmark.program.Application, sandmark.diff.DiffOptions)" access="pub" jdoc="Construct a DiffAlgorithm @param a the first Application @param b the second Application @param o the set of DiffOptions to use when diffing">
				<param name="a"/>
				<param name="b"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.classdiff.ConstPoolDiff.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.classdiff.ConstPoolDiff.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.classdiff.ConstPoolDiff.color(sandmark.diff.Result)" access="pub" jdoc="Color the constant pools such that the LCS is displayed in its own color @param r The Result object to color @return The sandmark.diff.Coloring for r">
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.diff.classdiff.ConstPoolDiff.diffClasses(sandmark.program.Class, sandmark.program.Class)" access="pub" jdoc="Diff two classes using this algorithm @param c1 the first class @param c2 the second class @return a Result object generated by this algorithm">
				<param name="c1"/>
				<param name="c2"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.classdiff.ClassDiffAlgorithm" intfc="n" abs="y" inn="n" sloc="60" jdoc="A ClassDiffAlgorithm will perform a comparison of any two class files, reporting similarities and or differences. This is an abstract class that implements the run() method. This method is used to extract the elements to be diffed from the Application objects. We also implement the getCurrent() and getTaskLength() methods in order to keep track of the progress of run() @author Zach Heidepriem">
			<field name="current" access="prot" jdoc=""/>
			<field name="taskLength" access="prot" jdoc=""/>
			<field name="stop" access="prot" jdoc=""/>
			<mth name="/:sandmark.diff.classdiff.ClassDiffAlgorithm.ClassDiffAlgorithm(sandmark.program.Application, sandmark.program.Application, sandmark.diff.DiffOptions)" access="pub" jdoc="Construct a DiffAlgorithm @param a the first Application @param b the second Application @param o the set of DiffOptions to use when diffing">
				<param name="a"/>
				<param name="b"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.classdiff.ClassDiffAlgorithm.run()" access="pub" jdoc="The run method creates and fills the results for this algorithm. After calling run(), call getResults() to retrieve the results. Compare classes using this object&amp;apos;s diffClasses() method.">
			</mth>
			<mth name="/:sandmark.diff.classdiff.ClassDiffAlgorithm.runHelper(java.util.Vector)" access="priv" jdoc="">
				<comm cntt="Do some preliminary checks based on options"/>
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.diff.classdiff.ClassDiffAlgorithm.getResults()" access="pub" jdoc="@return an array of Result objects generated by this algorithm.">
			</mth>
			<mth name="/:sandmark.diff.classdiff.ClassDiffAlgorithm.diff(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="Diff two given class objects using this algorithm @param o1 the first class object @param o2 the second class object @return a Result object generated by this algorithm">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.diff.classdiff.ClassDiffAlgorithm.diffClasses(sandmark.program.Class, sandmark.program.Class)" access="pub" jdoc="All ClassDiffAlgorithms must implement this method @param c1 the first class @param c2 the second class @return a Result object generated by this algorithm">
				<param name="c1"/>
				<param name="c2"/>
			</mth>
			<mth name="/:sandmark.diff.classdiff.ClassDiffAlgorithm.getTaskLength()" access="pub" jdoc="@return a measure of the expected time to apply the algorithm. See &amp;lt;code&amp;gt;getCurrent()&amp;lt; code&amp;gt;">
			</mth>
			<mth name="/:sandmark.diff.classdiff.ClassDiffAlgorithm.getCurrent()" access="pub" jdoc="Intended to be called while &amp;lt;code&amp;gt;run()&amp;lt; code&amp;gt; is being run in a separate thread. @return a measure of how much diffing the alorithm has completed.">
			</mth>
			<mth name="/:sandmark.diff.classdiff.ClassDiffAlgorithm.stop()" access="pub" jdoc="Stop this from running">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.diff.methoddiff">
		<class name="/:sandmark.diff.methoddiff.BakerAlgorithm" intfc="n" abs="n" inn="n" sloc="121" jdoc="A method diff algorithm that considers the positional relationship between variable uses. @author Zach Heidepriem">
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.diff.methoddiff.BakerAlgorithm.BakerAlgorithm(sandmark.program.Application, sandmark.program.Application, sandmark.diff.DiffOptions)" access="pub" jdoc="Construct a BakerAlgorithm @param a the first Application @param b the second Application @param o the set of DiffOptions to use when diffing">
				<param name="a"/>
				<param name="b"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.BakerAlgorithm.getName()" access="pub" jdoc="@return the name of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.BakerAlgorithm.getDescription()" access="pub" jdoc="@return a short description of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.BakerAlgorithm.color(sandmark.diff.Result)" access="pub" jdoc="@param r The Result object to color @return The Coloring for r using this algorithm">
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.BakerAlgorithm.diffMethods(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="Diff two given objects using this algorithm @param m1 the first method @param m2 the second method @return a Result object generated by this algorithm">
				<param name="m1"/>
				<param name="m2"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.BakerAlgorithm.computeOffsets(sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="the line number of last use"/>
				<comm cntt="the line number of last use"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.methoddiff.TupleList" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<mth name="/:sandmark.diff.methoddiff.TupleList.TupleList()" access="pub" jdoc="A comparable collection of LinkedList&amp;apos;s">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.TupleList.compareTo(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.methoddiff.CFGDiff" intfc="n" abs="n" inn="n" sloc="113" jdoc="A method diff algorithm that diffs structure of MethodCFG @author Zach Heidepriem">
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.diff.methoddiff.CFGDiff.CFGDiff(sandmark.program.Application, sandmark.program.Application, sandmark.diff.DiffOptions)" access="pub" jdoc="Construct a CFGDiff @param a the first Application @param b the second Application @param o the set of DiffOptions to use when diffing">
				<param name="a"/>
				<param name="b"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGDiff.getName()" access="pub" jdoc="@return the name of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGDiff.getDescription()" access="pub" jdoc="@return a short description of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGDiff.color(sandmark.diff.Result)" access="pub" jdoc="@param r The Result object to color @return The Coloring for r using this algorithm">
				<comm cntt="if(DEBUG){ System.out.println(t1); System.out.println(t2); }"/>
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGDiff.diffMethods(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="Diff two given objects using this algorithm @param m1 the first method @param m2 the second method @return a Result object generated by this algorithm">
				<comm cntt="if(DEBUG) { a.printCFG(); b.printCFG(); }"/>
				<comm cntt="if(DEBUG) System.out.println(t1.toString(true) +&amp;quot;\n&amp;quot; + t2.toString(true));"/>
				<comm cntt="if(DEBUG &amp;&amp; subtree1.nodeCount() == subtree2.nodeCount()){ System.out.println(subtree1); System.out.println(subtree2); }"/>
				<comm cntt="System.out.println(similarity);"/>
				<param name="m1"/>
				<param name="m2"/>
			</mth>
		<class name="/:sandmark.diff.methoddiff.CFGDiff$CFGResult" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<field name="subtree1" access="pub" jdoc=""/>
			<field name="subtree2" access="pub" jdoc=""/>
			<mth name="/:sandmark.diff.methoddiff.CFGDiff$CFGResult.CFGResult(sandmark.program.Method, sandmark.program.Method, double, sandmark.diff.methoddiff.CFGTree, sandmark.diff.methoddiff.CFGTree)" access="pub" jdoc="">
				<param name="m1"/>
				<param name="m2"/>
				<param name="similarity"/>
				<param name="subtree1"/>
				<param name="subtree2"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGDiff$CFGResult.getSubtree1()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGDiff$CFGResult.getSubtree2()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.diff.methoddiff.CFGTreeNode" intfc="n" abs="n" inn="n" sloc="45" jdoc="">
			<field name="level" access="pub" jdoc=""/>
			<field name="value" access="pub" jdoc=""/>
			<field name="tuple" access="pub" jdoc=""/>
			<field name="obj" access="pub" jdoc=""/>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.CFGTreeNode(int, Object)" access="pub" jdoc="">
				<param name="level"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.setValue(int)" access="pub" jdoc="">
				<param name="val"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.getTuple()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.append(int)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.getLevel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.getData()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTreeNode.hasInstructions()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.diff.methoddiff.DMDiffAlgorithm" intfc="n" abs="n" inn="n" sloc="157" jdoc="Compares basic blocks of CFGs The algorithm can be applied by calling run() explicitly or creating a new thread: &amp;lt;code&amp;gt;new Thread(myAlgorithm).start()&amp;lt; code&amp;gt;. After applying the algorithm, call &amp;lt;code&amp;gt;getResults()&amp;lt; code&amp;gt; @author Zach Heidepriem">
			<comm cntt="true;"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.diff.methoddiff.DMDiffAlgorithm.DMDiffAlgorithm(sandmark.program.Application, sandmark.program.Application, sandmark.diff.DiffOptions)" access="pub" jdoc="Creates a DMDiffAlgorithm @param a the first Application @param b the second Application @param o the set of DiffOptions to use when diffing">
				<param name="a"/>
				<param name="b"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.DMDiffAlgorithm.getName()" access="pub" jdoc="@return the name of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.DMDiffAlgorithm.getDescription()" access="pub" jdoc="@return a short description of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.DMDiffAlgorithm.diffMethods(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="Diff two given objects using this algorithm @param m1 the first method @param m2 the second method @return a Result object generated by this algorithm">
				<param name="m1"/>
				<param name="m2"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.DMDiffAlgorithm.getBlocksInOrder(sandmark.analysis.controlflowgraph.MethodCFG)" access="pub" jdoc="">
				<comm cntt="Sort the blocks by bytecode position"/>
				<param name="cfg"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.DMDiffAlgorithm.color(sandmark.diff.Result)" access="pub" jdoc="@param r The Result object to color @return The sandmark.diff.Coloring for r using this algorithm">
				<comm cntt="Make some arrays to hold the sorted blocks"/>
				<comm cntt="and fill them"/>
				<comm cntt="Make a vector so we call indexOf"/>
				<comm cntt="Make the first Result"/>
				<comm cntt="Make the second result"/>
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.DMDiffAlgorithm.getSimilarity(sandmark.analysis.controlflowgraph.MethodCFG, sandmark.analysis.controlflowgraph.MethodCFG)" access="priv" jdoc="">
				<param name="a"/>
				<param name="b"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.methoddiff.TrivialDiffAlgorithm" intfc="n" abs="n" inn="n" sloc="94" jdoc="Finds the longest common subsequence between all pairs of methods and returns similarity as a function of the length of the LCS. The algorithm can be applied by calling run() explicitly or creating a new thread: &amp;lt;code&amp;gt;new Thread(myAlgorithm).start()&amp;lt; code&amp;gt;. After applying the algorithm, call &amp;lt;code&amp;gt;getResults()&amp;lt; code&amp;gt; @author Zach Heidepriem">
			<comm cntt="true;"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="DIFF_ARGS" access="priv" jdoc=""/>
			<mth name="/:sandmark.diff.methoddiff.TrivialDiffAlgorithm.TrivialDiffAlgorithm(sandmark.program.Application, sandmark.program.Application, sandmark.diff.DiffOptions)" access="pub" jdoc="Creates a TrivialDiffAlgorithm (diffs opcodes) @param a the first Application @param b the second Application @param o the set of DiffOptions to use when diffing">
				<param name="a"/>
				<param name="b"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.TrivialDiffAlgorithm.TrivialDiffAlgorithm(sandmark.program.Application, sandmark.program.Application, sandmark.diff.DiffOptions, boolean)" access="pub" jdoc="Creates a TrvialDiffAlgorithm (literal diff) @param a the first Application @param b the second Application @param o the set of DiffOptions to use when diffing @param args If true, peform a literal comparison. If false, compare only opcodes. If not specified, default value is false;">
				<param name="a"/>
				<param name="b"/>
				<param name="o"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.TrivialDiffAlgorithm.getName()" access="pub" jdoc="@return the name of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.TrivialDiffAlgorithm.getDescription()" access="pub" jdoc="@return a short description of this algorithm">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.TrivialDiffAlgorithm.diffMethods(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="Diff two given objects using this algorithm @param m1 the first method @param m2 the second method @return a Result object generated by this algorithm">
				<param name="m1"/>
				<param name="m2"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.TrivialDiffAlgorithm.color(sandmark.diff.Result)" access="pub" jdoc="@param r The Result object to color @return The sandmark.diff.Coloring for r using this algorithm">
				<param name="r"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm" intfc="n" abs="y" inn="n" sloc="78" jdoc="A MethodDiffAlgorithm will perform a comparison of any two methods, reporting similarities and or differences. This abstract class implements the run method to extract the elements from the application objects. We also implement the getCurrent() and getTaskLength methods in order to keep track of the progress of run() @author Zach Heidepriem">
			<field name="current" access="prot" jdoc=""/>
			<field name="taskLength" access="prot" jdoc=""/>
			<field name="stop" access="prot" jdoc=""/>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.MethodDiffAlgorithm(sandmark.program.Application, sandmark.program.Application, sandmark.diff.DiffOptions)" access="pub" jdoc="Construct a MethodDiffAlgorithm @param a the first Application @param b the second Application @param o the set of DiffOptions to use when diffing">
				<param name="a"/>
				<param name="b"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.run()" access="pub" jdoc="The run method creates and fills the results for this algorithm. After calling run(), call getResults() to retrieve the results. Compares methods using this object&amp;apos;s diffMethods() method.">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.runHelper(java.util.Vector)" access="priv" jdoc="">
				<comm cntt="Do some preliminary checks based on options"/>
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.getTaskLength()" access="pub" jdoc="@return a measure of the expected time to apply the algorithm. See &amp;lt;code&amp;gt;getCurrent()&amp;lt; code&amp;gt;">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.getCurrent()" access="pub" jdoc="Intended to be called while &amp;lt;code&amp;gt;run()&amp;lt; code&amp;gt; is being run in a separate thread. @return a measure of how much diffing the alorithm has completed.">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.stop()" access="pub" jdoc="Stop this from running">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.getResults()" access="pub" jdoc="@return an array of Result objects generated by this algorithm.">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.diff(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="Diff two given method objects using this algorithm @param o1 the first method object @param o2 the second method object @return a Result object generated by this algorithm">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.diffMethods(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="All MethodDiffAlgorithms must implement this method @param m1 the first method @param m2 the second method @return a Result object generated by this algorithm">
				<param name="m1"/>
				<param name="m2"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.MethodDiffAlgorithm.getMethods(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.methoddiff.CFGTree" intfc="n" abs="n" inn="n" sloc="255" jdoc="">
			<comm cntt="for building"/>
			<comm cntt="Basically convert the trimmed cfg to a newgraph.Graph"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="cfg" access="priv" jdoc=""/>
			<field name="numLevels" access="priv" jdoc=""/>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.CFGTree(java.util.Iterator, java.util.Iterator)" access="pub" jdoc="">
				<param name="nodes"/>
				<param name="edges"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.CFGTree(sandmark.analysis.controlflowgraph.MethodCFG)" access="pub" jdoc="">
				<comm cntt="if(DEBUG) System.out.println(this);"/>
				<param name="cfgraph"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.setNumLevels()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.build(sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="">
				<comm cntt="if(DEBUG){ graph.print(); System.out.println(graph.nodeCount() + &amp;quot; &amp;quot; + graph.edgeCount()); }"/>
				<comm cntt="Find the first real block"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.build(sandmark.analysis.controlflowgraph.BasicBlock, CFGTreeNode, int)" access="priv" jdoc="">
				<param name="prev"/>
				<param name="prevTN"/>
				<param name="level"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.getNumLevels()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.rootValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.isomorphic(CFGTree, CFGTree)" access="pub" jdoc="">
				<comm cntt="if(DEBUG &amp;&amp; A.nodeCount() == B.nodeCount()) System.out.println(A +&amp;quot;\n&amp;quot; + B + &amp;quot;\n&amp;quot; + A.edgeCount() + &amp;quot; &amp;quot; + B.edgeCount() + &amp;quot; &amp;quot; + A.getNumLevels() + &amp;quot; &amp;quot; + B.getNumLevels());"/>
				<param name="A"/>
				<param name="B"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.mark(CFGTree, CFGTree)" access="priv" jdoc="">
				<comm cntt="Mark all leaves with a zero, make a list of leaves at last level"/>
				<comm cntt="System.out.println(tn.getLevel() + &amp;quot; &amp;quot; + A.getNumLevels());"/>
				<comm cntt="if(DEBUG) System.out.println(A+&amp;quot;$$$\n&amp;quot;+B);"/>
				<param name="A"/>
				<param name="B"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.assignInts(int, java.util.LinkedList, java.util.LinkedList, CFGTree, CFGTree)" access="priv" jdoc="">
				<comm cntt="should be 1 at most"/>
				<comm cntt="its the root"/>
				<comm cntt="should be 1 at most"/>
				<comm cntt="its the root"/>
				<comm cntt="if(DEBUG) System.out.println(L1 + &amp;quot;\n&amp;quot; + L2);"/>
				<comm cntt="if(DEBUG) System.out.println(S1 + &amp;quot;\n&amp;quot; + S2);"/>
				<comm cntt="Compare tuples of S1 and S2"/>
				<param name="index"/>
				<param name="L1"/>
				<param name="L2"/>
				<param name="A"/>
				<param name="B"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.buildLists(int, java.util.Vector, java.util.Vector, java.util.LinkedList, java.util.LinkedList, CFGTree, CFGTree)" access="priv" jdoc="">
				<comm cntt="Set the values and update L1"/>
				<comm cntt="Add all the leaves from Level level to L"/>
				<comm cntt="Do the same for L2"/>
				<comm cntt="Add all the leaves from Level level to L"/>
				<param name="level"/>
				<param name="S1"/>
				<param name="S2"/>
				<param name="L1"/>
				<param name="L2"/>
				<param name="A"/>
				<param name="B"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.getSubtree(Object)" access="pub" jdoc="">
				<comm cntt="Make a bunch of new nodes and put them in a map"/>
				<comm cntt="get all the edges from the nodes and copy into vector"/>
				<comm cntt="now the map has all the nodes, put them in a Collection"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.contains(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<comm cntt="Compares the block id&amp;apos;s, level doesn&amp;apos;t matter"/>
				<comm cntt="return hasNode(new CFGTreeNode(-1, bb));"/>
				<param name="bb"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.toString(boolean)" access="pub" jdoc="">
				<param name="printEdges"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.CFGTree.toString(Object, boolean)" access="pub" jdoc="">
				<param name="root"/>
				<param name="printEdges"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.methoddiff.ComparableBlock" intfc="n" abs="n" inn="n" sloc="47" jdoc="Wrap a basic block into a Comparable. Blocks are ordered by instruction. DMDiffAlgorithm, DM watermarker both use this to sort basic blocks to improve efficiency. @author Zach Heidepriem">
			<field name="block" access="pub" jdoc=""/>
			<mth name="/:sandmark.diff.methoddiff.ComparableBlock.ComparableBlock(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.ComparableBlock.compareTo(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.ComparableBlock.size()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.ComparableBlock.getOpcode(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.ComparableBlock.getInst(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.ComparableBlock.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.ComparableBlock.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.diff.methoddiff.ComparableBlock.printInstrs()" access="pub" jdoc="">
				<comm cntt="for(int i = 0; i &amp;lt; block.getInstList().size(); i++)"/>
				<comm cntt="System.out.println(block.getInstList().get(i));"/>
			</mth>
		</class>
		<class name="/:sandmark.diff.methoddiff.Tuple" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<mth name="/:sandmark.diff.methoddiff.Tuple.Tuple()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.diff.methoddiff.Tuple.compareTo(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.eclipse">
		<class name="/:sandmark.eclipse.SandMarkConfigTab" intfc="n" abs="n" inn="n" sloc="152" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<comm cntt="i guess it&amp;apos;s not really an obfuscator"/>
			<comm cntt="(non-Javadoc) @see org.eclipse.debug.ui.ILaunchConfigurationTab#createControl(org.eclipse.swt.widgets.Composite)"/>
			<comm cntt="(non-Javadoc) @see org.eclipse.debug.ui.ILaunchConfigurationTab#setDefaults(org.eclipse.debug.core.ILaunchConfigurationWorkingCopy)"/>
			<comm cntt="(non-Javadoc) @see org.eclipse.debug.ui.ILaunchConfigurationTab#initializeFrom(org.eclipse.debug.core.ILaunchConfiguration)"/>
			<comm cntt="(non-Javadoc) @see org.eclipse.debug.ui.ILaunchConfigurationTab#performApply(org.eclipse.debug.core.ILaunchConfigurationWorkingCopy)"/>
			<comm cntt="(non-Javadoc) @see org.eclipse.debug.ui.ILaunchConfigurationTab#getName()"/>
			<comm cntt="(non-Javadoc) @see org.eclipse.ui.externaltools.internal.launchConfigurations.ExternalToolsMainTab#getLocationLabel()"/>
			<comm cntt="(non-Javadoc) @see org.eclipse.ui.externaltools.internal.launchConfigurations.ExternalToolsMainTab#getWorkingDirectoryLabel()"/>
			<const name="ALG_NAME_KEY" access="pub" jdoc=""/>
			<const name="ALG_PROPS_KEY" access="pub" jdoc=""/>
			<const name="ALG_INPUT_FILE" access="pub" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<field name="sAlgs" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mAlgList" access="priv" jdoc=""/>
			<field name="mCPPContainer" access="priv" jdoc=""/>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.createControl(Composite)" access="pub" jdoc="">
				<param name="arg0"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.getAlgNames()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.setAlgorithm()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.changed()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.setDefaults(ILaunchConfigurationWorkingCopy)" access="pub" jdoc="">
				<param name="arg0"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.initializeFrom(ILaunchConfiguration)" access="pub" jdoc="">
				<comm cntt="not much to do other than just not initialize"/>
				<param name="arg0"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.performApply(ILaunchConfigurationWorkingCopy)" access="pub" jdoc="">
				<param name="arg0"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.widgetSelected(SelectionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.widgetDefaultSelected(SelectionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.getLocationLabel()" access="prot" jdoc="">
				<comm cntt="$NON-NLS-1$"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkConfigTab.getWorkingDirectoryLabel()" access="prot" jdoc="">
				<comm cntt="$NON-NLS-1$"/>
			</mth>
		</class>
		<class name="/:sandmark.eclipse.SandMarkLaunchDelegate" intfc="n" abs="n" inn="n" sloc="29" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.eclipse.SandMarkLaunchDelegate.launch(ILaunchConfiguration, String, ILaunch, IProgressMonitor)" access="pub" jdoc="">
				<param name="configuration"/>
				<param name="mode"/>
				<param name="launch"/>
				<param name="monitor"/>
			</mth>
		</class>
		<class name="/:sandmark.eclipse.SandMarkTabGroup" intfc="n" abs="n" inn="n" sloc="9" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.eclipse.SandMarkTabGroup.createTabs(ILaunchConfigurationDialog, String)" access="pub" jdoc="">
				<comm cntt="new SandMarkMainTab(),"/>
				<comm cntt="new RefreshTab(),"/>
				<comm cntt="new CommonTab(),"/>
				<param name="arg0"/>
				<param name="arg1"/>
			</mth>
		</class>
		<class name="/:sandmark.eclipse.ConfigPropertyPanel" intfc="n" abs="n" inn="n" sloc="76" jdoc="@see sandmark.gui.ConfigPropertyPanel">
			<field name="DEBUG" access="priv" jdoc=""/>
			<const name="MAX_VISIBLE_ROWS" access="priv" jdoc=""/>
			<field name="mProperties" access="priv" jdoc=""/>
			<field name="mTracker" access="priv" jdoc=""/>
			<field name="mChangeListeners" access="priv" jdoc=""/>
			<const name="TEXTFIELD" access="priv" jdoc=""/>
			<const name="COMBOBOX" access="priv" jdoc=""/>
			<mth name="/:sandmark.eclipse.ConfigPropertyPanel.ConfigPropertyPanel(org.eclipse.swt.widgets.Composite, sandmark.util.ConfigProperties, long, sandmark.gui.CurrentApplicationTracker)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="configProps"/>
				<param name="phaseMask"/>
				<param name="tracker"/>
			</mth>
			<mth name="/:sandmark.eclipse.ConfigPropertyPanel.modifyText(ModifyEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.eclipse.ConfigPropertyPanel.addChangeListener(ChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.eclipse.ConfigPropertyPanel.removeChangeListener(ChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.eclipse.ConfigPropertyPanel.getTracker()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.ConfigPropertyPanel.setUpdating(boolean)" access="priv" jdoc="">
				<param name="updating"/>
			</mth>
			<mth name="/:sandmark.eclipse.ConfigPropertyPanel.updateProperties()" access="pub" jdoc="Atomically update all properties">
			</mth>
			<mth name="/:sandmark.eclipse.ConfigPropertyPanel.getToolTip(sandmark.util.ConfigProperties, String)" access="prot" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
			</mth>
		<class name="/:sandmark.eclipse.ConfigPropertyPanel$ChangeListener" intfc="y" abs="n" inn="y" sloc="3" jdoc="">
			<mth name="/:sandmark.eclipse.ConfigPropertyPanel$ChangeListener.changed()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.eclipse.PropertyInfo" intfc="n" abs="y" inn="n" sloc="26" jdoc="">
			<field name="updating" access="pub" jdoc=""/>
			<field name="mOrigValue" access="prot" jdoc=""/>
			<field name="mProps" access="prot" jdoc=""/>
			<field name="mPropName" access="prot" jdoc=""/>
			<field name="mCPP" access="prot" jdoc=""/>
			<mth name="/:sandmark.eclipse.PropertyInfo.PropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.eclipse.PropertyInfo.updateProperty()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.PropertyInfo.getLabelText(String)" access="prot" jdoc="">
				<param name="propName"/>
			</mth>
			<mth name="/:sandmark.eclipse.PropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.eclipse.FieldAndButtonPropertyInfo" intfc="n" abs="y" inn="n" sloc="21" jdoc="">
			<mth name="/:sandmark.eclipse.FieldAndButtonPropertyInfo.FieldAndButtonPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.eclipse.FieldAndButtonPropertyInfo.getTextBox(Object)" access="prot" jdoc="">
				<param name="initValue"/>
			</mth>
			<mth name="/:sandmark.eclipse.FieldAndButtonPropertyInfo.getButtonLabel()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.FieldAndButtonPropertyInfo.getListener()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.eclipse.FilePropertyInfo" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<field name="mFNB" access="prot" jdoc=""/>
			<mth name="/:sandmark.eclipse.FilePropertyInfo.FilePropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.eclipse.FilePropertyInfo.getTextBox(Object)" access="prot" jdoc="">
				<param name="initValue"/>
			</mth>
			<mth name="/:sandmark.eclipse.FilePropertyInfo.getButtonLabel()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.FilePropertyInfo.getListener()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.FilePropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.FilePropertyInfo.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;vetoing change of &amp;quot; + propName + &amp;quot;: localValue: &amp;quot; +"/>
				<comm cntt="localValue + &amp;quot; ; mOrigValue: &amp;quot; + mOrigValue);"/>
				<param name="cp"/>
				<param name="propName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
		</class>
		<class name="/:sandmark.eclipse.JarPropertyInfo" intfc="n" abs="n" inn="n" sloc="10" jdoc="">
			<mth name="/:sandmark.eclipse.JarPropertyInfo.JarPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.eclipse.JarPropertyInfo.getListener()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.JarPropertyInfo.getFileCategory()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.eclipse.BooleanPropertyInfo" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="mCheckBox" access="priv" jdoc=""/>
			<mth name="/:sandmark.eclipse.BooleanPropertyInfo.BooleanPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.eclipse.BooleanPropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.BooleanPropertyInfo.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
		</class>
		<class name="/:sandmark.eclipse.StringPropertyInfo" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<field name="mWidget" access="priv" jdoc=""/>
			<mth name="/:sandmark.eclipse.StringPropertyInfo.StringPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
		<class name="/:sandmark.eclipse.StringPropertyInfo$Widget" intfc="n" abs="y" inn="y" sloc="5" jdoc="">
			<mth name="/:sandmark.eclipse.StringPropertyInfo$Widget.setValue(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$Widget.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$Widget.getWidget()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.eclipse.StringPropertyInfo$TextField" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<field name="mField" access="priv" jdoc=""/>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$TextField.TextField(ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$TextField.setValue(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$TextField.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$TextField.getWidget()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.eclipse.StringPropertyInfo$ComboBox" intfc="n" abs="n" inn="y" sloc="29" jdoc="">
			<field name="mBox" access="priv" jdoc=""/>
			<field name="mValues" access="pub" jdoc=""/>
			<field name="mEditable" access="priv" jdoc=""/>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$ComboBox.ComboBox(org.eclipse.swt.widgets.Composite, java.util.List, boolean)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="values"/>
				<param name="editable"/>
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$ComboBox.setValue(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$ComboBox.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.StringPropertyInfo$ComboBox.getWidget()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.eclipse.IntegerPropertyInfo" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/:sandmark.eclipse.IntegerPropertyInfo.IntegerPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.eclipse.IntegerPropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.eclipse.DoublePropertyInfo" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/:sandmark.eclipse.DoublePropertyInfo.DoublePropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.eclipse.DoublePropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.eclipse.PIFactory" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<mth name="/:sandmark.eclipse.PIFactory.PIFactory()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.PIFactory.createPI(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
		</class>
		<class name="/:sandmark.eclipse.SandMarkPlugin" intfc="n" abs="n" inn="n" sloc="61" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<comm cntt="The single instance of this plug-in runtime class."/>
			<comm cntt="(non-Javadoc) Method declared in AbstractUIPlugin."/>
			<comm cntt="(non-Javadoc) @see org.eclipse.ui.plugin.AbstractUIPlugin#createImageRegistry()"/>
			<field name="plugin" access="priv" jdoc=""/>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.SandMarkPlugin(IPluginDescriptor)" access="pub" jdoc="Constructs an instance of this plug-in runtime class. &amp;lt;p&amp;gt; An instance of this plug-in runtime class is automatically created when the facilities provided by the Ant Core plug-in are required. &amp;lt;b&amp;gt;Clients must never explicitly instantiate a plug-in runtime class.&amp;lt; b&amp;gt; &amp;lt; p&amp;gt; @param descriptor the plug-in descriptor for the Ant UI plug-in">
				<param name="descriptor"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.shutdown()" access="pub" jdoc="@see org.eclipse.core.runtime.Plugin#shutdown()">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.getDefault()" access="pub" jdoc="Returns this plug-in instance. @return the single instance of this plug-in runtime class">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.getUniqueIdentifier()" access="pub" jdoc="Convenience method which returns the unique identifier of this plugin.">
				<comm cntt="If the default instance is not yet initialized,"/>
				<comm cntt="return a static identifier. This identifier must"/>
				<comm cntt="match the plugin id defined in plugin.xml"/>
				<comm cntt="$NON-NLS-1$"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.log(Throwable)" access="pub" jdoc="Logs the specified throwable with this plug-in&amp;apos;s log. @param t throwable to log">
				<comm cntt="$NON-NLS-1$"/>
				<param name="t"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.log(String, Throwable)" access="pub" jdoc="Writes the message to the plug-in&amp;apos;s log @param message the text to write to the log">
				<param name="message"/>
				<param name="exception"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.newErrorStatus(String, Throwable)" access="pub" jdoc="Returns a new &amp;lt;code&amp;gt;IStatus&amp;lt; code&amp;gt; for this plug-in">
				<param name="message"/>
				<param name="exception"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.initializeDefaultPreferences(IPreferenceStore)" access="prot" jdoc="">
				<param name="prefs"/>
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.getStandardDisplay()" access="pub" jdoc="Returns the standard display to be used. The method first checks, if the thread calling this method has an associated display. If so, this display is returned. Otherwise the method returns the default display.">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.createImageRegistry()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.getActivePage()" access="pub" jdoc="Returns the active workbench page or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if none.">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.getActiveWorkbenchWindow()" access="pub" jdoc="Returns the active workbench window or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if none">
			</mth>
			<mth name="/:sandmark.eclipse.SandMarkPlugin.isMacOS()" access="pub" jdoc="Returns whether the current OS claims to be Mac">
				<comm cntt="$NON-NLS-1$"/>
				<comm cntt="$NON-NLS-1$"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.gui">
		<class name="/:sandmark.gui.MultiLineToolTipUI" intfc="n" abs="n" inn="n" sloc="150" jdoc="To add multiline tooltip support to your swing applications, just add this static call to your main method. Note, you only need to do this once, even if you change LookAndFeel as the UIManager knows not to overwrite the user defaults. Moreover, it uses the current L&amp;F foreground background colors &amp;lt;p&amp;gt;&amp;lt;pre&amp;gt; MultiLineToolTipUI.initialize(); &amp;lt; pre&amp;gt;&amp;lt;p&amp;gt; @author Albert L. M. Ting">
			<field name="SINGLETON" access="pub" jdoc=""/>
			<field name="DISPLAY_ACCELERATOR" access="pub" jdoc=""/>
			<field name="TIP_LINE_LENGTH" access="pub" jdoc=""/>
			<field name="m_inset" access="pub" jdoc=""/>
			<field name="m_accelerator_offset" access="pub" jdoc=""/>
			<field name="LINE_SEPARATOR" access="priv" jdoc=""/>
			<field name="LINE_SEPARATOR_LEN" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.MultiLineToolTipUI()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.initialize()" access="pub" jdoc="">
				<comm cntt="don&amp;apos;t hardcode the class name, fetch it dynamically. This way we can"/>
				<comm cntt="obfuscate."/>
				<comm cntt="needed for 1.2"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.createUI(javax.swing.JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.installUI(javax.swing.JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.uninstallUI(javax.swing.JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.setDisplayAcceleratorKey(boolean)" access="pub" jdoc="">
				<param name="val"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.getPreferredSize(javax.swing.JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.getMinimumSize(javax.swing.JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.getMaximumSize(javax.swing.JComponent)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.paint(java.awt.Graphics, javax.swing.JComponent)" access="pub" jdoc="">
				<param name="g"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.getAcceleratorString(javax.swing.JToolTip)" access="pub" jdoc="">
				<comm cntt="ignore, associated with ToolTipManager postTip action, in"/>
				<comm cntt="swing1.1beta3 and onward"/>
				<param name="tip"/>
			</mth>
			<mth name="/:sandmark.gui.MultiLineToolTipUI.breakupLines(String)" access="pub" jdoc="StringTokenizer(text,&amp;quot;\n&amp;quot;) really does a &amp;quot;\n+&amp;quot; which is not what we want. We also want it be based on the line.separator property. So create our own version. We first attempt to divide by line.separator, then by &amp;quot;\n&amp;quot;. Ideally, we&amp;apos;d prefer to just break up by line.separator, but we need to handle text that was defined in a properties file, with embedded \n.">
				<param name="text"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.MethodSorter" intfc="n" abs="n" inn="n" sloc="21" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="mTree" access="priv" jdoc=""/>
			<field name="mSelector" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.MethodSorter.MethodSorter(AppTree, javax.swing.JComboBox)" access="pub" jdoc="">
				<param name="tree"/>
				<param name="metricSelector"/>
			</mth>
			<mth name="/:sandmark.gui.MethodSorter.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.SandMarkFrame" intfc="n" abs="n" inn="n" sloc="190" jdoc="">
			<comm cntt="See comment in MultiLineToolTipUI"/>
			<field name="tabs" access="priv" jdoc=""/>
			<field name="logText" access="priv" jdoc=""/>
			<field name="descText" access="priv" jdoc=""/>
			<field name="menuBar" access="priv" jdoc=""/>
			<field name="mApplicationTracker" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.SandMarkFrame.SandMarkFrame()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.addTabs(javax.swing.JTabbedPane)" access="prot" jdoc="">
				<param name="tabpane"/>
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.showDescription()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.setDescription(String)" access="pub" jdoc="">
				<param name="description"/>
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.addLogEntry(String)" access="pub" jdoc="">
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.setTabsEnabled(boolean)" access="pub" jdoc="">
				<param name="enabled"/>
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.getCurrentApplication()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.getApplicationTracker()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.getDisplayedPanel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.getTabs()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.setAllEnabled(boolean)" access="pub" jdoc="">
				<param name="enabled"/>
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.start(Class)" access="prot" jdoc="">
				<comm cntt="this creates a splash image that is displayed until the GUI is loaded"/>
				<comm cntt="there is one more line at the bottom to set the window invisible"/>
				<comm cntt="sets the splash panel invisible"/>
				<param name="frameType"/>
			</mth>
			<mth name="/:sandmark.gui.SandMarkFrame.main(String)" access="pub" jdoc="Execution begins here for interactive runs of SandMark. @param args">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.SMAlgHierTreePane" intfc="n" abs="n" inn="n" sloc="92" jdoc="">
			<field name="mKeyToNode" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.SMAlgHierTreePane.SMAlgHierTreePane()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SMAlgHierTreePane.add(javax.swing.tree.DefaultMutableTreeNode, String, String)" access="priv" jdoc="">
				<param name="root"/>
				<param name="label"/>
				<param name="url"/>
			</mth>
			<mth name="/:sandmark.gui.SMAlgHierTreePane.addAll(javax.swing.tree.DefaultMutableTreeNode, int)" access="priv" jdoc="">
				<comm cntt="not really a class, ignore it"/>
				<comm cntt="not really a class, ignore it"/>
				<comm cntt="not really a class, ignore it"/>
				<param name="root"/>
				<param name="classKind"/>
			</mth>
			<mth name="/:sandmark.gui.SMAlgHierTreePane.createNodes()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SMAlgHierTreePane.selectNode(String)" access="pub" jdoc="">
				<param name="key"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.SandMarkMenuBar" intfc="n" abs="n" inn="n" sloc="62" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.SandMarkMenuBar.SandMarkMenuBar(SandMarkFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.StaticEmbedPanel" intfc="n" abs="n" inn="n" sloc="119" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mPanel" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mCPPConstraints" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mGraphButton" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.StaticEmbedPanel.StaticEmbedPanel(SandMarkFrame, StaticWatermarkPanel)" access="pub" jdoc="">
				<param name="frame"/>
				<param name="panel"/>
			</mth>
			<mth name="/:sandmark.gui.StaticEmbedPanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.StaticEmbedPanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticEmbedPanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticEmbedPanel.getApplication()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.Utils" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<mth name="/:sandmark.gui.Utils.Utils()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.Utils.centerOnParent(java.awt.Component, java.awt.Component)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="child"/>
			</mth>
		<class name="/:sandmark.gui.Utils$LabeledSlider" intfc="n" abs="n" inn="y" sloc="94" jdoc="">
			<field name="m_slider" access="priv" jdoc=""/>
			<field name="m_valText" access="priv" jdoc=""/>
			<field name="m_mapper" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.LabeledSlider()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.LabeledSlider(String, String, String)" access="pub" jdoc="">
				<param name="ttl"/>
				<param name="low"/>
				<param name="high"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.LabeledSlider(String, String, String, int, int)" access="pub" jdoc="">
				<param name="ttl"/>
				<param name="low"/>
				<param name="high"/>
				<param name="min"/>
				<param name="max"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.LabeledSlider(String, String, String, int, int, int)" access="pub" jdoc="">
				<param name="ttl"/>
				<param name="low"/>
				<param name="high"/>
				<param name="min"/>
				<param name="max"/>
				<param name="val"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.LabeledSlider(String, String, String, ValueMapper)" access="pub" jdoc="">
				<param name="ttl"/>
				<param name="low"/>
				<param name="high"/>
				<param name="mapper"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.LabeledSlider(String, String, String, int, int, ValueMapper)" access="pub" jdoc="">
				<param name="ttl"/>
				<param name="low"/>
				<param name="high"/>
				<param name="min"/>
				<param name="max"/>
				<param name="mapper"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.LabeledSlider(String, String, String, int, int, int, ValueMapper)" access="pub" jdoc="">
				<param name="ttl"/>
				<param name="low"/>
				<param name="high"/>
				<param name="min"/>
				<param name="max"/>
				<param name="val"/>
				<param name="mapper"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.init(String, String, String, ValueMapper)" access="priv" jdoc="">
				<param name="ttl"/>
				<param name="low"/>
				<param name="high"/>
				<param name="mapper"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.mkPanel(java.awt.Component, java.awt.Component)" access="priv" jdoc="">
				<param name="left"/>
				<param name="right"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.mkLbl(String, boolean)" access="priv" jdoc="">
				<param name="text"/>
				<param name="bold"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.stateChanged(javax.swing.event.ChangeEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.Utils$LabeledSlider.getSlider()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.gui.Utils$LabeledSlider$ValueMapper" intfc="y" abs="n" inn="y" sloc="4" jdoc="">
			<mth name="/:sandmark.gui.Utils$LabeledSlider$ValueMapper.map(int)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
		</class>
		</class>
		</class>
		<class name="/:sandmark.gui.ExtensionFileFilter" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<comm cntt="Constructor: &amp;quot;ext&amp;quot; is the extension, without the &amp;apos;.&amp;apos; in it."/>
			<comm cntt="&amp;quot;des&amp;quot; is the description of the type of files"/>
			<comm cntt="that the extension describes"/>
			<comm cntt="method used by JFileDialogs to see if a file should be displayed"/>
			<comm cntt="accessor method"/>
			<field name="extension" access="priv" jdoc=""/>
			<field name="description" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.ExtensionFileFilter.ExtensionFileFilter(String, String)" access="pub" jdoc="">
				<param name="ext"/>
				<param name="des"/>
			</mth>
			<mth name="/:sandmark.gui.ExtensionFileFilter.accept(java.io.File)" access="pub" jdoc="">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.gui.ExtensionFileFilter.getDescription()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.MethodSliceGUI" intfc="n" abs="n" inn="n" sloc="89" jdoc="">
			<field name="forwardSlice" access="priv" jdoc=""/>
			<field name="backwardSlice" access="priv" jdoc=""/>
			<field name="mMethod" access="priv" jdoc=""/>
			<field name="staticSlicer" access="priv" jdoc=""/>
			<field name="dynamicSlicer" access="priv" jdoc=""/>
			<field name="myCellRenderer" access="priv" jdoc=""/>
			<field name="mInstructionList" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.MethodSliceGUI.MethodSliceGUI(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.gui.MethodSliceGUI.displaySlice(java.util.ArrayList)" access="priv" jdoc="">
				<param name="slice"/>
			</mth>
			<mth name="/:sandmark.gui.MethodSliceGUI.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.MethodSliceGUI.initGUI()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.SliceRenderer" intfc="n" abs="n" inn="n" sloc="38" jdoc="">
			<const name="NOT_SELECTED" access="priv" jdoc=""/>
			<const name="NOT_IN_SLICE" access="priv" jdoc=""/>
			<const name="SELECTED" access="priv" jdoc=""/>
			<const name="IN_SLICE" access="priv" jdoc=""/>
			<field name="sBGColors" access="priv" jdoc=""/>
			<field name="sFGColors" access="priv" jdoc=""/>
			<field name="mSliceInstrs" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.SliceRenderer.SliceRenderer()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SliceRenderer.setSliceInstrs(java.util.List)" access="pub" jdoc="">
				<param name="instrs"/>
			</mth>
			<mth name="/:sandmark.gui.SliceRenderer.getListCellRendererComponent(javax.swing.JList, Object, int, boolean, boolean)" access="pub" jdoc="">
				<param name="list"/>
				<param name="value"/>
				<param name="index"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.SandMarkLiteFrame" intfc="n" abs="n" inn="n" sloc="14" jdoc="">
			<mth name="/:sandmark.gui.SandMarkLiteFrame.SandMarkLiteFrame()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SandMarkLiteFrame.addTabs(javax.swing.JTabbedPane)" access="prot" jdoc="">
				<param name="tabPane"/>
			</mth>
			<mth name="/:sandmark.gui.SandMarkLiteFrame.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.AppViewPanel" intfc="n" abs="n" inn="n" sloc="123" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="mCurrentGraph" access="priv" jdoc=""/>
			<field name="mSliderPanel" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.AppViewPanel.AppViewPanel(sandmark.program.Application, javax.swing.JPanel)" access="pub" jdoc="">
				<comm cntt="No special handling for metrics"/>
				<param name="app"/>
				<param name="sliderPanel"/>
			</mth>
			<mth name="/:sandmark.gui.AppViewPanel.createSplitPane()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AppViewPanel.tearDown()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AppViewPanel.saveViewState()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AppViewPanel.restoreViewState(Object)" access="pub" jdoc="">
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.gui.AppViewPanel.buildGraphView(sandmark.util.newgraph.Graph, sandmark.util.newgraph.GraphStyle, javax.swing.JSplitPane)" access="priv" jdoc="">
				<comm cntt="node Information area"/>
				<param name="graph"/>
				<param name="style"/>
				<param name="container"/>
			</mth>
		<class name="/:sandmark.gui.AppViewPanel$GraphView" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="graphPanel" access="pub" jdoc=""/>
			<field name="graphSlider" access="pub" jdoc=""/>
			<field name="container" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.AppViewPanel$GraphView.GraphView(sandmark.util.graph.graphview.GraphZoomSlider, javax.swing.JComponent)" access="pub" jdoc="">
				<param name="gzs"/>
				<param name="comp"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.GraphDisplayButton" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<field name="myFrame" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.GraphDisplayButton.GraphDisplayButton(javax.swing.JFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.GraphDisplayButton.update(java.util.Observable, Object)" access="pub" jdoc="">
				<param name="o"/>
				<param name="arg"/>
			</mth>
			<mth name="/:sandmark.gui.GraphDisplayButton.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.StatTableModel" intfc="n" abs="n" inn="n" sloc="79" jdoc="This class allows the representation of the JTable data for Statistics objcets. There are three types of representation: one for classes, one for methods and one for packages.">
			<const name="sClassStats" access="priv" jdoc=""/>
			<const name="sMethodStats" access="priv" jdoc=""/>
			<field name="mObj" access="priv" jdoc=""/>
			<field name="stats" access="priv" jdoc=""/>
			<field name="mStatValues" access="priv" jdoc=""/>
			<field name="mCalculator" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.StatTableModel.StatTableModel(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.gui.StatTableModel.StatTableModel(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.gui.StatTableModel.getColumnCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StatTableModel.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StatTableModel.getValueAt(int, int)" access="pub" jdoc="">
				<param name="rowIndex"/>
				<param name="columnIndex"/>
			</mth>
			<mth name="/:sandmark.gui.StatTableModel.getColumnName(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.gui.StatTableModel.enqueue(Stat, int)" access="priv" jdoc="">
				<param name="stat"/>
				<param name="row"/>
			</mth>
		<class name="/:sandmark.gui.StatTableModel$Stat" intfc="n" abs="y" inn="y" sloc="11" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="getMethodName" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.StatTableModel$Stat.getValue(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.gui.StatTableModel$Stat.Stat(String, String, Class)" access="pub" jdoc="">
				<param name="n"/>
				<param name="mn"/>
				<param name="t"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.StatTableModel$ClassStat" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<mth name="/:sandmark.gui.StatTableModel$ClassStat.ClassStat(String, String, Class)" access="pub" jdoc="">
				<param name="n"/>
				<param name="mn"/>
				<param name="t"/>
			</mth>
			<mth name="/:sandmark.gui.StatTableModel$ClassStat.getValue(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.StatTableModel$MethodStat" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<mth name="/:sandmark.gui.StatTableModel$MethodStat.MethodStat(String, String, Class)" access="pub" jdoc="">
				<param name="n"/>
				<param name="mn"/>
				<param name="t"/>
			</mth>
			<mth name="/:sandmark.gui.StatTableModel$MethodStat.getValue(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.StatTableModel$StatCalcTask" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<field name="stat" access="pub" jdoc=""/>
			<field name="row" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.StatTableModel$StatCalcTask.StatCalcTask(Stat, int)" access="pub" jdoc="">
				<param name="s"/>
				<param name="r"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.StatTableModel$StatCalculator" intfc="n" abs="n" inn="y" sloc="26" jdoc="">
			<field name="queue" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.StatTableModel$StatCalculator.run()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StatTableModel$StatCalculator.enqueue(StatCalcTask)" access="pub" jdoc="">
				<param name="task"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.QuickProtectPanel" intfc="n" abs="n" inn="n" sloc="222" jdoc="">
			<comm cntt="this will change with combo box"/>
			<field name="myFrame" access="priv" jdoc=""/>
			<field name="myCPP" access="priv" jdoc=""/>
			<field name="myCPPConstraints" access="priv" jdoc=""/>
			<field name="mInsetPanel" access="priv" jdoc=""/>
			<field name="quickProtect" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mGraphButton" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<field name="sCPToName" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.QuickProtectPanel.QuickProtectPanel(sandmark.gui.SandMarkFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.buildInsetPanel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.setQuickProtect(sandmark.wizard.quickprotect.QuickProtect)" access="pub" jdoc="">
				<param name="qp"/>
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.getApplication()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.getFrame()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel.getHelpURL()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.gui.QuickProtectPanel$QuickProtectComboBox" intfc="n" abs="n" inn="y" sloc="29" jdoc="">
			<mth name="/:sandmark.gui.QuickProtectPanel$QuickProtectComboBox.QuickProtectComboBox()" access="pub" jdoc="">
				<comm cntt="not really a QuickProtect"/>
				<comm cntt="not really a QuickProtect"/>
				<comm cntt="not really a QuickProtect"/>
			</mth>
			<mth name="/:sandmark.gui.QuickProtectPanel$QuickProtectComboBox.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.AboutDialog" intfc="n" abs="n" inn="n" sloc="193" jdoc="">
			<const name="windowSize" access="priv" jdoc=""/>
			<const name="paneSize" access="priv" jdoc=""/>
			<field name="editorPane" access="priv" jdoc=""/>
			<field name="okButton" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.AboutDialog.AboutDialog(javax.swing.JFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/:sandmark.gui.AboutDialog.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.AboutDialog.hyperlinkUpdate(javax.swing.event.HyperlinkEvent)" access="pub" jdoc="">
				<comm cntt="sandmark.util.Log.message( sandmark.util.Log.INTERNAL_EXCEPTION, &amp;quot;Exception caught and ignored:&amp;quot; + ex );"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.AboutDialog.gotoLink(javax.swing.event.HyperlinkEvent)" access="priv" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.AboutDialog.buildHTMLText()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AboutDialog.cutTags(java.lang.String)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Successful&amp;quot;);"/>
				<param name="text"/>
			</mth>
			<mth name="/:sandmark.gui.AboutDialog.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the about page for SandMark @return HTML code for the about page">
			</mth>
		</class>
		<class name="/:sandmark.gui.HelpDialog" intfc="n" abs="n" inn="n" sloc="75" jdoc="">
			<field name="myTree" access="priv" jdoc=""/>
			<field name="splitPane" access="priv" jdoc=""/>
			<const name="windowSize" access="priv" jdoc=""/>
			<const name="minimumSize1" access="priv" jdoc=""/>
			<const name="minimumSize2" access="priv" jdoc=""/>
			<field name="editorPane" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.HelpDialog.HelpDialog()" access="pub" jdoc="">
				<comm cntt="construct the tree pane"/>
				<comm cntt="construct an empty editor pane to start"/>
			</mth>
			<mth name="/:sandmark.gui.HelpDialog.valueChanged(javax.swing.event.TreeSelectionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.HelpDialog.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.HelpDialog.hyperlinkUpdate(javax.swing.event.HyperlinkEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.HelpDialog.gotoLink(javax.swing.event.HyperlinkEvent)" access="priv" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.HelpDialog.displayPage(java.lang.String)" access="priv" jdoc="">
				<param name="page"/>
			</mth>
			<mth name="/:sandmark.gui.HelpDialog.displayPage(java.net.URL)" access="priv" jdoc="">
				<param name="url"/>
			</mth>
			<mth name="/:sandmark.gui.HelpDialog.showHelpFor(String)" access="pub" jdoc="">
				<param name="helpKey"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.MethodViewPanel" intfc="n" abs="n" inn="n" sloc="186" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="mMethod" access="priv" jdoc=""/>
			<field name="mSliderPanel" access="priv" jdoc=""/>
			<field name="mCurrentGraph" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.MethodViewPanel.MethodViewPanel(sandmark.program.Method, javax.swing.JPanel)" access="pub" jdoc="">
				<comm cntt="No special handling for instruction,stats,metrics"/>
				<param name="method"/>
				<param name="sliderPanel"/>
			</mth>
			<mth name="/:sandmark.gui.MethodViewPanel.tearDown()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.MethodViewPanel.saveViewState()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.MethodViewPanel.restoreViewState(Object)" access="pub" jdoc="">
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.gui.MethodViewPanel.getInstructionTable(sandmark.program.Method)" access="priv" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.gui.MethodViewPanel.getCFGStyle()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.MethodViewPanel.getIFGStyle()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.MethodViewPanel.buildGraphView(sandmark.util.newgraph.Graph, sandmark.util.newgraph.GraphStyle, javax.swing.JSplitPane)" access="priv" jdoc="">
				<comm cntt="node Information area"/>
				<param name="graph"/>
				<param name="style"/>
				<param name="container"/>
			</mth>
			<mth name="/:sandmark.gui.MethodViewPanel.createSplitPane()" access="priv" jdoc="">
			</mth>
		<class name="/:sandmark.gui.MethodViewPanel$GraphView" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="graphPanel" access="pub" jdoc=""/>
			<field name="graphSlider" access="pub" jdoc=""/>
			<field name="container" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.MethodViewPanel$GraphView.GraphView(sandmark.util.graph.graphview.GraphZoomSlider, javax.swing.JComponent)" access="pub" jdoc="">
				<param name="gzs"/>
				<param name="comp"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.CurrentApplicationTracker" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<field name="mCurrentApplication" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.CurrentApplicationTracker.getCurrentApplication()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.CurrentApplicationTracker.setApplication(sandmark.program.Application)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;setting application to &amp;quot; + app);"/>
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.ObfuscatePanel" intfc="n" abs="n" inn="n" sloc="227" jdoc="">
			<comm cntt="Describe what obfuscation is."/>
			<field name="mInsetPanel" access="priv" jdoc=""/>
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mCPPConstraints" access="priv" jdoc=""/>
			<field name="mComboBox" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mGraphButton" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<field name="mMethodConfigProps" access="priv" jdoc=""/>
			<field name="mClassConfigProps" access="priv" jdoc=""/>
			<field name="mDescription" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.ObfuscatePanel.ObfuscatePanel(SandMarkFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.buildInsetPanel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.getApplication()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.getFrame()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.showDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.showTransientDescription(String)" access="pub" jdoc="">
				<param name="description"/>
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.algorithmChanged(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the About page for Obfuscate @return HTML code for the about page">
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.getHelpURL()" access="pub" jdoc="Get the URL of the Help page for Obfuscate @return url for the help page">
			</mth>
			<mth name="/:sandmark.gui.ObfuscatePanel.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.SplashPanel" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<field name="img" access="priv" jdoc=""/>
			<field name="displayable" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.SplashPanel.SplashPanel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SplashPanel.paintComponent(java.awt.Graphics)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.StaticBirthmarkPanel" intfc="n" abs="n" inn="n" sloc="179" jdoc="">
			<field name="mInsetPanel" access="priv" jdoc=""/>
			<field name="percentSim" access="priv" jdoc=""/>
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mCPPConstraints" access="priv" jdoc=""/>
			<field name="mComboBox" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<field name="mDescription" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.StaticBirthmarkPanel(SandMarkFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.buildInsetPanel()" access="pub" jdoc="">
				<comm cntt="javax.swing.JLabel percentLabel = new javax.swing.JLabel( &amp;quot;Percent Similarity:&amp;quot;); percentLabel.setForeground(DARK_SAND_COLOR); gbc.gridx = 1; gbc.weightx = 1; gbc.gridwidth = 1; gbc.fill = java.awt.GridBagConstraints.BOTH; layout.setConstraints(percentLabel,gbc); mInsetPanel.add(percentLabel);"/>
				<comm cntt="javax.swing.JTextField"/>
				<comm cntt="gbc.anchor = java.awt.GridBagConstraints.SOUTHWEST;"/>
				<comm cntt="mGraphButton = new GraphDisplayButton(mFrame); mGraphButton.setVisible(false); gbc.gridx = 2; gbc.weightx = 0; gbc.anchor = java.awt.GridBagConstraints.SOUTHEAST; layout.setConstraints(mGraphButton, gbc); mInsetPanel.add(mGraphButton); gbc.gridx = 3; gbc.anchor = java.awt.GridBagConstraints.SOUTHEAST; layout.setConstraints(configureButton,gbc); mInsetPanel.add(configureButton);"/>
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<comm cntt="String inputFile = sandmark.Console.getConfigProperties().getProperty"/>
				<comm cntt="(&amp;quot;Input File&amp;quot;);"/>
				<param name="cp"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.getApplication()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.getFrame()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.showDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.showTransientDescription(String)" access="pub" jdoc="">
				<param name="description"/>
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.algorithmChanged(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.StaticBirthmarkPanel.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.HelpButton" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<field name="mHelpKey" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.HelpButton.HelpButton(String)" access="pub" jdoc="">
				<param name="helpKey"/>
			</mth>
			<mth name="/:sandmark.gui.HelpButton.HelpButton(String, String)" access="pub" jdoc="">
				<param name="helpKey"/>
				<param name="buttonTitle"/>
			</mth>
			<mth name="/:sandmark.gui.HelpButton.setHelpKey(String)" access="pub" jdoc="">
				<param name="helpKey"/>
			</mth>
			<mth name="/:sandmark.gui.HelpButton.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.FilenameBox" intfc="n" abs="n" inn="n" sloc="64" jdoc="">
			<field name="m_inst" access="priv" jdoc=""/>
			<field name="m_hash" access="priv" jdoc=""/>
			<field name="m_hist" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.FilenameBox.FilenameBox(Object)" access="pub" jdoc="">
				<comm cntt="m_instances keeps track of all existing FilenameBox objects,"/>
				<comm cntt="so that they can be notified whenever any list changes"/>
				<comm cntt="unfortunately this defeats garbage collection... oh well"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.gui.FilenameBox.use()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.FilenameBox.updateList()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.FilenameBox.itemStateChanged(java.awt.event.ItemEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.FilenameBox.getText()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.FilenameBox.setText(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
		<class name="/:sandmark.gui.FilenameBox$Item" intfc="n" abs="n" inn="y" sloc="9" jdoc="">
			<field name="shrt" access="pub" jdoc=""/>
			<field name="lng" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.FilenameBox$Item.Item(String, String)" access="pub" jdoc="">
				<param name="s"/>
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.gui.FilenameBox$Item.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.FilenameBox$FileList" intfc="n" abs="n" inn="y" sloc="27" jdoc="">
			<mth name="/:sandmark.gui.FilenameBox$FileList.add(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.DynamicTracePanel" intfc="n" abs="n" inn="n" sloc="122" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mPanel" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mCPPConstraints" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mTraceButton" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.DynamicTracePanel.DynamicTracePanel(SandMarkFrame, DynamicWatermarkPanel)" access="pub" jdoc="">
				<param name="frame"/>
				<param name="panel"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicTracePanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicTracePanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicTracePanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicTracePanel.getApplication()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.NextWMButton" intfc="n" abs="n" inn="n" sloc="28" jdoc="">
			<field name="mWMIter" access="priv" jdoc=""/>
			<field name="mWMList" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.NextWMButton.NextWMButton(javax.swing.JComboBox)" access="pub" jdoc="">
				<param name="wmList"/>
			</mth>
			<mth name="/:sandmark.gui.NextWMButton.setIter(java.util.Iterator)" access="pub" jdoc="">
				<param name="wmIter"/>
			</mth>
			<mth name="/:sandmark.gui.NextWMButton.addNextItem()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.MetricTableModel" intfc="n" abs="n" inn="n" sloc="62" jdoc="This class allows the representation of the JTable data for Statistics objcets. There are three types of representation: one for classes, one for methods and one for packages.">
			<field name="mGetter" access="priv" jdoc=""/>
			<field name="mMetrics" access="priv" jdoc=""/>
			<field name="mMetricValues" access="priv" jdoc=""/>
			<field name="mCalculator" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.MetricTableModel.MetricTableModel(sandmark.program.Application)" access="pub" jdoc="Constructs the package level data representation. @param app the application object">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel.MetricTableModel(sandmark.program.Class)" access="pub" jdoc="Constructs the class level data representation.">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel.MetricTableModel(sandmark.program.Method)" access="pub" jdoc="Constructs the method level data representation.">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel.getColumnCount()" access="pub" jdoc="Returns the number of colmuns. @return returns the number of columns in the table">
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel.getRowCount()" access="pub" jdoc="Returns the current number of rows @return the number of rows in the table.">
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel.getValueAt(int, int)" access="pub" jdoc="Returns the value at the cell specified @param row the row in the table @param col the column in the table @return the Object located at row, col in the table.">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel.getColumnName(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel.enqueue(sandmark.metric.Metric, int)" access="priv" jdoc="">
				<param name="metric"/>
				<param name="row"/>
			</mth>
		<class name="/:sandmark.gui.MetricTableModel$MetricGetter" intfc="n" abs="y" inn="y" sloc="3" jdoc="">
			<mth name="/:sandmark.gui.MetricTableModel$MetricGetter.getValue(sandmark.metric.Metric)" access="pub" jdoc="">
				<param name="metric"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.MetricTableModel$AppMetricGetter" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="mApp" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.MetricTableModel$AppMetricGetter.AppMetricGetter(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel$AppMetricGetter.getValue(sandmark.metric.Metric)" access="pub" jdoc="">
				<param name="metric"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.MetricTableModel$ClassMetricGetter" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="mClass" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.MetricTableModel$ClassMetricGetter.ClassMetricGetter(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel$ClassMetricGetter.getValue(sandmark.metric.Metric)" access="pub" jdoc="">
				<param name="metric"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.MetricTableModel$MethodMetricGetter" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="mMethod" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.MetricTableModel$MethodMetricGetter.MethodMetricGetter(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel$MethodMetricGetter.getValue(sandmark.metric.Metric)" access="pub" jdoc="">
				<param name="metric"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.MetricTableModel$MetricCalcTask" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<field name="metric" access="pub" jdoc=""/>
			<field name="row" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.MetricTableModel$MetricCalcTask.MetricCalcTask(sandmark.metric.Metric, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="r"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.MetricTableModel$MetricCalculator" intfc="n" abs="n" inn="y" sloc="26" jdoc="">
			<field name="queue" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.MetricTableModel$MetricCalculator.run()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.MetricTableModel$MetricCalculator.enqueue(MetricCalcTask)" access="pub" jdoc="">
				<param name="task"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.ViewPanel" intfc="y" abs="n" inn="n" sloc="5" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.gui.ViewPanel.tearDown()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ViewPanel.saveViewState()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ViewPanel.restoreViewState(Object)" access="pub" jdoc="">
				<param name="viewState"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.DynamicRecognizePanel" intfc="n" abs="n" inn="n" sloc="96" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mPanel" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mCPPConstraints" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mGraphButton" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.DynamicRecognizePanel.DynamicRecognizePanel(SandMarkFrame, DynamicWatermarkPanel)" access="pub" jdoc="">
				<param name="frame"/>
				<param name="panel"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicRecognizePanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicRecognizePanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicRecognizePanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicRecognizePanel.getApplication()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.ObfDialog" intfc="n" abs="n" inn="n" sloc="350" jdoc="The Obfuscation dialog pops up when the user clicks the Configure button in the Obfuscate panel. This dialog lets the user select specific obfuscation algorithms and obfuscation levels for individual methods, classes, or the entire jar file. @author Steven Kobes">
			<comm cntt="named constants"/>
			<comm cntt="GUI widgets"/>
			<comm cntt="the split pane contains everything on the dialog"/>
			<comm cntt="an ObfTree occupies the left side of the split pane"/>
			<comm cntt="the right side of the split pane is a box in a panel"/>
			<comm cntt="this box holds all the widgets in the right pane"/>
			<comm cntt="top right corner -- tells the user what object is being edited"/>
			<comm cntt="little decorative horizontal rule is done by a bordered panel"/>
			<comm cntt="the &amp;quot;obfuscation&amp;quot; slider"/>
			<comm cntt="the &amp;quot;multithreaded&amp;quot; and &amp;quot;reflection&amp;quot; checkboxes lie in a panel"/>
			<comm cntt="the &amp;quot;performance critical&amp;quot; slider"/>
			<comm cntt="the &amp;quot;advanced options&amp;quot; checkbox"/>
			<comm cntt="the list of specific obfuscations is a table in a scroll pane"/>
			<comm cntt="and here&amp;apos;s the table (ObfListModel is an inner class)"/>
			<comm cntt="for some reason this guy needs to get called on every update()"/>
			<comm cntt="the OK and Cancel buttons at the bottom lie in their own panel"/>
			<comm cntt="a strut is a fixed-size spacer component for a box or a panel"/>
			<comm cntt="table model for the list of obfuscations"/>
			<comm cntt="called when the &amp;quot;reflection&amp;quot; checkbox changes"/>
			<comm cntt="called when the &amp;quot;multithreaded&amp;quot; checkbox changes"/>
			<comm cntt="called when OK is clicked"/>
			<comm cntt="called when &amp;quot;advanced&amp;quot; is clicked"/>
			<comm cntt="update the widgets in the right pane of the"/>
			<comm cntt="dialog with info about a newly selected object"/>
			<const name="TITLE" access="priv" jdoc=""/>
			<const name="WINDOW_SIZE" access="priv" jdoc=""/>
			<const name="MIN_LEFT_PANE_WIDTH" access="priv" jdoc=""/>
			<const name="MIN_RIGHT_PANE_WIDTH" access="priv" jdoc=""/>
			<const name="DIVIDER_LOCATION" access="priv" jdoc=""/>
			<const name="MIN_HEIGHT_FOR_ADV" access="priv" jdoc=""/>
			<const name="PREF_HEIGHT_FOR_ADV" access="priv" jdoc=""/>
			<const name="CHECK_BOX_WIDTH" access="priv" jdoc=""/>
			<field name="m_splitPane" access="priv" jdoc=""/>
			<field name="m_tree" access="priv" jdoc=""/>
			<field name="m_lblTitle" access="priv" jdoc=""/>
			<field name="m_obfSlider" access="priv" jdoc=""/>
			<field name="m_chkThread" access="priv" jdoc=""/>
			<field name="m_chkReflect" access="priv" jdoc=""/>
			<field name="m_perfSlider" access="priv" jdoc=""/>
			<field name="m_advCheck" access="priv" jdoc=""/>
			<field name="m_obfList" access="priv" jdoc=""/>
			<field name="m_table" access="priv" jdoc=""/>
			<field name="m_btnOK" access="priv" jdoc=""/>
			<field name="m_btnCancel" access="priv" jdoc=""/>
			<field name="m_obfModel" access="priv" jdoc=""/>
			<field name="mCachedConstraints" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.ObfDialog.ObfDialog(javax.swing.JFrame, sandmark.program.Application)" access="pub" jdoc="Constructs a new ObfDialog with the given parent and jar file. @param parent The parent frame. @param app The application we&amp;apos;re configuring">
				<param name="parent"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkSplitPane(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkLeft(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkRight()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkBox()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkLabel()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkRule()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkObfSlider()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkCheckboxes()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkPerfSlider()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkAdvCheck()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkObfList()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkTable()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.fixCheckBoxColWidth()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.mkButtons()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.strut(boolean, int)" access="priv" jdoc="">
				<param name="vertical"/>
				<param name="size"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="Handle user manipulation of JButtons and JCheckBoxes. @param evt The event parameters.">
				<param name="evt"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.refl()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.thread()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.onOK()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.onAdvClick()" access="priv" jdoc="">
				<comm cntt="if the window isn&amp;apos;t big enough, make it bigger"/>
				<comm cntt="rearrange and repaint the window"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.stateChanged(javax.swing.event.ChangeEvent)" access="pub" jdoc="Called when a slider is slid. @param evt The event parameters.">
				<param name="evt"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.valueChanged(javax.swing.event.TreeSelectionEvent)" access="pub" jdoc="Called when a new object in the tree is selected. @param evt The event parameters.">
				<param name="evt"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog.update()" access="priv" jdoc="">
				<comm cntt="the path through the tree from root to current selection"/>
				<comm cntt="nothing selected"/>
				<comm cntt="update obfuscation list"/>
				<comm cntt="if you don&amp;apos;t put a space at the end the last letter"/>
				<comm cntt="gets slightly cut off because of the italic font :("/>
				<comm cntt="for some reason JTable likes to reset the column widths"/>
				<comm cntt="every time the model changes, so this needs to be called"/>
				<comm cntt="on each update()"/>
			</mth>
		<class name="/:sandmark.gui.ObfDialog$ObfListModel" intfc="n" abs="n" inn="y" sloc="60" jdoc="">
			<comm cntt="one row for every obfuscation"/>
			<comm cntt="two columns: one for a check box and one for the name"/>
			<comm cntt="check boxes are Booleans, names are Strings"/>
			<comm cntt="only column zero (the checkboxes) is editable"/>
			<comm cntt="called by update()... new table data"/>
			<field name="applicableAlgShortNames" access="priv" jdoc=""/>
			<field name="constraints" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.ObfDialog$ObfListModel.ObfListModel(sandmark.program.Object, sandmark.program.UserObjectConstraints)" access="pub" jdoc="">
				<param name="o"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog$ObfListModel.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog$ObfListModel.getColumnCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog$ObfListModel.getColumnClass(int)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog$ObfListModel.getValueAt(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog$ObfListModel.setValueAt(Object, int, int)" access="pub" jdoc="">
				<param name="val"/>
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog$ObfListModel.isCellEditable(int, int)" access="pub" jdoc="">
				<param name="row"/>
				<param name="col"/>
			</mth>
			<mth name="/:sandmark.gui.ObfDialog$ObfListModel.fireChange()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ObfDialog$ObfListModel.findApplicableAlgs(sandmark.program.Object)" access="priv" jdoc="">
				<param name="object"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.OptimisePanel" intfc="n" abs="n" inn="n" sloc="218" jdoc="">
			<comm cntt="Describe what optimization is."/>
			<field name="mInsetPanel" access="priv" jdoc=""/>
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mCPPConstraints" access="priv" jdoc=""/>
			<field name="mComboBox" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mGraphButton" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<field name="mDescription" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.OptimisePanel.OptimisePanel(SandMarkFrame)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;]]] &amp;quot; + sandmark.util.classloading.IClassFinder.GEN_OPTIMIZER);"/>
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.buildInsetPanel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.getApplication()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.getFrame()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.showDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.showTransientDescription(String)" access="pub" jdoc="">
				<param name="description"/>
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.algorithmChanged(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the About page for Optimise @return HTML code for the about page">
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.getHelpURL()" access="pub" jdoc="Get the URL of the Help page for Optimise @return url for the help page">
			</mth>
			<mth name="/:sandmark.gui.OptimisePanel.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.DynamicBirthmarkPanel" intfc="n" abs="n" inn="n" sloc="183" jdoc="">
			<field name="mInsetPanel" access="priv" jdoc=""/>
			<field name="percentSim" access="priv" jdoc=""/>
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mCPPConstraints" access="priv" jdoc=""/>
			<field name="mComboBox" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<field name="mDescription" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.DynamicBirthmarkPanel(SandMarkFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.buildInsetPanel()" access="pub" jdoc="">
				<comm cntt="javax.swing.JButton configureButton = new javax.swing.JButton(&amp;quot;Configure&amp;quot;); configureButton.setBackground(SAND_COLOR); configureButton.setForeground(DARK_SAND_COLOR); configureButton.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent e) { ((javax.swing.JButton)e.getSource()).setEnabled(false); try { mCPP.updateProperties(); if(getApplication() == null) { sandmark.util.Log.message(0,&amp;quot;Invalid application&amp;quot;); return; } sandmark.gui.ObfDialog obd = new sandmark.gui.ObfDialog (mFrame,getApplication()); obd.show(); } catch(java.io.IOException ex) { sandmark.util.Log.message(0,&amp;quot;Bad file name: &amp;quot; + ex); } catch(Exception ex) { ex.printStackTrace(); sandmark.util.Log.message(0,&amp;quot;Unexpected error: &amp;quot; + ex); } finally { ((javax.swing.JButton)e.getSource()).setEnabled(true); } } });"/>
				<comm cntt="}"/>
				<comm cntt="sandmark.obfuscate.Obfuscator.runObfuscation"/>
				<comm cntt="(getApplication(),mComboBox.getCurrentAlgorithm());"/>
				<comm cntt="getApplication().save(mConfigProps.getProperty(&amp;quot;Output File&amp;quot;));"/>
				<comm cntt="javax.swing.JLabel percentLabel = new javax.swing.JLabel( &amp;quot;Percent Similarity:&amp;quot;); percentLabel.setForeground(DARK_SAND_COLOR); gbc.gridx = 1; gbc.weightx = 1; gbc.gridwidth = 1; gbc.fill = java.awt.GridBagConstraints.BOTH; layout.setConstraints(percentLabel,gbc); mInsetPanel.add(percentLabel);"/>
				<comm cntt="javax.swing.JTextField"/>
				<comm cntt="gbc.anchor = java.awt.GridBagConstraints.SOUTHWEST;"/>
				<comm cntt="mGraphButton = new GraphDisplayButton(mFrame); mGraphButton.setVisible(false); gbc.gridx = 2; gbc.weightx = 0; gbc.anchor = java.awt.GridBagConstraints.SOUTHEAST; layout.setConstraints(mGraphButton, gbc); mInsetPanel.add(mGraphButton); gbc.gridx = 3; gbc.anchor = java.awt.GridBagConstraints.SOUTHEAST; layout.setConstraints(configureButton,gbc); mInsetPanel.add(configureButton);"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<comm cntt="mCPP = new ConfigPropertyPanel(alg.getConfigProperties());"/>
				<comm cntt="((java.awt.GridBagLayout)mInsetPanel.getLayout()).setConstraints(mCPP,mCPPConstraints);"/>
				<comm cntt="if(alg instanceof sandmark.birthmark.DynamicBirthmark){"/>
				<comm cntt="System.out.println(&amp;quot;extra props&amp;quot;);"/>
				<comm cntt="extraProps = mClassConfigProps;"/>
				<comm cntt="}"/>
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<comm cntt="String inputFile = sandmark.Console.getConfigProperties().getProperty"/>
				<comm cntt="(&amp;quot;Input File&amp;quot;);"/>
				<param name="cp"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.getApplication()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.getFrame()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.showDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.showTransientDescription(String)" access="pub" jdoc="">
				<param name="description"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.algorithmChanged(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicBirthmarkPanel.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.ClassViewPanel" intfc="n" abs="n" inn="n" sloc="59" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.gui.ClassViewPanel.ClassViewPanel(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.gui.ClassViewPanel.tearDown()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ClassViewPanel.saveViewState()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ClassViewPanel.restoreViewState(Object)" access="pub" jdoc="">
				<param name="v"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.SMAlgHierTreeNode" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<field name="mName" access="priv" jdoc=""/>
			<field name="mHelpURL" access="priv" jdoc=""/>
			<field name="mPropPanel" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.SMAlgHierTreeNode.SMAlgHierTreeNode(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="helpURL"/>
			</mth>
			<mth name="/:sandmark.gui.SMAlgHierTreeNode.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SMAlgHierTreeNode.helpURL()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.StaticWatermarkPanel" intfc="n" abs="n" inn="n" sloc="76" jdoc="">
			<field name="mInsetPanel" access="priv" jdoc=""/>
			<field name="mEmbedPanel" access="priv" jdoc=""/>
			<field name="mRecognizePanel" access="priv" jdoc=""/>
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mComboBox" access="priv" jdoc=""/>
			<field name="mDescription" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.StaticWatermarkPanel.StaticWatermarkPanel(SandMarkFrame)" access="pub" jdoc="">
				<comm cntt="mInsetPanel.setBorder"/>
				<comm cntt="(javax.swing.BorderFactory.createCompoundBorder"/>
				<comm cntt="(javax.swing.BorderFactory.createRaisedBevelBorder(),"/>
				<comm cntt="javax.swing.BorderFactory.createLoweredBevelBorder()));"/>
				<comm cntt="Static ComboBox"/>
				<comm cntt="Static labels"/>
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.StaticWatermarkPanel.getCurrentAlgorithm()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticWatermarkPanel.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.StaticWatermarkPanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticWatermarkPanel.getFrame()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticWatermarkPanel.showDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticWatermarkPanel.showTransientDescription(String)" access="pub" jdoc="">
				<param name="description"/>
			</mth>
			<mth name="/:sandmark.gui.StaticWatermarkPanel.algorithmChanged(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.VSplitPanel" intfc="n" abs="n" inn="n" sloc="137" jdoc="">
			<field name="mSplitPane" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.VSplitPanel.VSplitPanel(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="LogPane must be constructed before APpViewPanel because AVP"/>
				<comm cntt="issues a warning. see bug 185"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.gui.VSplitPanel.buildSortPanel(AppTree, sandmark.metric.Metric[])" access="priv" jdoc="">
				<param name="tree"/>
				<param name="metrics"/>
			</mth>
			<mth name="/:sandmark.gui.VSplitPanel.getSandMarkViewPanel(SandMarkFrame)" access="pub" jdoc="">
				<param name="smf"/>
			</mth>
			<mth name="/:sandmark.gui.VSplitPanel.updateViewPanel(javax.swing.JTree, javax.swing.JPanel)" access="priv" jdoc="">
				<param name="tree"/>
				<param name="selectedTab"/>
			</mth>
		<class name="/:sandmark.gui.VSplitPanel$SortPanel" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<field name="panel" access="pub" jdoc=""/>
			<field name="metrics" access="pub" jdoc=""/>
			<field name="ops" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.VSplitPanel$SortPanel.SortPanel(javax.swing.JPanel, javax.swing.JComboBox, javax.swing.JComboBox)" access="pub" jdoc="">
				<param name="p"/>
				<param name="m"/>
				<param name="o"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.SandMarkViewPanel" intfc="n" abs="n" inn="n" sloc="68" jdoc="">
			<field name="mySandMarkFrame" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.SandMarkViewPanel.SandMarkViewPanel(SandMarkFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.SandMarkViewPanel.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="ev"/>
			</mth>
			<mth name="/:sandmark.gui.SandMarkViewPanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SandMarkViewPanel.getFrame()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.AlgorithmPanel" intfc="y" abs="n" inn="n" sloc="6" jdoc="">
			<mth name="/:sandmark.gui.AlgorithmPanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AlgorithmPanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.AlgorithmPanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AlgorithmPanel.getApplication()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.SMarkGUIConstants" intfc="y" abs="n" inn="n" sloc="75" jdoc="">
			<const name="TRACE_BUTTON_X" access="pub" jdoc=""/>
			<const name="TRACE_BUTTON_Y" access="pub" jdoc=""/>
			<const name="EMBED_BUTTON_X" access="pub" jdoc=""/>
			<const name="EMBED_BUTTON_Y" access="pub" jdoc=""/>
			<const name="START_BUTTON_X" access="pub" jdoc=""/>
			<const name="START_BUTTON_Y" access="pub" jdoc=""/>
			<const name="DONE_BUTTON_X" access="pub" jdoc=""/>
			<const name="DONE_BUTTON_Y" access="pub" jdoc=""/>
			<const name="RECOGNIZE_BUTTON_X" access="pub" jdoc=""/>
			<const name="RECOGNIZE_BUTTON_Y" access="pub" jdoc=""/>
			<const name="BROWSE_BUTTON_X" access="pub" jdoc=""/>
			<const name="BROWSE_BUTTON_Y" access="pub" jdoc=""/>
			<const name="RANDOM_BUTTON_X" access="pub" jdoc=""/>
			<const name="RANDOM_BUTTON_Y" access="pub" jdoc=""/>
			<const name="CONFIGURE_BUTTON_X" access="pub" jdoc=""/>
			<const name="CONFIGURE_BUTTON_Y" access="pub" jdoc=""/>
			<const name="NEXT_BUTTON_X" access="pub" jdoc=""/>
			<const name="NEXT_BUTTON_Y" access="pub" jdoc=""/>
			<const name="OBFUSCATE_BUTTON_X" access="pub" jdoc=""/>
			<const name="OBFUSCATE_BUTTON_Y" access="pub" jdoc=""/>
			<const name="OPTIMIZE_BUTTON_X" access="pub" jdoc=""/>
			<const name="OPTIMIZE_BUTTON_Y" access="pub" jdoc=""/>
			<const name="DECOMPILE_BUTTON_X" access="pub" jdoc=""/>
			<const name="DECOMPILE_BUTTON_Y" access="pub" jdoc=""/>
			<const name="DIFF_BUTTON_X" access="pub" jdoc=""/>
			<const name="DIFF_BUTTON_Y" access="pub" jdoc=""/>
			<const name="STATISTICS_BUTTON_X" access="pub" jdoc=""/>
			<const name="STATISTICS_BUTTON_Y" access="pub" jdoc=""/>
			<const name="VIEW_BUTTON_X" access="pub" jdoc=""/>
			<const name="VIEW_BUTTON_Y" access="pub" jdoc=""/>
			<const name="VISUALIZE_BUTTON_X" access="pub" jdoc=""/>
			<const name="VISUALIZE_BUTTON_Y" access="pub" jdoc=""/>
			<const name="COLS20" access="pub" jdoc=""/>
			<const name="COLS30" access="pub" jdoc=""/>
			<const name="ROWS1" access="pub" jdoc=""/>
			<const name="ROWS6" access="pub" jdoc=""/>
			<const name="TEXTAREA_X" access="pub" jdoc=""/>
			<const name="TEXTAREA_Y" access="pub" jdoc=""/>
			<const name="ALGORITHM_LABEL_X" access="pub" jdoc=""/>
			<const name="ALGORITHM_LABEL_Y" access="pub" jdoc=""/>
			<const name="JARFILE_LABEL_X" access="pub" jdoc=""/>
			<const name="JARFILE_LABEL_Y" access="pub" jdoc=""/>
			<const name="KEY_LABEL_X" access="pub" jdoc=""/>
			<const name="KEY_LABEL_Y" access="pub" jdoc=""/>
			<const name="OBFUSCATED_LABEL_X" access="pub" jdoc=""/>
			<const name="OBFUSCATED_LABEL_Y" access="pub" jdoc=""/>
			<const name="OPTIMIZED_LABEL_X" access="pub" jdoc=""/>
			<const name="OPTIMIZED_LABEL_Y" access="pub" jdoc=""/>
			<const name="DECOMPILE_LABEL_X" access="pub" jdoc=""/>
			<const name="DECOMPILE_LABEL_Y" access="pub" jdoc=""/>
			<const name="DIFF_LABEL_X" access="pub" jdoc=""/>
			<const name="DIFF_LABEL_Y" access="pub" jdoc=""/>
			<const name="WATERMARKS_LABEL_X" access="pub" jdoc=""/>
			<const name="WATERMARKS_LABEL_Y" access="pub" jdoc=""/>
			<const name="ARGUMENTS_LABEL_X" access="pub" jdoc=""/>
			<const name="ARGUMENTS_LABEL_Y" access="pub" jdoc=""/>
			<const name="MAIN_LABEL_X" access="pub" jdoc=""/>
			<const name="MAIN_LABEL_Y" access="pub" jdoc=""/>
			<const name="CLASSPATH_LABEL_X" access="pub" jdoc=""/>
			<const name="CLASSPATH_LABEL_Y" access="pub" jdoc=""/>
			<const name="RECOGNIZE_LABEL_X" access="pub" jdoc=""/>
			<const name="RECOGNIZE_LABEL_Y" access="pub" jdoc=""/>
			<const name="TRACEFILE_LABEL_X" access="pub" jdoc=""/>
			<const name="TRACEFILE_LABEL_Y" access="pub" jdoc=""/>
			<const name="TRACE_LABEL_X" access="pub" jdoc=""/>
			<const name="TRACE_LABEL_Y" access="pub" jdoc=""/>
			<const name="WMARKJAR_LABEL_X" access="pub" jdoc=""/>
			<const name="WMARKJAR_LABEL_Y" access="pub" jdoc=""/>
			<const name="WMARKVALUE_LABEL_X" access="pub" jdoc=""/>
			<const name="WMARKVALUE_LABEL_Y" access="pub" jdoc=""/>
			<const name="EMBED_LABEL_X" access="pub" jdoc=""/>
			<const name="EMBED_LABEL_Y" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.gui.CopyrightDialog" intfc="n" abs="n" inn="n" sloc="56" jdoc="">
			<const name="windowSize" access="priv" jdoc=""/>
			<field name="editorPane" access="priv" jdoc=""/>
			<const name="COPYRIGHT_PAGE" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.CopyrightDialog.CopyrightDialog(javax.swing.JFrame)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/:sandmark.gui.CopyrightDialog.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.CopyrightDialog.hyperlinkUpdate(javax.swing.event.HyperlinkEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.CopyrightDialog.gotoLink(javax.swing.event.HyperlinkEvent)" access="priv" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.WebBrowser" intfc="n" abs="n" inn="n" sloc="246" jdoc="">
			<comm cntt="Make the URLs"/>
			<comm cntt="Processes button clicks and text field events in this frame."/>
			<comm cntt="Processes hyperlink clicks in this frame."/>
			<comm cntt="(Try to) go to the page with the given textually represented URL"/>
			<comm cntt="Creates the menus"/>
			<comm cntt="Adds a new JMenuItem. Convenience method."/>
			<comm cntt="Adds a new JMenuItem. Convenience method."/>
			<comm cntt="Adds a new JMenuItem. Convenience method."/>
			<comm cntt="Adds a new JMenuItem. Convenience method."/>
			<comm cntt="Adds a new JMenuItem. Convenience method."/>
			<comm cntt="Adds a new JMenuItem. Convenience method."/>
			<field name="DEFAULT_HOME_URL" access="pub" jdoc=""/>
			<field name="DEFAULT_SEARCH_URL" access="pub" jdoc=""/>
			<field name="m_sParent" access="priv" jdoc=""/>
			<field name="m_jep" access="priv" jdoc=""/>
			<field name="m_jcbLocation" access="priv" jdoc=""/>
			<field name="m_jlStatus" access="priv" jdoc=""/>
			<field name="m_jmBack" access="priv" jdoc=""/>
			<field name="m_jmForward" access="priv" jdoc=""/>
			<field name="m_sHome" access="priv" jdoc=""/>
			<field name="m_sSearch" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.WebBrowser.WebBrowser()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.WebBrowser(java.lang.String)" access="pub" jdoc="">
				<param name="home"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.WebBrowser(java.lang.String, javax.swing.JFrame)" access="pub" jdoc="">
				<param name="home"/>
				<param name="parent"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.WebBrowser(java.lang.String, java.lang.String, javax.swing.JFrame)" access="pub" jdoc="">
				<comm cntt="Construct GUI components"/>
				<comm cntt="event listeners"/>
				<comm cntt="go to home page"/>
				<param name="home"/>
				<param name="search"/>
				<param name="parent"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<comm cntt="trim(m_jcbLocation.getSelectedIndex());"/>
				<param name="event"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.hyperlinkUpdate(javax.swing.event.HyperlinkEvent)" access="pub" jdoc="">
				<comm cntt="an event in a page with frames; must be handled differently"/>
				<comm cntt="any other web page event"/>
				<param name="event"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.addButton(java.lang.String, java.awt.Container)" access="priv" jdoc="">
				<param name="text"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.addPage(java.lang.String)" access="priv" jdoc="">
				<comm cntt="m_jcbLocation.removeActionListener(this);"/>
				<comm cntt="m_jcbLocation.addActionListener(this);"/>
				<param name="text"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.trim(int)" access="priv" jdoc="">
				<param name="ii"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.canGoBack()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.canGoForward()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.enableStuff()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.goToPage(java.lang.String)" access="priv" jdoc="">
				<comm cntt="new RuntimeException().printStackTrace();"/>
				<comm cntt="System.out.println(&amp;quot;goToPage(): null text&amp;quot;);"/>
				<param name="text"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.createBar()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.addItem(javax.swing.JMenu, java.lang.String)" access="priv" jdoc="">
				<param name="menu"/>
				<param name="text"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.addItem(javax.swing.JMenu, java.lang.String, int)" access="priv" jdoc="">
				<param name="menu"/>
				<param name="text"/>
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.addItem(javax.swing.JMenu, java.lang.String, java.lang.String, int)" access="priv" jdoc="">
				<param name="menu"/>
				<param name="text"/>
				<param name="icon"/>
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.addItem(javax.swing.JMenu, java.lang.String, java.lang.String, int, javax.swing.KeyStroke)" access="priv" jdoc="">
				<param name="menu"/>
				<param name="text"/>
				<param name="icon"/>
				<param name="m"/>
				<param name="accel"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.addCheckItem(javax.swing.JMenu, java.lang.String, java.lang.String, int, boolean)" access="priv" jdoc="">
				<param name="menu"/>
				<param name="text"/>
				<param name="icon"/>
				<param name="m"/>
				<param name="sel"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.addCheckItem(javax.swing.JMenu, java.lang.String, java.lang.String, int, boolean, javax.swing.KeyStroke)" access="priv" jdoc="">
				<param name="menu"/>
				<param name="text"/>
				<param name="icon"/>
				<param name="m"/>
				<param name="sel"/>
				<param name="accel"/>
			</mth>
			<mth name="/:sandmark.gui.WebBrowser.setupItem(javax.swing.JMenuItem, javax.swing.JMenu, java.lang.String, int, javax.swing.KeyStroke)" access="priv" jdoc="">
				<param name="item"/>
				<param name="menu"/>
				<param name="icon"/>
				<param name="m"/>
				<param name="accel"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.JHoverButton" intfc="n" abs="n" inn="n" sloc="86" jdoc="">
			<field name="myOffIcon" access="priv" jdoc=""/>
			<field name="myOnIcon" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.JHoverButton.JHoverButton()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.JHoverButton(javax.swing.Action)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.JHoverButton(javax.swing.Icon)" access="pub" jdoc="">
				<param name="icon"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.JHoverButton(java.lang.String)" access="pub" jdoc="">
				<param name="text"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.JHoverButton(java.lang.String, javax.swing.Icon)" access="pub" jdoc="">
				<param name="text"/>
				<param name="icon"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.JHoverButton(javax.swing.Icon, javax.swing.Icon)" access="pub" jdoc="">
				<param name="offIcon"/>
				<param name="onIcon"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.JHoverButton(java.lang.String, javax.swing.Icon, javax.swing.Icon)" access="pub" jdoc="">
				<param name="text"/>
				<param name="offIcon"/>
				<param name="onIcon"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.JHoverButton(javax.swing.Icon, java.lang.String)" access="pub" jdoc="">
				<param name="icon"/>
				<param name="actionCommand"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.JHoverButton(javax.swing.Icon, javax.swing.Icon, java.lang.String)" access="pub" jdoc="">
				<param name="offIcon"/>
				<param name="onIcon"/>
				<param name="actionCommand"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.setEnabled(boolean)" access="pub" jdoc="">
				<comm cntt="make sure hover doesn&amp;apos;t take effect stay on for a disabled button"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.mouseClicked(java.awt.event.MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.mousePressed(java.awt.event.MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.mouseReleased(java.awt.event.MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.mouseEntered(java.awt.event.MouseEvent)" access="pub" jdoc="">
				<comm cntt="show border (&amp;quot;hover&amp;quot; effect) when mouse is over"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.mouseExited(java.awt.event.MouseEvent)" access="pub" jdoc="">
				<comm cntt="turn off &amp;quot;hover&amp;quot; effect when mouse leaves"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.JHoverButton.init()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.SkinPanel" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<field name="image" access="priv" jdoc=""/>
			<field name="imgWidth" access="priv" jdoc=""/>
			<field name="imgHeight" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.SkinPanel.SkinPanel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SkinPanel.paintComponent(java.awt.Graphics)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.SandMarkGUIConstants" intfc="y" abs="n" inn="n" sloc="48" jdoc="">
			<const name="ROOT_PATH" access="pub" jdoc=""/>
			<const name="LOGO_IMAGE" access="pub" jdoc=""/>
			<const name="SMALL_LOGO_IMAGE" access="pub" jdoc=""/>
			<const name="SAND_COLOR" access="pub" jdoc=""/>
			<const name="DARK_SAND_COLOR" access="pub" jdoc=""/>
			<const name="_12_CHARS_WIDE" access="pub" jdoc=""/>
			<const name="NS_PANEL_DIMS" access="pub" jdoc=""/>
			<const name="W_PANEL_DIMS" access="pub" jdoc=""/>
			<const name="METHOD_DIALOG_DIMS" access="pub" jdoc=""/>
			<const name="CLASS_DIALOG_DIMS" access="pub" jdoc=""/>
			<const name="PACKAGE_DIALOG_DIMS" access="pub" jdoc=""/>
			<const name="NO_OBFUSCATION" access="pub" jdoc=""/>
			<const name="HALF_OBFUSCATION" access="pub" jdoc=""/>
			<const name="FULL_OBFUSCATION" access="pub" jdoc=""/>
			<const name="TITLE" access="pub" jdoc=""/>
			<const name="SAND_IMAGE" access="pub" jdoc=""/>
			<const name="JDIALOG_OFFSET" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_0" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_1" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_2" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_3" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_4" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_5" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_6" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_7" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_8" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_9" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_10" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_11" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_12" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_13" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_14" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_15" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_16" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_17" access="pub" jdoc=""/>
			<const name="CLASS_STAT_DIALOG_WIDTH_18" access="pub" jdoc=""/>
			<const name="METHOD_STAT_DIALOG_WIDTH_0" access="pub" jdoc=""/>
			<const name="METHOD_STAT_DIALOG_WIDTH_1" access="pub" jdoc=""/>
			<const name="METHOD_STAT_DIALOG_WIDTH_2" access="pub" jdoc=""/>
			<const name="METHOD_STAT_DIALOG_WIDTH_3" access="pub" jdoc=""/>
			<const name="METHOD_STAT_DIALOG_WIDTH_4" access="pub" jdoc=""/>
			<const name="METHOD_STAT_DIALOG_WIDTH_5" access="pub" jdoc=""/>
			<const name="METHOD_STAT_DIALOG_WIDTH_6" access="pub" jdoc=""/>
			<const name="PACKAGE_STAT_DIALOG_WIDTH_0" access="pub" jdoc=""/>
			<const name="PACKAGE" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.gui.HomePanel" intfc="n" abs="n" inn="n" sloc="84" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.HomePanel.HomePanel(SandMarkFrame)" access="pub" jdoc="">
				<comm cntt="editorPane.setAlignmentY(java.awt.Component.LEFT_ALIGNMENT);"/>
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.HomePanel.getPreferredSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.HomePanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.HomePanel.getFrame()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.DecompileDialog" intfc="n" abs="n" inn="n" sloc="42" jdoc="This dialog pops up when the user clicks on Decompile button in the Decompile pane. It shows the source code of the decompiled jar file. @author Andrzej Pawlowski">
			<const name="WINDOW_SIZE" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<field name="closeButton" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.DecompileDialog.DecompileDialog(javax.swing.JFrame, String)" access="pub" jdoc="">
				<comm cntt="textArea displays the decompiled file"/>
				<comm cntt="Christian does not want the background color behind the code to be sand"/>
				<comm cntt="color."/>
				<comm cntt="textArea.setBackground(SAND_COLOR);"/>
				<comm cntt="buttonPanel containing the close button"/>
				<comm cntt="contentPane.setBackground(SAND_COLOR);"/>
				<param name="parent"/>
				<param name="text"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.RecognizeButton" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<field name="mPanel" access="priv" jdoc=""/>
			<field name="mButton" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.RecognizeButton.RecognizeButton(AlgorithmPanel, NextWMButton)" access="pub" jdoc="">
				<param name="panel"/>
				<param name="button"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.LogPane" intfc="n" abs="n" inn="n" sloc="14" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="MAX_BUFFER_LENGTH" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.LogPane.LogPane()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.gui.LogPane$LogWriter" intfc="n" abs="n" inn="y" sloc="23" jdoc="">
			<field name="mArea" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.LogPane$LogWriter.LogWriter(javax.swing.JTextArea)" access="pub" jdoc="">
				<param name="area"/>
			</mth>
			<mth name="/:sandmark.gui.LogPane$LogWriter.write(String)" access="pub" jdoc="">
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.gui.LogPane$LogWriter.write(String, int, int)" access="pub" jdoc="">
				<param name="str"/>
				<param name="offset"/>
				<param name="length"/>
			</mth>
			<mth name="/:sandmark.gui.LogPane$LogWriter.write(char, int, int)" access="pub" jdoc="">
				<param name="buf"/>
				<param name="offset"/>
				<param name="length"/>
			</mth>
			<mth name="/:sandmark.gui.LogPane$LogWriter.close()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.LogPane$LogWriter.flush()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.AlgorithmComboBox" intfc="n" abs="n" inn="n" sloc="74" jdoc="">
			<field name="listeners" access="priv" jdoc=""/>
			<field name="lastSelection" access="priv" jdoc=""/>
			<field name="mListener" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.AlgorithmComboBox.AlgorithmComboBox(DescriptionListener, int)" access="pub" jdoc="">
				<comm cntt="I guess it really isn&amp;apos;t a class, so don&amp;apos;t let the user select it"/>
				<comm cntt="I guess it really isn&amp;apos;t a class, so don&amp;apos;t let the user select it"/>
				<comm cntt="I guess it really isn&amp;apos;t a class, so don&amp;apos;t let the user select it"/>
				<param name="listener"/>
				<param name="algType"/>
			</mth>
			<mth name="/:sandmark.gui.AlgorithmComboBox.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AlgorithmComboBox.addListener(AlgorithmPanel)" access="pub" jdoc="">
				<param name="panel"/>
			</mth>
			<mth name="/:sandmark.gui.AlgorithmComboBox.removeListener(AlgorithmPanel)" access="pub" jdoc="">
				<param name="panel"/>
			</mth>
			<mth name="/:sandmark.gui.AlgorithmComboBox.popupMenuCanceled(javax.swing.event.PopupMenuEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.AlgorithmComboBox.popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.AlgorithmComboBox.popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		<class name="/:sandmark.gui.AlgorithmComboBox$DescriptionListener" intfc="y" abs="n" inn="y" sloc="5" jdoc="">
			<mth name="/:sandmark.gui.AlgorithmComboBox$DescriptionListener.showTransientDescription(String)" access="pub" jdoc="">
				<param name="description"/>
			</mth>
			<mth name="/:sandmark.gui.AlgorithmComboBox$DescriptionListener.showDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AlgorithmComboBox$DescriptionListener.algorithmChanged(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.AlgorithmComboBox$MyComboBoxRenderer" intfc="n" abs="n" inn="y" sloc="12" jdoc="">
			<mth name="/:sandmark.gui.AlgorithmComboBox$MyComboBoxRenderer.getListCellRendererComponent(javax.swing.JList, Object, int, boolean, boolean)" access="pub" jdoc="">
				<param name="list"/>
				<param name="value"/>
				<param name="index"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.DynamicRecognizeButton" intfc="n" abs="n" inn="n" sloc="64" jdoc="">
			<field name="mPanel" access="priv" jdoc=""/>
			<field name="mButton" access="priv" jdoc=""/>
			<field name="mFrame" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.DynamicRecognizeButton.DynamicRecognizeButton(AlgorithmPanel, NextWMButton, SandMarkFrame)" access="pub" jdoc="">
				<param name="panel"/>
				<param name="button"/>
				<param name="frame"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.DecompilePanel" intfc="n" abs="n" inn="n" sloc="73" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.DecompilePanel.DecompilePanel(SandMarkFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.DecompilePanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DecompilePanel.getFrame()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.DynamicEmbedPanel" intfc="n" abs="n" inn="n" sloc="115" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mPanel" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mCPPConstraints" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mGraphButton" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.DynamicEmbedPanel.DynamicEmbedPanel(SandMarkFrame, DynamicWatermarkPanel)" access="pub" jdoc="">
				<param name="frame"/>
				<param name="panel"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicEmbedPanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicEmbedPanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicEmbedPanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicEmbedPanel.getApplication()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.ClassSorter" intfc="n" abs="n" inn="n" sloc="21" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="mTree" access="priv" jdoc=""/>
			<field name="mSelector" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.ClassSorter.ClassSorter(AppTree, javax.swing.JComboBox)" access="pub" jdoc="">
				<param name="tree"/>
				<param name="metricSelector"/>
			</mth>
			<mth name="/:sandmark.gui.ClassSorter.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		<class name="/:sandmark.gui.ClassSorter$ReverseComparator" intfc="n" abs="n" inn="y" sloc="5" jdoc="">
			<field name="mComp" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.ClassSorter$ReverseComparator.ReverseComparator(java.util.Comparator)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/:sandmark.gui.ClassSorter$ReverseComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.ConfigPropertyPanel" intfc="n" abs="n" inn="n" sloc="88" jdoc="A ConfigPropertyPanel lays out the properties of a ConfigProperties object using widgets appropriate for the types of the properties. A ConfigPropertyPanel can be constructed with a phaseMask that will be used to determine whether a property should be displayed. If phaseMask &amp; getPhases(property) != 0, property will be included in the ConfigPropertyPanel. By default, phaseMask == ~(0L), so all properties are displayed. A ConfigPropertyPanel observes changes to properties it displays, so changes to properties are automatically reflected in the widget contents. A ConfigPropertyPanel reflects the contents of its widgets into the ConfigProperties object only when updateProperties or updateProperty is called. @author Andrew Huntwork &amp;lt;ash@cs.arizona.edu&amp;gt;">
			<field name="DEBUG" access="priv" jdoc=""/>
			<const name="MAX_VISIBLE_ROWS" access="priv" jdoc=""/>
			<field name="mProperties" access="priv" jdoc=""/>
			<field name="mRowNum" access="priv" jdoc=""/>
			<field name="mPanel" access="priv" jdoc=""/>
			<field name="mPanelLayout" access="priv" jdoc=""/>
			<field name="mTracker" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.ConfigPropertyPanel.ConfigPropertyPanel(sandmark.util.ConfigProperties, long, CurrentApplicationTracker)" access="pub" jdoc="">
				<param name="configProps"/>
				<param name="phaseMask"/>
				<param name="tracker"/>
			</mth>
			<mth name="/:sandmark.gui.ConfigPropertyPanel.getPanel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ConfigPropertyPanel.getPanelLayout()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ConfigPropertyPanel.getRowNum()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ConfigPropertyPanel.getTracker()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ConfigPropertyPanel.setUpdating(boolean)" access="priv" jdoc="">
				<param name="updating"/>
			</mth>
			<mth name="/:sandmark.gui.ConfigPropertyPanel.updateProperties()" access="pub" jdoc="Atomically update all properties">
			</mth>
			<mth name="/:sandmark.gui.ConfigPropertyPanel.getToolTip(sandmark.util.ConfigProperties, String)" access="prot" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.FileBrowseButtonEventListener" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="mBox" access="pub" jdoc=""/>
			<field name="mCWD" access="prot" jdoc=""/>
			<mth name="/:sandmark.gui.FileBrowseButtonEventListener.FileBrowseButtonEventListener(FilenameBox)" access="pub" jdoc="">
				<param name="box"/>
			</mth>
			<mth name="/:sandmark.gui.FileBrowseButtonEventListener.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.gui.FileBrowseButtonEventListener.getFilter()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.JarBrowseButtonEventListener" intfc="n" abs="n" inn="n" sloc="8" jdoc="">
			<mth name="/:sandmark.gui.JarBrowseButtonEventListener.JarBrowseButtonEventListener(FilenameBox)" access="pub" jdoc="">
				<param name="box"/>
			</mth>
			<mth name="/:sandmark.gui.JarBrowseButtonEventListener.getFilter()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.PropertyInfo" intfc="n" abs="y" inn="n" sloc="26" jdoc="">
			<field name="updating" access="pub" jdoc=""/>
			<field name="mOrigValue" access="prot" jdoc=""/>
			<field name="mProps" access="prot" jdoc=""/>
			<field name="mPropName" access="prot" jdoc=""/>
			<field name="mCPP" access="prot" jdoc=""/>
			<mth name="/:sandmark.gui.PropertyInfo.PropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.PropertyInfo.updateProperty()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.PropertyInfo.getLabelText(String)" access="prot" jdoc="">
				<param name="propName"/>
			</mth>
			<mth name="/:sandmark.gui.PropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.FieldAndButtonPropertyInfo" intfc="n" abs="y" inn="n" sloc="39" jdoc="">
			<mth name="/:sandmark.gui.FieldAndButtonPropertyInfo.FieldAndButtonPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<comm cntt="fileNameBox.setBackground(SAND_COLOR);"/>
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.FieldAndButtonPropertyInfo.getTextBox(Object)" access="prot" jdoc="">
				<param name="initValue"/>
			</mth>
			<mth name="/:sandmark.gui.FieldAndButtonPropertyInfo.getButtonLabel()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.FieldAndButtonPropertyInfo.getListener()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.FilePropertyInfo" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<field name="mFNB" access="prot" jdoc=""/>
			<mth name="/:sandmark.gui.FilePropertyInfo.FilePropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.FilePropertyInfo.getTextBox(Object)" access="prot" jdoc="">
				<param name="initValue"/>
			</mth>
			<mth name="/:sandmark.gui.FilePropertyInfo.getButtonLabel()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.FilePropertyInfo.getListener()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.FilePropertyInfo.getFileCategory()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.FilePropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.FilePropertyInfo.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;vetoing change of &amp;quot; + propName + &amp;quot;: localValue: &amp;quot; +"/>
				<comm cntt="localValue + &amp;quot; ; mOrigValue: &amp;quot; + mOrigValue);"/>
				<param name="cp"/>
				<param name="propName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.JarPropertyInfo" intfc="n" abs="n" inn="n" sloc="10" jdoc="">
			<mth name="/:sandmark.gui.JarPropertyInfo.JarPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.JarPropertyInfo.getListener()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.JarPropertyInfo.getFileCategory()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.BooleanPropertyInfo" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<field name="mCheckBox" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.BooleanPropertyInfo.BooleanPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.BooleanPropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.BooleanPropertyInfo.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.StringPropertyInfo" intfc="n" abs="n" inn="n" sloc="52" jdoc="">
			<field name="mWidget" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.StringPropertyInfo.StringPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
		<class name="/:sandmark.gui.StringPropertyInfo$Widget" intfc="n" abs="y" inn="y" sloc="5" jdoc="">
			<mth name="/:sandmark.gui.StringPropertyInfo$Widget.setValue(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo$Widget.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo$Widget.getWidget()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.StringPropertyInfo$TextField" intfc="n" abs="n" inn="y" sloc="9" jdoc="">
			<field name="mField" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.StringPropertyInfo$TextField.TextField(javax.swing.JTextField)" access="pub" jdoc="">
				<param name="field"/>
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo$TextField.setValue(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo$TextField.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo$TextField.getWidget()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.StringPropertyInfo$ComboBox" intfc="n" abs="n" inn="y" sloc="19" jdoc="">
			<field name="mBox" access="priv" jdoc=""/>
			<field name="mEditable" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.StringPropertyInfo$ComboBox.ComboBox(javax.swing.JComboBox, boolean)" access="pub" jdoc="">
				<param name="box"/>
				<param name="editable"/>
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo$ComboBox.setValue(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo$ComboBox.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StringPropertyInfo$ComboBox.getWidget()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.IntegerPropertyInfo" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/:sandmark.gui.IntegerPropertyInfo.IntegerPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.IntegerPropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.DoublePropertyInfo" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/:sandmark.gui.DoublePropertyInfo.DoublePropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.DoublePropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.ProgramObjectPropertyInfo" intfc="n" abs="y" inn="n" sloc="64" jdoc="">
			<field name="mTextField" access="pub" jdoc=""/>
			<field name="mObjectTree" access="pub" jdoc=""/>
			<field name="mFrame" access="pub" jdoc=""/>
			<field name="mContainer" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.ProgramObjectPropertyInfo.ProgramObjectPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.ProgramObjectPropertyInfo.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.ProgramObjectPropertyInfo.getListener()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ProgramObjectPropertyInfo.setSelectedObjects(java.util.List)" access="prot" jdoc="">
				<param name="selectedObjects"/>
			</mth>
			<mth name="/:sandmark.gui.ProgramObjectPropertyInfo.getObjectVisibilityMask()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.ClassPropertyInfo" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<field name="mSelectedClasses" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.ClassPropertyInfo.ClassPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.ClassPropertyInfo.getObjectVisibilityMask()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ClassPropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ClassPropertyInfo.getTextBox(Object)" access="pub" jdoc="">
				<param name="initValue"/>
			</mth>
			<mth name="/:sandmark.gui.ClassPropertyInfo.getButtonLabel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.ClassPropertyInfo.setSelectedObjects(java.util.List)" access="prot" jdoc="">
				<param name="selectedObjects"/>
			</mth>
			<mth name="/:sandmark.gui.ClassPropertyInfo.setText()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.MethodPropertyInfo" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<field name="mSelectedMethods" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.MethodPropertyInfo.MethodPropertyInfo(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
			<mth name="/:sandmark.gui.MethodPropertyInfo.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.MethodPropertyInfo.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.MethodPropertyInfo.getTextBox(Object)" access="pub" jdoc="">
				<param name="initValue"/>
			</mth>
			<mth name="/:sandmark.gui.MethodPropertyInfo.getButtonLabel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.MethodPropertyInfo.setSelectedObjects(java.util.List)" access="prot" jdoc="">
				<param name="selectedObjects"/>
			</mth>
			<mth name="/:sandmark.gui.MethodPropertyInfo.getObjectVisibilityMask()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.MethodPropertyInfo.setText()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.PIFactory" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<mth name="/:sandmark.gui.PIFactory.PIFactory()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.PIFactory.createPI(sandmark.util.ConfigProperties, String, ConfigPropertyPanel)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propName"/>
				<param name="cpp"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.LiteHomePanel" intfc="n" abs="n" inn="n" sloc="77" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.LiteHomePanel.LiteHomePanel(SandMarkFrame)" access="pub" jdoc="">
				<comm cntt="editorPane.setAlignmentY(java.awt.Component.LEFT_ALIGNMENT);"/>
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.LiteHomePanel.getPreferredSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.LiteHomePanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.LiteHomePanel.getFrame()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.DynamicWatermarkPanel" intfc="n" abs="n" inn="n" sloc="85" jdoc="">
			<field name="mEmbedPanel" access="priv" jdoc=""/>
			<field name="mTracePanel" access="priv" jdoc=""/>
			<field name="mRecognizePanel" access="priv" jdoc=""/>
			<field name="mInsetPanel" access="priv" jdoc=""/>
			<field name="mComboBox" access="priv" jdoc=""/>
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mDescription" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.DynamicWatermarkPanel.DynamicWatermarkPanel(SandMarkFrame)" access="pub" jdoc="">
				<comm cntt="Dynamic ComboBox"/>
				<comm cntt="Static labels"/>
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicWatermarkPanel.getCurrentAlgorithm()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicWatermarkPanel.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicWatermarkPanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicWatermarkPanel.getFrame()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicWatermarkPanel.showDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.DynamicWatermarkPanel.showTransientDescription(String)" access="pub" jdoc="">
				<param name="description"/>
			</mth>
			<mth name="/:sandmark.gui.DynamicWatermarkPanel.algorithmChanged(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.AppTree" intfc="n" abs="n" inn="n" sloc="77" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<const name="SHOW_APPS" access="pub" jdoc=""/>
			<const name="SHOW_CLASSES" access="pub" jdoc=""/>
			<const name="SHOW_METHODS" access="pub" jdoc=""/>
			<const name="SHOW_FIELDS" access="pub" jdoc=""/>
			<field name="mFlags" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.AppTree.AppTree(java.util.List, int, int)" access="pub" jdoc="">
				<param name="apps"/>
				<param name="flags"/>
				<param name="selectionType"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree.AppTree(sandmark.program.Application, int, int)" access="pub" jdoc="">
				<param name="app"/>
				<param name="flags"/>
				<param name="selectType"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree.saveTreeState()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AppTree.restoreTreeState(Object)" access="pub" jdoc="">
				<param name="state"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree.sortApps(java.util.Comparator)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree.sortClasses(java.util.Comparator)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree.sortMethods(java.util.Comparator)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree.selectNode(sandmark.program.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
		<class name="/:sandmark.gui.AppTree$AppTreeModel" intfc="n" abs="n" inn="y" sloc="136" jdoc="">
			<field name="mRoot" access="priv" jdoc=""/>
			<field name="mObjectToNode" access="priv" jdoc=""/>
			<field name="mListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.AppTreeModel(java.util.List, int)" access="pub" jdoc="">
				<param name="apps"/>
				<param name="flags"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.getRoot()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.addTreeModelListener(javax.swing.event.TreeModelListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.removeTreeModelListener(javax.swing.event.TreeModelListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.valueForPathChanged(javax.swing.tree.TreePath, Object)" access="pub" jdoc="">
				<param name="path"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.isLeaf(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.getChildCount(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.getChild(Object, int)" access="pub" jdoc="">
				<param name="node"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.getIndexOfChild(Object, Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="child"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.onModelChanged()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.setAppComparator(java.util.Comparator)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.setClassComparator(java.util.Comparator)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel.setMethodAndFieldComparator(java.util.Comparator)" access="pub" jdoc="">
				<param name="comp"/>
			</mth>
		<class name="/:sandmark.gui.AppTree$AppTreeModel$ModelNode" intfc="n" abs="n" inn="y" sloc="5" jdoc="">
			<field name="object" access="pub" jdoc=""/>
			<field name="kids" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel$ModelNode.ModelNode(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.gui.AppTree$AppTreeModel$ModelNodeComparator" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<field name="mComp" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel$ModelNodeComparator.ModelNodeComparator(java.util.Comparator)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.AppTree$AppTreeModel$ModelNodeComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.AppTree$TreeViewState" intfc="n" abs="n" inn="y" sloc="12" jdoc="">
			<field name="expandedNodes" access="pub" jdoc=""/>
			<field name="selectionPaths" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.AppTree$TreeViewState.TreeViewState(java.util.Enumeration, javax.swing.tree.TreePath)" access="pub" jdoc="">
				<param name="e"/>
				<param name="s"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.gui.StaticRecognizePanel" intfc="n" abs="n" inn="n" sloc="94" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mPanel" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mCPPConstraints" access="priv" jdoc=""/>
			<field name="mHelpButton" access="priv" jdoc=""/>
			<field name="mGraphButton" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.StaticRecognizePanel.StaticRecognizePanel(SandMarkFrame, StaticWatermarkPanel)" access="pub" jdoc="">
				<param name="frame"/>
				<param name="panel"/>
			</mth>
			<mth name="/:sandmark.gui.StaticRecognizePanel.setAlgorithm(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.gui.StaticRecognizePanel.getCPP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticRecognizePanel.getCurrentAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.StaticRecognizePanel.getApplication()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.SandMarkPanel" intfc="y" abs="n" inn="n" sloc="4" jdoc="">
			<mth name="/:sandmark.gui.SandMarkPanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.SandMarkPanel.getFrame()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.gui.diff">
		<class name="/:sandmark.gui.diff.ResultsPane" intfc="n" abs="n" inn="n" sloc="78" jdoc="A ScrollPane for displaying an array of sandmark.diff.Results @author Zach Heidepriem">
			<field name="main" access="pub" jdoc=""/>
			<field name="frame" access="pub" jdoc=""/>
			<field name="options" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.diff.ResultsPane.ResultsPane(sandmark.gui.diff.DiffFrame, sandmark.diff.DiffOptions)" access="pub" jdoc="Make a sandmark.diff.ResultsPane @param df the DiffFrame to add this to. DiffFrames must provide &amp;lt;code&amp;gt;public void color(sandmark.diff.Result r)&amp;lt; code&amp;gt;">
				<param name="df"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.gui.diff.ResultsPane.setResults(sandmark.diff.Result[])" access="pub" jdoc="Update the results of this pane @param results the results to put in the pane">
				<comm cntt="String strings[] = { results[i].getMethod1().getClassName(), results[i].getMethod1().getName(), results[i].getMethod2().getClassName(), results[i].getMethod2().getName() }; int index = strings[0].lastIndexOf(&amp;quot;.&amp;quot;); String a = strings[0].substring(index+1); index = strings[2].lastIndexOf(&amp;quot;.&amp;quot;); String b = strings[2].substring(index+1);"/>
				<param name="results"/>
			</mth>
			<mth name="/:sandmark.gui.diff.ResultsPane.scrollToTop()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.diff.ResultsPane.validate()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.diff.DiffFrame" intfc="n" abs="n" inn="n" sloc="269" jdoc="A frame for diffing jar files and viewing resulting pair of methods side by side. @author Zach Heidepriem">
			<comm cntt="Recursively set fg bg"/>
			<comm cntt="Describe what diffing is."/>
			<comm cntt="An editor pane to show a sandmark.diff.Coloring"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="HPAD" access="priv" jdoc=""/>
			<field name="VPAD" access="priv" jdoc=""/>
			<field name="diffButton" access="priv" jdoc=""/>
			<field name="stopButton" access="priv" jdoc=""/>
			<field name="optionsButton" access="priv" jdoc=""/>
			<field name="options" access="priv" jdoc=""/>
			<field name="leftScrollPane" access="priv" jdoc=""/>
			<field name="rightScrollPane" access="priv" jdoc=""/>
			<field name="resultsPane" access="priv" jdoc=""/>
			<field name="leftEP" access="priv" jdoc=""/>
			<field name="rightEP" access="priv" jdoc=""/>
			<field name="messageLabel" access="priv" jdoc=""/>
			<field name="leftFile" access="priv" jdoc=""/>
			<field name="rightFile" access="priv" jdoc=""/>
			<field name="leftFilename" access="priv" jdoc=""/>
			<field name="rightFilename" access="priv" jdoc=""/>
			<field name="algorithms" access="priv" jdoc=""/>
			<field name="algorithm" access="priv" jdoc=""/>
			<field name="algorithmComboBox" access="priv" jdoc=""/>
			<field name="app1" access="priv" jdoc=""/>
			<field name="app2" access="priv" jdoc=""/>
			<field name="numResults" access="priv" jdoc=""/>
			<field name="progressBar" access="priv" jdoc=""/>
			<field name="sConfigProps" access="priv" jdoc=""/>
			<field name="timer" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.diff.DiffFrame.DiffFrame(String, String)" access="pub" jdoc="Create and show a DiffFrame @param a the name of the first jar file to diff @param b the name of the second jar file to diff">
				<comm cntt="pack();"/>
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.makeComponents()" access="priv" jdoc="">
				<comm cntt="int tfsize = 14;"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.layoutComponents()" access="priv" jdoc="">
				<comm cntt="setResizable(false);"/>
				<comm cntt="javax.swing.JPanel leftPanel = new javax.swing.JPanel(flow);"/>
				<comm cntt="leftPanel.add(sePanel);"/>
				<comm cntt="sePanel.add(optionsButton);"/>
				<comm cntt="leftScrollPane.setPreferredSize(paneDim);"/>
				<comm cntt="rightScrollPane.setPreferredSize(paneDim);"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.setColors(java.awt.Container)" access="pub" jdoc="">
				<param name="container"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.getProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the About page for Diff @return html code for the about page">
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.getHelpURL()" access="pub" jdoc="Get the URL of the Help page for Decompile @return url of the help page">
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.getOverview()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.main(String[])" access="pub" jdoc="Create and show a DiffFrame @param args the first two arguments should contain the names of the files to diff">
				<comm cntt="for testing"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.error(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.color(sandmark.diff.Result)" access="pub" jdoc="Shows a sandmark.diff.Result in this DiffFrame @param r sandmark.diff.Result to show in this DiffFrame">
				<comm cntt="leftEP.setSize(400, 400);"/>
				<comm cntt="rightEP.setSize(400,400);"/>
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.diff()" access="priv" jdoc="">
				<comm cntt="make sure we have time to calculate length"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame.showResults()" access="priv" jdoc="">
			</mth>
		<class name="/:sandmark.gui.diff.DiffFrame$BytecodeEP" intfc="n" abs="n" inn="y" sloc="29" jdoc="">
			<field name="coloring" access="pub" jdoc=""/>
			<mth name="/:sandmark.gui.diff.DiffFrame$BytecodeEP.BytecodeEP(sandmark.diff.Coloring)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffFrame$BytecodeEP.intToColor(int)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
		<class name="/:sandmark.gui.diff.DiffFrame$BytecodeEP$MyCellRenderer" intfc="n" abs="n" inn="y" sloc="17" jdoc="">
			<mth name="/:sandmark.gui.diff.DiffFrame$BytecodeEP$MyCellRenderer.getListCellRendererComponent(javax.swing.JList, Object, int, boolean, boolean)" access="pub" jdoc="">
				<param name="list"/>
				<param name="value"/>
				<param name="index"/>
				<param name="isSelected"/>
				<param name="cellHasFocus"/>
			</mth>
		</class>
		</class>
		</class>
		<class name="/:sandmark.gui.diff.DiffOptionsFrame" intfc="n" abs="n" inn="n" sloc="131" jdoc="">
			<field name="options" access="priv" jdoc=""/>
			<field name="minLabel" access="priv" jdoc=""/>
			<field name="ignoreLabel" access="priv" jdoc=""/>
			<field name="filterTF" access="priv" jdoc=""/>
			<field name="ignoreTF" access="priv" jdoc=""/>
			<field name="filterNamesCB" access="priv" jdoc=""/>
			<field name="filterBodiesCB" access="priv" jdoc=""/>
			<field name="methodRB1" access="priv" jdoc=""/>
			<field name="methodRB2" access="priv" jdoc=""/>
			<field name="okButton" access="priv" jdoc=""/>
			<field name="filterNames" access="priv" jdoc=""/>
			<field name="filterBodies" access="priv" jdoc=""/>
			<field name="objectCompare" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.diff.DiffOptionsFrame.DiffOptionsFrame(java.awt.Frame, sandmark.diff.DiffOptions)" access="pub" jdoc="">
				<comm cntt="setResizable(false);"/>
				<param name="f"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffOptionsFrame.makeComponents()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.diff.DiffOptionsFrame.layoutComponents()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.diff.DiffOptionsFrame.saveAndExit()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.gui.diff.DiffPanel" intfc="n" abs="n" inn="n" sloc="68" jdoc="">
			<field name="mFrame" access="priv" jdoc=""/>
			<field name="mCPP" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.gui.diff.DiffPanel.DiffPanel(sandmark.gui.SandMarkFrame)" access="pub" jdoc="">
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.gui.diff.DiffPanel.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.gui.diff.DiffPanel.getFrame()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.metric">
		<class name="/:sandmark.metric.CkClassInheritanceMeasure" intfc="n" abs="n" inn="n" sloc="18" jdoc="This class evaluates the depth of the class in the inheritance tree. Extends from &amp;apos;ClassMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkClassInheritanceMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassInheritanceMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassInheritanceMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassInheritanceMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassInheritanceMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassInheritanceMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<comm cntt="metric 2: finding the depth of the class in the inheritance tree"/>
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadMethodVolumeMeasure" intfc="n" abs="n" inn="n" sloc="29" jdoc="Volume is based on the &amp;apos;length&amp;apos;and &amp;apos;vocabulary&amp;apos; measure. Extends from &amp;apos;MethodMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadMethodVolumeMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVolumeMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVolumeMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVolumeMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVolumeMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVolumeMeasure.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="CALCULATION OF THE DERIVED METRICS"/>
				<param name="methodgen"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadAppEffortMeasure" intfc="n" abs="n" inn="n" sloc="26" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;effort&amp;apos; measure at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadAppEffortMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppEffortMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppEffortMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppEffortMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppEffortMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppEffortMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.NestingLevelComplexity" intfc="n" abs="n" inn="n" sloc="163" jdoc="This class builds the CFG, determines selection nodes and calculates the Halstead and Nesting Level complexities. For each node, first we calculate the Halstead&amp;apos;s measure. Then for each node X which has nodes {p1, p2, .. pn} in its &amp;quot;scope&amp;quot;, the measure(X) = measure(X) + measures(p1+p2+...+pn) The overall nesting level complexity is the sum of measures of all nodes in the method CFG.">
			<comm cntt="Builds the cfg for the given method, forms a set of ComplexityNodes, one for each basic block and marks the selection nodes @param mg the BCEL method object"/>
			<comm cntt="Calculates the Halstead metric for the list of instructions in each basic block. This method obtains the list of BLOAT instructions for each basic block using the &amp;apos;ordered&amp;apos; basic block list of BCEL instructions. @param me the BLOAT method object"/>
			<comm cntt="Evaluates the adjusted complexities for each basic block for selection nodes, adjusted complexity is the sum of raw complexities of all the nodes that lie in the range of a selection node, ie. nodes that lie between the selection node itself and the glb of its immediate successors. For other nodes, adj complexity = raw complexity"/>
			<comm cntt="Gets the list of lower bound nodes of the subgraph formed of of the successor nodes of the selection node. A &amp;apos;lower bound&amp;apos; node is one that can be reached by the entire set of nodes. @param succNodes the list of nodes whose lower bounds is to be obtained @return lbList the list of lower bound nodes"/>
			<comm cntt="Checks whether a given BasicBlock is a successor of another ie. whether there exists some path from startNode to endNode @param endNode @param startNode"/>
			<comm cntt="Builds a lower bound graph with the lower bound nodes and returns the root of that graph as the GLB @param inList the list of lower bound nodes @return glb greatest lower bound node"/>
			<comm cntt="Gets the list of nodes between the selection node and the computed greatest lower bound node. @param selNode the BasicBlock object - selection node @param glbNode the BasicBlock object - glb node @return rangeList list of BasicBlock objects"/>
			<comm cntt="Evaluates the Harrison-Magel metric that is based on the Halstead metrics and the nesting level of program constructs. @param mg the BCEL method object @return the calculated metric"/>
			<field name="myNodes" access="pub" jdoc=""/>
			<mth name="/:sandmark.metric.NestingLevelComplexity.buildCFG(sandmark.program.Method)" access="priv" jdoc="">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.metric.NestingLevelComplexity.getRawComplexities(sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="HalsteadMethodLengthMeasure hm = (HalsteadMethodLengthMeasure) HalsteadMethodLengthMeasure.getInstance(); int measure = hm.getMeasure(me);"/>
				<param name="me"/>
			</mth>
			<mth name="/:sandmark.metric.NestingLevelComplexity.getAdjComplexities()" access="priv" jdoc="">
				<comm cntt="Get immediate successors of the selection node"/>
				<comm cntt="Find glb of the succ nodes"/>
				<comm cntt="Build lb graph and get the greatest lower bound"/>
				<comm cntt="Find the nodes between the selection node"/>
				<comm cntt="and the greatest lower bound"/>
				<comm cntt="Add complexities"/>
			</mth>
			<mth name="/:sandmark.metric.NestingLevelComplexity.getLBList(java.util.List)" access="priv" jdoc="">
				<param name="succNodes"/>
			</mth>
			<mth name="/:sandmark.metric.NestingLevelComplexity.isSuccessor(sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="">
				<param name="endNode"/>
				<param name="startNode"/>
			</mth>
			<mth name="/:sandmark.metric.NestingLevelComplexity.getGLB(java.util.ArrayList)" access="priv" jdoc="">
				<comm cntt="build LB Graph"/>
				<comm cntt="Add edges to the lb Graph"/>
				<comm cntt="Find the root"/>
				<param name="inList"/>
			</mth>
			<mth name="/:sandmark.metric.NestingLevelComplexity.getRangeNodes(sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="">
				<param name="selNode"/>
				<param name="glbNode"/>
			</mth>
			<mth name="/:sandmark.metric.NestingLevelComplexity.evalMeasures(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="BUILD THE CFG OF THE METHOD AND MARK SELECTION NODES"/>
				<comm cntt="GET THE HALSTEAD MEASURES FOR EACH BLOCK (RAW COMPLEXITY)"/>
				<comm cntt="GET THE ADJUSTED COMPLEXITIES FOR EACH BLOCK"/>
				<comm cntt="GET THE TOTAL COMPLEXITY"/>
				<param name="mg"/>
			</mth>
		<class name="/:sandmark.metric.NestingLevelComplexity$ComplexityNode" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<comm cntt="Constructs a new ComplexityNode which is nothing but a BasicBlock that includes some extra properties given above"/>
			<field name="myBlock" access="pub" jdoc=""/>
			<field name="rawComplexity" access="pub" jdoc=""/>
			<field name="adjComplexity" access="pub" jdoc=""/>
			<field name="selection" access="pub" jdoc=""/>
			<field name="startLabel" access="pub" jdoc=""/>
			<field name="endLabel" access="pub" jdoc=""/>
			<mth name="/:sandmark.metric.NestingLevelComplexity$ComplexityNode.ComplexityNode(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="bb"/>
			</mth>
			<mth name="/:sandmark.metric.NestingLevelComplexity$ComplexityNode.compareTo(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.metric.ClassMetric" intfc="n" abs="y" inn="n" sloc="20" jdoc="A ClassMetric object encapsulates code for obtaining a class level complexity measure. Extends from sandmark.metric.Metric class Any metric that inherits from ClassMetric should contain a public constructor that takes a{@link sandmark.program.Class sandmark.program.Class} as the sole parameter in order to be loaded dynamically.">
			<mth name="/:sandmark.metric.ClassMetric.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.ClassMetric.getThresholdInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.ClassMetric.getMeasure(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.metric.ClassMetric.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<param name="clazz"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.CkAppInheritanceMeasure" intfc="n" abs="n" inn="n" sloc="24" jdoc="This class implements the inheritance measure of CkOO metrics at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkAppInheritanceMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppInheritanceMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppInheritanceMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppInheritanceMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppInheritanceMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppInheritanceMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.MunsonAppMeasure" intfc="n" abs="n" inn="n" sloc="23" jdoc="This class implements the munson&amp;apos;s metrics at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.MunsonAppMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonAppMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonAppMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonAppMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonAppMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonAppMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.KafuraAppMeasure" intfc="n" abs="n" inn="n" sloc="25" jdoc="This class implements the kafura&amp;apos;s metrics at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.KafuraAppMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraAppMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraAppMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraAppMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraAppMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraAppMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.MethodComparator" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<field name="myMetric" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.MethodComparator.MethodComparator(sandmark.metric.MethodMetric)" access="pub" jdoc="">
				<param name="metric"/>
			</mth>
			<mth name="/:sandmark.metric.MethodComparator.compare(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.metric.MethodComparator.equals(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.AppIdentifierLength" intfc="n" abs="n" inn="n" sloc="31" jdoc="Measures the average length of identifiers within an application (class and interface names) @author Kelly Heffner (kheffner@cs.arizona.edu)">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.AppIdentifierLength.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.AppIdentifierLength.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.AppIdentifierLength.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.AppIdentifierLength.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.AppIdentifierLength.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.AppIdentifierLength.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.metric.AppIdentifierLength.normalizeByScaling(int)" access="prot" jdoc="">
				<param name="rawValue"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.McCabeMethodMeasure" intfc="n" abs="n" inn="n" sloc="19" jdoc="This class implements the mcCabe&amp;apos;s data structure metrics. Extends from &amp;apos;MethodMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.McCabeMethodMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeMethodMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeMethodMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeMethodMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeMethodMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeMethodMeasure.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<param name="methodgen"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HarrisonAppMeasure" intfc="n" abs="n" inn="n" sloc="25" jdoc="This class implements the harrison magel&amp;apos;s metrics at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HarrisonAppMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonAppMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonAppMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonAppMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonAppMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonAppMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.ApplicationMetric" intfc="n" abs="y" inn="n" sloc="20" jdoc="An ApplicationMetric object encapsulates code for obtaining an application level complexity measure.">
			<mth name="/:sandmark.metric.ApplicationMetric.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.ApplicationMetric.getThresholdInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.ApplicationMetric.getMeasure(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.metric.ApplicationMetric.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadMethodEffortMeasure" intfc="n" abs="n" inn="n" sloc="38" jdoc="&amp;apos;Effort&amp;apos; is the product of &amp;apos;difficulty&amp;apos; and volume&amp;apos; Extends from &amp;apos;MethodMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadMethodEffortMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodEffortMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodEffortMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodEffortMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodEffortMeasure.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="CALCULATION OF THE DERIVED METRICS"/>
				<comm cntt="check LOG function above base 2 reqd"/>
				<param name="methodgen"/>
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodEffortMeasure.getName()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadClassVocabMeasure" intfc="n" abs="n" inn="n" sloc="27" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;vocabulary&amp;apos; measure at class level. Extends from &amp;apos;ClassMetric&amp;apos; class.">
			<field name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadClassVocabMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVocabMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVocabMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVocabMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVocabMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVocabMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadAppMeasure" intfc="n" abs="n" inn="n" sloc="26" jdoc="This class implements the Halstead&amp;apos;s measures (5 submeasures) at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadAppMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.ClassOpcodeComparator" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<field name="myOpcode" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.ClassOpcodeComparator.ClassOpcodeComparator(String)" access="pub" jdoc="">
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.metric.ClassOpcodeComparator.compare(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.metric.ClassOpcodeComparator.equals(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadAppLengthMeasure" intfc="n" abs="n" inn="n" sloc="25" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;length&amp;apos; measure at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadAppLengthMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppLengthMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppLengthMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppLengthMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppLengthMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppLengthMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.KafuraClassMeasure" intfc="n" abs="n" inn="n" sloc="185" jdoc="This class implements the henry kafura&amp;apos;s coupling metrics. It basically checks the amount of information flow in and out the methods in the class. Extends from &amp;apos;ClassMetric&amp;apos; class">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<comm cntt="tbi; criteria for &amp;apos;global-in&amp;apos;"/>
				<comm cntt="tbi; criteria for &amp;apos;global-out&amp;apos;"/>
				<comm cntt="note: these are inflows and outflows for a single class"/>
				<param name="myClassObj"/>
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getInvokedFromWithinClass(sandmark.program.Method, sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="take care of recursive calls also"/>
				<comm cntt="org.apache.bcel.generic.Instruction ins[] = instrlist.getInstructions();"/>
				<comm cntt="if(ins == null)"/>
				<comm cntt="return 0;"/>
				<comm cntt="for(int m=0; m&amp;lt;ins.length; m++) {"/>
				<comm cntt="String code = ins[m].toString();"/>
				<comm cntt="same class name ... now check methodname"/>
				<comm cntt="method name also matches"/>
				<param name="mg"/>
				<param name="mgens"/>
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.returnsData(sandmark.program.Method)" access="priv" jdoc="">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getLocalOutFlows(sandmark.program.Class)" access="priv" jdoc="This method calculates the localOutFlow information ie. number of method invocation done by a method + the number of calls made to this method ( provided this method returns some value. The summation is taken over all the methods and the result returned.">
				<comm cntt="if method does not return anything , the rest part of the loop is not required"/>
				<comm cntt="for every method int the class"/>
				<comm cntt="for every class"/>
				<param name="classObj"/>
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getNonVoidMethodsInvoked(sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="make sure its not a constructor or a java library call"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getLocalInFlows(sandmark.program.Class)" access="priv" jdoc="This method calculates the localInFlow information ie. number of invocation done to each method + number of invocations ( provided the other method returns some value) The summation is taken over all the methods and the result is returned.">
				<comm cntt="check that the methods return some value atleast; then there is &amp;apos;inflow&amp;apos;"/>
				<comm cntt="org.apache.bcel.generic.Instruction ins[] = instrlist.getInstructions();"/>
				<comm cntt="method name also matches"/>
				<param name="classObj"/>
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.hasProperty()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.KafuraClassMeasure.getMetricProperties()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.metric.ClassComparator" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<field name="myMetric" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.ClassComparator.ClassComparator(sandmark.metric.ClassMetric)" access="pub" jdoc="">
				<param name="metric"/>
			</mth>
			<mth name="/:sandmark.metric.ClassComparator.compare(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.metric.ClassComparator.equals(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.CkAppCouplingMeasure" intfc="n" abs="n" inn="n" sloc="26" jdoc="This class implements the Ck Object Oriented metrics at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkAppCouplingMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppCouplingMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppCouplingMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppCouplingMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppCouplingMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppCouplingMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadMethodDifficultyMeasure" intfc="n" abs="n" inn="n" sloc="35" jdoc="&amp;apos;Difficulty&amp;apos; is calculated based on the number of operands, number of distinct operands, number of operators and number of distinct operators in the method. Extends from &amp;apos;MethodMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadMethodDifficultyMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodDifficultyMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodDifficultyMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodDifficultyMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodDifficultyMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodDifficultyMeasure.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="CALCULATION OF THE DERIVED METRICS"/>
				<comm cntt="check LOG function above base 2 reqd"/>
				<param name="methodgen"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.MunsonClassMeasure" intfc="n" abs="n" inn="n" sloc="24" jdoc="This class implements the munson&amp;apos;s metrics at class level. Extends from &amp;apos;ClassMetric&amp;apos; class">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.MunsonClassMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonClassMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonClassMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonClassMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonClassMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonClassMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<comm cntt="mnMeasure.evaluateMetric();"/>
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadMethodLengthMeasure" intfc="n" abs="n" inn="n" sloc="27" jdoc="&amp;apos;Length&amp;apos; is calculated based on the number of operands and operators Extends from &amp;apos;MethodMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadMethodLengthMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodLengthMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodLengthMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodLengthMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodLengthMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodLengthMeasure.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="CALCULATION OF THE DERIVED METRICS"/>
				<param name="methodgen"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadAppDifficultyMeasure" intfc="n" abs="n" inn="n" sloc="27" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;difficulty&amp;apos; measure at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadAppDifficultyMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppDifficultyMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppDifficultyMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppDifficultyMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppDifficultyMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppDifficultyMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadClassLengthMeasure" intfc="n" abs="n" inn="n" sloc="27" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;Length&amp;apos; measure at class level. Extends from &amp;apos;ClassMetric&amp;apos; class.">
			<field name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadClassLengthMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassLengthMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassLengthMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassLengthMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassLengthMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassLengthMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadClassDifficultyMeasure" intfc="n" abs="n" inn="n" sloc="28" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;difficulty&amp;apos; measure at class level. Extends from &amp;apos;ClassMetric&amp;apos; class.">
			<field name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadClassDifficultyMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassDifficultyMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassDifficultyMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassDifficultyMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassDifficultyMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassDifficultyMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<comm cntt="hmMeasure.evaluateMetric();"/>
				<param name="clazz"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.MethodMetric" intfc="n" abs="y" inn="n" sloc="20" jdoc="">
			<mth name="/:sandmark.metric.MethodMetric.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MethodMetric.getThresholdInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MethodMetric.getMeasure(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.metric.MethodMetric.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<param name="method"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.FakeMetric" intfc="n" abs="y" inn="n" sloc="14" jdoc="">
			<field name="complexityMeasure" access="pub" jdoc=""/>
			<field name="metricName" access="prot" jdoc=""/>
			<field name="shortDescription" access="prot" jdoc=""/>
			<field name="thresholdInfo" access="prot" jdoc=""/>
			<field name="metricLowerBound" access="prot" jdoc=""/>
			<field name="metricUpperBound" access="prot" jdoc=""/>
			<field name="metricStdDev" access="prot" jdoc=""/>
			<mth name="/:sandmark.metric.FakeMetric.getMeasure()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadClassMeasure" intfc="n" abs="n" inn="n" sloc="26" jdoc="This class implements the Halstead&amp;apos;s (all 5 submeasures) measure at class level. Extends from &amp;apos;ClassMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadClassMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.CkAppMeasure" intfc="n" abs="n" inn="n" sloc="23" jdoc="This class implements the Ck Object Oriented metrics at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkAppMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadClassVolumeMeasure" intfc="n" abs="n" inn="n" sloc="28" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;volume&amp;apos; measure at class level. Extends from &amp;apos;ClassMetric&amp;apos; class.">
			<field name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadClassVolumeMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVolumeMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVolumeMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVolumeMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVolumeMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassVolumeMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadUtil" intfc="n" abs="n" inn="n" sloc="181" jdoc="This class implements the various modules required to evaluate the Halstead&amp;apos;s complexity measure.">
			<comm cntt="this method cannot be removed, because NestingLevelComplexity"/>
			<comm cntt="relies on it!!"/>
			<field name="numOperators" access="priv" jdoc=""/>
			<field name="numOperands" access="priv" jdoc=""/>
			<field name="numDistinctOperators" access="priv" jdoc=""/>
			<field name="numDistinctOperands" access="priv" jdoc=""/>
			<field name="operTypeVector" access="priv" jdoc=""/>
			<field name="operandVector" access="priv" jdoc=""/>
			<field name="methodgen" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadUtil.HalsteadUtil(sandmark.program.Method)" access="pub" jdoc="">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.metric.HalsteadUtil.getMeasure(String)" access="pub" jdoc="Returns the value corresponding to the given measure @param measure the symbolic name of the measure whose value is needed @return the value corresponding to that measure">
				<param name="measure"/>
			</mth>
			<mth name="/:sandmark.metric.HalsteadUtil.setMeasure(String, int)" access="pub" jdoc="Sets measure with the corresponding value @param measure the symbolic name of the measure @param value the value to be set">
				<param name="measure"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.metric.HalsteadUtil.evalMeasures()" access="pub" jdoc="Evaluates the Halstead measures n1,n2,N1 and N2 @return resultVector result vector containing the Halstead measures in the order N1, N2, n1, n2">
			</mth>
			<mth name="/:sandmark.metric.HalsteadUtil.evalMeasures(java.util.Iterator)" access="prot" jdoc="">
				<param name="ins"/>
			</mth>
			<mth name="/:sandmark.metric.HalsteadUtil.getOperatorType(org.apache.bcel.generic.Instruction)" access="pub" jdoc="Gets the operator type of the given instruction returns &amp;apos;none&amp;apos; if not an operator instruction @param opcode the instruction to be analyzed @return operType the operator type of the instruction">
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.metric.HalsteadUtil.isOperatorDistinct(String)" access="priv" jdoc="Maintains a vector of operator types that are already present in the method. Returns whether the given operator type is distinct or not. @param operType the operator type to be analyzed">
				<param name="operType"/>
			</mth>
			<mth name="/:sandmark.metric.HalsteadUtil.getOperand(org.apache.bcel.generic.Instruction)" access="pub" jdoc="Returns the operand of the given &amp;apos;operand instruction&amp;apos; if present returns &amp;apos;none&amp;apos; if not an operand instruction @param instruc the instruction to be analyzed">
				<param name="instruc"/>
			</mth>
			<mth name="/:sandmark.metric.HalsteadUtil.isOperandDistinct(String)" access="priv" jdoc="Maintains a vector of operands that are already present in the method. Returns whether the given operand is distinct or not. @param operand the operand to be analyzed">
				<param name="operand"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.CkClassSubclassMeasure" intfc="n" abs="n" inn="n" sloc="18" jdoc="This class evaluates the subclass frequency measure. Extends from &amp;apos;ClassMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkClassSubclassMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassSubclassMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassSubclassMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassSubclassMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassSubclassMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassSubclassMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<comm cntt="metric 3: finding the number of the children in the class hierarchy"/>
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.LocalIdentifierLength" intfc="n" abs="n" inn="n" sloc="37" jdoc="Measures the average length of identifiers within a method (from the local variable name table). @author Kelly Heffner (kheffner@cs.arizona.edu)">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.LocalIdentifierLength.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.LocalIdentifierLength.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.LocalIdentifierLength.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.LocalIdentifierLength.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.LocalIdentifierLength.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.LocalIdentifierLength.calculateMeasure(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="This code is extraneous and counts variable lengths twice"/>
				<comm cntt="localvariabletable already contains argumentnames"/>
				<comm cntt="String [] argNames = myMethod.getArgumentNames();"/>
				<comm cntt="if(argNames != null)"/>
				<comm cntt="for(int i = 0; i &amp;lt; argNames.length; i++){"/>
				<comm cntt="identifierLength += argNames[i].length();"/>
				<comm cntt="identifierCount++;"/>
				<comm cntt="}"/>
				<param name="myMethod"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadAppVocabMeasure" intfc="n" abs="n" inn="n" sloc="25" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;vocabulary&amp;apos; measure at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadAppVocabMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVocabMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVocabMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVocabMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVocabMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVocabMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.MunsonMethodMeasure" intfc="n" abs="n" inn="n" sloc="32" jdoc="This class implements the munson&amp;apos;s data structure metrics. The measure is obtained by taking into account the number of scalars(non-array variables), the number of vectors(array variables) and the number of dimensions of each vector. Extends from &amp;apos;MethodMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.MunsonMethodMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonMethodMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonMethodMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonMethodMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonMethodMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.MunsonMethodMeasure.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="C(scalar) = 2; C(array) = 3 + 2 n + C(arrayElement)"/>
				<param name="methodgen"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.MethodOpcodeComparator" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<field name="myOpcode" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.MethodOpcodeComparator.MethodOpcodeComparator(String)" access="pub" jdoc="">
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.metric.MethodOpcodeComparator.compare(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.metric.MethodOpcodeComparator.equals(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HarrisonClassMeasure" intfc="n" abs="n" inn="n" sloc="24" jdoc="This class implements the harrison magel&amp;apos;s metrics at class level. Extends from &amp;apos;ClassMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HarrisonClassMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonClassMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonClassMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonClassMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonClassMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonClassMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.CkClassResponseMeasure" intfc="n" abs="n" inn="n" sloc="28" jdoc="This class evaluates the response of a class i.e. the number of methods possibly invoked from this class. Extends from &amp;apos;ClassMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkClassResponseMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassResponseMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassResponseMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassResponseMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassResponseMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassResponseMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<comm cntt="metric 5: response of a class; basically the number of methods possibly invoked from this class."/>
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.ApplicationComparator" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<field name="myMetric" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.ApplicationComparator.ApplicationComparator(sandmark.metric.ApplicationMetric)" access="pub" jdoc="">
				<param name="metric"/>
			</mth>
			<mth name="/:sandmark.metric.ApplicationComparator.compare(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:sandmark.metric.ApplicationComparator.equals(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.StatsUtil" intfc="n" abs="n" inn="n" sloc="288" jdoc="This class contains the utility modules for Metric classes. It consists of various APIs that evaluate diffent code statistics of the target application. @author Tapas R. Sahoo">
			<comm cntt="we define &amp;quot;hierarchy level&amp;quot; to be the length of the path from java.lang.Object to me"/>
			<comm cntt="returns the names of all the methods this class owns that were added by a superclass in the same application."/>
			<comm cntt="i.e. java methods are not counted and overridden methods are not counted"/>
			<comm cntt="hashes Instruction.getName() Strings to an Integer count of that kind of instruction within this method"/>
			<comm cntt="opcode is the result of Instruction.getName()"/>
			<comm cntt="opcode is the result of Instruction.getName()"/>
			<comm cntt="opcode is the result of Instruction.getName()"/>
			<comm cntt="this method calculates the number of public instance methods in the class"/>
			<comm cntt="this method calculates the number of instance methods in the class"/>
			<comm cntt="this method calculates the number of instance variables in a class"/>
			<mth name="/:sandmark.metric.StatsUtil.getNumClasses(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getClassNameAt(sandmark.program.Application, int)" access="pub" jdoc="">
				<param name="app"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getPackageNames(sandmark.program.Application)" access="pub" jdoc="returns packageNames in the format A B C.. stored in vector (see &amp;apos;parsePackage&amp;apos; method for implementation detail">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getListOfClassesByPackageName(sandmark.program.Application, String)" access="pub" jdoc="">
				<param name="app"/>
				<param name="packageName"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfConditionalStats(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="org.apache.bcel.generic.Instruction[] instrs ="/>
				<comm cntt="method.getInstructionList().getInstructions();"/>
				<comm cntt="for (int i=0;i&amp;lt;instrs.length;i++){"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getMethodNames(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getApplicationCallCount(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNamesOfMethodsInvoked(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="for (int i=0;i&amp;lt;instrs.length;i++){"/>
				<comm cntt="if the method is in a non-application class, then parent will be null (right?)"/>
				<comm cntt="kheffner - no it will be an instance of LibraryClass"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfScalarLocals(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfVectorLocals(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getMethodVectorDimensions(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getClassHierarchyLevel(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfSubClasses(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfSuperClasses(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getAllClassNames(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getApplicationMethodsInherited(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfTotalPublicMethods(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getByteCodeUsage(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="org.apache.bcel.generic.Instruction[] instrs ="/>
				<comm cntt="method.getInstructionList().getInstructions();"/>
				<comm cntt="for (int i=0;i&amp;lt;instrs.length;i++){"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfOpcodesInMethod(sandmark.program.Method, String)" access="pub" jdoc="">
				<param name="method"/>
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfOpcodesInClass(sandmark.program.Class, String)" access="pub" jdoc="">
				<param name="clazz"/>
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfOpcodesInPackage(sandmark.program.Application, String, String)" access="pub" jdoc="">
				<param name="app"/>
				<param name="packageName"/>
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getMethodSizeInBytes(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="org.apache.bcel.generic.Instruction instrs[] = method.getInstructionList().getInstructions();"/>
				<comm cntt="for(int k=0;k&amp;lt;instrs.length;k++)"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfPublicMethods(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfInstanceMethods(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfInstanceVariables(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfAbstractClassesInPackage(sandmark.program.Application, String)" access="pub" jdoc="">
				<param name="app"/>
				<param name="packageName"/>
			</mth>
			<mth name="/:sandmark.metric.StatsUtil.getNumberOfMethodsOverridden(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.McCabeClassMeasure" intfc="n" abs="n" inn="n" sloc="24" jdoc="">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.McCabeClassMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeClassMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeClassMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeClassMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeClassMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeClassMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadMethodMeasure" intfc="n" abs="n" inn="n" sloc="37" jdoc="This class implements the Halstead&amp;apos;s metrics at method level. (Extends from &amp;apos;MethodMetric&amp;apos; class) Contains 5 submetrics : length, vocabulary, volume, difficulty and effort. Submeasures calculated from &amp;apos;HalsteadUtil&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadMethodMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodMeasure.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="CALCULATION OF THE DERIVED METRICS"/>
				<comm cntt="check LOG function above base 2 reqd"/>
				<param name="methodgen"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HarrisonMethodMeasure" intfc="n" abs="n" inn="n" sloc="28" jdoc="This class implements the harrison magel&amp;apos;s nesting level metrics. The evaluations is primarily based on how much nesting(branching) occurs in a control flow graph. Extends from &amp;apos;MethodMetric&amp;apos; class">
			<const name="singleton" access="priv" jdoc=""/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HarrisonMethodMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonMethodMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonMethodMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonMethodMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonMethodMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HarrisonMethodMeasure.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<param name="methodgen"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.ClassIdentifierLength" intfc="n" abs="n" inn="n" sloc="32" jdoc="Measures the average length of identifiers within a class (method and field names). @author Kelly Heffner (kheffner@cs.arizona.edu)">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.ClassIdentifierLength.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.ClassIdentifierLength.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.ClassIdentifierLength.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.ClassIdentifierLength.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.ClassIdentifierLength.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.ClassIdentifierLength.calculateMeasure(sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="Get the length of method names"/>
				<comm cntt="Get the length of field names"/>
				<param name="myClass"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.CkClassMeasure" intfc="n" abs="n" inn="n" sloc="36" jdoc="This class implements all the CkOO metric measures at class level. Extends from &amp;apos;ClassMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkClassMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<comm cntt="metric 2: finding the depth of the class in the inheritance tree"/>
				<comm cntt="metric 3: finding the number of the children in the class hierarchy"/>
				<comm cntt="metric 4: coupling between object classes; number of methods in the other classes that lies in the scope of this class, (and are &amp;quot;actively&amp;quot; invoked from this class)."/>
				<comm cntt="metric 5: response of a class; basically the number of methods possibly invoked from this class."/>
				<comm cntt="metric 6: lack of cohesion in methods... TBD: how to calculate the dissimilarity measure ?"/>
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.McCabeAppMeasure" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.McCabeAppMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeAppMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeAppMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeAppMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeAppMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.McCabeAppMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadMethodVocabMeasure" intfc="n" abs="n" inn="n" sloc="27" jdoc="&amp;apos;Vocabulary&amp;apos; is the total number of distinct operators and operands. Extends from &amp;apos;MethodMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadMethodVocabMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVocabMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVocabMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVocabMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVocabMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadMethodVocabMeasure.calculateMeasure(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="CALCULATION OF THE DERIVED METRICS"/>
				<param name="methodgen"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadClassEffortMeasure" intfc="n" abs="n" inn="n" sloc="27" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;Effort&amp;apos; measure at class level. Extends from &amp;apos;ClassMetric&amp;apos; class.">
			<field name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadClassEffortMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassEffortMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassEffortMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassEffortMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassEffortMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadClassEffortMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<param name="myClassObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.CkAppResponseMeasure" intfc="n" abs="n" inn="n" sloc="25" jdoc="This class implements the response measure of Ck Object Oriented metrics at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkAppResponseMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppResponseMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppResponseMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppResponseMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppResponseMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppResponseMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.HalsteadAppVolumeMeasure" intfc="n" abs="n" inn="n" sloc="25" jdoc="This class implements the Halstead&amp;apos;s &amp;apos;Volume&amp;apos; measure at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class.">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.HalsteadAppVolumeMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVolumeMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVolumeMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVolumeMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVolumeMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.HalsteadAppVolumeMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="myAppObj"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.Metric" intfc="n" abs="y" inn="n" sloc="27" jdoc="This class is the base class for all the metrics implementation. The different implementations - {ApplicationMetric, ClassMetric, MethodMetric} extend from this Metric class.">
			<comm cntt="Added by kheffner on 11 3 03 - raising normalization methods and"/>
			<comm cntt="variables up one inheritance level from AppMetric, MethodMetric, etc.."/>
			<comm cntt="to the basic Metric class."/>
			<comm cntt="Modified by kheffner on 11 15 03 - changes from protected variables to"/>
			<comm cntt="public methods"/>
			<mth name="/:sandmark.metric.Metric.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.Metric.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.Metric.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.Metric.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.Metric.getNormalizedMeasure(float)" access="pub" jdoc="">
				<param name="rawValue"/>
			</mth>
			<mth name="/:sandmark.metric.Metric.normalizeByScaling(float)" access="prot" jdoc="">
				<param name="rawValue"/>
			</mth>
			<mth name="/:sandmark.metric.Metric.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.Metric.getThresholdInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.Metric.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.metric.CkAppSubclassMeasure" intfc="n" abs="n" inn="n" sloc="25" jdoc="This class implements the SubClasses measure of CkOO metrics at application level. Extends from &amp;apos;ApplicationMetric&amp;apos; class">
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkAppSubclassMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppSubclassMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppSubclassMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppSubclassMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppSubclassMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkAppSubclassMeasure.calculateMeasure(sandmark.program.Application)" access="prot" jdoc="">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.metric.CkClassCouplingMeasure" intfc="n" abs="n" inn="n" sloc="23" jdoc="This class evaluates the coupling between classes i.e. number of methods in the other classes that lies in the scope of this class, (and are &amp;quot;actively&amp;quot; invoked from this class). Extends from &amp;apos;ClassMetric&amp;apos; class">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="singleton" access="priv" jdoc=""/>
			<mth name="/:sandmark.metric.CkClassCouplingMeasure.getLowerBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassCouplingMeasure.getUpperBound()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassCouplingMeasure.getStdDev()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassCouplingMeasure.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassCouplingMeasure.getInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.metric.CkClassCouplingMeasure.calculateMeasure(sandmark.program.Class)" access="prot" jdoc="">
				<comm cntt="metric 4: coupling between object classes; number of methods in the other classes that lies in the scope of this class, (and are &amp;quot;actively&amp;quot; invoked from this class)."/>
				<param name="myClassObj"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.newstatistics">
		<class name="/:sandmark.newstatistics.Stats" intfc="n" abs="n" inn="n" sloc="970" jdoc="This class is a collection of StatisticsRecords. It builds these records from an Application object input. It can find a record, access it and provide statistical data about the classes it records. @author Tapas R. Sahoo">
			<comm cntt="private boolean DEBUG = true; private boolean LOOP = true;"/>
			<comm cntt="________________ end of constructor ; stats evaluation _____________"/>
			<comm cntt="_____ new stat implementation starts here ____"/>
			<comm cntt="this method finds the number of methods in the class that are inherited from more than one class"/>
			<field name="myAppObject" access="priv" jdoc=""/>
			<field name="myRecords" access="priv" jdoc=""/>
			<field name="myPackages" access="priv" jdoc=""/>
			<field name="totalNumberOfClasses" access="priv" jdoc=""/>
			<field name="numberOfAbstractClasses" access="priv" jdoc=""/>
			<field name="totalNumberOfMethods" access="priv" jdoc=""/>
			<field name="totalNumberOfPublicMethods" access="priv" jdoc=""/>
			<field name="avgNumberOfMethods" access="priv" jdoc=""/>
			<field name="totalNumberOfInstanceVariables" access="priv" jdoc=""/>
			<field name="avgNumberOfInstanceVariables" access="priv" jdoc=""/>
			<field name="numArrayDimensions" access="priv" jdoc=""/>
			<field name="numberOfMetrics" access="priv" jdoc=""/>
			<field name="numberOfMethodMetrics" access="priv" jdoc=""/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.newstatistics.Stats.Stats(sandmark.program.Application)" access="pub" jdoc="Constructs a new Statistics collection. @param appObject The Application which contains the classes to analyze.">
				<comm cntt="run through every class in the Application Object"/>
				<comm cntt="Set up the className and the packageName for this StatisticsRecord object"/>
				<comm cntt="get the class hierarchy information"/>
				<comm cntt="get the number of inherited methods"/>
				<comm cntt="total api call in a class"/>
				<comm cntt="get the number of conditional statements"/>
				<comm cntt="get number of method invokes"/>
				<comm cntt="get number of scalars and vectors"/>
				<comm cntt="get the number of overridden methods"/>
				<comm cntt="print the inheritance chain for this class :"/>
				<comm cntt="since 1 count is for self overridding !"/>
				<comm cntt="Get the dimensions of the array &amp; store it in a vector; the vector length goes in sync with the numArray"/>
				<comm cntt="ensure its not a invoke to java.lang , or constructor"/>
				<comm cntt="field info is updated later in the constructor; so not committed yet"/>
				<comm cntt="get number of inherited classes"/>
				<comm cntt="NOTE: same class also included in the subclass list; so inorder to discard it, -1"/>
				<comm cntt="CC"/>
				<comm cntt="_____ Start Field statistic development ____"/>
				<comm cntt="get the dimensions of the array &amp; store it in a vector; the vector length goes in sync with the numArray"/>
				<comm cntt="numArrayDimensions.removeAllElements();"/>
				<comm cntt="get the sandmark.program.Mmethod objects and store them in a record"/>
				<param name="appObject"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.findAllRecords()" access="pub" jdoc="Displays most of the code statistics in the class">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.isBasicType(org.apache.bcel.generic.Type)" access="priv" jdoc="Returns &amp;apos;true&amp;apos; if the parameter is a basic type, else returns false.">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.parsePackage(String)" access="pub" jdoc="This method derives the package name from the full-name. For example: given &amp;apos;sandmark.newstatistics.Stats&amp;apos;, this method would return &amp;apos;sandmark newstatistics&amp;apos;">
				<param name="fullName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.parseClass(String)" access="pub" jdoc="This method derives the class name from the full-name. For example: given &amp;apos;sandmark.newstatistics.Stats&amp;apos;, this method would return &amp;apos;Stats&amp;apos;">
				<param name="fullName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.findClassRecord(String)" access="priv" jdoc="Internal method which returns a reference to a StatisticsRecord in the collection with given name.">
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.findRecord(String, String)" access="priv" jdoc="Improvement to the above method; the above method does not support multiple classes of same name in different packages; subsequently giving &amp;apos;method&amp;apos; record not found error.">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getByteCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getByteCodeByPackage(String)" access="pub" jdoc="">
				<param name="packageName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumMethods(String, String)" access="pub" jdoc="Returns the number of the method in specified class, or -1 if class does not exist.">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNames(String, String)" access="pub" jdoc="Returns the names of all of the methods in the class specified">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getClassNameAt(int)" access="pub" jdoc="Returns the classname at the specified index @return the name of the class at &amp;lt;i&amp;gt;index&amp;lt; i&amp;gt; @param index the index at which to get the classname">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumClasses()" access="pub" jdoc="Returns the number of classes in this application object">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getPackageNameAt(int)" access="pub" jdoc="Given a specific index, this method returns the packageName at that index @return the name of the package at &amp;lt;i&amp;gt;index&amp;lt; i&amp;gt; @param index the index at which to get the packageName">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getPackageName(String)" access="pub" jdoc="">
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumPackages()" access="pub" jdoc="Returns the number of packages in this application object">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getListOfClassesByPackageName(String)" access="pub" jdoc="Returns a list of all of the classNames are in the specified package. @return a list of all of the classNames are in the specified package. @param packageName the name of the package from which to get classNames.">
				<param name="packageName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getAllClassNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getAllMethodNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumClassesInPackage(String)" access="pub" jdoc="Returns the number of classes in the specified package.">
				<param name="packageName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getPackageNames()" access="pub" jdoc="Returns a list of all of the packages in this Application object, discounting duplicates.">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.findPackage(String)" access="pub" jdoc="Checks to see if the named package is in this collection. @return true if package exists in this collection, false if it does not. @param packageToFind the name of the package to look for in this collection.">
				<param name="packageToFind"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getPackageIndex(String)" access="pub" jdoc="">
				<param name="packageToFind"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getByteCodeByClassName(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getByteCode(String, String, String)" access="pub" jdoc="Returns the bytecode of a specified method. @return the &amp;lt;code&amp;gt;List&amp;lt; code&amp;gt; representation of the bytecode. @param className the name of the class. @param methodName the name of the method from which to get the bytecode.">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getMethodByteCodeUsage(String, String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getByteCodeUsage(String, String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getMethodSizeInBytes(String, String, String)" access="pub" jdoc="Returns the size of the method in bytes, or -1 if the class or method does not exist @return the number of bytes in the method, or -1 if the class or method does not exist @param className the name of the class @param methodName the name of the method from which to get the size.">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.throwsCatchesExceptions(String, String, String)" access="pub" jdoc="Returns true if specified method throws or catches exceptions, or false if it does not. @return true if specified method throws or catches exceptions, or false if it does not. @param className the name of the class @param methodName the name of the method to investigate">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumNonStaticFields(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfStaticFields(String, String)" access="pub" jdoc="Returns the number of fields in the specified class which are static, or -1 if the class does not exist">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumNonStaticFieldsByType(String, String, String)" access="pub" jdoc="Returns the number of fields, by type in the specified class which are non-static, or -1 if the class does not exist">
				<param name="packageName"/>
				<param name="className"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumFieldsNonBasicTypes(String, String)" access="pub" jdoc="Returns the number of fields that are not basic in the specified class, or -1 if the class does not exist">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.hasForwardBranches(String, String, String)" access="pub" jdoc="Returns true if specified method uses forward branches, or false if it does not.">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.hasBackwardBranches(String, String, String)" access="pub" jdoc="Returns true if specified method uses backward branches, or false if it does not.">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNonStaticFields(String, String)" access="pub" jdoc="Returns a &amp;lt;code&amp;gt;List&amp;lt; code&amp;gt; of all the Non-Static fields in the specified class.">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.callsStaticMethods(String, String, String)" access="pub" jdoc="Returns true if specified method calls other static methods, or false if it does not.">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.callsDynamicMethods(String, String, String)" access="pub" jdoc="Returns true if specified method calls other dynamic methods, or false if it does not.">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfOpcodesInMethod(String, String, String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfOpcodesInClass(String, String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfOpcodesInPackage(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getMethodEditor(String, String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfStatmentsInMethod(String, String, String)" access="pub" jdoc="________________ modules for &amp;apos;method size&amp;apos; __________________">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfMessageSends(String, String, String)" access="pub" jdoc="">
				<comm cntt="TBD: ... calls the &amp;apos;getNumberOfMessageSends&amp;apos; in &amp;apos;StatisticsRecord&amp;apos; class"/>
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfPublicMethods(String, String)" access="pub" jdoc="________________ modules for &amp;apos;class size&amp;apos; __________________">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfPrivateMethods(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfProtectedMethods(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfInstanceMethods(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getAvgNumberOfInstanceMethods()" access="pub" jdoc="this method returns the average number of instance methods per class in this application object">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfInstanceVariables(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getAvgNumberOfInstanceVariables()" access="pub" jdoc="this method returns the average number of instance variables per class in this application object">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfClassMethods(String, String)" access="pub" jdoc="this method calculates the number of class methods (ie. static methods) in a class">
				<comm cntt="to be implemented in the StatiticsRecord file , currently it returns &amp;apos;true&amp;apos;"/>
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfApiCalls(String, String)" access="pub" jdoc="To Be Implemented ... public int getCFGdepth(String packageName, String className, String methodName) { StatisticsRecord stat = null; if((stat = findRecord(packageName, className)) == null) { System.out.println(&amp;quot; no Records found for class: &amp;quot; + className); return -1; } return stat.getCFGdepth(methodName); }">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfloops(String, String, String)" access="pub" jdoc="Returns the number of loops in the method. Here we are only taking care of &amp;quot;proper regions&amp;quot;, so, we just extract them based on knowledge of backedges. Note that there can be loops forming improper regions( ones find in unstructured languages); that has not been implemented over here yet">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNamesOfMethodsInvoked(String, String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfMethodParams(String, String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfCondStatsInMethod(String, String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfScalarLocals(String, String, String)" access="pub" jdoc="returns the number of non-array locals in the method">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfVectorLocals(String, String, String)" access="pub" jdoc="returns the number of array locals in the method">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getMethodVectorDimensions(String, String, String)" access="pub" jdoc="Returns the &amp;apos;number of dimensions&amp;apos; of all the vectors(non-array locals) in the method">
				<param name="packageName"/>
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfConditionalStatements(String, String)" access="pub" jdoc="_______________ modules for &amp;apos;class internals&amp;apos; _____________">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getAverageNumberOfMethodParams(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfScalars(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfVectors(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getVectorDimensions(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfMethodsInvoked(String, String)" access="pub" jdoc="_______________ modules for &amp;apos;class externals&amp;apos; _____________">
				<comm cntt="use API --&amp;gt; getNumberOfApiCalls() in constructor;"/>
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfInheritedMethods(String, String)" access="priv" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfMethodsInScope(String, String)" access="pub" jdoc="">
				<comm cntt="use API --&amp;gt; getNumberOfPublicMethods() ;"/>
				<comm cntt="ie. protected methods from the ancestors that are &amp;apos;public&amp;apos;ly extended .. &amp;gt;&amp;gt;&amp;gt;&amp;gt;TBD:"/>
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getClassHierarchyLevel(String, String)" access="pub" jdoc="_______________ modules for &amp;apos;class inheritance&amp;apos; _____________">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfSubClasses(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfAbstractClasses()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfmultipleInheritance(String, String)" access="pub" jdoc="">
				<comm cntt="TBD: not supported in java!"/>
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfMethodsInherited(String, String)" access="pub" jdoc="_______________ modules for &amp;apos;method inheritance&amp;apos; _____________">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfMethodsAdded(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfMethodsOverridden(String, String)" access="pub" jdoc="">
				<param name="packageName"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getApplicationObject()" access="pub" jdoc="___________________ Metrics specific modules ____________">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfMetrics()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getNumberOfMethodMetrics()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.setNumberOfMetrics(int)" access="pub" jdoc="">
				<param name="numMetrics"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getMetricNames()" access="pub" jdoc="Returns the Application level Metric names. @return an array of fully qualified class names of Application level metrics">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getMethodMetricNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getClassMetricNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getMetricNames(int)" access="priv" jdoc="">
				<param name="classFinderID"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getMetrics(int)" access="priv" jdoc="">
				<param name="metricType"/>
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getApplicationMetrics()" access="pub" jdoc="Returns the Application level Metric objects">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getClassMetrics()" access="pub" jdoc="returns the Class level metric objects">
			</mth>
			<mth name="/:sandmark.newstatistics.Stats.getMethodMetrics()" access="pub" jdoc="returns the Method level metric objects">
			</mth>
		</class>
		<class name="/:sandmark.newstatistics.Statistics" intfc="n" abs="n" inn="n" sloc="18" jdoc="@author Christian Collberg @version 1.0">
			<comm cntt="Describe what statistics is."/>
			<field name="sConfigProps" access="priv" jdoc="Get the GENERAL properties of Statistics"/>
			<mth name="/:sandmark.newstatistics.Statistics.getProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.Statistics.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the About page for Statistics @return html code for the about page">
			</mth>
			<mth name="/:sandmark.newstatistics.Statistics.getHelpURL()" access="pub" jdoc="Get the URL of the Help page for Statistics @return URL for the help page">
			</mth>
			<mth name="/:sandmark.newstatistics.Statistics.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.newstatistics.CFGwidth" intfc="n" abs="n" inn="n" sloc="288" jdoc="Calculates the width of a method CFG i.e. how far can the execution path digress from the simplest sequential execution.">
			<comm cntt="traversed in dfs sequence;"/>
			<field name="BUG" access="priv" jdoc=""/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="mcfg" access="priv" jdoc=""/>
			<field name="meth" access="priv" jdoc=""/>
			<field name="finalWidth" access="priv" jdoc=""/>
			<field name="edgeStack" access="priv" jdoc=""/>
			<field name="rangeStack" access="priv" jdoc=""/>
			<mth name="/:sandmark.newstatistics.CFGwidth.CFGwidth(sandmark.program.Method)" access="pub" jdoc="">
				<param name="mObj"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGwidth.isBackEdge(sandmark.util.newgraph.EdgeImpl, java.util.ArrayList)" access="priv" jdoc="">
				<param name="edge"/>
				<param name="backedges"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGwidth.isEndOfRange(sandmark.analysis.controlflowgraph.BasicBlock, Range)" access="priv" jdoc="">
				<param name="tempblk"/>
				<param name="currRange"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGwidth.edgeListEmpty(Range)" access="priv" jdoc="">
				<param name="currRange"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGwidth.evaluate()" access="pub" jdoc="">
				<comm cntt="if(DEBUG)System.out.println(&amp;quot;lastIH -&amp;gt; &amp;quot;+fromblk.getLastInstruction());"/>
				<comm cntt="traverse ahead until branch node detected;"/>
				<comm cntt="pop the top element from stack;"/>
				<comm cntt="delete this edge from range object list at top of stack,if present. IMP: currwidth to range object width!"/>
				<comm cntt="also pop and push this rangeObject into stack"/>
				<comm cntt="check if this is back edge; then discard; continue;"/>
				<comm cntt="if(this block has reached the end of the innermost range) if(no edges left to be traversed at head of this range) pop out that range from stack; Update &amp;apos;currwidth&amp;apos;; Take next path (from edgeStack);"/>
				<comm cntt="also. push the outgoing edges from end(oldrange) into stack"/>
				<comm cntt="with succCount value as 0; so continues at top"/>
				<comm cntt="with succCount value as 0; so continues at top"/>
				<comm cntt="also pop and push this rangeObject into stack"/>
				<comm cntt="also. push the outgoing edges from end(oldrange) into stack"/>
				<comm cntt="if end of cfg reached, exit ..."/>
				<comm cntt="wont exit this loop unless a branch node is detected; range STACK is modified inside."/>
				<comm cntt="update &amp;apos;maxwidth&amp;apos;"/>
				<comm cntt="new brach node detected; push a range object corresponding to it into stack"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGwidth.setMaxWidth(int)" access="priv" jdoc="">
				<param name="width"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGwidth.getMaxWidth()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.newstatistics.CFGwidth$Range" intfc="n" abs="n" inn="y" sloc="21" jdoc="Container for all width range related information at branching nodes">
			<field name="width" access="priv" jdoc=""/>
			<field name="sblk" access="pub" jdoc=""/>
			<field name="eblk" access="pub" jdoc=""/>
			<field name="edgelist" access="pub" jdoc=""/>
			<mth name="/:sandmark.newstatistics.CFGwidth$Range.Range(int, sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.controlflowgraph.BasicBlock, java.util.Iterator)" access="pub" jdoc="">
				<param name="w"/>
				<param name="from"/>
				<param name="to"/>
				<param name="edgeIter"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGwidth$Range.getWidth()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.newstatistics.StatisticsRecord" intfc="n" abs="n" inn="n" sloc="770" jdoc="This class contains statistical information about one class including data about its fields, methods and the package in which it is located. @author Tapas R. Sahoo">
			<comm cntt="total number of methods in the class"/>
			<comm cntt="return the sandmark.program.Method object given a String methodName"/>
			<comm cntt="Returns a hashtable associating instruction with a value indicating how often its called"/>
			<comm cntt="This method is used to build up the &amp;apos;type&amp;apos; part of the method"/>
			<comm cntt="signature. It converts things like &amp;apos;[[I&amp;apos; to &amp;apos;int[][]&amp;apos; and"/>
			<comm cntt="&amp;apos;Ljava lang Integer&amp;apos; to &amp;apos;Integer&amp;apos;."/>
			<comm cntt="______________ &amp;apos;method size&amp;apos; implementation __________"/>
			<comm cntt="________________ &amp;apos;class size&amp;apos; implementation _____________"/>
			<comm cntt="______________ &amp;apos;method internals&amp;apos; implementation __________"/>
			<comm cntt="________________ &amp;apos;class internal&amp;apos; implementation __________"/>
			<comm cntt="____________ &amp;apos;class external&amp;apos; implementation _____________"/>
			<comm cntt="______________ &amp;apos;class hierarchy&amp;apos; implementation __________"/>
			<comm cntt="______________ &amp;apos;method hierarchy&amp;apos; implementation ________"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="myDEBUG" access="priv" jdoc=""/>
			<field name="myPackageName" access="priv" jdoc=""/>
			<field name="myClassName" access="priv" jdoc=""/>
			<field name="myNumberOfMethods" access="priv" jdoc=""/>
			<field name="myNumNonBasicFields" access="priv" jdoc=""/>
			<field name="myNumberStaticFields" access="priv" jdoc=""/>
			<field name="myNonStaticFields" access="priv" jdoc=""/>
			<field name="myMethods" access="priv" jdoc=""/>
			<field name="myNumberOfMethodsAdded" access="priv" jdoc=""/>
			<field name="myNumberOfPublicMethods" access="priv" jdoc=""/>
			<field name="myNumberOfProtectedMethods" access="priv" jdoc=""/>
			<field name="myNumberOfPrivateMethods" access="priv" jdoc=""/>
			<field name="myNumberOfInstanceMethods" access="priv" jdoc=""/>
			<field name="myNumberOfClassMethods" access="priv" jdoc=""/>
			<field name="myNumberOfMethodsInherited" access="priv" jdoc=""/>
			<field name="myNumberOfMethodsInvoked" access="priv" jdoc=""/>
			<field name="myNumberOfMethodsInScope" access="priv" jdoc=""/>
			<field name="myNumberOfMethodsOverridden" access="priv" jdoc=""/>
			<field name="myNumberOfApiCalls" access="priv" jdoc=""/>
			<field name="myNumberOfConditionalStatements" access="priv" jdoc=""/>
			<field name="myClassHierarchyLevel" access="priv" jdoc=""/>
			<field name="myNumberOfSubClasses" access="priv" jdoc=""/>
			<field name="myNumberOfScalars" access="priv" jdoc=""/>
			<field name="myNumberOfVectors" access="priv" jdoc=""/>
			<field name="myVectorDimensions" access="priv" jdoc=""/>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.StatisticsRecord()" access="pub" jdoc="Constructs a new StatisticsRecord">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setClassName(String)" access="pub" jdoc="Sets the class name associated with this record to the one provided.">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getClassName()" access="pub" jdoc="Returns the name of this class.">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.equals(Object)" access="pub" jdoc="Returns true if this object is the same as the one to which it is being compared. @return true if this object has the same class name and package name as the one to which it is being compared. False if either of these two tests if false.">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getPackageName()" access="pub" jdoc="Returns the name of the package to which this class belongs.">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setPackageName(String)" access="pub" jdoc="Sets the package name of this class to the specified argument.">
				<param name="toSet"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getMethodSize(String)" access="pub" jdoc="Returns the size of the given method in bytes @return the number of bytes that make up this method @param methodName the name of the method">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.throwsCatchesExc(String)" access="pub" jdoc="Returns true if this method throws or catches exceptions, otherwise it returns false. @return true if this method throws or catches exceptions, false otherwise. @param methodName the name of the method">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumNonStaticFields()" access="pub" jdoc="Returns the number of non-static fields in this class. @return the number of non-static fields in this class.">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNonStaticFields()" access="pub" jdoc="Returns a &amp;lt;code&amp;gt;List&amp;lt; code&amp;gt; of all the Non-Static fields in the specified class. @return a &amp;lt;code&amp;gt;List&amp;lt; code&amp;gt; representation of all non-static field types in the specified class">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.addNonStaticField(String)" access="pub" jdoc="Adds a non-static field object of specified type to the collection. @param type the type of non-static field to add.">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumStaticFields(int)" access="pub" jdoc="Sets the number of static fields to the specified number. @param number the number of static fields to acknowledge.">
				<param name="number"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumStaticFields()" access="pub" jdoc="Returns the number of static fields in this class. @return the number of static fields in this class">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumNonBasicFields(int)" access="pub" jdoc="Sets the number fields with non-basic types to the specified number @param numNonBasic the number of fields of non-basic type">
				<param name="numNonBasic"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumNonBasicFields()" access="pub" jdoc="Returns the number of non-basic fields that this class contains. @return the number of non-basic fields that this class contains.">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberMethods()" access="pub" jdoc="Returns the number of methods which this method contains @return the number of methods which this method contains">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setMethods(sandmark.program.Method[])" access="pub" jdoc="Sets the methods in this class to the specified array of MethodEditor objects. @param methods the array of MethodEditor objects to add.">
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getMethod(String)" access="priv" jdoc="">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNames()" access="pub" jdoc="Retruns the names of all of the methods in the class specified @return String array representing all of the method names in the class specified">
				<comm cntt="org.apache.bcel.generic.Type type = mg.getReturnType();"/>
				<comm cntt="To make entries more readable, this section"/>
				<comm cntt="will allow modification from BLOAT(now BCEL!) returns to"/>
				<comm cntt="a more readable format."/>
				<comm cntt="temp += parseType(type);"/>
				<comm cntt="not required to &amp;apos;parse&amp;apos; anymore for bcel format output"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getMethodByteCodes(String)" access="pub" jdoc="Returns a &amp;lt;code&amp;gt;List&amp;lt; code&amp;gt; of the bytecodes in the specied method. @return a &amp;lt;code&amp;gt;List&amp;lt; code&amp;gt; of the bytecodes in the specied method. @param methodName the name of the method from which to draw the bytecodes.">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfConditionalStatementsInMethod(String)" access="pub" jdoc="">
				<comm cntt="go through all of the Instructions in the byte code of this method."/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getMethodByteCodeUsage(String)" access="pub" jdoc="">
				<comm cntt="short x = instr.getOpcode();"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getByteCodeUsage(String)" access="pub" jdoc="">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumNonStatFieldsByType(String)" access="pub" jdoc="Returns the number of non-static fields in this class that are of the specified type. @return the number of non-static fields in this class that are of the specified type. @param type type to count.">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.isOfTypeBranch(org.apache.bcel.generic.Instruction)" access="pub" jdoc="">
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.hasForwardBranch(String)" access="pub" jdoc="Returns true if there is a forward branch instruction in the method specified. @return true if there is a forward branch, otherwise false. @param methodName the name of the method to inspect.">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.hasBackwardBranch(String)" access="pub" jdoc="Returns true if there is a backward branch instruction in the method specified. @return true if there is a backward branch, otherwise false. @param methodName the name of the method to inspect.">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.callsStaticMethods(String)" access="pub" jdoc="Returns true if the specified method calls other static methods, otherwise false @return true if the specified method calls other static methods, otherwise false @param methodName the name of the method to investigate">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.callsDynamicMethods(String)" access="pub" jdoc="Returns true if the specified method calls other dynamic methods, otherwise false @return true if the specified method calls other static methods, otherwise false @param methodName the name of the method to investigate">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.parseType(String)" access="priv" jdoc="">
				<comm cntt="org.apache.bcel.generic.Type type)"/>
				<comm cntt="for every parameter argument to the method..."/>
				<comm cntt="gets the dimensions of the array, if any."/>
				<comm cntt="This tree goes through the 8 primitive types in Java"/>
				<comm cntt="if it is not a primitive, it must be a class"/>
				<comm cntt="This case checks for classes without package"/>
				<comm cntt="- 1);"/>
				<comm cntt="This class parses out the package. For instance:"/>
				<comm cntt="converts: Ljava lang String to String"/>
				<comm cntt="- 1);"/>
				<comm cntt="this part tacks on the dimensions of array to the end."/>
				<param name="sig"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getMethodEditor(String)" access="pub" jdoc="new StatisticRecord implementation ....">
				<comm cntt="used, since getMethod is private !"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfStatementsInMethod(String)" access="pub" jdoc="">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfMessageSends(String)" access="pub" jdoc="">
				<comm cntt="TBD:"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfMethodsAdded(int)" access="pub" jdoc="">
				<param name="numMethods"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfMethodsAdded()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfPublicMethods(int)" access="pub" jdoc="">
				<param name="numMethods"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfPublicMethods()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfPrivateMethods(int)" access="pub" jdoc="">
				<param name="numMethods"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfPrivateMethods()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfProtectedMethods(int)" access="pub" jdoc="">
				<param name="numMethods"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfProtectedMethods()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfInstanceMethods(int)" access="pub" jdoc="">
				<param name="numMethods"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfInstanceMethods()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfInstanceVariables()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfClassMethods(int)" access="pub" jdoc="">
				<param name="numMethods"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfClassMethods()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfloops(String)" access="pub" jdoc="This function evaluates the CFG depth based on the maximum depth of loop nesting in the CFG. ... To Be Implemented ... public int getCFGdepth(String methodName) { sandmark.program.Method meth = this.getMethod(methodName); if(meth==null) { System.out.println(&amp;quot; getNumberOfloops : methodObject is null &amp;quot;); return -1; } if(meth.getInstructionList()==null) { if(DEBUG) System.out.println(&amp;quot; getCFGdepth: no instructions in this method. returning numloops=0 &amp;quot;); return 0; } sandmark.analysis.controlflowgraph.MethodCFG mcfg = new sandmark.analysis.controlflowgraph.MethodCFG(meth); java.util.ArrayList backedgelist = mcfg.getBackEdges(); slot 0-&amp;gt;1, 2-&amp;gt;3 etc denote the back edges int finalDepth = 0; for(int k=0; k&amp;lt;backedgelist.size()-1; k++) { int currDepth=1; org.apache.bcel.generic.InstructionHandle tailIH = (org.apache.bcel.generic.InstructionHandle)backedgelist.get(k)); org.apache.bcel.generic.InstructionHandle headIH = (org.apache.bcel.generic.InstructionHandle)backedgelist.get(k+1)); get all the other back edges and check for dom postdom condition } }">
				<comm cntt="extract the back-edges and the loops in the method CFG"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfVectorLocals(String)" access="pub" jdoc="">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getMethodVectorDimensions(String)" access="pub" jdoc="">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfScalarLocals(String)" access="pub" jdoc="">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.isScalarType(org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfApiCalls(int)" access="pub" jdoc="">
				<param name="numberOfApiCalls"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfApiCalls()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNamesOfMethodsInvoked(String)" access="pub" jdoc="">
				<comm cntt="check added for print etc. calls"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfMethodParams(String)" access="pub" jdoc="">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfConditionalStatements(int)" access="pub" jdoc="">
				<param name="numOfCondStats"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfConditionalStatements()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfScalars(int)" access="pub" jdoc="">
				<param name="numScalars"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfScalars()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfVectors(int)" access="pub" jdoc="">
				<param name="numVectors"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfVectors()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setVectorDimensions(java.util.Vector)" access="pub" jdoc="">
				<param name="numArrayDimensions"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getVectorDimensions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfMethodsInvoked(int)" access="pub" jdoc="">
				<param name="numberOfmethodsInvoked"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfMethodsInvoked()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfMethodsInScope(int)" access="pub" jdoc="">
				<param name="numberOfmethodsInScope"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfMethodsInScope()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setClassHierarchyLevel(int)" access="pub" jdoc="">
				<param name="hierarchyLevel"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getClassHierarchyLevel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfSubClasses(int)" access="pub" jdoc="">
				<param name="numberOfSubClasses"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfSubClasses()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfMethodsInherited(int)" access="pub" jdoc="">
				<param name="numberOfMethodsInherited"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfMethodsInherited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.setNumberOfMethodsOverridden(int)" access="pub" jdoc="">
				<param name="numberOfMethodsOverridden"/>
			</mth>
			<mth name="/:sandmark.newstatistics.StatisticsRecord.getNumberOfMethodsOverridden()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.newstatistics.StatisticsRecord$StaticFieldData" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="myType" access="pub" jdoc=""/>
			<field name="myCount" access="pub" jdoc=""/>
			<mth name="/:sandmark.newstatistics.StatisticsRecord$StaticFieldData.StaticFieldData(String)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.newstatistics.CFGdepth" intfc="n" abs="n" inn="n" sloc="84" jdoc="">
			<comm cntt="traversed in dfs sequence ..."/>
			<comm cntt="list of &amp;apos;Scope&amp;apos; objects present till now ..."/>
			<comm cntt="container for all loop scope related information; including current depth level"/>
			<field name="mcfg" access="priv" jdoc=""/>
			<field name="meth" access="priv" jdoc=""/>
			<field name="maxNestingLevel" access="priv" jdoc=""/>
			<field name="edgeStack" access="priv" jdoc=""/>
			<field name="currloopscope" access="priv" jdoc=""/>
			<mth name="/:sandmark.newstatistics.CFGdepth.CFGdepth(sandmark.program.Method)" access="pub" jdoc="">
				<param name="mObj"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGdepth.isBackEdge(sandmark.util.newgraph.EdgeImpl, java.util.ArrayList)" access="priv" jdoc="">
				<param name="edge"/>
				<param name="backedges"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGdepth.updateScope(sandmark.util.newgraph.EdgeImpl)" access="priv" jdoc="">
				<comm cntt="check if this edge encapsulates this &amp;apos;tempscope&amp;apos;"/>
				<comm cntt="else, extend this scope, incr the nesting level count and set &amp;apos;modify&amp;apos; flag to true"/>
				<comm cntt="create a new scope for this back edge"/>
				<param name="edge"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGdepth.evaluate()" access="pub" jdoc="">
				<comm cntt="pop the top element from stack; if stack empty, break;"/>
				<comm cntt="check if this is back edge, then update currloopscope,"/>
				<comm cntt="dont push this blk into stack; and continue;"/>
				<comm cntt="get all successors and push into stack;continue;"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGdepth.setFinalNestingLevel()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.CFGdepth.getMaxNestingLevel()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.newstatistics.CFGdepth$Scope" intfc="n" abs="n" inn="y" sloc="26" jdoc="">
			<field name="nestlevel" access="priv" jdoc=""/>
			<field name="sblk" access="pub" jdoc=""/>
			<field name="eblk" access="pub" jdoc=""/>
			<mth name="/:sandmark.newstatistics.CFGdepth$Scope.Scope(int, sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="level"/>
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGdepth$Scope.getLevel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.newstatistics.CFGdepth$Scope.setLevel(int)" access="pub" jdoc="">
				<param name="newlevel"/>
			</mth>
			<mth name="/:sandmark.newstatistics.CFGdepth$Scope.setScope(sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate">
		<class name="/:sandmark.obfuscate.Obfuscator" intfc="n" abs="n" inn="n" sloc="31" jdoc="The sandmark.obfuscate.Obfuscator class supervises obfuscation as parameterized by the global Properties and possibly also by a Scoreboard and other things yet to be determined. @author Christian Collberg @version 1.0">
			<mth name="/:sandmark.obfuscate.Obfuscator.runObfuscation(sandmark.program.Application, sandmark.Algorithm)" access="pub" jdoc="">
				<comm cntt="(alg instanceof sandmark.obfuscate.MethodObfuscator) {"/>
				<param name="app"/>
				<param name="alg"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.MethodObfuscator" intfc="n" abs="y" inn="n" sloc="4" jdoc="A MethodObfuscator object encapsulates code for performing an obfuscation that operates on a single method. @author Christian Collberg @version 1.0">
			<mth name="/:sandmark.obfuscate.MethodObfuscator.apply(sandmark.program.Method)" access="pub" jdoc="Applies this obfuscation to a single method.">
				<param name="meth"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.AppObfuscator" intfc="n" abs="y" inn="n" sloc="5" jdoc="An AppObfuscator object encapsulates code for performing an obfuscation that encompasses the entire application program. @author Christian Collberg @version 1.0">
			<mth name="/:sandmark.obfuscate.AppObfuscator.apply(sandmark.program.Application)" access="pub" jdoc="Applies this obfuscation to an application.">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.GeneralObfuscator" intfc="n" abs="y" inn="n" sloc="5" jdoc="A GeneralObfuscator object encapsulates code for performing a particular obfuscation. Obfuscations are grouped into three abstract subclasses: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; AppObfuscator &amp;lt;LI&amp;gt; ClassObfuscator &amp;lt;LI&amp;gt; MethodObfuscator &amp;lt; UL&amp;gt; @author Christian Collberg @version 1.1 5 20 2002 K.H.">
			<mth name="/:sandmark.obfuscate.GeneralObfuscator.getConfigProperties()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.ObfuscationException" intfc="n" abs="n" inn="n" sloc="7" jdoc="">
			<mth name="/:sandmark.obfuscate.ObfuscationException.ObfuscationException(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.AllClassesObfuscator" intfc="n" abs="y" inn="n" sloc="12" jdoc="An AllClassesObfuscator applies a ClassObfuscator to all the classes in an application. @author Christian Collberg @version 1.0">
			<field name="co" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.AllClassesObfuscator.AllClassesObfuscator(sandmark.obfuscate.ClassObfuscator)" access="pub" jdoc="Constructs an AllClassesObfuscator using a ClassObfuscator and its label. @param co">
				<param name="co"/>
			</mth>
			<mth name="/:sandmark.obfuscate.AllClassesObfuscator.apply(sandmark.program.Application)" access="pub" jdoc="Applies the class obfuscation to all classes contained in an application.">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.ClassObfuscator" intfc="n" abs="y" inn="n" sloc="4" jdoc="A ClassObfuscator object encapsulates code for performing an obfuscation that operates on a whole class. @author Christian Collberg @version 1.0">
			<mth name="/:sandmark.obfuscate.ClassObfuscator.apply(sandmark.program.Class)" access="pub" jdoc="Applies this obfuscation to a single class.">
				<param name="cls"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.ArrayObfuscation">
		<class name="/:sandmark.obfuscate.ArrayObfuscation.Folder" intfc="n" abs="y" inn="n" sloc="467" jdoc="">
			<comm cntt="[Ljava.lang.String; java.lang.String [B Byte.TYPE"/>
			<comm cntt=""/>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.arraylength(Object)" access="pub" jdoc="">
				<comm cntt="2"/>
				<param name="array"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.elementType(String)" access="priv" jdoc="">
				<param name="arraysig"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.newarray(int, String)" access="pub" jdoc="">
				<param name="count"/>
				<param name="newsig"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.baload(Object, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.caload(Object, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.daload(Object, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.faload(Object, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.iaload(Object, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.laload(Object, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.saload(Object, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.dastore(Object, int, double)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.fastore(Object, int, float)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.lastore(Object, int, long)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.Folder.iastore(Object, int, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.ArrayObfuscation.arr" intfc="n" abs="n" inn="n" sloc="159" jdoc="This is a helper class which has methods that call Kelly&amp;apos;s Stack Simulator to simulate the stack and get the necessary instruction handles">
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.arr.chekifarrayinreturn(org.apache.bcel.generic.InstructionHandle, int, sandmark.analysis.stacksimulator.StackSimulator)" access="pub" jdoc="">
				<param name="ih1"/>
				<param name="lvi"/>
				<param name="ss"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.arr.chekifarrayinstaticmtd(org.apache.bcel.generic.InstructionHandle, int, int, sandmark.analysis.stacksimulator.StackSimulator)" access="pub" jdoc="">
				<param name="ih1"/>
				<param name="lvi"/>
				<param name="num_args"/>
				<param name="ss"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.arr.chekifarrayinobjectsmtd(org.apache.bcel.generic.InstructionHandle, int, int, sandmark.analysis.stacksimulator.StackSimulator)" access="pub" jdoc="">
				<comm cntt="org.apache.bcel.generic.MethodGen mg, org.apache.bcel.generic.ConstantPoolGen cpg)"/>
				<param name="ih1"/>
				<param name="lvi"/>
				<param name="num_args"/>
				<param name="ss"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.arr.getNameofArray(org.apache.bcel.generic.InstructionHandle, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="mg.getApplication().finalize();"/>
				<param name="ih2"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.arr.getIndexInstructions(org.apache.bcel.generic.InstructionHandle, sandmark.program.Method)" access="pub" jdoc="">
				<param name="ih2"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.arr.getValueInstructions(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, sandmark.program.Method)" access="pub" jdoc="">
				<param name="ih1"/>
				<param name="ih2"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter" intfc="n" abs="n" inn="n" sloc="1655" jdoc="IntArraySplitter, as the name suggests, does Data Obfuscation by splitting an integer array in the original program into two arrays, and based on some encoding method, the elements are put in either of the two arrays. The current implementation supports the following form of encoding: Even elements are put in one array and odd in another. @author Ashok Venkatraj (ashok@cs.arizona.edu)">
			<comm cntt="This function is called whenever code is added inside in a try-catch block. Modifies the startPC,endPC and handlerPC of the exception table to reflect the changes to the code. @param coe ExceptionTable Object @param coecopy A deep copy of the exception table of the unmodified code. @param cur_pos Position of the bytecode instruction that is modified in the unmodifed code. @param count Number of new instructions added to method in place of current instruction. @param addcount A cumulative count of the instructions added to the method."/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="classgen" access="priv" jdoc=""/>
			<field name="methods1" access="priv" jdoc=""/>
			<field name="methodgen" access="priv" jdoc=""/>
			<field name="classname2" access="priv" jdoc=""/>
			<field name="in" access="pub" jdoc=""/>
			<field name="to_del" access="pub" jdoc=""/>
			<field name="arraycount" access="pub" jdoc=""/>
			<field name="returnhandle" access="pub" jdoc=""/>
			<field name="no_of_locals" access="pub" jdoc=""/>
			<field name="len_of_array" access="pub" jdoc=""/>
			<field name="arr1_lvindex" access="pub" jdoc=""/>
			<field name="arr2_lvindex" access="pub" jdoc=""/>
			<field name="arr_assign_start" access="pub" jdoc=""/>
			<field name="arr_assign_end" access="pub" jdoc=""/>
			<field name="lvindex" access="pub" jdoc=""/>
			<field name="poscount" access="pub" jdoc=""/>
			<field name="delcount" access="pub" jdoc=""/>
			<field name="arraytype" access="pub" jdoc=""/>
			<field name="increase" access="pub" jdoc=""/>
			<field name="cur_mtd" access="pub" jdoc=""/>
			<field name="cur_sig" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.initialize(sandmark.program.Class)" access="pub" jdoc="Gets all the BCEL bytecode editing class objects up and running @param cg1">
				<param name="cg1"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.getLength(int, org.apache.bcel.generic.Instruction[])" access="pub" jdoc="Obtain the length of an array ,whose length is constant ,from bytecode @param i Offset of the newarray instruction @param l Instruction array for this method .">
				<param name="i"/>
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.addDynaNewArr(byte, int, int, int, org.apache.bcel.generic.InstructionList, int[], org.apache.bcel.generic.ConstantPoolGen)" access="pub" jdoc="If the array &amp;apos;s length will be known only at runtime , use this method to add two new integer arrays and delete the old array @param type The type of the array @param xastores_offset @param lens_offset The offset in bytecode where you can find the instruction that specifies the length of the array @param local_il Instruction List Array @param local_pos Instruction Position Array @param cpg1 ConstantPoolGen">
				<param name="type"/>
				<param name="xastores_offset"/>
				<param name="lens_offset"/>
				<param name="newarrays_offset"/>
				<param name="local_il"/>
				<param name="local_pos"/>
				<param name="cpg1"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.addNewArrays(byte, int, int, org.apache.bcel.generic.InstructionList, int[], org.apache.bcel.generic.ConstantPoolGen)" access="pub" jdoc="Add two new integer arrays and delete the old array @param type The type of the array @param xastores_offset @param lens_offset The offset in bytecode where you can find the instruction that specifies the length of the array @param local_il Instruction List Array @param local_pos Instruction Position Array @param cpg1 ConstantPoolGen">
				<param name="type"/>
				<param name="xastores_offset"/>
				<param name="lens_offset"/>
				<param name="local_il"/>
				<param name="local_pos"/>
				<param name="cpg1"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.setIndex(int, org.apache.bcel.generic.InstructionList, int[], org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<comm cntt="e6.printStackTrace();"/>
				<param name="aload"/>
				<param name="local_il"/>
				<param name="local_pos"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.deleteIlist(int, int, org.apache.bcel.generic.InstructionList, int[])" access="pub" jdoc="">
				<comm cntt="e6.printStackTrace();"/>
				<param name="sip"/>
				<param name="eip"/>
				<param name="local_il"/>
				<param name="local_pos"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.insert_iby_2(org.apache.bcel.generic.InstructionList, int[], int, int)" access="pub" jdoc="">
				<param name="local_il"/>
				<param name="local_pos"/>
				<param name="index_end_ip"/>
				<param name="incr_tillnow"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.finish_insert(org.apache.bcel.generic.InstructionList, int[], int, int, int, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionList, int)" access="pub" jdoc="">
				<param name="local_il"/>
				<param name="local_pos"/>
				<param name="aloads_offset"/>
				<param name="Ilistlen"/>
				<param name="Vlistlen"/>
				<param name="Ilist"/>
				<param name="Vlist"/>
				<param name="cur_xastore_ip"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.editingReads(org.apache.bcel.generic.InstructionList, int[], int, int)" access="pub" jdoc="">
				<comm cntt="e6.printStackTrace();"/>
				<comm cntt="e6.printStackTrace();"/>
				<param name="local_il"/>
				<param name="local_pos"/>
				<param name="aloadsoffset"/>
				<param name="ialoadsoffset"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.adjustArrLengths()" access="pub" jdoc="">
				<comm cntt="classgen.getMethods()[cur_mtd].getCode().getExceptionTable();"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.editlength(org.apache.bcel.generic.InstructionList, int[], int)" access="pub" jdoc="">
				<param name="local_il"/>
				<param name="local_pos"/>
				<param name="aloads_offset"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.adjustArrReads()" access="pub" jdoc="">
				<comm cntt="modify for xastore"/>
				<comm cntt="found iastore for an aload i.e array write"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.adjustArrWrites()" access="pub" jdoc="">
				<comm cntt=""/>
				<comm cntt="this is to keep track of arrays ,using arrays as index"/>
				<comm cntt="ip in bytecode after the array write"/>
				<comm cntt="ih is got"/>
				<comm cntt="end of if iastore"/>
				<comm cntt="} eo for loop"/>
				<comm cntt="eo if"/>
				<comm cntt="eo for loop"/>
				<comm cntt="classgen.setConstantPool(cpg1);"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.createIndexIlist(int, int, org.apache.bcel.generic.InstructionList, int[])" access="pub" jdoc="">
				<param name="sip"/>
				<param name="eip"/>
				<param name="local_il"/>
				<param name="local_pos"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.createValueIlist(org.apache.bcel.generic.InstructionHandle[], org.apache.bcel.generic.InstructionList, int[])" access="pub" jdoc="">
				<param name="val"/>
				<param name="local_il"/>
				<param name="local_pos"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.split(int, int, int, byte)" access="pub" jdoc="">
				<comm cntt=""/>
				<comm cntt="dups"/>
				<comm cntt=""/>
				<comm cntt="dups"/>
				<comm cntt="delete dup and arrindex"/>
				<comm cntt="if (dup)"/>
				<comm cntt="for"/>
				<comm cntt="e.printStackTrace();"/>
				<comm cntt="e.printStackTrace();"/>
				<comm cntt="e.printStackTrace();"/>
				<comm cntt="dont forget to do iii lar to incr-=locallen for all these cases too"/>
				<comm cntt="Newly added code"/>
				<comm cntt="end of newly added code"/>
				<comm cntt="if"/>
				<comm cntt="for"/>
				<comm cntt="else"/>
				<param name="dup"/>
				<param name="xstore"/>
				<param name="flag"/>
				<param name="arrtype"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.arr_creat_split()" access="pub" jdoc="The main function that coordinates the calls to all other functions which actually execute the algorithm">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.testifok(org.apache.bcel.generic.Instruction[], int[], org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.ConstantPoolGen, sandmark.program.Method)" access="pub" jdoc="The future work will include the integration of Array Merging with Array Splitting. The reason I am saying this is that this function won&amp;apos;t be needed then .. @param local_in Instruction Array @param local_pos Instruction Position Array @param local_il Instruction List Array (editing purposes) @param cpg1 org.apache.bcel.generic.ConstantPoolGen @param local_mg sandmark.program.Method">
				<param name="local_in"/>
				<param name="local_pos"/>
				<param name="local_il"/>
				<param name="cpg1"/>
				<param name="local_mg"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.apply(sandmark.program.Application)" access="pub" jdoc="Calls the other methods to obfuscate the class file using the Array-Spltting algorithm @param app Application Object">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.IntArraySplitter()" access="pub" jdoc="Constructor">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.IntArraySplitter.adjustExceptions(org.apache.bcel.classfile.CodeException[], org.apache.bcel.classfile.CodeException[], int, int, int)" access="priv" jdoc="">
				<param name="coe"/>
				<param name="coecopy"/>
				<param name="cur_pos"/>
				<param name="count"/>
				<param name="addcount"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder" intfc="n" abs="y" inn="n" sloc="285" jdoc="This class is used by the ArraySplitter obfuscation. It is added into obfuscated applications, but not used directly by ArraySplitter.">
			<comm cntt="Called when a putfield or putstatic is done"/>
			<comm cntt="on one of the split arrays. The return value"/>
			<comm cntt="goes in the &amp;apos;front&amp;apos;."/>
			<comm cntt="replace every ARRAYLENGTH with a call to this function"/>
			<comm cntt="replace every BALOAD with a call to this function or the next one"/>
			<comm cntt="replace every CALOAD with a call to this function"/>
			<comm cntt="replace every DALOAD with a call to this function"/>
			<comm cntt="replace every FALOAD with a call to this function"/>
			<comm cntt="replace every IALOAD with a call to this function"/>
			<comm cntt="replace every LALOAD with a call to this function"/>
			<comm cntt="replace every SALOAD with a call to this function"/>
			<comm cntt="replace every AALOAD with a call to this function"/>
			<comm cntt="and follow it with a CHECKCAST to the correct array type"/>
			<comm cntt=""/>
			<comm cntt="replace every BASTORE with a call to this function or the next one"/>
			<comm cntt="replace every CASTORE with a call to this function"/>
			<comm cntt="replace every DASTORE with a call to this function"/>
			<comm cntt="replace every FASTORE with a call to this function"/>
			<comm cntt="replace every IASTORE with a call to this function"/>
			<comm cntt="replace every LASTORE with a call to this function"/>
			<comm cntt="replace every SASTORE with a call to this function"/>
			<comm cntt="replace every AASTORE with a call to this function"/>
			<field name="name2front" access="priv" jdoc=""/>
			<field name="front2end" access="priv" jdoc=""/>
			<field name="front2frontlength" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.putvar(Object, String)" access="pub" jdoc="">
				<param name="array"/>
				<param name="fieldname"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.getEnd(String)" access="pub" jdoc="">
				<param name="fieldname"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.copyOut()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.arraylength(Object)" access="pub" jdoc="">
				<param name="array"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.baload(Object, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.caload(char[], int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.daload(double[], int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.faload(float[], int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.iaload(int[], int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.laload(long[], int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.saload(short[], int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.aaload(Object, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.bastore(Object, int, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.castore(char[], int, char)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.dastore(double[], int, double)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.fastore(float[], int, float)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.iastore(int[], int, int)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.lastore(long[], int, long)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.sastore(short[], int, short)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.HashHolder.aastore(Object, int, Object)" access="pub" jdoc="">
				<param name="array"/>
				<param name="index"/>
				<param name="value"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder" intfc="n" abs="n" inn="n" sloc="592" jdoc="This obfuscation looks for fields that are single-dimensional arrays of primitive types, and folds them. That is, it will make them into multi-dimensional arrays with a mapping between linear indexes and multi-dimensional indexes. We randomly fold the array either once or twice. The new dimensions will have length 2, so that each fold is a fold &amp;apos;in half&amp;apos; so to speak. We only use primitive types because strange problems can arise when folding arrays of references. We must place severe restrictions on the arrays which we can fold, because folded arrays are a fundamentally different type fom their unfolded selves. The canFold method acts as a filter to remove all the fields that cannot be folded. Specifically, each such field must pass the following tests: 1. First, we find the set of operands that might be &amp;apos;put&amp;apos; into the field f. Call it PUT(f). Also, we find the set of all &amp;apos;gets&amp;apos; of the field. Call it GET(f). It is convenient to label (PUT(f) union GET(f)) as ALL(f). 2. For each field f, PUT(f) must only contain ACONST_NULL or NEWARRAY instructions. This is to ensure that we can trace the origins of the field value, and avoid alias problems involving reference semantics. 3. For each i in ALL(f), make sure i is not: a. passed as a method parameter b. used in a CHECKCAST c. used in an INSTANCEOF d. stored in a different field e. stored into a different array f. returned from a method 4. For each i in ALL(f), find all instructions that may use i as an operand. For each of these instructions, look at the set of values each operand may take on. If one of these sets intersects ALL(f) but is not a subset of ALL(f), then f cannot be folded. (in other words, you can&amp;apos;t have a folded array and a non-folded array be used in the same place, because there would be a type conflict). Once all the foldable fields have been identified, we patch the instructions that access them. For each field f, we actually fold all arrays in PUT(f) (i.e. we replace all the NEWARRAY instructions with calls to SandmarkFolder.newarray, which will return a folded version of the array). We also replace all array instructions with static method calls to do the actual work. We only replace the instructions that we know act only upon the folded arrays. The other array instructions remain the same.">
			<comm cntt="for debugging only"/>
			<comm cntt="Determines if the given fields are safe to split with this algorithm. Ensures that: 1. Any PUTFIELD PUTSTATIC to the given field will only put an array that was allocated in the same method as the PUT. 2. Any GET from the field, or copy of the value from a PUT to that field will not be used inappropriately, as follows: a. passed as a method parameter b. stored inside another array c. returned from a method d. put into a different field Unsafe fields will be nulled out in the &amp;apos;fields&amp;apos; array. @return the uses of each field"/>
			<comm cntt="method to test for intersection of operands with ALL(f)"/>
			<comm cntt="(see comments at beginning of class)"/>
			<comm cntt="Adds the SandmarkFolder class to the application"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="SANDMARK_FOLDER" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.ArrayFolder()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.patchInstructions(sandmark.program.Method, int[], sandmark.program.Field[], java.util.HashSet[], java.util.HashSet[])" access="priv" jdoc="After finding all the foldable fields, this method will actually change all the instructions that manipulate them. @param method the method whose instructions will be patched. @param adddimensions an array, parallel to allfields, that holds the number of dimensions that were added to each array field. @param allfields the array of all the fields (unfoldable fields will be nulled out) @param newarrays the set of array-creating instructions that need to be patched. @param uses the instructions that use items in newarrays that need to be patched.">
				<comm cntt="newsig will look like &amp;quot;[,[B&amp;quot; for a byte array with one extra"/>
				<comm cntt="dimension added, or &amp;quot;[[,[B&amp;quot; for a byte array with 2 extra dimensions, etc."/>
				<comm cntt="don&amp;apos;t need to patch ACONST_NULL, just NEWARRAY"/>
				<comm cntt="replace with a call to SandmarkFolder.newarray(int,String)Object"/>
				<comm cntt="and then a cast to the right array type"/>
				<comm cntt=""/>
				<param name="method"/>
				<param name="adddimensions"/>
				<param name="allfields"/>
				<param name="newarrays"/>
				<param name="uses"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.getLongFieldName(sandmark.program.Field)" access="priv" jdoc="">
				<param name="field"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.apply(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="locate all single-dimension array fields with primite element type"/>
				<comm cntt="found all array fields, whittle them down"/>
				<comm cntt="canFold will null out elements of allfields and fill"/>
				<comm cntt="in elements of newarrays and myreferences."/>
				<comm cntt="the non-null elements of allfields should be safe to fold."/>
				<comm cntt="early termination check..."/>
				<comm cntt="keep going!!"/>
				<comm cntt="randomly decide how much to fold each array (once or twice)"/>
				<comm cntt="random{1,2}"/>
				<comm cntt="patch all the uses and the newarrays"/>
				<comm cntt="fix all the constant pool indexes for the field references"/>
				<comm cntt="end foreach method"/>
				<comm cntt="end foreach class"/>
				<comm cntt="now give the fields their new types"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.canFold(sandmark.program.Field[], java.util.HashSet[], sandmark.program.Application, sandmark.analysis.classhierarchy.ClassHierarchy, java.util.HashSet[])" access="prot" jdoc="">
				<comm cntt="for each field, the set of GETs of that field (handles)"/>
				<comm cntt="for each field, the set of values stored by PUTs into OTHER fields"/>
				<comm cntt="this list will contain all the values that are abused (handles)"/>
				<comm cntt="goes into newarrays[f]"/>
				<comm cntt="goes into otherputvalues[f]"/>
				<comm cntt="no more than one should match"/>
				<comm cntt="start looking for baddies"/>
				<comm cntt="this must be a dead instruction, skip"/>
				<comm cntt="this must be a dead instruction, skip"/>
				<comm cntt="end foreach method"/>
				<comm cntt="end foreach class"/>
				<comm cntt="check to see that each field is ok"/>
				<comm cntt="null --&amp;gt; method parameter (or caught exception or returnaddress?), not safe!"/>
				<comm cntt="find all uses of these fields and check that they can&amp;apos;t use anything else"/>
				<comm cntt="check stack"/>
				<comm cntt="stores"/>
				<comm cntt="check local"/>
				<comm cntt="check stack"/>
				<comm cntt="check stack"/>
				<comm cntt="check reference on which this is being invoked (not for static)"/>
				<comm cntt="end foreach method"/>
				<comm cntt="end foreach class"/>
				<param name="fields"/>
				<param name="newarrays"/>
				<param name="app"/>
				<param name="ch"/>
				<param name="myreferences"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.filterNormals(sandmark.program.Field[], java.util.HashSet[], java.util.HashSet[], java.util.HashSet[], sandmark.analysis.stacksimulator.StackData[], org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="fields"/>
				<param name="newarrays"/>
				<param name="mygets"/>
				<param name="uses"/>
				<param name="data"/>
				<param name="handle"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.addHelperClasses(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArrayFolder.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter" intfc="n" abs="n" inn="n" sloc="592" jdoc="Caveat: None of the split arrays can be passed to any java library method that attempts to use any array-specific instructions on them (because I can&amp;apos;t patch them).">
			<comm cntt="fix: putfield, putstatic, arraylength, aaload baload, caload, saload, daload, faload iaload, laload, aastore, bastore, castore sastore, dastore, fastore, iastore, lastore"/>
			<comm cntt="Determines if the given fields are safe to split with this algorithm. Ensures that: 1. Any PUTFIELD PUTSTATIC to the given field will only put an array that was allocated in the same method as the PUT. 2. Any GET from the field, or copy of the value from a PUT to that field will not be used inappropriately, as follows: a. passed as a method parameter b. stored inside another array c. returned from a method d. put into a different field Unsafe fields will be nulled out in the &amp;apos;fields&amp;apos; array."/>
			<const name="SANDMARK_HASHHOLDER" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.patchInstruction(org.apache.bcel.generic.InstructionHandle, sandmark.program.Method, java.util.ArrayList, java.util.ArrayList, sandmark.analysis.classhierarchy.ClassHierarchy)" access="priv" jdoc="">
				<comm cntt="LDC &amp;lt;fieldname&amp;gt; INVOKESTATIC SandmarkHashHolder.putvar(Object, String)Object CHECKCAST &amp;lt;type&amp;gt;[] SWAP DUP_X1 LDC &amp;lt;fieldname&amp;gt; INVOKESTATIC SandmarkHashHolder.getEnd(String)Object CHECKCAST &amp;lt;type&amp;gt;[] PUTFIELD &amp;lt;end&amp;gt; PUTFIELD &amp;lt;front&amp;gt;"/>
				<comm cntt="LDC &amp;lt;fieldname&amp;gt; INVOKESTATIC SandmarkHashHolder.putvar(Object, String)Object CHECKCAST &amp;lt;type&amp;gt;[] PUTSTATIC &amp;lt;front&amp;gt; LDC &amp;lt;fieldname&amp;gt; INVOKESTATIC SandmarkHashHolder.getEnd(String)Object CHECKCAST &amp;lt;type&amp;gt;[] PUTSTATIC &amp;lt;end&amp;gt;"/>
				<comm cntt=""/>
				<param name="handle"/>
				<param name="method"/>
				<param name="arrayfields"/>
				<param name="newfields"/>
				<param name="ch"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.apply(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="gather all fields with single-dimension array type"/>
				<comm cntt="if nothing is going to be split, exit"/>
				<comm cntt="make the end arrays for each split array"/>
				<comm cntt="patch every method in the application"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.canSplit(sandmark.program.Field[], sandmark.program.Application, sandmark.analysis.classhierarchy.ClassHierarchy)" access="prot" jdoc="">
				<comm cntt="for each field, the set of values that might be PUT into that field (handles)"/>
				<comm cntt="for each field, the set of GETs of that field (handles)"/>
				<comm cntt="for each field, the set of values stored by PUTs into OTHER fields"/>
				<comm cntt="this list will contain all the values that are abused (handles)"/>
				<comm cntt="goes into newarrays[f]"/>
				<comm cntt="goes into otherputvalues[f]"/>
				<comm cntt="no more than one should match"/>
				<comm cntt="start looking for baddies"/>
				<comm cntt="this must be a dead instruction, skip"/>
				<comm cntt="this must be a dead instruction, skip"/>
				<comm cntt="this must be a dead instruction, skip"/>
				<comm cntt="end foreach method"/>
				<comm cntt="end foreach class"/>
				<comm cntt="check to see that each field is ok"/>
				<comm cntt="null --&amp;gt; method parameter (or caught exception or returnaddress?), not safe!"/>
				<comm cntt="these 3 are ok, the rest are not"/>
				<param name="fields"/>
				<param name="app"/>
				<param name="ch"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.getSources(sandmark.program.Method, sandmark.analysis.stacksimulator.StackSimulator, sandmark.analysis.stacksimulator.StackData[])" access="prot" jdoc="Finds the instructions that made the values for the given list of stackdata. If any of the stackdata entries are ALOAD, then we trace through the local var to the ASTORE that put it there, and take those instructions. @return a HashSet full of handles (and possibly null)">
				<comm cntt="local should be full of ASTOREs, but might have some other things"/>
				<comm cntt="method parameter"/>
				<comm cntt="it might actually be another kind of STORE, because of strange things about JSRs"/>
				<param name="method"/>
				<param name="stack"/>
				<param name="argdata"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.addHelperClasses(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.ArrayObfuscation.ArraySplitter.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.addbogusfields">
		<class name="/:sandmark.obfuscate.addbogusfields.AddBogusFields" intfc="n" abs="n" inn="n" sloc="116" jdoc="The AddBogusFields obfuscator changes adds a bogus field to each class in an application and throughout the class makes assignments to the field. @author Ginger Myles and Miriam Miklofsky">
			<comm cntt="Embedding"/>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.AddBogusFields()" access="pub" jdoc="Constructor.">
			</mth>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.addbogusfields.AddBogusFields.apply(sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="choose a random field"/>
				<comm cntt="get info about chosen field"/>
				<comm cntt="create the bogus field"/>
				<comm cntt="get the methods"/>
				<comm cntt="for each method scan the instruction list for the chosen field"/>
				<comm cntt="get the instruction list for the method"/>
				<comm cntt="construct instruction list to insert"/>
				<comm cntt="now scan the instruction handles"/>
				<comm cntt="end if"/>
				<comm cntt="if it is an instance of a putfield then we need"/>
				<comm cntt="to add the assignment to the sister field right"/>
				<comm cntt="after it."/>
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="replace old instruction List with the new instruction list"/>
				<comm cntt="il.insert(ihs[0], insertList);"/>
				<comm cntt="update the class gen so that the changes to the method take hold"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<param name="cls"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.appendboguscode">
		<class name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode" intfc="n" abs="n" inn="n" sloc="118" jdoc="This is the AppendBogusCode class which appends code after the final statement of a method (this may crash some reverse engineering software). @author Justin Cappos (&amp;lt;a href=&amp;quot;mailto:justin@cs.arizona.edu&amp;quot;&amp;gt;justin@cs.arizona.edu&amp;lt; a&amp;gt;) @version 1.0, August 3rd, 2002">
			<comm cntt="This is just a test routine..."/>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.apply(sandmark.program.Method)" access="pub" jdoc="Performs the actual modification of the requested method...">
				<comm cntt="Nothing to do! (that was easy)"/>
				<comm cntt="Here is some nasty code that randomly adds instructions in..."/>
				<comm cntt="I may change this later to sample portions of the method and copy those instead..."/>
				<comm cntt="All done! Put it back together..."/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.getAlgURL()" access="pub" jdoc="Returns the URL at which you can find information about this obfuscator.">
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.getAlgHTML()" access="pub" jdoc="Returns an HTML description of this obfuscator.">
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.getLongName()" access="pub" jdoc="Returns a long description of this obfuscator&amp;apos;s name.">
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.getShortName()" access="pub" jdoc="Returns a short description of this obfuscator&amp;apos;s name.">
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.getMutations()" access="pub" jdoc="">
				<comm cntt="thread safe, reflection safe"/>
			</mth>
			<mth name="/:sandmark.obfuscate.appendboguscode.AppendBogusCode.getPostprohibited()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.blockmarker">
		<class name="/:sandmark.obfuscate.blockmarker.BlockMarker" intfc="n" abs="n" inn="n" sloc="114" jdoc="">
			<const name="MARK_PROBABILITY" access="priv" jdoc=""/>
			<field name="r" access="priv" jdoc=""/>
			<field name="markCount" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.BlockMarker()" access="pub" jdoc="">
				<comm cntt="new java.util.Random();"/>
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.nextValue()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.markMethod(sandmark.program.LocalMethod, sandmark.watermark.util.BasicBlockMarker, boolean)" access="priv" jdoc="">
				<param name="method"/>
				<param name="marker"/>
				<param name="isLastMethod"/>
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.markClass(sandmark.program.Class, sandmark.watermark.util.BasicBlockMarker, boolean)" access="priv" jdoc="">
				<comm cntt="we just don&amp;apos;t mark empty methods"/>
				<param name="clazz"/>
				<param name="marker"/>
				<param name="isLastClass"/>
			</mth>
			<mth name="/:sandmark.obfuscate.blockmarker.BlockMarker.apply(sandmark.program.Application)" access="pub" jdoc="&amp;lt;STRONG&amp;gt; Not yet implemented; needs to be written and documented. &amp;lt; STRONG&amp;gt;">
				<comm cntt="System.out.println(&amp;quot;marked &amp;quot; + markCount + &amp;quot; blocks&amp;quot;);"/>
				<param name="app"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.boguspredicates">
		<class name="/:sandmark.obfuscate.boguspredicates.bogusPredicates" intfc="n" abs="n" inn="n" sloc="182" jdoc="">
			<const name="DEBUG" access="pub" jdoc=""/>
			<field name="pred_list" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.bogusPredicates()" access="pub" jdoc="">
				<comm cntt="A list of carefully chosen predicates are maintained as a list"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.apply(sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="new java.util.Random();"/>
				<comm cntt="new java.util.Random();"/>
				<comm cntt="end while"/>
				<comm cntt="mgen.update();"/>
				<comm cntt="methods[k] = mgen.getMethod();"/>
				<comm cntt="methodEditor.commit();"/>
				<comm cntt="end of for"/>
				<comm cntt="cg.setMethods(methods);"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boguspredicates.bogusPredicates.getMutations()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.boolsplitter">
		<class name="/:sandmark.obfuscate.boolsplitter.BoolSplitter" intfc="n" abs="n" inn="n" sloc="370" jdoc="">
			<comm cntt=""/>
			<comm cntt="private void replace(sandmark.analysis.stacksimulator.StackData[] sd) { org.apache.bcel.generic.InstructionHandle tempih; java.util.ArrayList llist=new java.util.ArrayList(); for(int parse=0;parse&amp;lt;sd.length;parse++){ tempih=sd[parse].getInstruction(); if(tempih!=null &amp;&amp; !llist.contains(tempih)){ il.append(tempih,new org.apache.bcel.generic.ICONST(0)); llist.add(tempih); } } }"/>
			<field name="mg" access="pub" jdoc=""/>
			<field name="cfg" access="pub" jdoc=""/>
			<field name="il" access="pub" jdoc=""/>
			<field name="ih" access="pub" jdoc=""/>
			<field name="ihandle" access="pub" jdoc=""/>
			<field name="boollist" access="pub" jdoc=""/>
			<field name="nonboollist" access="pub" jdoc=""/>
			<field name="unknownlist" access="pub" jdoc=""/>
			<field name="cn" access="pub" jdoc=""/>
			<field name="st" access="pub" jdoc=""/>
			<field name="endflag" access="pub" jdoc=""/>
			<field name="indexmap" access="pub" jdoc=""/>
			<field name="dynamicRandom" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.setConfigProperties(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.apply(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="replBoolArrays();"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.replBoolArrays()" access="priv" jdoc="">
				<comm cntt="array, index, value"/>
				<comm cntt="index, value, array, index, value"/>
				<comm cntt="index, value, array, index"/>
				<comm cntt="index, value, index, array, index"/>
				<comm cntt="index, value, index, array"/>
				<comm cntt="index, value, index, array, array"/>
				<comm cntt="index, value, array, array, index, array, array"/>
				<comm cntt="index, value, array, array, index, array"/>
				<comm cntt="index, value, array, array, index"/>
				<comm cntt="index, value, array, array, index, 1"/>
				<comm cntt="index, value, array, array, (index&amp;lt;&amp;lt;1)"/>
				<comm cntt="index, value, array, array, (index&amp;lt;&amp;lt;1), (index&amp;lt;&amp;lt;1)"/>
				<comm cntt="index, value, array, (index&amp;lt;&amp;lt;1), array, (index&amp;lt;&amp;lt;1), (index&amp;lt;&amp;lt;1)"/>
				<comm cntt="index, value, array, (index&amp;lt;&amp;lt;1), array, (index&amp;lt;&amp;lt;1)"/>
				<comm cntt="index, value, array, (index&amp;lt;&amp;lt;1), array, (index&amp;lt;&amp;lt;1), 1"/>
				<comm cntt="index, value, array, (index&amp;lt;&amp;lt;1), array, (index&amp;lt;&amp;lt;1)+1"/>
				<comm cntt="index, value, array, (index&amp;lt;&amp;lt;1), array, (index&amp;lt;&amp;lt;1)+1, 0"/>
				<comm cntt="index, value, array, (index&amp;lt;&amp;lt;1) stored 0 into array[(index&amp;lt;&amp;lt;1)+1]"/>
				<comm cntt="index, (index&amp;lt;&amp;lt;1), value, array, (index&amp;lt;&amp;lt;1)"/>
				<comm cntt="index, (index&amp;lt;&amp;lt;1), value, array"/>
				<comm cntt="index, array, (index&amp;lt;&amp;lt;1), value, array"/>
				<comm cntt="index, array, (index&amp;lt;&amp;lt;1), value"/>
				<comm cntt="BASTORE"/>
				<comm cntt="index stored value into array[index&amp;lt;&amp;lt;1]"/>
				<comm cntt="&amp;lt;empty&amp;gt;"/>
				<comm cntt="array, index"/>
				<comm cntt="array, index, 1"/>
				<comm cntt="array, (index&amp;lt;&amp;lt;1)"/>
				<comm cntt="array, (index&amp;lt;&amp;lt;1), array, (index&amp;lt;&amp;lt;1)"/>
				<comm cntt="array, (index&amp;lt;&amp;lt;1), array, (index&amp;lt;&amp;lt;1), 1"/>
				<comm cntt="array, (index&amp;lt;&amp;lt;1), array, (index&amp;lt;&amp;lt;1)+1"/>
				<comm cntt="array, (index&amp;lt;&amp;lt;1), array[(index&amp;lt;&amp;lt;1)+1]"/>
				<comm cntt="array[(index&amp;lt;&amp;lt;1)+1], array, (index&amp;lt;&amp;lt;1), array[(index&amp;lt;&amp;lt;1)+1]"/>
				<comm cntt="array[(index&amp;lt;&amp;lt;1)+1], array, (index&amp;lt;&amp;lt;1)"/>
				<comm cntt="BALOAD"/>
				<comm cntt="array[(index&amp;lt;&amp;lt;1)+1], array[index&amp;lt;&amp;lt;1]"/>
				<comm cntt="array[(index&amp;lt;&amp;lt;1)+1]^array[index&amp;lt;&amp;lt;1]"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.detectBoolVariables()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.splitBoolVariables()" access="priv" jdoc="">
				<comm cntt="put random boolean value into the new local slots corresponding to parameter booleans"/>
				<comm cntt="Now we need to fix any BranchInstructions whose target is an ISTORE"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.insertDynamicRandom()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.insertDynamicRandom(org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.isboolarray(sandmark.analysis.stacksimulator.StackData[])" access="priv" jdoc="">
				<param name="sd"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.acceptable(sandmark.analysis.stacksimulator.StackData[])" access="priv" jdoc="">
				<comm cntt="this is ok too"/>
				<param name="sd"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.addbool(int)" access="priv" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.addnonbool(int)" access="priv" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.addunknownbool(int)" access="priv" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.boolsplitter.BoolSplitter.removebool(int)" access="priv" jdoc="">
				<param name="index"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.branchinsertion">
		<class name="/:sandmark.obfuscate.branchinsertion.BranchInsertion" intfc="n" abs="n" inn="n" sloc="105" jdoc="">
			<field name="mRatio" access="priv" jdoc=""/>
			<field name="mProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.apply(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;inserted &amp;quot; + insertedBranches + &amp;quot; branches&amp;quot;);"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="props"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion.getMutations()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2" intfc="n" abs="n" inn="n" sloc="100" jdoc="">
			<field name="mRatio" access="priv" jdoc=""/>
			<field name="mProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.apply(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;RATIO: &amp;quot; + mRatio);"/>
				<comm cntt="System.out.println(&amp;quot;inserted &amp;quot; + insertedBranches + &amp;quot; branches&amp;quot;);"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.propertyChanged(sandmark.util.ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="props"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.branchinsertion.BranchInsertion2.getMutations()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.buggycode">
		<class name="/:sandmark.obfuscate.buggycode.BugCode" intfc="n" abs="n" inn="n" sloc="351" jdoc="">
			<comm cntt="returns an instruction list that performs a random manipulation on an integer local."/>
			<comm cntt="each one will load it, mess with it, then store it."/>
			<comm cntt="returns a random value in the range 0--(high-1)"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="USE_OP_LIB" access="priv" jdoc=""/>
			<const name="mutations" access="priv" jdoc=""/>
			<const name="preprohib" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.containsException(sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="Tests to see if any instruction in this BB is the target of a CodeExceptionGen. (i.e. if this BB spans the start or end of an exception block boundary)">
				<param name="blk"/>
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.apply(sandmark.program.Method)" access="pub" jdoc="Applies the buggy code obfuscation. The &amp;apos;bug&amp;apos; in question is just to randomly change the value of an integer local variable. If no integer locals exist, we add one.">
				<comm cntt="select a local INT variable, store its index in targetVar"/>
				<comm cntt=""/>
				<comm cntt="make testBlock just an opaquely true jump to bb, and redirect"/>
				<comm cntt="all the targeters of bb&amp;apos;s first instruction to testBlock."/>
				<comm cntt="the fallthrough block of the opaquely true IFEQ will be buggy code &amp;gt;:-)"/>
				<comm cntt="testBlock will consist of &amp;apos;nop, ifeq&amp;apos; and will have stuff"/>
				<comm cntt="inserted into it later with opaque predicates"/>
				<comm cntt="reset the all branch targeters of this bb to be the new jump"/>
				<comm cntt=""/>
				<comm cntt="this has to be after the def&amp;apos;n of testBlock"/>
				<comm cntt="insert a bug code in the new block copy"/>
				<comm cntt="cleanup"/>
				<param name="mObj"/>
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getRandomBug(org.apache.bcel.generic.InstructionList, int)" access="priv" jdoc="">
				<param name="ilist"/>
				<param name="localindex"/>
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.chooseBB(sandmark.program.Method, sandmark.analysis.controlflowgraph.MethodCFG)" access="priv" jdoc="">
				<comm cntt="search for a bb with the following properties:"/>
				<comm cntt="1. not in a subroutine (doesn&amp;apos;t end in RET)"/>
				<comm cntt="2. not inside an exception handler"/>
				<comm cntt="3. does not end with an uninitialized object on top of the stack"/>
				<comm cntt="should this also check getStackAt(i)[j] for all j?"/>
				<param name="mObj"/>
				<param name="mcfg"/>
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.makeCopiedBlock(sandmark.program.Method, sandmark.analysis.controlflowgraph.MethodCFG, sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="This method creates the bogus buggy fallthrough block, and updates the CFG accordingly. @returns the new copied buggy block">
				<comm cntt="else, fall through for the opaque branch will be the new bug block create the new block and insert it above the &amp;apos;start_ih&amp;apos; ie. original block"/>
				<comm cntt="copy the contents of bb&amp;apos;s instruction list into copiedBlock"/>
				<comm cntt="insert the same instruction for new block;"/>
				<comm cntt="redundant?"/>
				<comm cntt="get the fall through instruction handle (if any)"/>
				<comm cntt="for the target basic block"/>
				<comm cntt="if bb had a fallthrough, add a block after bb to GOTO it"/>
				<param name="mObj"/>
				<param name="mcfg"/>
				<param name="bb"/>
				<param name="testBlock"/>
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getRandomValue(int)" access="priv" jdoc="">
				<param name="high"/>
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.initializeNextLocal(sandmark.program.Method, sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="This method initializes the next local var (at index method.getMaxLocals()) to be a random integer value. The code to do that will be inserted at the start of the given basic block.">
				<param name="mg"/>
				<param name="bb"/>
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getMutations()" access="pub" jdoc="Returns a list of the changes that this algorithm makes to the code.">
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.getPreprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.buggycode.BugCode.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.classsplitter">
		<class name="/:sandmark.obfuscate.classsplitter.ClassSplitter" intfc="n" abs="n" inn="n" sloc="316" jdoc="To be brief ,the splitting technique splits at the class level. A class C is broken into classes C 1 , C 2 ...C n -1 and C ,such that C 2 inherits from C 1 ... and C inherits from C n-1. C 1 has fields and methods that only refer to themselves, whereas C 2 has fields and methods that can refer to themselves as well as fields and methods in C1 .">
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.apply(sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="do not apply to classes that implement any interfaces"/>
				<comm cntt="make all methods, fields, and classes public (and nonfinal)"/>
				<comm cntt="the number of new classes we split cls into will be equal to topoLevels.size()"/>
				<comm cntt="XXXash: this is a hack to workaround addEmptyConstructor sometimes"/>
				<comm cntt="calling the wrong parent constructor. It should be called only on"/>
				<comm cntt="the original class, whose constructor really does need to be changed"/>
				<comm cntt="to call the constructor of its new superclass"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.topoLevelSort(sandmark.util.newgraph.MutableGraph, sandmark.program.Class)" access="priv" jdoc="Returns a topological sort of the dependency graph, filtering out the &amp;apos;pegged&amp;apos; members. The actual innards of the returned list are hashtables which hash the name type of the members to the members themselves. The order of hashtables in the list is such that everything in a given table has all of its DG successors in an earlier (or the same) list. Because of the filtering, pegged members and methods pointing to pegged members will be in the last hashtable. This method will destroy the given DG.">
				<comm cntt="add member if it is not pegged and all of its"/>
				<comm cntt="successors are already in the table"/>
				<comm cntt="everything else must be in the last level, by definition (even pegged things???)"/>
				<param name="depGraph"/>
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.findPeggedObjects(sandmark.program.Class)" access="priv" jdoc="Returns a hashtable full of all the &amp;apos;pegged&amp;apos; methods and fields in this class. A pegged member is one of: &amp;lt;br&amp;gt; a method that returns an instance of its enclosing class,&amp;lt;br&amp;gt; a method that takes an instance of its enclosing class as a parameter, &amp;lt;br&amp;gt; a static method, &amp;lt;br&amp;gt; an abstract method, &amp;lt;br&amp;gt; a native method, &amp;lt;br&amp;gt; a constructor, &amp;lt;br&amp;gt; a static field, &amp;lt;br&amp;gt; or a field of the same type as its enclosing class.&amp;lt;br&amp;gt; Pegged members cannot leave the original class. They must not be moved to one of the new superclasses.">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.fixupMethods(sandmark.program.Class, sandmark.program.Class)" access="priv" jdoc="For every method or field reference in copiedClass where oldClass is the enclosing class of that field or method, change it so that copiedClass is the new enclosing class.">
				<comm cntt="for each field or method instruction..."/>
				<comm cntt="only apply when the enclosing class is oldClass"/>
				<comm cntt="reset all method invocations to be from copiedClass"/>
				<comm cntt="if (!makecast){ check to see if we will need to do our checkcast hack org.apache.bcel.generic.Type[] argtypes = ii.getArgumentTypes(cpg); for (int a=0;a&amp;lt;argtypes.length;a++){ if (argtypes[a].getSignature().equals(&amp;quot;L&amp;quot;+oldClass.getName().replace(&amp;apos;.&amp;apos;,&amp;apos; &amp;apos;)+&amp;quot;;&amp;quot;)){ makecast = true; break; } } }"/>
				<comm cntt="only if this is not &amp;lt;init&amp;gt;"/>
				<comm cntt="if there was a method call in this method that took oldClass as a parameter,"/>
				<comm cntt="and this is not copiedClass&amp;apos;s constructor..."/>
				<comm cntt="this hack just takes &amp;apos;this&amp;apos; and casts it to oldClass,"/>
				<comm cntt="so that it can be safely passed to the method"/>
				<param name="copiedClass"/>
				<param name="oldClass"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.fixupConstructors(sandmark.program.Class)" access="priv" jdoc="For every constructor in this class, it changes every call to a superconstructor to be a call to the immediate superclass&amp;apos;s superconstructor.">
				<comm cntt="There is a slight issue with this method. Consider a class B that extends A,"/>
				<comm cntt="but in B&amp;apos;s constructor it also makes another separate instance of A. Then B&amp;apos;s &amp;lt;init&amp;gt;"/>
				<comm cntt="method will contain 2 references to A.&amp;lt;init&amp;gt;, but only one should be changed to"/>
				<comm cntt="reflect the class splitting. We do dataflow analysis using the StackSimulator"/>
				<comm cntt="to deal with this."/>
				<comm cntt="for each constructor.."/>
				<comm cntt="if the owner of this superconstructor is an ancestor of clazz.."/>
				<comm cntt="do dataflow analysis to see if this is the right init call"/>
				<comm cntt="stack height of &amp;apos;this&amp;apos; will be argtypes.length"/>
				<comm cntt="this stack item came from a parameter (or &amp;apos;this&amp;apos;)"/>
				<comm cntt="call the immediate superclass&amp;apos;s constructor instead"/>
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.isSuperClass(java.lang.String, sandmark.program.Class)" access="priv" jdoc="Checks to see if superClassName is the name of an ancestor of subClass (where a class is defined to be an ancestor of itself).">
				<param name="superClassName"/>
				<param name="subClass"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.tableContainsItems(java.util.Hashtable, java.util.Iterator)" access="priv" jdoc="Returns true iff the given hashtable contains all the items in the given iterator as keys.">
				<param name="table"/>
				<param name="itemIt"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.fieldOrMethodKey(sandmark.program.Object)" access="priv" jdoc="Returns a string name for the given sandmark Object. Either fieldname+fieldsig or methodname+methodsig.">
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.trimClass(sandmark.program.Class, java.util.Hashtable)" access="priv" jdoc="trimclass trims the classfile&amp;apos;s contents to hold only those fields and methods that the topological sort of the DG asks it to have .">
				<param name="clazz"/>
				<param name="fieldsAndMethods"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.addPassthroughConstructors(sandmark.program.Class)" access="pub" jdoc="Removes all the constructors of a class and adds in new constructors that simply wrap the constructors of the immediate superclass.">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.ClassSplitter()" access="pub" jdoc="Constructor">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.ClassSplitter.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.classsplitter.FalseRefactor" intfc="n" abs="n" inn="n" sloc="107" jdoc="">
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.apply(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.doRefactoring(sandmark.program.Class, sandmark.program.Class, String)" access="pub" jdoc="">
				<param name="class1"/>
				<param name="class2"/>
				<param name="baseClassName"/>
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.classsplitter.FalseRefactor.getMutations()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.dynamicinliner">
		<class name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner" intfc="n" abs="n" inn="n" sloc="310" jdoc="">
			<comm cntt="apply()"/>
			<comm cntt="Inline a virtual method call, if it is accessible"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="inlineCount" access="priv" jdoc=""/>
			<field name="firstUnusedLocal" access="priv" jdoc=""/>
			<field name="method" access="priv" jdoc=""/>
			<field name="invokedMethod" access="priv" jdoc=""/>
			<field name="hier" access="priv" jdoc=""/>
			<field name="ihs" access="priv" jdoc=""/>
			<field name="inliner" access="priv" jdoc=""/>
			<field name="inlinedMethods" access="priv" jdoc=""/>
			<field name="app" access="priv" jdoc=""/>
			<field name="is" access="priv" jdoc=""/>
			<field name="clazz" access="priv" jdoc=""/>
			<field name="firstTime" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.DynamicInliner()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.apply(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="Make a map"/>
				<comm cntt="Go through all the classes"/>
				<comm cntt="Go through all the methods"/>
				<comm cntt="Go through all the instructions"/>
				<comm cntt="Check if the instruction is an invoke"/>
				<comm cntt="start"/>
				<comm cntt="methods"/>
				<comm cntt="classes"/>
				<param name="application"/>
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.inlineVirtual()" access="priv" jdoc="">
				<comm cntt="We dont know what method to use, put all possibles"/>
				<comm cntt="into a vector"/>
				<comm cntt="Bad things happen when an exception handler uses the invoke"/>
				<comm cntt="as the endPC. Save those handlers so we can update endPC&amp;apos;s later"/>
				<comm cntt="Store the last inst for all branches to end up at"/>
				<comm cntt="We need to find the objref which is down the stack somewhere"/>
				<comm cntt="Store that ref and generate a load inst to load it when"/>
				<comm cntt="needed."/>
				<comm cntt="the first method doesn&amp;apos;t need a branch, because it will become"/>
				<comm cntt="the last inlined method, i.e. the else branch"/>
				<comm cntt="Now inline a branch for each method in the vector"/>
				<comm cntt="We still have the call in there, take it out"/>
				<comm cntt="Fix the exception handlers we broke"/>
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getExceptions(org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.inlineBranch(org.apache.bcel.generic.ConstantPoolGen, org.apache.bcel.generic.Instruction, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<comm cntt="If the invokedMethod is empty, just return"/>
				<comm cntt="Add the class to the constant pool, if not already there"/>
				<comm cntt="..,invoke,..-&amp;gt;..,load objref,instof,ifeq-&amp;gt;next,invoke,goto-&amp;gt;end,..."/>
				<comm cntt="or just inline the method"/>
				<comm cntt="Now we can just replace the invoke with the method"/>
				<comm cntt="now add the call back so we can do it all again"/>
				<comm cntt="if(DEBUG) System.out.println(list);"/>
				<param name="cpg"/>
				<param name="load"/>
				<param name="end"/>
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getLoadInst(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, sandmark.program.Method)" access="priv" jdoc="Save the stack down to the object ref, then restore it, and return an instruction that loads the variable the object ref got saved to">
				<param name="callingMethod"/>
				<param name="callSite"/>
				<param name="calledMethod"/>
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.dynamicinliner.DynamicInliner.getMutations()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.encryptclasses">
		<class name="/:sandmark.obfuscate.encryptclasses.JarEncrypter" intfc="n" abs="n" inn="n" sloc="217" jdoc="">
			<field name="KEY_ALG" access="priv" jdoc=""/>
			<field name="CIPHER_ALG" access="priv" jdoc=""/>
			<field name="KEY_SIZE" access="priv" jdoc=""/>
			<field name="ENCRYPTED_LOADER_CURRENT_PATH" access="priv" jdoc=""/>
			<field name="ENCRYPTED_LOADER_CLASS_NAME" access="priv" jdoc=""/>
			<field name="USAGE" access="priv" jdoc=""/>
			<field name="KEY_FIELD_NAME" access="priv" jdoc=""/>
			<field name="MAIN_CLASS_FIELD_NAME" access="priv" jdoc=""/>
			<field name="hexStr" access="priv" jdoc=""/>
			<field name="mProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.apply(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.fixupLoader(java.io.InputStream, String, java.security.Key)" access="priv" jdoc="">
				<comm cntt="cg.setClassName(ENCRYPTED_LOADER_CLASS_NAME);"/>
				<param name="is"/>
				<param name="mainClassName"/>
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.generateKey(String)" access="priv" jdoc="">
				<param name="keyStr"/>
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getKeyStr(java.security.Key)" access="priv" jdoc="">
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.JarEncrypter.getMutations()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.encryptclasses.EncryptedClassLoader" intfc="n" abs="n" inn="n" sloc="82" jdoc="">
			<field name="KEY_ALG" access="priv" jdoc=""/>
			<field name="CIPHER_ALG" access="priv" jdoc=""/>
			<field name="sKeyStr" access="priv" jdoc=""/>
			<field name="sMainClassName" access="priv" jdoc=""/>
			<field name="mKey" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.encryptclasses.EncryptedClassLoader.EncryptedClassLoader()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.EncryptedClassLoader.findClass(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.EncryptedClassLoader.loadClassData(String)" access="priv" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.obfuscate.encryptclasses.EncryptedClassLoader.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.exceptionbranches">
		<class name="/:sandmark.obfuscate.exceptionbranches.DispatcherException" intfc="n" abs="n" inn="n" sloc="289" jdoc="This is the dispatcher class that gets added to each jarfile that has been obfuscated with ExceptionBranches. It maintains a static hashtable of position values to their corresponding lists of exceptions to throw. For switch statements, it also hashes their positions to their list of integer matches, and their &amp;apos;default&amp;apos; exceptions to throw. These hashtables are built up by having obfuscated classes make calls to DispatcherException.register and DispatcherException.registerSwitch. This class is not used by the obfuscation itself, only the obfuscated jarfile. This class is also an Exception class, so that if anything goes wrong with returning an instance of the correct exception type, a DispatcherException with be returned instead of the correct exception type.">
			<comm cntt="these constants define all the different integer &amp;apos;if&amp;apos; statements"/>
			<comm cntt=""/>
			<comm cntt="hashes Integers to String[]s"/>
			<comm cntt="hashes Integers to int[]s"/>
			<comm cntt="hashes Integers to Strings"/>
			<comm cntt="hashes String names to instances"/>
			<comm cntt=""/>
			<comm cntt="a helper method for code-factoring"/>
			<comm cntt=""/>
			<comm cntt="a helper method for code-factoring"/>
			<comm cntt=""/>
			<comm cntt="replaces a &amp;apos;goto&amp;apos; or &amp;apos;goto_w&amp;apos; instruction"/>
			<comm cntt="replaces a &amp;apos;lookupswitch&amp;apos; or &amp;apos;tableswitch&amp;apos; instruction"/>
			<const name="IF_ICMPEQ" access="priv" jdoc=""/>
			<const name="IF_ICMPGE" access="priv" jdoc=""/>
			<const name="IF_ICMPGT" access="priv" jdoc=""/>
			<const name="IF_ICMPLE" access="priv" jdoc=""/>
			<const name="IF_ICMPLT" access="priv" jdoc=""/>
			<const name="IF_ICMPNE" access="priv" jdoc=""/>
			<const name="IFEQ" access="priv" jdoc=""/>
			<const name="IFGE" access="priv" jdoc=""/>
			<const name="IFGT" access="priv" jdoc=""/>
			<const name="IFLE" access="priv" jdoc=""/>
			<const name="IFLT" access="priv" jdoc=""/>
			<const name="IFNE" access="priv" jdoc=""/>
			<field name="position2classes" access="priv" jdoc=""/>
			<field name="position2matches" access="priv" jdoc=""/>
			<field name="position2default" access="priv" jdoc=""/>
			<field name="name2instance" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.DispatcherException(String)" access="pub" jdoc="Standard exception class constructor">
				<param name="message"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.register(int, String)" access="pub" jdoc="Called by &amp;lt;clinit&amp;gt; methods to register branches with their exception types. This is only for ifs and gotos. @param position a globally unique integer representing a given branch instruction. @param class a String of the following form &amp;quot;name1=name2=name3&amp;quot; where the nameX are the fully-qualified classnames of the various exception types, in the right order. (i.e. &amp;quot;sandmark.obfuscate.exceptionbranches.SandmarkException1=sandmark.obfuscate.exceptionbranches.SandmarkException2=&amp;quot;)">
				<param name="position"/>
				<param name="classes"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.registerSwitch(int, String, String, String)" access="pub" jdoc="Similar to register, but for switch statements. @param position a globally unique integer representing a given switch instruction. @param matches a string of the integer matches for this switch, separated by &amp;apos;=&amp;apos; characters (i.e. &amp;quot;1=2=3=4=5436756928&amp;quot;) @param classes a string of exception classnames separated by &amp;apos;=&amp;apos; characters (see register). @param defaultclass the name of the exception to throw on the &amp;apos;default&amp;apos; case">
				<param name="position"/>
				<param name="matches"/>
				<param name="classes"/>
				<param name="defaultclass"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_acmpeq(Object, Object, int)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_acmpne(Object, Object, int)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.ifnonnull(Object, int)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.ifnull(Object, int)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_binaryop(int, int, int, short)" access="priv" jdoc="">
				<param name="i1"/>
				<param name="i2"/>
				<param name="position"/>
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_icmpeq(int, int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="i2"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_icmpge(int, int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="i2"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_icmpgt(int, int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="i2"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_icmple(int, int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="i2"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_icmplt(int, int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="i2"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_icmpne(int, int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="i2"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.if_unaryop(int, int, short)" access="priv" jdoc="">
				<param name="i1"/>
				<param name="position"/>
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.ifeq(int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.ifge(int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.ifgt(int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.ifle(int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.iflt(int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.ifne(int, int)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.dogoto(int)" access="pub" jdoc="">
				<param name="position"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.DispatcherException.doswitch(int, int)" access="pub" jdoc="">
				<param name="value"/>
				<param name="position"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches" intfc="n" abs="n" inn="n" sloc="444" jdoc="This class changes all branches (except JSRs) into &amp;apos;throw&amp;apos; instructions. For an &amp;apos;if&amp;apos; statement there are 2 possible targets -- the fallthrough and the branch. This can be replicated by throwing one of 2 different exception types, placing handlers around that &amp;apos;throw&amp;apos; which will redirect control flow to the appropriate place. But of course, knowing which exception to throw would be directly related to the runtime values of the &amp;apos;if&amp;apos; operands. So we make a static helper method that will take these 2 values and return a subclass of Throwable, which will be the appropriate exception to cause the hander to go to the right place. Similar schemes work for goto instrutions and switch statements. The helper class we use is DispatcherException (formerly &amp;apos;Dispatcher&amp;apos;, but it became convenient to make it an exception type itself). The dispatcher has many static helper methods that are designed to emulate the behaviors of various branch instructions, but return Throwable instances. In order to know which exceptions it should return when, each obfuscated class has had its &amp;lt;clinit&amp;gt; augmented to make calls to DispatcherException.register or Dispatcher.registerSwitch. These methods assign a globally unique ID number to each branch point, and these ID numbers are also hashkeys that map to a list of exceptions. When you register an &amp;apos;if&amp;apos; statement in the dispatcher, you give it 2 exception class types (order is important) and the first one will be used if the comparison succeeds, the second if it fails. Instances of these exception classes are created at runtime via Class.forName(exceptionName).newInstance(). To simplifyy this entire scheme, we only replace branches at which there is an empty stack (except for the operands needed by the branch instruction). That way, when the &amp;apos;throw&amp;apos; instruction destroys the stack, nothing is lost.">
			<comm cntt="global counter for position values"/>
			<comm cntt="the application in question"/>
			<comm cntt="true iff a call to addDispatcherClass has been made"/>
			<comm cntt="the global list of pre-made exception classes (sandmark.program.Class)"/>
			<field name="POSITION_ITERATOR" access="priv" jdoc=""/>
			<field name="app" access="priv" jdoc=""/>
			<field name="addedDispatcher" access="priv" jdoc=""/>
			<field name="exceptionList" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.ExceptionBranches(sandmark.program.Application)" access="pub" jdoc="Creates an ExceptionBranches instance for the given application. Only methods in this application can be obfuscated (it checks!).">
				<param name="_app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.ExceptionBranches()" access="pub" jdoc="">
				<comm cntt="this must be here!!"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.init(sandmark.program.Application)" access="priv" jdoc="">
				<param name="_app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.apply(sandmark.program.Method)" access="pub" jdoc="Apply the obfuscation to the given method. If the method has a null InstructionList (i.e. native or abstract interface), nothing happens.">
				<comm cntt="copy out the exception handlers"/>
				<comm cntt="(so i can add new exception handlers to the front of the list later)"/>
				<comm cntt="I will need to generate this many exception classes"/>
				<comm cntt="find all the branches with empty stacks"/>
				<comm cntt="if i didn&amp;apos;t find any good branches, quit"/>
				<comm cntt="create the exception classes"/>
				<comm cntt="the new exception handlers I will make"/>
				<comm cntt="maps Instructions to Integers"/>
				<comm cntt="maps Instructions to String[]s"/>
				<comm cntt="maps Select Instructions to int[]s"/>
				<comm cntt="add the global handlers for each exception"/>
				<comm cntt="if instructions will call DispatcherException.{ifeq, ifge, if_icmpeq, ...}"/>
				<comm cntt="the name of the static method will equal the instruction name."/>
				<comm cntt="we use &amp;apos;=&amp;apos; - delimited strings for simplicity of registering them later (see fixClinit)"/>
				<comm cntt="need 2 handlers since there are two possible targets"/>
				<comm cntt="goto instructions are replaced with DispatcherException.dogoto,"/>
				<comm cntt="since I can&amp;apos;t make a method called &amp;apos;goto&amp;apos;."/>
				<comm cntt="only 1 possible target"/>
				<comm cntt="LOOKUPSWITCH and TABLESWITCH instructions both act the same in theory..."/>
				<comm cntt="they just have different ways of organizing their match-target pairs."/>
				<comm cntt="they both get replaced with DispatcherException.doswitch"/>
				<comm cntt="there&amp;apos;s matches.length+1 handlers, since the matches don&amp;apos;t include the &amp;apos;default&amp;apos; case."/>
				<comm cntt="now add ACONST_NULL and POP everywhere, so that fallthroughs still work"/>
				<comm cntt="i.e: ACONST_NULL"/>
				<comm cntt="POP"/>
				<comm cntt="&amp;lt;old branch target&amp;gt;"/>
				<comm cntt="...."/>
				<comm cntt=""/>
				<comm cntt="(then we redirect all branches from old target to the POP)"/>
				<comm cntt="update clinit to make calls to DispatcherException.register"/>
				<comm cntt="and DispatcherException.registerSwitch"/>
				<comm cntt="clear then out of the Method since we kept backups"/>
				<comm cntt="add in the new handlers, then null out their targets"/>
				<comm cntt="add in the old handlers, then null out their targets"/>
				<comm cntt="add the DispatcherException class to the jar (if not already there)"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.addDispatcherClass()" access="priv" jdoc="This method will add DispatcherException to the jar, if it hasn&amp;apos;t been added already">
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.fixClinit(sandmark.program.Method, java.util.Hashtable, java.util.Hashtable, java.util.Hashtable)" access="priv" jdoc="Updates adds the &amp;lt;clinit&amp;gt; method to the parent class, to add calls to DispctaherException.register and DispatcherException.registerSwitch.">
				<comm cntt="if it doesn&amp;apos;t exist, make it!"/>
				<comm cntt="register each branch"/>
				<param name="method"/>
				<param name="branch2position"/>
				<param name="branch2exceptions"/>
				<param name="switch2matches"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.updateTargeters(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="This method does smart targeter updating. @param old the old target @param top the first instruction of the new list replacing &amp;apos;old&amp;apos; @param bottom the last instruction of the new list replacing &amp;apos;old&amp;apos;">
				<comm cntt="if there are no targeters, &amp;apos;targeters&amp;apos; will be null (bad design!!)"/>
				<comm cntt="the only difference is that you probably want any exception handlers ending"/>
				<comm cntt="at &amp;apos;old&amp;apos; to now end at &amp;apos;bottom&amp;apos; rather than &amp;apos;top&amp;apos;."/>
				<param name="old"/>
				<param name="top"/>
				<param name="bottom"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.makeExceptionClasses(sandmark.program.Method, int)" access="priv" jdoc="This will make, add, and return the list of exception classes needed for a given method. There will be exactly &amp;apos;howmany&amp;apos; of them. (&amp;quot;There are howmany?&amp;quot; &amp;quot;Exactly!&amp;quot;). They might not actually be created by this call... we cache classes so that we can reuse them between methods.">
				<comm cntt="try to take as many as we can from the list of already-made ones"/>
				<comm cntt="if you need more, make &amp;apos;em"/>
				<comm cntt="these classes directly extend Throwable and"/>
				<comm cntt="have nothing but a no-arg constructor that just calls super()."/>
				<param name="method"/>
				<param name="howmany"/>
			</mth>
			<mth name="/:sandmark.obfuscate.exceptionbranches.ExceptionBranches.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.inliner">
		<class name="/:sandmark.obfuscate.inliner.Inliner" intfc="n" abs="n" inn="n" sloc="119" jdoc="">
			<mth name="/:sandmark.obfuscate.inliner.Inliner.apply(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;methods inlined: &amp;quot; + inlineCount);"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.stackContainsUninitialized(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.containsBadInvokes(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.inliner.Inliner.getMutations()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.insertopaquepred">
		<class name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred" intfc="n" abs="n" inn="n" sloc="108" jdoc="">
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.insertopaquepred.InsertOpaquePred.apply(sandmark.program.Method)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.instructionordering">
		<class name="/:sandmark.obfuscate.instructionordering.InstructionOrdering" intfc="n" abs="n" inn="n" sloc="174" jdoc="">
			<comm cntt="class BlockComparator"/>
			<field name="myCpg" access="pub" jdoc=""/>
			<field name="mg" access="pub" jdoc=""/>
			<field name="cfg" access="pub" jdoc=""/>
			<field name="dgr" access="pub" jdoc=""/>
			<field name="met" access="pub" jdoc=""/>
			<field name="il" access="pub" jdoc=""/>
			<field name="ih" access="pub" jdoc=""/>
			<field name="exceptions" access="pub" jdoc=""/>
			<field name="ihandle" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.apply(sandmark.program.Method)" access="pub" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.doMethod()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.reorderinstruction()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.writeback(sandmark.util.newgraph.MutableGraph, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="reorderGraph"/>
				<param name="lastih"/>
			</mth>
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering.getTopological(sandmark.util.newgraph.MutableGraph, java.util.HashMap)" access="pub" jdoc="">
				<param name="reorderGraph"/>
				<param name="NToM"/>
			</mth>
		<class name="/:sandmark.obfuscate.instructionordering.InstructionOrdering$BlockComparator" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<mth name="/:sandmark.obfuscate.instructionordering.InstructionOrdering$BlockComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.interleavemethods">
		<class name="/:sandmark.obfuscate.interleavemethods.Interleaver" intfc="n" abs="n" inn="n" sloc="679" jdoc="This class allows you to interleave two methods. It returns an &amp;lt;link&amp;gt;sandmark.obfuscate.interleavemethods.InterleavedMethod&amp;lt; link&amp;gt;. You may pass it the bytes you wish to use as the key values, or let the Interleave choose them itself (after which you can retrieve them from the returned InterleavedMethod). Note that A and B are not removed from the class.">
			<comm cntt="Move all exceptions into C, with the updated IH&amp;apos;s, of course."/>
			<comm cntt="This involves splitting any single Exc. Hand. that go across"/>
			<comm cntt="blocks."/>
			<comm cntt="If EndOfException is in same block as ih, return EndOfException."/>
			<comm cntt="else return the last instruction in the block"/>
			<comm cntt="For every InstructionList in list, see if it has a"/>
			<comm cntt="load which doesnt come after a store. Also check if it stores"/>
			<comm cntt="an array. If so, add its"/>
			<comm cntt="(type, index) tuple to retVal"/>
			<comm cntt="Take a collection of (type, index) tuples and create"/>
			<comm cntt="instructions that store null values of type &amp;apos;type&amp;apos; in index &amp;apos;index&amp;apos;"/>
			<comm cntt="Creates the bytecode equivalent to:"/>
			<comm cntt="java.util.Random r = new java.util.Random(arg[index]);"/>
			<comm cntt="{create array code}"/>
			<comm cntt="Generates the bytecode equivalent to: array = new int[size]; for(int pc = 0; pc &amp;lt; size; pc++) array[pc] = r.nextInt(); pc = 0"/>
			<comm cntt="translates methods with basic blocks Method A(a1...an), Method B(b1..bm)"/>
			<comm cntt="into fsm, ie: switch(pc){ case X: {bb }... }"/>
			<comm cntt="Branching around will break the fsm. So instead of branching,"/>
			<comm cntt="we just update pc. E.g. ifge-&amp;gt;target; break; will become:"/>
			<comm cntt="ifge-&amp;gt;+2"/>
			<comm cntt="break;"/>
			<comm cntt="pc += [change]"/>
			<comm cntt="goto-&amp;gt;target"/>
			<comm cntt="redirects all branches according to old2new"/>
			<comm cntt="returns true if oldList contains a key that maps to &amp;apos;o&amp;apos; under old2new"/>
			<comm cntt="Return true if can verify il"/>
			<comm cntt="Take an ArrrayList of in order basic blocks and return an ArrayList of"/>
			<comm cntt="InstructionList objects, s.t each InstructionList can verify"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="app" access="priv" jdoc=""/>
			<field name="randomClass" access="priv" jdoc=""/>
			<field name="constructor" access="priv" jdoc=""/>
			<field name="nextInt" access="priv" jdoc=""/>
			<field name="random_slot" access="priv" jdoc=""/>
			<field name="pc_slot" access="priv" jdoc=""/>
			<field name="arg_slot" access="priv" jdoc=""/>
			<field name="array_slot" access="priv" jdoc=""/>
			<field name="switchIH" access="priv" jdoc=""/>
			<field name="cpg" access="priv" jdoc=""/>
			<field name="factory" access="priv" jdoc=""/>
			<field name="ils1" access="priv" jdoc=""/>
			<field name="ils2" access="priv" jdoc=""/>
			<field name="start2end" access="priv" jdoc=""/>
			<field name="old2new" access="priv" jdoc=""/>
			<field name="new2old" access="priv" jdoc=""/>
			<field name="target2value" access="pub" jdoc=""/>
			<const name="VERIFIED" access="priv" jdoc=""/>
			<const name="FAILED" access="priv" jdoc=""/>
			<const name="BAD_TARGET" access="priv" jdoc=""/>
			<const name="ILLEGAL_PEEK" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.Interleaver()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.interleave(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="">
				<param name="A"/>
				<param name="B"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.interleave(sandmark.program.Method, sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="Interleave A and B into existing method C (All members of C will be replaced).">
				<param name="A"/>
				<param name="B"/>
				<param name="C"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.interleave(sandmark.program.Method, sandmark.program.Method, sandmark.program.Method, byte)" access="pub" jdoc="Interleave A and B into existing method C, C&amp;apos;s sig is same as A and B&amp;apos;s, with a byte appended. (All members of C will be replaced). @param byteA the key byte value for Method A; i.e., calls to A(...) should be replaced with calls to A(...,byteA)">
				<param name="A"/>
				<param name="B"/>
				<param name="C"/>
				<param name="byteA"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.interleave(sandmark.program.Method, sandmark.program.Method, sandmark.program.Method, byte, byte)" access="pub" jdoc="Interleave A and B into existing method C (All members of C will be replaced). @param byteA the key byte value for Method A; i.e., calls to A(...) should be replaced with calls to A(...,byteA) @param byteB the key byte value for Method A; i.e., calls to B(...) should be replaced with calls to B(...,byteB)">
				<comm cntt="method A(...,int V) { S1;...Sk; } method B(...) { T1;...Tm; } becomes --&amp;gt; method C(...,byte V) &amp;lt;fsm&amp;gt;"/>
				<comm cntt="so we can getStart()"/>
				<comm cntt="so we can getStart()"/>
				<comm cntt="We first sync the local vars so verifier finds no type mismatches"/>
				<comm cntt="random_slot = InterleaveUtil.getSlot(A, B);"/>
				<comm cntt="set ils1 and ils2."/>
				<comm cntt="So we have a block that has a load w no store before it."/>
				<comm cntt="It wont verify because there is path which doesnt store"/>
				<comm cntt="before loading. So we insert a bunch of fake store instructions"/>
				<comm cntt="before the switch code."/>
				<param name="A"/>
				<param name="B"/>
				<param name="C"/>
				<param name="byteA"/>
				<param name="byteB"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.fixExceptions(org.apache.bcel.generic.CodeExceptionGen[], sandmark.program.Method)" access="priv" jdoc="">
				<param name="exceptions"/>
				<param name="C"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.getEnd(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="endOfException"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.getStart2End()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.getBadLoads(java.util.ArrayList, sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="org.apache.bcel.generic.Instruction[] instrs = il.getInstructions();"/>
				<comm cntt="Check if we&amp;apos;re storing an array"/>
				<comm cntt="System.out.println(&amp;quot;Array type index: &amp;quot; + arraytype +"/>
				<comm cntt="&amp;quot; &amp;quot; + store.getIndex());"/>
				<param name="list"/>
				<param name="M"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.insertFakeStores(java.util.Collection)" access="priv" jdoc="">
				<param name="badLoads"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.getRandomCode()" access="priv" jdoc="">
				<comm cntt="creates the code: Random r = new Random(seed)"/>
				<comm cntt="create an array of random numbers in array_slot"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.createArray()" access="priv" jdoc="">
				<comm cntt="pc = 0"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.getBlocks(sandmark.program.Method, sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="Get the basic blocks in order"/>
				<comm cntt="for(org.apache.bcel.generic.InstructionHandle ih ="/>
				<comm cntt="B.getInstructionList().getStart() ; ih != null ;"/>
				<comm cntt="ih = ih.getNext()) {"/>
				<comm cntt="System.out.println(ih + &amp;quot;:&amp;quot;);"/>
				<comm cntt="org.apache.bcel.generic.InstructionTargeter targeters[] ="/>
				<comm cntt="ih.getTargeters();"/>
				<comm cntt="for(int i = 0 ; targeters != null &amp;&amp; i &amp;lt; targeters.length ; i++)"/>
				<comm cntt="System.out.println(&amp;quot; &amp;quot; + targeters[i]);"/>
				<comm cntt="}"/>
				<comm cntt="Not going to use bb&amp;apos;s directly, merge s.t. every group verfifies"/>
				<param name="A"/>
				<param name="B"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.getSwitchCode(sandmark.program.Method, sandmark.program.Method, byte, byte)" access="priv" jdoc="">
				<comm cntt="First insert the last two lines, which update PC"/>
				<comm cntt="Use byteA as random seed"/>
				<comm cntt="And map basic blocks -&amp;gt; random val, which will used for &amp;apos;case&amp;apos;"/>
				<comm cntt="Every instruction knows its id"/>
				<comm cntt="same for b"/>
				<comm cntt="Every instruction knows its id"/>
				<comm cntt="Now extract all the blocks from the set, which are ordered by hash,"/>
				<comm cntt="and put them in the list, updating matches targets"/>
				<comm cntt="Put at end for now, will move to front later"/>
				<comm cntt="for sorting"/>
				<comm cntt="Retrieve the matches and targets by match"/>
				<comm cntt="and put the switch at the beginning"/>
				<comm cntt="and branch back at the end"/>
				<param name="A"/>
				<param name="B"/>
				<param name="byteA"/>
				<param name="byteB"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.putAll(org.apache.bcel.generic.InstructionList, Object)" access="priv" jdoc="">
				<param name="il"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.fixBranches(org.apache.bcel.generic.InstructionList)" access="priv" jdoc="">
				<comm cntt="Dont want to touch last instructin, the goto (aka break)"/>
				<comm cntt="If we have branch, first increment pc accordingly."/>
				<comm cntt="now targets contains all targets of this branch"/>
				<comm cntt="if newTarget is not the first instruction.."/>
				<comm cntt="Don&amp;apos;t fixup branches inside a block"/>
				<comm cntt="newTarget is the first instruction"/>
				<param name="il"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.updateTargets(org.apache.bcel.generic.InstructionList)" access="priv" jdoc="">
				<param name="il"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.newListContains(java.util.Set, Object)" access="priv" jdoc="">
				<param name="oldList"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.verify(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.ConstantPoolGen, sandmark.analysis.stacksimulator.StackSimulator, sandmark.analysis.defuse.ReachingDefs)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;STACK &amp;gt; 0: &amp;quot; + il.getStart());"/>
				<comm cntt="System.out.println(&amp;quot;bad exit stack&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;bad exception&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;bad branch&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;ret &amp;quot; + old2new.get(wrapper.getIH()) + &amp;quot; &amp;quot; +"/>
				<comm cntt="new2old.get(ih) + &amp;quot; &amp;quot; + wrapper.getIH());"/>
				<comm cntt="System.out.println(&amp;quot;verified&amp;quot;);"/>
				<param name="il"/>
				<param name="cpg"/>
				<param name="ss"/>
				<param name="rd"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.group(sandmark.program.Method, java.util.ArrayList, sandmark.analysis.stacksimulator.StackSimulator)" access="priv" jdoc="">
				<comm cntt="This means we have an instruction that reads from an empty stack or il.getStart() can&amp;apos;t start. Such instructions may not lead off case statements, so attach to previous."/>
				<comm cntt="Have some code left over, add it"/>
				<param name="method"/>
				<param name="blocks"/>
				<param name="ss"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.getInstructionList(sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="">
				<comm cntt="In case it&amp;apos;s empty we can call getstart anyway"/>
				<param name="bb"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.demoteIntegers(Object[])" access="priv" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.demoteIHs(Object[])" access="priv" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.getSortedMatches(java.util.HashMap)" access="priv" jdoc="">
				<param name="map"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.addByteArg(sandmark.program.Method)" access="priv" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.Interleaver.randomByte()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.interleavemethods.InterleavedMethod" intfc="n" abs="n" inn="n" sloc="19" jdoc="The resulting method of an Interleave.interleave call. Interleaving methods A and B results in an InterleavedMethod C, which takes an extra byte as its last parameter. E.g., calls to A should be changed from: A(...) -&amp;gt; C(...,C.getByteA()) and the same for B.">
			<field name="byteA" access="pub" jdoc=""/>
			<field name="byteB" access="pub" jdoc=""/>
			<field name="method" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleavedMethod.InterleavedMethod(sandmark.program.Method, byte, byte)" access="pub" jdoc="">
				<param name="method"/>
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleavedMethod.getByteA()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleavedMethod.getByteB()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleavedMethod.getMethod()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.interleavemethods.InterleaveUtil" intfc="n" abs="n" inn="n" sloc="102" jdoc="">
			<comm cntt="Don&amp;apos;t let any index have more than one type assigned to it"/>
			<comm cntt="increment all non-arg lv&amp;apos;s by incVal"/>
			<comm cntt="The count variable for m is defined as &amp;quot;a measure of the number of argument values, where an argument value of type long or type double contributes two units to the count value and an argument of any other type contributes one unit.&amp;quot;"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveUtil.getSlot(sandmark.program.Method)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveUtil.getSlot(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="Return an LV index &amp;apos;i&amp;apos; available to both input methods s.t. every slot &amp;gt; i is unused in both methods.">
				<param name="A"/>
				<param name="B"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveUtil.getStack(org.apache.bcel.generic.Instruction, org.apache.bcel.generic.ConstantPoolGen)" access="pub" jdoc="">
				<param name="inst"/>
				<param name="cpg"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveUtil.syncLocalVars(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="A and B have same sig, so arguments in locals are of same type. This method re-numbers the locals s.t. types match across methods. In addition, it allows each LV index to store only one type.">
				<param name="A"/>
				<param name="B"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveUtil.makeLVsDistinct(sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="M doesn&amp;apos;t yet have the byte argument that we will end up adding"/>
				<param name="M"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveUtil.incrementLVs(sandmark.program.Method, int)" access="priv" jdoc="">
				<param name="M"/>
				<param name="incVal"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveUtil.getLVindex(sandmark.program.Method, int)" access="priv" jdoc="">
				<param name="M"/>
				<param name="argIndex"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveUtil.getCount(sandmark.program.Method)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods" intfc="n" abs="n" inn="n" sloc="528" jdoc="Implementation of method interleaver. Puts 2 methods with same sig into one new one, whose execution path is based on the value of an opaque predicate input as an additional parameter to the new method. Some future enhancements could be: -inline more than 2 methods at a time (variable#) -don&amp;apos;t require same params, but add in params as needed (alternatively pass params as java.lang.Objects) -don&amp;apos;t require same return types. This could be done by changing all return types to java.lang.Objects 15 September 2003 @author Zach Heidepriem">
			<comm cntt="This obfuscator applies to one app"/>
			<comm cntt="returns false if the method canot be merged."/>
			<comm cntt="if true, fills in orig2new"/>
			<comm cntt="HELPER METHODS"/>
			<comm cntt="fix"/>
			<comm cntt="method(...) --becomes--&amp;gt; if(Pt) x = predVal copy(...,x);"/>
			<comm cntt="Return an interator of Bundles, each of which store"/>
			<comm cntt="(instruction, method, class)"/>
			<field name="COOLHANDLE" access="pub" jdoc=""/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="DYNAMIC_INIT" access="priv" jdoc=""/>
			<const name="STATIC_INIT" access="priv" jdoc=""/>
			<field name="application" access="priv" jdoc=""/>
			<field name="ch" access="priv" jdoc=""/>
			<field name="amap" access="priv" jdoc=""/>
			<field name="bmap" access="priv" jdoc=""/>
			<field name="orig2new" access="priv" jdoc=""/>
			<field name="bbytes" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.apply(sandmark.program.Application)" access="pub" jdoc="Algorithm: 1) For every method A in the app, if A is eligible for renaming but it&amp;apos;s not a key of orig2new: For every method A&amp;apos; in getAllOverrides(A) (includes A), copy A&amp;apos; into C&amp;apos; where every C&amp;apos; has same name and signature. Put (A&amp;apos;,C&amp;apos;) into orig2new. 2) If we found an eligble A { a) Try to find a match for A, B s.t. B is in the same class as A, has the same sig as A, can be renamed, and isn&amp;apos;t a key or value in orig2new. If we successfully find a pair (A,B), select a random bytes p,q. For every method A&amp;apos; in getAllOverrides(A) put (A&amp;apos;, p) into amap b) For every method B&amp;apos; in getAllOverrides(B) (includes B) let A&amp;apos; = B&amp;apos;.getEnclosingClass().getMethod(A.name(), A.sig()): if A&amp;apos; != null then bmap.put(B&amp;apos;, A&amp;apos;); orig2new.put(B&amp;apos;,orig2new.get(A&amp;apos;)) else (C&amp;apos; = B&amp;apos;.copy()).setName(orig2new.get(A).getName()); orig2new.put(B&amp;apos;, C&amp;apos;); 3) For each entry (M,C) in orig2new append a byte parameter P to C&amp;apos;s params 4) For each entry (B,A) in bmap let q = bbytes.get(B), p = Amap.get(A), C = orig2new.get(A) Then C becomes { Interleaver.interleave(A,B,C,p,q) } 5) Go through the entire app and update all the method calls. For every call to M: if amap.containsKey(M) then p = amap.get(M), C = orig2new.get(M): C(...) --becomes--&amp;gt; int x = (y != p); if(Pt) x = p C(...,x); else if bmap.containsKey(M) then p = amap.get(bmap.get(M)), C = orig2new.get(M): C(...) --becomes--&amp;gt; int x = p; if(Pt) x = (y!=p) C(...,x); else if orig2new.containsKey(M) then p = randomByte(), C = orig2new.get(M): C(...) --becomes--&amp;gt; C(...,p) 6) For every entry (M, C) in orig2new, remove M.">
				<comm cntt="Some global variables..."/>
				<comm cntt="A-&amp;gt;predVal"/>
				<comm cntt="B-&amp;gt;A"/>
				<comm cntt="M-&amp;gt;C"/>
				<comm cntt="B-&amp;gt;q"/>
				<comm cntt="publicize and de-finalize all methods"/>
				<comm cntt="Go through all the classes and methods"/>
				<param name="application"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.step1(sandmark.program.Method)" access="priv" jdoc="">
				<param name="A"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.step2(sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="Find a match"/>
				<comm cntt="we found a B, so add a pair"/>
				<comm cntt="2A"/>
				<comm cntt="2B"/>
				<param name="A"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.step3()" access="priv" jdoc="">
				<comm cntt="Only add 1 byte for each C"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.step4()" access="priv" jdoc="">
				<comm cntt="Assert"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.step5()" access="priv" jdoc="">
				<comm cntt="Step 5: fix all the calls using the maps we built,"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.step6()" access="priv" jdoc="">
				<comm cntt="Step 6: delete all the original methods"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.fix(Bundle)" access="priv" jdoc="">
				<comm cntt="If its an invoke..."/>
				<comm cntt="can&amp;apos;t find the class in app, return"/>
				<comm cntt="boolean isB;"/>
				<comm cntt="check to see if we need to change it..."/>
				<comm cntt="isB = false;"/>
				<comm cntt="isB = true;"/>
				<comm cntt="else we have a single method"/>
				<comm cntt="No interleaving was performed in copy. Ignore the byte"/>
				<comm cntt="isB = false;"/>
				<comm cntt="Its some regular call, dont do anything"/>
				<comm cntt="ii"/>
				<param name="bundle"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.updateCall(sandmark.program.Method, sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, Byte)" access="priv" jdoc="">
				<comm cntt="Add the class to the constant pool, if not already there"/>
				<comm cntt="create a call to A&amp;apos;()"/>
				<comm cntt="Create a new invoke instruction..."/>
				<comm cntt="its private method or call to super method"/>
				<comm cntt="this should never happen as long as only 4 subclasses of II"/>
				<comm cntt="Find a y != predVal"/>
				<comm cntt="Make some instructions"/>
				<comm cntt="Create local variable &amp;quot;im_x&amp;quot; to the method call"/>
				<comm cntt="First store some value y != predVal &amp;apos;x = y&amp;apos;"/>
				<comm cntt="now we have { .., load y; newcall }"/>
				<comm cntt="Put in a true predicate (ie push a 1)"/>
				<comm cntt="Push 1 for now. replace after all other changes have been made"/>
				<comm cntt="with opl predicate"/>
				<comm cntt="now there&amp;apos;s an extra 1 on the stack, before load"/>
				<comm cntt="If we want to call A(), branch. Else dont branch"/>
				<comm cntt="There&amp;apos;s a 1 on the stack.."/>
				<comm cntt="So { if[eq]-&amp;gt;load; bipush(predVal);"/>
				<comm cntt="istore(loc); load(loc); newcall }"/>
				<comm cntt="and replace the old one"/>
				<comm cntt="Clean everything up"/>
				<comm cntt="This is supposed to fix the line numbers"/>
				<param name="method"/>
				<param name="copy"/>
				<param name="ih"/>
				<param name="predVal"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getAppInstructions(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getMethodsToRename(sandmark.program.Method, java.util.HashSet)" access="priv" jdoc="">
				<param name="method"/>
				<param name="set"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.isInit(sandmark.program.Method)" access="priv" jdoc="">
				<param name="origMethod"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.isSpecial(sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="Not even going to try to interleave method if it overrides"/>
				<comm cntt="a java method, or is init, or main, or toString, or equals or..."/>
				<param name="origMethod"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getMatch(sandmark.program.Method)" access="priv" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.randomByte()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.print()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods.main(String[])" access="pub" jdoc="For testing purposes only">
				<param name="args"/>
			</mth>
		<class name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$MethodBundle" intfc="n" abs="n" inn="y" sloc="22" jdoc="">
			<field name="method1" access="priv" jdoc=""/>
			<field name="method2" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$MethodBundle.MethodBundle(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="">
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$MethodBundle.getA()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$MethodBundle.getB()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$MethodBundle.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$Bundle" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<field name="clazz" access="priv" jdoc=""/>
			<field name="method" access="priv" jdoc=""/>
			<field name="ih" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$Bundle.Bundle(org.apache.bcel.generic.InstructionHandle, sandmark.program.Method, sandmark.program.Class)" access="pub" jdoc="">
				<param name="ih"/>
				<param name="method"/>
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$Bundle.getIH()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$Bundle.getMethod()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.InterleaveMethods$Bundle.getEnclosingClass()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.obfuscate.interleavemethods.StackOp" intfc="n" abs="n" inn="n" sloc="7" jdoc="">
			<field name="consumes" access="pub" jdoc=""/>
			<field name="produces" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.interleavemethods.StackOp.StackOp(int, int)" access="pub" jdoc="">
				<param name="consumes"/>
				<param name="produces"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.interleavemethods.TypeIndex" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<field name="type" access="pub" jdoc=""/>
			<field name="index" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.interleavemethods.TypeIndex.TypeIndex(org.apache.bcel.generic.Type, int)" access="pub" jdoc="">
				<param name="type"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.TypeIndex.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.TypeIndex.typesMatch(org.apache.bcel.generic.Type, org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="t1"/>
				<param name="t2"/>
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.TypeIndex.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.interleavemethods.TypeIndex.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.irreducibility">
		<class name="/:sandmark.obfuscate.irreducibility.Irreducibility" intfc="n" abs="n" inn="n" sloc="315" jdoc="">
			<comm cntt="System.out.println(&amp;quot;wazzup&amp;quot;);"/>
			<const name="pop" access="priv" jdoc=""/>
			<const name="pop2" access="priv" jdoc=""/>
			<const name="pushNull" access="priv" jdoc=""/>
			<const name="pushLong" access="priv" jdoc=""/>
			<const name="pushFloat" access="priv" jdoc=""/>
			<const name="pushDouble" access="priv" jdoc=""/>
			<const name="pushInt" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.getLVType(sandmark.analysis.stacksimulator.Context, int)" access="priv" jdoc="">
				<param name="c"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.goodType(org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="t"/>
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.okType(org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="t"/>
			</mth>
			<mth name="/:sandmark.obfuscate.irreducibility.Irreducibility.apply(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;inserting predicate in method &amp;quot; + meth.getName() +"/>
				<comm cntt="&amp;quot; at &amp;quot; + pushPredicateValue);"/>
				<param name="meth"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.localvar">
		<class name="/:sandmark.obfuscate.localvar.VariableReassigner" intfc="n" abs="n" inn="n" sloc="84" jdoc="VariableReassigner optimizes a method by using sandmark.analysis.controlflowgraph.RegisterAllocator to reallocate the local variable usage. @author Kelly Heffner (kheffner@cs.arizona.edu)">
			<const name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.apply(sandmark.program.Method)" access="pub" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.localvar.VariableReassigner.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.methodmadness">
		<class name="/:sandmark.obfuscate.methodmadness.MethodMerger" intfc="n" abs="n" inn="n" sloc="69" jdoc="">
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.apply(sandmark.program.Class)" access="pub" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getPostsuggestions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.MethodMerger.getPostprohibited()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.methodmadness.StaticSplit" intfc="n" abs="n" inn="n" sloc="67" jdoc="">
			<comm cntt="Returns the URL at which you can find information about this obfuscator."/>
			<comm cntt="Returns an HTML description of this obfuscator."/>
			<comm cntt="Returns a long description of this obfuscator&amp;apos;s name."/>
			<comm cntt="Returns a short description of this obfuscator&amp;apos;s name."/>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.apply(sandmark.program.Class)" access="pub" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getPostsuggestions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.StaticSplit.getShortName()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.methodmadness.ParamReorder" intfc="n" abs="n" inn="n" sloc="56" jdoc="">
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.getAlgURL()" access="pub" jdoc="Returns the URL at which you can find information about this obfuscator">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.getAlgHTML()" access="pub" jdoc="Returns an HTML description of this obfuscator">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.getLongName()" access="pub" jdoc="Returns a long description of this obfuscator">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.getShortName()" access="pub" jdoc="Returns a short description of this obfuscator">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.ParamReorder.apply(sandmark.program.Method)" access="pub" jdoc="">
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner" intfc="n" abs="n" inn="n" sloc="56" jdoc="">
			<comm cntt="Returns the URL at which you can find information about this obfuscator."/>
			<comm cntt="Returns an HTML description of this obfuscator."/>
			<comm cntt="Returns a long description of this obfuscator&amp;apos;s name."/>
			<comm cntt="Returns a short description of this obfuscator&amp;apos;s name."/>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.apply(sandmark.program.Method)" access="pub" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.SignatureBludgeoner.getPostprohibited()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.methodmadness.Method2RMadness" intfc="n" abs="n" inn="n" sloc="157" jdoc="">
			<comm cntt="Turn to true to print debugging messages."/>
			<comm cntt="Turn to true to print status output messages as the obfuscator runs."/>
			<comm cntt="Runs a quick test of this obfuscator."/>
			<comm cntt="Makes public the fields methods in this Application object&amp;apos;s classes."/>
			<comm cntt="{ create a class hierarchy for later seeing if methods are renamable 1. make all fields methods public if(OUTPUT) System.out.println(&amp;quot;Step 1) Publicizer; making fields methods all public...&amp;quot;); (new sandmark.obfuscate.methodmadness.Publicizer()).apply(app); app.save(&amp;quot;TEMP1.jar&amp;quot;); System.gc(); System.runFinalization(); 2. replace nonstatic methods with static methods if(OUTPUT) System.out.println(&amp;quot;Step 2) StaticSplit; moving dynamic method bodies into static methods...&amp;quot;); app = new sandmark.program.Application(&amp;quot;TEMP1.jar&amp;quot;); java.util.Iterator itr = app.classes(); sandmark.obfuscate.methodmadness.StaticSplit split = new sandmark.obfuscate.methodmadness.StaticSplit(); while(itr.hasNext()) split.apply((sandmark.program.Class)itr.next()); split = null; app.save(&amp;quot;TEMP2.jar&amp;quot;); System.gc(); System.runFinalization(); 3. promote all primitives into wrapper objects if(OUTPUT) System.out.println(&amp;quot;Step 3) PrimitivePromoter; wrapping all primitives into object wrappers...&amp;quot;); app = new sandmark.program.Application(&amp;quot;TEMP2.jar&amp;quot;); (new sandmark.obfuscate.methodmadness.PrimitivePromoter()).apply(app); app.save(&amp;quot;TEMP3.jar&amp;quot;); System.gc(); System.runFinalization(); 4. reorder arguments of static methods if(OUTPUT) System.out.println(&amp;quot;Step 4) ParameterReorder; shuffling method argument orders...&amp;quot;); app = new sandmark.program.Application(&amp;quot;TEMP3.jar&amp;quot;); (new sandmark.obfuscate.methodmadness.ParameterReorderer()).apply(app); app.save(&amp;quot;TEMP4.jar&amp;quot;); System.gc(); System.runFinalization(); 5. convert arguments into Object[] if(OUTPUT) System.out.println(&amp;quot;Step 5) SignatureBludgeoner; making all static methods take Object[]...&amp;quot;); app = new sandmark.program.Application(&amp;quot;TEMP4.jar&amp;quot;); (new sandmark.obfuscate.methodmadness.SignatureBludgeoner()).apply(app); app.save(&amp;quot;TEMP5.jar&amp;quot;); System.gc(); System.runFinalization(); 6. merge static methods into master method if(OUTPUT) System.out.println(&amp;quot;Step 6) MethodMerger; combining each class&amp;apos;s static methods...&amp;quot;); app = new sandmark.program.Application(&amp;quot;TEMP5.jar&amp;quot;); (new sandmark.obfuscate.methodmadness.MethodMerger()).apply(app); app.save(&amp;quot;TEMP6.jar&amp;quot;); System.gc(); System.runFinalization(); }"/>
			<comm cntt="Returns the URL at which you can find information about this obfuscator."/>
			<comm cntt="Returns an HTML description of this obfuscator."/>
			<comm cntt="Returns a long description of this obfuscator&amp;apos;s name."/>
			<comm cntt="Returns a short description of this obfuscator&amp;apos;s name."/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="OUTPUT" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.main(String[])" access="pub" jdoc="">
				<comm cntt="step 1: use static split to create private static versions of methods"/>
				<comm cntt="apply primitive promotion, param reordering, signature bludgeoning"/>
				<comm cntt="to all the private static methods"/>
				<comm cntt="3"/>
				<comm cntt="4"/>
				<comm cntt="5"/>
				<comm cntt="6"/>
				<comm cntt="step 2: local promotion"/>
				<comm cntt="step 7: apply method merger to merge the private static methods"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.apply(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="use static split to create private static versions of methods"/>
				<comm cntt="apply primitive promotion, param reordering, signature bludgeoning"/>
				<comm cntt="to all the private static methods"/>
				<comm cntt="apply method merger to merge the private static methods"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.Method2RMadness.getMutations()" access="pub" jdoc="">
				<comm cntt="we can do this since the properties are all singletons"/>
				<comm cntt="sandmark.config.ModificationProperty [] temp = new sandmark.obfuscate.methodmadness.Publicizer().getMutations(); for(int i = 0; i &amp;lt; temp.length; i++) retVal.add(temp[i]);"/>
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter" intfc="n" abs="n" inn="n" sloc="63" jdoc="">
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.apply(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="promote locals"/>
				<comm cntt="promote params"/>
				<comm cntt="promote return type"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.methodmadness.PrimitivePromoter.getPostprohibited()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.modifyifelse">
		<class name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse" intfc="n" abs="n" inn="n" sloc="320" jdoc="">
			<field name="cp" access="pub" jdoc=""/>
			<field name="cg" access="pub" jdoc=""/>
			<field name="mg" access="pub" jdoc=""/>
			<field name="cfg" access="pub" jdoc=""/>
			<field name="endblk" access="pub" jdoc=""/>
			<field name="block" access="pub" jdoc=""/>
			<field name="curr" access="pub" jdoc=""/>
			<field name="left" access="pub" jdoc=""/>
			<field name="right" access="pub" jdoc=""/>
			<field name="rlist" access="pub" jdoc=""/>
			<field name="llist" access="pub" jdoc=""/>
			<field name="ldom" access="pub" jdoc=""/>
			<field name="rdom" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.initialize(sandmark.program.Method)" access="pub" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.apply(sandmark.program.Method)" access="pub" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.display()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.prepareList()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.preparePdomList()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.getEndBlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.checkList()" access="priv" jdoc="">
				<comm cntt="All the predecessors &amp; successors must be in the same list"/>
			</mth>
			<mth name="/:sandmark.obfuscate.modifyifelse.ModifyIfElse.modifyifelse()" access="pub" jdoc="">
				<comm cntt="parse over all basic blocks"/>
				<comm cntt="check if the last instruction is a if instruction else continue"/>
				<comm cntt="System.out.println(&amp;quot; FOUND IF&amp;quot;);"/>
				<comm cntt="find the block that is the target block make it right"/>
				<comm cntt="find the fallthrough block make it left"/>
				<comm cntt="System.out.println(&amp;quot;STEP 1&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;left=&amp;quot;+left.getIH()+&amp;quot;right&amp;quot;+right.getIH());"/>
				<comm cntt="System.out.println(&amp;quot;STEP 2&amp;quot;); block = null; for(int i = 0; i &amp;lt; ldom.size(); i++){ block = (sandmark.analysis.controlflowgraph.BasicBlock)ldom.get(i); System.out.println(&amp;quot;L PDOM=&amp;quot;+block.getIH()); } block = null; for(int i = 0; i &amp;lt; rdom.size(); i++){ block = (sandmark.analysis.controlflowgraph.BasicBlock)rdom.get(i); System.out.println(&amp;quot;R PDOM=&amp;quot;+block.getIH()); }"/>
				<comm cntt="System.out.println(&amp;quot; STEP 3 endblk=&amp;quot;+endblk.getIH());"/>
				<comm cntt="for(int i = 0; i &amp;lt; llist.size(); i++){ block = (sandmark.analysis.controlflowgraph.BasicBlock)llist.get(i); System.out.println(&amp;quot;LLIST=&amp;quot;+block.getIH()); } for(int i = 0; i &amp;lt; rlist.size(); i++){ block = (sandmark.analysis.controlflowgraph.BasicBlock)rlist.get(i); System.out.println(&amp;quot;RLIST=&amp;quot;+block.getIH()); } System.out.println(&amp;quot; STEP 4&amp;quot;);"/>
				<comm cntt="get the highest numbered block in the right list"/>
				<comm cntt="System.out.println(&amp;quot; STEP 5&amp;quot;);"/>
				<comm cntt="The blocks should all be continuous"/>
				<comm cntt="get the highest numbered block in the left list"/>
				<comm cntt="The blocks should all be continuous"/>
				<comm cntt="System.out.println(&amp;quot;Fallthrough=&amp;quot;+block.getIH());"/>
				<comm cntt="endblk.getIH()"/>
				<comm cntt="System.out.println(&amp;quot;target= &amp;quot;+ ((org.apache.bcel.generic.IfInstruction)lastInst).getTarget()); System.out.println(&amp;quot;left=&amp;quot;+left.getIH()+&amp;quot;right=&amp;quot;+right.getIH());"/>
				<comm cntt="display();"/>
				<comm cntt="End FOR"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.nameoverloading">
		<class name="/:sandmark.obfuscate.nameoverloading.NameOverloading" intfc="n" abs="n" inn="n" sloc="194" jdoc="Name obfuscation based on Paul Tyma&amp;apos;s patented algorithm. @author Andrew Lenards with revision by Kelly Heffner and a big rewrite by Andrew Huntwork &amp;lt;p&amp;gt;lenards@cs.arizona.edu and kheffner@cs.arizona.edu and ash@cs.arizona.edu">
			<comm cntt="Obfuscation - Layout Transformation The algorithm below is way more complicated than necessary, so i removed a bunch of steps, but it&amp;apos;s still basically equivalent to this algorithm. -- ASH name: MethodOverloadingObfuscator input := jar containing class files Algorithm: graph &amp;lt;- collectMethodNode(input) # foreach class file, create a MethodNode # representing the class name it came from, # the name of the method, and the signuture # of the method. # &amp;lt;for all methods in the class&amp;gt; # [important] if the method is not related # to the Java 2 SDK, add it to # the set representing the # &amp;quot;graph&amp;quot; connectGraph(graph) # determine which nodes should be connected # and created edges between them. # def: given a MethodNode n1 and a # MethodNode n2, they are connected # iff they have the same signature. colorGraph() # assign names to the nodes, a node cannot # share the same name with any node that # it is connected to. createLookup() # defining a mapping of old name to new name commitNameChanges() # traverse the methods of each classfile, # use the lookup to determine the new name # of a given method, encode the name, set # the index in the constant pool, mark the # index as changed, and dump the classfile save changes to jar # each classfile had its changed dumped into # it, save the jar to make all changes final end"/>
			<field name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.apply(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.collectSignatureGroups(sandmark.program.Application, sandmark.analysis.classhierarchy.ClassHierarchy)" access="priv" jdoc="">
				<param name="app"/>
				<param name="ch"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.createFieldRenameMap(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.createMethodRenameMap(sandmark.program.Application, java.util.Hashtable)" access="priv" jdoc="">
				<param name="app"/>
				<param name="sigToMethodList"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.getSignatureString(sandmark.program.Method)" access="priv" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading.main(String[])" access="pub" jdoc="">
				<param name="andy"/>
			</mth>
		<class name="/:sandmark.obfuscate.nameoverloading.NameOverloading$MethodNameAndSig" intfc="n" abs="n" inn="y" sloc="25" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="signature" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$MethodNameAndSig.MethodNameAndSig(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$MethodNameAndSig.MethodNameAndSig(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$MethodNameAndSig.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$MethodNameAndSig.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$MethodNameAndSig.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.obfuscate.nameoverloading.NameOverloading$FieldNameAndSig" intfc="n" abs="n" inn="y" sloc="25" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="signature" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$FieldNameAndSig.FieldNameAndSig(sandmark.program.Field)" access="pub" jdoc="">
				<param name="field"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$FieldNameAndSig.FieldNameAndSig(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$FieldNameAndSig.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$FieldNameAndSig.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nameoverloading.NameOverloading$FieldNameAndSig.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.nodesplitter">
		<class name="/:sandmark.obfuscate.nodesplitter.NodeSplitter" intfc="n" abs="n" inn="n" sloc="368" jdoc="">
			<comm cntt="create a new name for the pointer field (will be &amp;quot;next&amp;quot;+someInt)"/>
			<comm cntt="create a new name for the split class (will be oldName+someInt)"/>
			<comm cntt="adds the pointer field to the original class, and updates the"/>
			<comm cntt="constructors to set it"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getPointerFieldName(sandmark.program.Class, sandmark.program.Class)" access="priv" jdoc="">
				<param name="origClass"/>
				<param name="splitClass"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getSplitClassName(sandmark.program.Class)" access="priv" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.createSplitClass(sandmark.program.Class, java.util.Hashtable)" access="priv" jdoc="">
				<comm cntt="r.nextDouble() &amp;gt; 0.5) {"/>
				<comm cntt="If we&amp;apos;re moving a static field, we need to make sure the"/>
				<comm cntt="original class&amp;apos;s &amp;lt;clinit&amp;gt; is called before any field in the"/>
				<comm cntt="new class is accessed. So we add a static field to the original"/>
				<comm cntt="class and set it from the new class&amp;apos;s &amp;lt;clinit&amp;gt;, thus invoking"/>
				<comm cntt="the original class&amp;apos;s &amp;lt;clinit&amp;gt;."/>
				<param name="cls"/>
				<param name="movedFields"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.addPointerField(sandmark.program.Class, sandmark.program.Class)" access="priv" jdoc="">
				<comm cntt="create the new instructions to go in each &amp;lt;init&amp;gt;"/>
				<comm cntt="for each &amp;lt;init&amp;gt; method..."/>
				<comm cntt="for each &amp;lt;init&amp;gt; method, go through the instructions and find the"/>
				<comm cntt="super-constructor calls, and copy them into a list"/>
				<comm cntt="for each super.&amp;lt;init&amp;gt; call, add the new instructions after it"/>
				<param name="origClass"/>
				<param name="splitClass"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.adjustReferences(sandmark.program.Application, sandmark.analysis.classhierarchy.ClassHierarchy, java.util.Hashtable, java.util.Hashtable)" access="priv" jdoc="">
				<comm cntt="only updating field instructions"/>
				<comm cntt="if the field mentioned has been moved to the split class..."/>
				<comm cntt="oldref, value1, value2"/>
				<comm cntt="value1, value2, oldref, value1, value2"/>
				<comm cntt="value1, value2, oldref"/>
				<comm cntt="value1, value2, newref"/>
				<comm cntt="newref, value1, value3, newref"/>
				<comm cntt="newref, value1, value2"/>
				<comm cntt="oldref, value"/>
				<comm cntt="value, oldref"/>
				<comm cntt="value, newref"/>
				<comm cntt="newref, value"/>
				<param name="app"/>
				<param name="ch"/>
				<param name="movedFields"/>
				<param name="pointerFields"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.redirectHandlers(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="method"/>
				<param name="old"/>
				<param name="top"/>
				<param name="bottom"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.apply(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.nodesplitter.NodeSplitter.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.objectify">
		<class name="/:sandmark.obfuscate.objectify.Objectify" intfc="n" abs="n" inn="n" sloc="93" jdoc="">
			<mth name="/:sandmark.obfuscate.objectify.Objectify.apply(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.obfuscate.objectify.Objectify.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.objectify.Objectify.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.objectify.Objectify.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.objectify.Objectify.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.objectify.Objectify.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.objectify.Objectify.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.objectify.Objectify.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.objectify.Objectify.getMutations()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.paramalias">
		<class name="/:sandmark.obfuscate.paramalias.ParamAlias" intfc="n" abs="n" inn="n" sloc="221" jdoc="This obfuscator adds a global field to get class to have the same memory location as a random formal parameter of a method">
			<const name="debug" access="priv" jdoc=""/>
			<field name="methodToChange" access="priv" jdoc=""/>
			<field name="paramIndex" access="priv" jdoc=""/>
			<field name="paramType" access="priv" jdoc=""/>
			<field name="paramName" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.ParamAlias()" access="pub" jdoc="Constructor.">
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.apply(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.applyEachClass(sandmark.program.Class[])" access="priv" jdoc="">
				<comm cntt="methodToChange will be set after this (if successful)"/>
				<comm cntt="no method in this class to change"/>
				<comm cntt="find the index of the param and it&amp;apos;s type"/>
				<comm cntt="create the new field"/>
				<comm cntt="add the new field"/>
				<comm cntt="create new instruction list"/>
				<comm cntt="first make initial assignment from new field to parameter found"/>
				<comm cntt="load (this)"/>
				<comm cntt="load the parameter that was found"/>
				<comm cntt="add putfield instruction"/>
				<param name="classes"/>
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.hasValidParam(int, org.apache.bcel.generic.ConstantPoolGen, sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;ParamType: &amp;quot; + paramType +&amp;quot;\nType Check: &amp;quot; + types[i]);"/>
				<param name="newFieldIndex"/>
				<param name="cpg"/>
				<param name="methodToCheck"/>
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.getInfoAboutVar(String, org.apache.bcel.generic.ConstantPoolGen)" access="priv" jdoc="">
				<param name="name"/>
				<param name="cpg"/>
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.updateInstructions(int, org.apache.bcel.generic.ConstantPoolGen, org.apache.bcel.generic.InstructionList, sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="get the instruction list for the method"/>
				<comm cntt="now must go through all instructions and change reference to new field"/>
				<comm cntt="insert the first instructions for the new field"/>
				<param name="newFieldIndex"/>
				<param name="cpg"/>
				<param name="insertList"/>
				<param name="theMethod"/>
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.deleteInst(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="il"/>
				<param name="ihs"/>
				<param name="next"/>
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.findParamIndex(org.apache.bcel.generic.Type[])" access="priv" jdoc="">
				<param name="typesArr"/>
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.findMethod(sandmark.program.Class)" access="priv" jdoc="">
				<comm cntt="get a random method"/>
				<comm cntt="check to see if method has at least one parameter and continue to add field etc."/>
				<comm cntt="a method to change does not exist for this class"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.obfuscate.paramalias.ParamAlias.main(String[])" access="pub" jdoc="">
				<comm cntt="just a little test program"/>
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.promotelocals">
		<class name="/:sandmark.obfuscate.promotelocals.PromoteLocals" intfc="n" abs="n" inn="n" sloc="55" jdoc="">
			<comm cntt="Constructor"/>
			<comm cntt="Returns this obfuscator&amp;apos;s short name."/>
			<comm cntt="Returns this obfuscator&amp;apos;s long name."/>
			<comm cntt="Get the HTML codes of the About page for SplitClass"/>
			<comm cntt="Get the URL of the Help page for PromoteLocals"/>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.PromoteLocals()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.getAlgURL()" access="pub" jdoc="">
				<comm cntt="I don&amp;apos;t know what this should be -Anna-"/>
			</mth>
			<mth name="/:sandmark.obfuscate.promotelocals.PromoteLocals.apply(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="now uses primitivepromotion.LocalPromoter which does the same thing"/>
				<param name="meth"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.renameidentifiers">
		<class name="/:sandmark.obfuscate.renameidentifiers.RenameLocals" intfc="n" abs="n" inn="n" sloc="182" jdoc="">
			<comm cntt="Returns this obfuscator&amp;apos;s short name."/>
			<comm cntt="Returns this obfuscator&amp;apos;s long name."/>
			<comm cntt="Get the HTML codes of the About page for Degrade"/>
			<comm cntt="Get the URL of the Help page for Degrade"/>
			<comm cntt="All the work for the RenameLocals obfuscation"/>
			<comm cntt="FOR all classes DO rename local variables."/>
			<comm cntt="FOR all methods DO rename local variables. We don&amp;apos;t rename &amp;quot;this&amp;quot; because it seems to screw up SourceAgain. Maybe we should?"/>
			<comm cntt="Return a new name for a given local variable."/>
			<const name="DEBUG" access="pub" jdoc=""/>
			<const name="DEFAULT" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.apply(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.rename(sandmark.program.Class, String)" access="pub" jdoc="">
				<comm cntt="org.apache.bcel.generic.ClassGen cg,"/>
				<comm cntt="org.apache.bcel.classfile.Method[] methods=cg.getMethods();"/>
				<comm cntt="cg.getConstantPool();"/>
				<comm cntt="org.apache.bcel.classfile.Method origMeth = methods[i];"/>
				<comm cntt="org.apache.bcel.generic.MethodGen mg="/>
				<comm cntt="new org.apache.bcel.generic.MethodGen(origMeth,className,cpg);"/>
				<comm cntt="rename(mg);"/>
				<comm cntt="org.apache.bcel.classfile.Method newMeth = mg.getMethod();"/>
				<comm cntt="cg.replaceMethod(origMeth,newMeth);"/>
				<param name="cls"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.rename(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="org.apache.bcel.generic.MethodGen mg) {"/>
				<comm cntt="mg.addLocalVariable(newName, type, slot, local.getStart(), local.getEnd());"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.findNewName(String, org.apache.bcel.generic.Type, java.util.Hashtable, java.util.Hashtable)" access="pub" jdoc="">
				<param name="oldName"/>
				<param name="type"/>
				<param name="localMap"/>
				<param name="localCount"/>
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.map(org.apache.bcel.generic.Type, String[], java.util.Hashtable)" access="pub" jdoc="">
				<param name="t"/>
				<param name="names"/>
				<param name="localMap"/>
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.initMap()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.renameidentifiers.RenameLocals.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.reorder.constantpool">
		<class name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer" intfc="n" abs="n" inn="n" sloc="235" jdoc="This obfuscation randomly permutes the constant pool indexes of its classes.">
			<comm cntt=""/>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getPermutation(org.apache.bcel.generic.ConstantPoolGen)" access="priv" jdoc="">
				<param name="cpg"/>
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getindex(java.util.Hashtable, int)" access="priv" jdoc="">
				<param name="hash"/>
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.fixFields(sandmark.program.Class, java.util.Hashtable, org.apache.bcel.classfile.ConstantPool)" access="priv" jdoc="">
				<param name="clazz"/>
				<param name="indexhash"/>
				<param name="cp"/>
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.fixMethods(sandmark.program.Class, java.util.Hashtable, org.apache.bcel.classfile.ConstantPool)" access="priv" jdoc="">
				<comm cntt="also fix instructions"/>
				<param name="clazz"/>
				<param name="indexhash"/>
				<param name="cpool"/>
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.fixAttributes(org.apache.bcel.classfile.Attribute[], java.util.Hashtable, org.apache.bcel.classfile.ConstantPool)" access="priv" jdoc="">
				<comm cntt="fix exception handlers and sub-attributes"/>
				<comm cntt="do nothing"/>
				<comm cntt="do nothing"/>
				<comm cntt="do nothing"/>
				<comm cntt="do nothing"/>
				<param name="atts"/>
				<param name="indexhash"/>
				<param name="cp"/>
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.fixCP(java.util.Hashtable, org.apache.bcel.generic.ConstantPoolGen)" access="priv" jdoc="">
				<comm cntt="do nothing"/>
				<comm cntt="do nothing"/>
				<comm cntt="do nothing"/>
				<comm cntt="do nothing"/>
				<comm cntt="do nothing"/>
				<param name="indexhash"/>
				<param name="cpg"/>
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.apply(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.reorder.constantpool.CPReorderer.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.scalarmerger">
		<class name="/:sandmark.obfuscate.scalarmerger.ScalarMerger" intfc="n" abs="n" inn="n" sloc="224" jdoc="Provides a method obfuscator that combines two int variables into a single long, making access to either more confusing. @author Gregg Townsend (&amp;lt;a href=&amp;quot;mailto:gmt@cs.arizona.edu&amp;quot;&amp;gt;gmt@cs.arizona.edu&amp;lt; a&amp;gt;) @version 1.0, August 29, 2003">
			<comm cntt="This fixStore code was also tested, but it is longer and less confusing: I2L I2L convert store value to long BIPUSH 32 BIPUSH 32 push shift count LSHL LSHL shift int to top of long BIPUSH 32 push shift count again LUSHR shift back down (clears I2D sign bit extension) LCONST_1 LCONST_1 load long constant 1 LNEG LNEG convert to all-ones mask BIPUSH 32 BIPUSH 32 push shift count LUSHR !=!= LSHL shift to make half ones, half zeroes LLOAD lx LLOAD lx load old combined value LAND LAND preserve old value of other variable LADD LADD combine with new value for this variable LSTORE lx LSTORE lx store combined long value"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.apply(sandmark.program.Method)" access="pub" jdoc="Applies this obfuscation to a single method.">
				<comm cntt="nothing to do"/>
				<comm cntt="Choose two local int variables (ix1 and ix2) for merging."/>
				<comm cntt="tally integer accesses"/>
				<comm cntt="invalidate entries of incoming args"/>
				<comm cntt="get best integer candidate"/>
				<comm cntt="get next-best candidate"/>
				<comm cntt="if couldn&amp;apos;t find two candidates"/>
				<comm cntt="Allocate a new long variable and initilize it to 1,"/>
				<comm cntt="effectively initializing the two ints to 0 and 1."/>
				<comm cntt="The actual value doesn&amp;apos;t matter because the translation"/>
				<comm cntt="of the old code will reinitialize each half separately."/>
				<comm cntt="index of new long variable"/>
				<comm cntt="trace actions, if enabled"/>
				<comm cntt="Replace instructions that operate on the ints"/>
				<comm cntt="Clean up and exit."/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.tally(sandmark.program.Method)" access="priv" jdoc="Checks all local variable instructions in an instruction list and tallies variable usage. Returns an array of scores corresponding to local variables. A positive score counts the number of integer accesses. A negative score indicates a variable that is used for a non-integer value.">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.skipArgs(sandmark.program.Method, int[])" access="priv" jdoc="Invalidates tally entries that correspond to method arguments.">
				<param name="meth"/>
				<param name="vscores"/>
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.best(int[])" access="priv" jdoc="Scans an array of tallies and returns the index of the most active integer local variable after resetting that variable&amp;apos;s score to zero. Ties are broken in favor of lower numbered variables. Returns -1 if there is no local variable with a positive score.">
				<param name="vscores"/>
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.fixup(org.apache.bcel.generic.InstructionList, int, int, int)" access="priv" jdoc="Scans the instruction list and replaces instructions that operate on the chosen integer locals.">
				<param name="il"/>
				<param name="ix1"/>
				<param name="ix2"/>
				<param name="lx"/>
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.fixLoad(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, int, boolean)" access="priv" jdoc="Replaces an ILOAD with a load from one half of lx. The generated sequence is as follows: &amp;lt;PRE&amp;gt; left half right half comments --------- ---------- --------------------------------------------- LLOAD lx LLOAD lx load combined value BIPUSH 32 push shift count LSHR position to low 32 bits L2I L2I convert low 32 bits to int &amp;lt; PRE&amp;gt;">
				<param name="il"/>
				<param name="ih"/>
				<param name="lx"/>
				<param name="lefthalf"/>
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.fixStore(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, int, boolean)" access="priv" jdoc="Replace an ISTORE with a store into one half of lx. The generated sequence is as follows: &amp;lt;PRE&amp;gt; left half right half comments --------- ---------- --------------------------------------------- I2L I2L convert the new int to a long BIPUSH 32 push shift count LSHL shift into position LLOAD lx LLOAD lx load the old combined value DUP2_X2 DUP2_X2 hide a second copy below the new value LXOR LXOR compute bitwise difference to new value LCONST_1 LCONST_1 load long constant 1 LNEG LNEG convert to all-ones mask BIPUSH 32 BIPUSH 32 push shift count LSHL !=!= LUSHR shift to make half ones, half zeroes LAND LAND select the change bits for the correct half LXOR LXOR change the bits in the combined value LSTORE lx LSTORE lx store new combined value &amp;lt; PRE&amp;gt;">
				<param name="il"/>
				<param name="ih"/>
				<param name="lx"/>
				<param name="lefthalf"/>
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.fixIncr(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, int, boolean)" access="priv" jdoc="Replaces an IINC with an increment of half of lx. The generated sequence is as follows: &amp;lt;PRE&amp;gt; left half right half comments --------- ---------- --------------------------------------------- LLOAD lx LLOAD lx load combined value DUP2 duplicate for later use DUP2 duplicate for later use BIPUSH n BIPUSH n push increment value I2L I2L convert to long BIPUSH 32 push shift count LSHL position increment value LADD LADD add increment to long value LXOR compute bitwise difference vs. old value LCONST_1 load long constant 1 LNEG convert to all-ones mask BIPUSH 32 push shift count LUSHR shift to fill top half with zeroes LAND isolate changes to lower half LXOR apply changes to original value LSTORE lx LSTORE lx store combined long value &amp;lt; PRE&amp;gt;">
				<param name="il"/>
				<param name="ih"/>
				<param name="lx"/>
				<param name="lefthalf"/>
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.getShortName()" access="pub" jdoc="Returns &amp;quot;Scalar Merger&amp;quot;, the short name of this algorithm.">
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.getLongName()" access="pub" jdoc="Returns &amp;quot;Scalar Merger&amp;quot;, the long name of this algorithm.">
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.getAlgHTML()" access="pub" jdoc="Returns an HTML description of this obfuscator&amp;apos;s function.">
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.getAlgURL()" access="pub" jdoc="Returns the URL within the source tree of an HTML file describing this obfuscator.">
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.getAuthor()" access="pub" jdoc="Returns the name of the author of this obfuscator.">
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.getAuthorEmail()" access="pub" jdoc="Returns the e-mail address of the author of this obfuscator.">
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.getDescription()" access="pub" jdoc="Returns a brief description of this obfuscator.">
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.getMutations()" access="pub" jdoc="Returns a list of modification properties characterizing this obfuscator.">
			</mth>
			<mth name="/:sandmark.obfuscate.scalarmerger.ScalarMerger.main(String[])" access="pub" jdoc="Applies the obfuscation to every method in the jar file given as the command argument. &amp;lt;P&amp;gt; Usage: java sandmark.obfuscate.scalarmerger.ScalarMerger file.jar &amp;lt;P&amp;gt; Writes: CHANGED.jar">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.setfieldspublic">
		<class name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic" intfc="n" abs="n" inn="n" sloc="48" jdoc="The SetFieldsPublic obfuscator changes the field access modifiers of all of the fields in a class. @author Christian Collberg @version 1.0">
			<comm cntt="Embedding"/>
			<field name="AND_MASK" access="pub" jdoc=""/>
			<field name="OR_MASK" access="pub" jdoc=""/>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.SetFieldsPublic()" access="pub" jdoc="Constructor.">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.setfieldspublic.SetFieldsPublic.apply(sandmark.program.Class)" access="pub" jdoc="">
				<param name="cls"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.stringencoder">
		<class name="/:sandmark.obfuscate.stringencoder.LFStringEncoder" intfc="n" abs="n" inn="n" sloc="348" jdoc="">
			<comm cntt="Added by CC."/>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.mapLDC(sandmark.program.Class, java.util.Map)" access="pub" jdoc="">
				<param name="cls"/>
				<param name="indexMap"/>
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.encodeConstantPool(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.encode(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.scanClass(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.InsertDecodeInstructions(sandmark.program.Class, org.apache.bcel.generic.InstructionList)" access="priv" jdoc="">
				<comm cntt="il.append(_factory.createPrintln(&amp;quot;decoding...&amp;quot;));"/>
				<param name="cls"/>
				<param name="il"/>
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.AddClass(sandmark.program.Application, String)" access="pub" jdoc="">
				<param name="app"/>
				<param name="ClassName"/>
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.ObfuscateJar(String)" access="pub" jdoc="">
				<comm cntt="System.out.println(e.getMessage());"/>
				<param name="JarFile"/>
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.apply(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.obfuscate.stringencoder.LFStringEncoder.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.obfuscate.varsplitter">
		<class name="/:sandmark.obfuscate.varsplitter.VarSplitter" intfc="n" abs="n" inn="n" sloc="211" jdoc="">
			<comm cntt="This method splits all usage of old_slot between usage of old_slot and new_slot All store and inc statements are done on each slot in order to keep their contents synchronized in the order of new_slot, old_slot (this avoids some nasty race conditions...)"/>
			<comm cntt="Performs the actual modification of the requested method..."/>
			<comm cntt="This is just a test routine..."/>
			<comm cntt="Returns the URL at which you can find information about this obfuscator."/>
			<comm cntt="Returns an HTML description of this obfuscator."/>
			<comm cntt="Returns a long description of this obfuscator&amp;apos;s name."/>
			<comm cntt="Returns a short description of this obfuscator&amp;apos;s name."/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.split_vars(org.apache.bcel.generic.InstructionList, int, int)" access="priv" jdoc="">
				<comm cntt="Is this a load instruction for the old_slot?"/>
				<comm cntt="How about a store instruction for the old_slot?"/>
				<comm cntt="Append the original instruction to itself..."/>
				<comm cntt="Append xSTORE new_slot to the original instruction..."/>
				<comm cntt="Move the curih location past the new store inst..."/>
				<comm cntt="Am I an INC for the old_slot?"/>
				<comm cntt="Append the instruction to itself to the original instruction..."/>
				<comm cntt="Move the curih location past the inc insts..."/>
				<param name="instlist"/>
				<param name="old_slot"/>
				<param name="new_slot"/>
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.apply(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="Find the method we are going to modify"/>
				<comm cntt="This should NEVER happen, but just in case the file is corrupt"/>
				<comm cntt="Could I find the method?"/>
				<comm cntt="Nothing to do! (that was easy)"/>
				<comm cntt="System.out.println(il);"/>
				<comm cntt="Find the argument size..."/>
				<comm cntt="The local variables are the arguments of the method; I want to avoid using those slots."/>
				<comm cntt="If this is a store load inc instruction... that doesn&amp;apos;t refer to the arguments..."/>
				<comm cntt="&amp;gt;="/>
				<comm cntt="Don&amp;apos;t use this one..."/>
				<comm cntt="put this one in the good list (it seems to work)..."/>
				<comm cntt="This may be changed later..."/>
				<comm cntt="should be &amp;gt; than paramter list index."/>
				<comm cntt="randomly choosing a localvariable to use..."/>
				<comm cntt="Nothing to work with :("/>
				<comm cntt="This nasty statement picks a memory location of a local variable that fits our criteria"/>
				<comm cntt="Ok, now memloc is assigned the old slot location and newloc is assigned a new available slot location of the same size"/>
				<comm cntt="calling split_vars(...) to do the real work..."/>
				<comm cntt="All done! Put it back together..."/>
				<param name="methodObj"/>
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getPresuggestions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getPostsuggestions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getPreprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.obfuscate.varsplitter.VarSplitter.getPostprohibited()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.optimise">
		<class name="/:sandmark.optimise.AppOptimizer" intfc="n" abs="y" inn="n" sloc="2" jdoc="An AppOptimizer object encapsulates code for performing an optimization that encompasses the entire application program. @author Christian Collberg @version 1.0">
		</class>
		<class name="/:sandmark.optimise.Optimise" intfc="n" abs="n" inn="n" sloc="90" jdoc="">
			<comm cntt="Describe what optimize is."/>
			<field name="sConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.optimise.Optimise.optimizeApplication(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.optimise.Optimise.getProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.optimise.Optimise.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the About page for Optimise @return html code for the about page">
			</mth>
			<mth name="/:sandmark.optimise.Optimise.getHelpURL()" access="pub" jdoc="Get the URL of the Help page for Optimise @return url of the help page">
			</mth>
			<mth name="/:sandmark.optimise.Optimise.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.optimise.ClassOptimizer" intfc="n" abs="y" inn="n" sloc="2" jdoc="A ClassOptimizer object encapsulates code for performing an optimization that operates on a whole class. @author Christian Collberg @version 1.0">
		</class>
		<class name="/:sandmark.optimise.OptimizationException" intfc="n" abs="n" inn="n" sloc="7" jdoc="">
			<mth name="/:sandmark.optimise.OptimizationException.OptimizationException(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:sandmark.optimise.MethodOptimizer" intfc="n" abs="y" inn="n" sloc="2" jdoc="A MethodOptimizer object encapsulates code for performing an optimization that operates on a single method. @author Christian Collberg @version 1.0">
		</class>
		<class name="/:sandmark.optimise.Optimizer" intfc="n" abs="n" inn="n" sloc="31" jdoc="The sandmark.optimise.Optimizer class supervises optimization as parameterized by the global Properties and possibly also by a Scoreboard and other things yet to be determined. @author Christian Collberg @version 1.0">
			<mth name="/:sandmark.optimise.Optimizer.runOptimization(sandmark.program.Application, sandmark.Algorithm)" access="pub" jdoc="">
				<comm cntt="(alg instanceof sandmark.optimise.MethodOptimizer) {"/>
				<param name="app"/>
				<param name="alg"/>
			</mth>
		</class>
		<class name="/:sandmark.optimise.AllClassesOptimizer" intfc="n" abs="y" inn="n" sloc="12" jdoc="An AllClassesOptimizer applies a ClassOptimizer to all the classes in an application. @author Christian Collberg @version 1.0">
			<field name="co" access="pub" jdoc=""/>
			<mth name="/:sandmark.optimise.AllClassesOptimizer.AllClassesOptimizer(sandmark.optimise.ClassOptimizer)" access="pub" jdoc="Constructs an AllClassesOptimizer using a ClassOptimizer and its label. @param co">
				<param name="co"/>
			</mth>
			<mth name="/:sandmark.optimise.AllClassesOptimizer.apply(sandmark.program.Application)" access="pub" jdoc="Applies the class optimization to all classes contained in an application.">
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.optimise.GeneralOptimizer" intfc="y" abs="n" inn="n" sloc="1" jdoc="A GeneralOptimizer object encapsulates code for performing a particular optimization. Optimizations are grouped into three abstract subclasses: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; AppOptimizer &amp;lt;LI&amp;gt; ClassOptimizer &amp;lt;LI&amp;gt; MethodOptimizer &amp;lt; UL&amp;gt; @author Christian Collberg @version 1.1 5 20 2002 K.H.">
		</class>
	</pkg>
	<pkg name="/:sandmark.optimise.bloat">
		<class name="/:sandmark.optimise.bloat.BLOAT" intfc="n" abs="n" inn="n" sloc="102" jdoc="">
			<mth name="/:sandmark.optimise.bloat.BLOAT.apply(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.optimise.bloat.BLOAT.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.optimise.bloat.BLOAT.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.optimise.bloat.BLOAT.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.optimise.bloat.BLOAT.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.optimise.bloat.BLOAT.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.optimise.bloat.BLOAT.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.optimise.bloat.BLOAT.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.optimise.bloat.BLOAT.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.optimise.bloat.BLOAT.getMutations()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.program">
		<class name="/:sandmark.program.Application" intfc="n" abs="n" inn="n" sloc="369" jdoc="Represents a complete Java program. An Application object is the root of a tree encompassing Classes and all their subcomponents, plus other jar file entries such as images or sound clips. The jar file manifest is part of the application itself and is not a node in the tree. &amp;lt;P&amp;gt; For more background, see the {@link sandmark.program} package overview. &amp;lt;P&amp;gt;Here is a simple example that reads a jar file and prints the classes: &amp;lt;PRE&amp;gt; sandmark.program.Application app = new sandmark.program.Application(&amp;quot;program.jar&amp;quot;); java.util.Iterator it = a.classes(); while (it.hasNext()) { sandmark.program.Class cls = (sandmark.program.Class) it.next(); System.out.println(&amp;quot;class &amp;quot; + cls.getName()); } &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt;This example renames the main class and writes a new jar file: &amp;lt;PRE&amp;gt; sandmark.program.Application app = new sandmark.program.Application(&amp;quot;old.jar&amp;quot;); sandmark.program.Class c = app.getMain(); c.setName(&amp;quot;Start&amp;quot;); app.setMain(c); app.save(&amp;quot;new.jar&amp;quot;); &amp;lt; PRE&amp;gt; @author Gregg Townsend and Kelly Heffner">
			<comm cntt="attribute manifest"/>
			<field name="manifest" access="priv" jdoc=""/>
			<field name="mMostRecentPath" access="priv" jdoc=""/>
			<field name="mPathChangeListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.program.Application.Application()" access="pub" jdoc="Creates an empty application.">
			</mth>
			<mth name="/:sandmark.program.Application.Application(String)" access="pub" jdoc="Creates an application from a given jar file or class file. &amp;lt;P&amp;gt; If a jar file has an index file (META-INF INDEX.LIST), it is discarded because this code does not know how to maintain and update it. An index can be recreated later by running &amp;lt;CODE&amp;gt;&amp;quot;jar -i file.jar&amp;quot;&amp;lt; CODE&amp;gt;. &amp;lt;P&amp;gt; If a jar file has a manifest file (META-INF MANIFEST.MF), it is used to initialize the application&amp;apos;s manifest, but it does not appear as a member file within the application. &amp;lt;P&amp;gt; The &amp;lt;CODE&amp;gt;MAIN_CLASS&amp;lt; CODE&amp;gt; attribute is set if specified by the manifest or if exactly one &amp;lt;CODE&amp;gt;public static void main(String[])&amp;lt; CODE&amp;gt; method is found among all the classes loaded. @param filename the name of a jar file or class file">
				<param name="filename"/>
			</mth>
			<mth name="/:sandmark.program.Application.Application(java.io.File)" access="pub" jdoc="Creates an application from a given jar file or class file. &amp;lt;P&amp;gt; If a jar file has an index file (META-INF INDEX.LIST), it is discarded because this code does not know how to maintain and update it. An index can be recreated later by running &amp;lt;CODE&amp;gt;&amp;quot;jar -i file.jar&amp;quot;&amp;lt; CODE&amp;gt;. &amp;lt;P&amp;gt; If a jar file has a manifest file (META-INF MANIFEST.MF), it is used to initialize the application&amp;apos;s manifest, but it does not appear as a member file within the application. &amp;lt;P&amp;gt; The &amp;lt;CODE&amp;gt;MAIN_CLASS&amp;lt; CODE&amp;gt; attribute is set if specified by the manifest or if exactly one &amp;lt;CODE&amp;gt;public static void main(String[])&amp;lt; CODE&amp;gt; method is found among all the classes loaded. @param file a jar file or class file">
				<comm cntt="set App name"/>
				<comm cntt="set main class"/>
				<comm cntt="load user configuration settings if they exist"/>
				<param name="file"/>
			</mth>
			<mth name="/:sandmark.program.Application.loadJarFile(java.io.File)" access="priv" jdoc="Loads the contents of a jar file into this application.">
				<comm cntt="clean up manifest"/>
				<param name="file"/>
			</mth>
			<mth name="/:sandmark.program.Application.unwanted(String)" access="priv" jdoc="Returns true if the given filename matches a META-INF file that we want to discard instead of reading in.">
				<comm cntt="make tests case insensitive"/>
				<comm cntt="old manifest"/>
				<comm cntt="jar index"/>
				<comm cntt="class signatures"/>
				<comm cntt="manifest signature"/>
				<comm cntt="alternate manifest signature"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.program.Application.rmsigs(java.util.jar.Manifest)" access="priv" jdoc="Cleans the manifest of digital signatures for class files (which become invalid when SandMark modifies the classes).">
				<param name="manifest"/>
			</mth>
			<mth name="/:sandmark.program.Application.findMain()" access="priv" jdoc="Sets the &amp;lt;CODE&amp;gt;MAIN_CLASS&amp;lt; CODE&amp;gt; attribute if there is exactly one &amp;lt;CODE&amp;gt;public static void main(String[])&amp;lt; CODE&amp;gt; method in the loaded classes.">
			</mth>
			<mth name="/:sandmark.program.Application.save(String)" access="pub" jdoc="Writes this application to the specified file as a jar file. A manifest file (META-INF MANIFEST.MF) is included unless it would be empty. A user configuration file is written. @param filename the name of the file">
				<param name="filename"/>
			</mth>
			<mth name="/:sandmark.program.Application.save(java.io.File)" access="pub" jdoc="">
				<param name="file"/>
			</mth>
			<mth name="/:sandmark.program.Application.save(java.io.OutputStream)" access="pub" jdoc="Writes this application to the specified output stream as a jar file. A manifest file (META-INF MANIFEST.MF) is included unless it would be empty. @param ostream the output stream">
				<comm cntt="manifest is empty, so don&amp;apos;t write it"/>
				<comm cntt="include manifest in jar file"/>
				<comm cntt="must have this or it won&amp;apos;t write the Main-Class attribute!"/>
				<comm cntt="BCEL&amp;apos;s JavaClass.dump insists on closing its output stream;"/>
				<comm cntt="override close() to avoid trouble with the multi-file jar output."/>
				<comm cntt="sort list of members for a sensibly-ordered output jarfile"/>
				<comm cntt="write the jar file, excluding library objects"/>
				<param name="ostream"/>
			</mth>
			<mth name="/:sandmark.program.Application.close()" access="pub" jdoc="Frees resources and renders this application object invalid.">
				<comm cntt="flush cache"/>
			</mth>
			<mth name="/:sandmark.program.Application.finalize()" access="pub" jdoc="Calls {@link sandmark.program.Application#close() close}.">
			</mth>
			<mth name="/:sandmark.program.Application.getManifest()" access="pub" jdoc="Gets the manifest of this application. @return the program manifest">
			</mth>
			<mth name="/:sandmark.program.Application.getMain()" access="pub" jdoc="Gets the &amp;lt;CODE&amp;gt;MAIN_CLASS&amp;lt; CODE&amp;gt; attribute of this application. @return the class containing the main method, or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if no main class is set">
			</mth>
			<mth name="/:sandmark.program.Application.setMain(sandmark.program.Class)" access="pub" jdoc="Sets the &amp;lt;CODE&amp;gt;MAIN_CLASS&amp;lt; CODE&amp;gt; attribute for this application. If the argument is &amp;lt;CODE&amp;gt;null&amp;lt; CODE&amp;gt;, the attribute is cleared. The application&amp;apos;s &amp;lt;CODE&amp;gt;mark&amp;lt; CODE&amp;gt; method is called. @param c the class containing the main method for the application">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.program.Application.setMain(String)" access="pub" jdoc="Sets the &amp;lt;CODE&amp;gt;MAIN_CLASS&amp;lt; CODE&amp;gt; attribute for this application. If the argument is &amp;lt;CODE&amp;gt;null&amp;lt; CODE&amp;gt;, the attribute is cleared. The application&amp;apos;s &amp;lt;CODE&amp;gt;mark&amp;lt; CODE&amp;gt; method is called. @param classname the name of the class containing the main method for this application">
				<param name="classname"/>
			</mth>
			<mth name="/:sandmark.program.Application.findClass(String)" access="pub" jdoc="Returns the specified class, which may be in this Application, in one of the jar specified in this Application&amp;apos;s Manifest in the Class-Path variable, or in the CLASSPATH">
				<comm cntt="Doesn&amp;apos;t exist, so keep going"/>
				<comm cntt="It&amp;apos;s screwed up, so keep going"/>
				<comm cntt="It&amp;apos;s screwed up, so keep going"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.program.Application.getClass(String)" access="pub" jdoc="Returns the specified class. @param name the fully qualified name of the desired class (for example &amp;lt;code&amp;gt;java.lang.String&amp;lt; code&amp;gt; @return the Class object for the desired class">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.program.Application.getClasses()" access="pub" jdoc="Returns a list of all the classes in this application. @return an array of Class objects containing each class in the application">
			</mth>
			<mth name="/:sandmark.program.Application.classes()" access="pub" jdoc="Returns an iterator over all the classes in this application. @return an iterator of &amp;lt;code&amp;gt;sandmark.program.Class&amp;lt; code&amp;gt; objects containing each class in this application">
			</mth>
			<mth name="/:sandmark.program.Application.getFile(String)" access="pub" jdoc="Returns a single file associated with this application. @param name the name of a member of the jarfile @return a file abstraction for the specified component">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.program.Application.getFiles()" access="pub" jdoc="Returns a list of all the files associated with this application, excluding class files and the manifest. @return an array of sandmark.program.File objects">
			</mth>
			<mth name="/:sandmark.program.Application.files()" access="pub" jdoc="Returns an iterator over all the files associated with this application, excluding class files and the manifest. @return an iterator of sandmark.program.File objects">
			</mth>
			<mth name="/:sandmark.program.Application.getHierarchy()" access="pub" jdoc="Returns the class hierarchy containing all the classes in the application. The hierarchy is cached so that repeated calls to &amp;lt;code&amp;gt;getHierarchy&amp;lt; code&amp;gt; return the same object as long as this application and its components are not modified. @return the class hierarchy information for this application">
				<comm cntt="(String jarfile) {"/>
			</mth>
			<mth name="/:sandmark.program.Application.getStatistics()" access="pub" jdoc="Returns the Stats object for this application, constructing one if necessary.">
			</mth>
			<mth name="/:sandmark.program.Application.getMostRecentPath()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Application.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.program.Application.setPath(java.io.File)" access="priv" jdoc="">
				<param name="file"/>
			</mth>
			<mth name="/:sandmark.program.Application.getPath()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Application.addPathChangeListener(PathChangeListener)" access="pub" jdoc="">
				<param name="listener"/>
			</mth>
			<mth name="/:sandmark.program.Application.removePathChangeListener(PathChangeListener)" access="pub" jdoc="">
				<param name="listener"/>
			</mth>
			<mth name="/:sandmark.program.Application.getCanonicalName()" access="pub" jdoc="">
				<comm cntt="there is no real name for the jar file from inside the program"/>
			</mth>
			<mth name="/:sandmark.program.Application.saveUserConstraints()" access="pub" jdoc="Saves the user configuration settings to disk, if the application exists on disk. @return true if the application existed on disk and config was written">
			</mth>
			<mth name="/:sandmark.program.Application.loadUserConstraints()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Application.delete()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.program.LocalClass" intfc="n" abs="n" inn="n" sloc="41" jdoc="Represents a class found in the program jar file, or synthesized. &amp;lt;P&amp;gt; Modification methods in this class automatically call the{@link sandmark.program.Object#mark() mark} method to register their changes. @see sandmark.program.Class">
			<mth name="/:sandmark.program.LocalClass.LocalClass(sandmark.program.Application, String, String, String, int, String[])" access="pub" jdoc="Constructs a new LocalClass and adds it to an application. The arguments mimic a BCEL JavaClass constructor.">
				<param name="parent"/>
				<param name="class_name"/>
				<param name="super_class_name"/>
				<param name="file_name"/>
				<param name="access_flags"/>
				<param name="interfaces"/>
			</mth>
			<mth name="/:sandmark.program.LocalClass.LocalClass(sandmark.program.Application, java.io.InputStream, String)" access="pub" jdoc="Constructs a LocalClass and adds it to an application. The class is read from an InputStream containing a classfile.">
				<param name="parent"/>
				<param name="istream"/>
				<param name="fname"/>
			</mth>
			<mth name="/:sandmark.program.LocalClass.LocalClass(sandmark.program.Application, org.apache.bcel.classfile.JavaClass)" access="pub" jdoc="Constructs a LocalClass from a BCEL JavaClass and adds it to an application.">
				<param name="parent"/>
				<param name="jclass"/>
			</mth>
			<mth name="/:sandmark.program.LocalClass.LocalClass(sandmark.program.Application, org.apache.bcel.classfile.JavaClass, sandmark.program.Class)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="jclass"/>
				<param name="original"/>
			</mth>
			<mth name="/:sandmark.program.LocalClass.makeCPG(sandmark.program.Class, org.apache.bcel.classfile.ConstantPool)" access="pub" jdoc="Constructs a LocalCPG for this class.">
				<comm cntt="package"/>
				<param name="c"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.program.LocalClass.makeField(sandmark.program.Class, org.apache.bcel.classfile.Field)" access="pub" jdoc="Constructs a LocalField for this class.">
				<comm cntt="package"/>
				<param name="c"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.program.LocalClass.makeMethod(sandmark.program.Class, org.apache.bcel.classfile.Method)" access="pub" jdoc="Constructs a LocalMethod for this class.">
				<comm cntt="package"/>
				<param name="c"/>
				<param name="m"/>
			</mth>
		</class>
		<class name="/:sandmark.program.LibraryField" intfc="n" abs="n" inn="n" sloc="7" jdoc="Represents a field within a class or interface found on the CLASSPATH. Such fields are immutable; modification attempts produce a java.lang.UnsupportedOperationException. @see sandmark.program.Field">
			<mth name="/:sandmark.program.LibraryField.LibraryField(sandmark.program.Class, org.apache.bcel.classfile.Field)" access="pub" jdoc="Constructs a LibraryField from a BCEL Field and adds it to a class.">
				<comm cntt="package"/>
				<param name="parent"/>
				<param name="f"/>
			</mth>
		</class>
		<class name="/:sandmark.program.PathChangeListener" intfc="y" abs="n" inn="n" sloc="3" jdoc="">
			<mth name="/:sandmark.program.PathChangeListener.pathChanged(java.io.File)" access="pub" jdoc="">
				<param name="newPath"/>
			</mth>
		</class>
		<class name="/:sandmark.program.LocalField" intfc="n" abs="n" inn="n" sloc="11" jdoc="Represents a modifiable field within a class or interface. &amp;lt;P&amp;gt; Modification methods in this class automatically call the{@link sandmark.program.Object#mark() mark} method to register their changes. @see sandmark.program.Field">
			<mth name="/:sandmark.program.LocalField.LocalField(sandmark.program.Class, int, org.apache.bcel.generic.Type, String)" access="pub" jdoc="Constructs a LocalField and adds it to a class. The arguments mimic a BCEL FieldGen constructor.">
				<param name="parent"/>
				<param name="access_flags"/>
				<param name="type"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.program.LocalField.LocalField(sandmark.program.Class, org.apache.bcel.classfile.Field)" access="pub" jdoc="Constructs a LocalField from a BCEL Field and adds it to a class.">
				<param name="parent"/>
				<param name="f"/>
			</mth>
		</class>
		<class name="/:sandmark.program.ObjectMemberChangeListener" intfc="y" abs="n" inn="n" sloc="9" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.program.ObjectMemberChangeListener.addedObject(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="added"/>
			</mth>
			<mth name="/:sandmark.program.ObjectMemberChangeListener.deletingObject(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="deleted"/>
			</mth>
			<mth name="/:sandmark.program.ObjectMemberChangeListener.copiedObject(sandmark.program.Object, sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="orig"/>
				<param name="copy"/>
			</mth>
		</class>
		<class name="/:sandmark.program.LocalCPG" intfc="n" abs="n" inn="n" sloc="6" jdoc="Wraps the ConstantPoolGen class in order to intercept method calls and mark the enclosing class as dirty.">
			<mth name="/:sandmark.program.LocalCPG.LocalCPG(sandmark.program.Class, org.apache.bcel.classfile.ConstantPool)" access="pub" jdoc="Constructs a Sandmark LocalCPG from a BCEL ConstantPool.">
				<param name="c"/>
				<param name="cp"/>
			</mth>
		</class>
		<class name="/:sandmark.program.MarkListener" intfc="y" abs="n" inn="n" sloc="3" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.program.MarkListener.objectMarked(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.program.ConstantPoolGen" intfc="n" abs="y" inn="n" sloc="90" jdoc="Wraps the ConstantPoolGen class in order to intercept BCEL method calls. Each method that modifies the constant pool calls the &amp;lt;CODE&amp;gt;mark&amp;lt; CODE&amp;gt; method of the associated class in addition to performing its usual function.">
			<comm cntt="most headers below were extracted unedited from BCEL ConstantPoolGen"/>
			<field name="smclass" access="priv" jdoc="The enclosing Class object."/>
			<mth name="/:sandmark.program.ConstantPoolGen.ConstantPoolGen(sandmark.program.Class, org.apache.bcel.classfile.ConstantPool)" access="pub" jdoc="Constructs a Sandmark ConstantPoolGen from a BCEL ConstantPool.">
				<param name="c"/>
				<param name="cp"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.getSMClass()" access="pub" jdoc="Gets the class associated with this constant pool.">
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addString(String)" access="pub" jdoc="Add a new String constant to the ConstantPool, if it is not already in there. @param str String to add @return index of entry">
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addClass(String)" access="pub" jdoc="Add a new Class reference to the ConstantPool, if it is not already in there. @param str Class to add @return index of entry">
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addClass(org.apache.bcel.generic.ObjectType)" access="pub" jdoc="Add a new Class reference to the ConstantPool for a given type. @param str Class to add @return index of entry">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addArrayClass(org.apache.bcel.generic.ArrayType)" access="pub" jdoc="Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY instruction, e.g. to the ConstantPool. @param type type of array class @return index of entry">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addInteger(int)" access="pub" jdoc="Add a new Integer constant to the ConstantPool, if it is not already in there. @param n integer number to add @return index of entry">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addFloat(float)" access="pub" jdoc="Add a new Float constant to the ConstantPool, if it is not already in there. @param n Float number to add @return index of entry">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addUtf8(String)" access="pub" jdoc="Add a new Utf8 constant to the ConstantPool, if it is not already in there. @param n Utf8 string to add @return index of entry">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addLong(long)" access="pub" jdoc="Add a new long constant to the ConstantPool, if it is not already in there. @param n Long number to add @return index of entry">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addDouble(double)" access="pub" jdoc="Add a new double constant to the ConstantPool, if it is not already in there. @param n Double number to add @return index of entry">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addNameAndType(String, String)" access="pub" jdoc="Add a new NameAndType constant to the ConstantPool if it is not already in there. @param n NameAndType string to add @return index of entry">
				<param name="name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addMethodref(String, String, String)" access="pub" jdoc="Add a new Methodref constant to the ConstantPool, if it is not already in there. @param n Methodref string to add @return index of entry">
				<param name="class_name"/>
				<param name="method_name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addMethodref(org.apache.bcel.generic.MethodGen)" access="pub" jdoc="Add a new Methodref constant to the ConstantPool, if it is not already in there. @param method method to add @return index of entry">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addMethodref(sandmark.program.Method)" access="pub" jdoc="Add a new Methodref constant to the ConstantPool, if it is not already in there. @param method method to add @return index of entry">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addInterfaceMethodref(String, String, String)" access="pub" jdoc="Add a new InterfaceMethodref constant to the ConstantPool, if it is not already in there. @param n InterfaceMethodref string to add @return index of entry">
				<param name="class_name"/>
				<param name="method_name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addInterfaceMethodref(org.apache.bcel.generic.MethodGen)" access="pub" jdoc="Add a new InterfaceMethodref constant to the ConstantPool, if it is not already in there. @param method method to add @return index of entry">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addInterfaceMethodref(sandmark.program.Method)" access="pub" jdoc="Add a new InterfaceMethodref constant to the ConstantPool, if it is not already in there. @param method method to add @return index of entry">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addFieldref(String, String, String)" access="pub" jdoc="Add a new Fieldref constant to the ConstantPool, if it is not already in there. @param n Fieldref string to add @return index of entry">
				<param name="class_name"/>
				<param name="field_name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.setConstant(int, org.apache.bcel.classfile.Constant)" access="pub" jdoc="&amp;quot;Use with care!&amp;quot; is the entire BCEL description. (It should be something like &amp;quot;Do not use, it&amp;apos;s broken.&amp;quot;) @param i index in constant pool @param c new constant pool entry at index i">
				<param name="i"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.program.ConstantPoolGen.addConstant(org.apache.bcel.classfile.Constant, ConstantPoolGen)" access="pub" jdoc="Import constant from another ConstantPool and return new index.">
				<param name="c"/>
				<param name="cp"/>
			</mth>
		</class>
		<class name="/:sandmark.program.UserObjectConstraints" intfc="n" abs="n" inn="n" sloc="82" jdoc="Encapsulates the obfuscation user configuration information for one application object. This information includes the level of obfuscation that is desired for this object, whether the object is involved in threaded code or code that uses reflection, and other properties that affect what obfuscations should be run on the object. @author Steven Kobes @since SandMark 3.1">
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="multithreaded" access="pub" jdoc=""/>
			<field name="reflection" access="pub" jdoc=""/>
			<field name="performanceCritical" access="pub" jdoc=""/>
			<field name="obfuscationLevel" access="pub" jdoc=""/>
			<field name="myOffAlgorithms" access="priv" jdoc=""/>
			<mth name="/:sandmark.program.UserObjectConstraints.UserObjectConstraints()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.UserObjectConstraints(UserObjectConstraints)" access="pub" jdoc="">
				<param name="constraints"/>
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.copyFrom(UserObjectConstraints)" access="pub" jdoc="">
				<param name="constraints"/>
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.isAlgoOn(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.isAlgoOn(String)" access="pub" jdoc="">
				<param name="algShortName"/>
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.setAlgoOn(sandmark.Algorithm, boolean)" access="pub" jdoc="">
				<param name="a"/>
				<param name="isOn"/>
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.setAlgoOn(String, boolean)" access="pub" jdoc="">
				<param name="algShortName"/>
				<param name="isOn"/>
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.writeUserConstraints(java.io.OutputStream, sandmark.program.Application)" access="pub" jdoc="Writes the user constraints for each part of the application to the given output stream.">
				<comm cntt="put every object with a user constraint into a hash table and"/>
				<comm cntt="serialize the table"/>
				<comm cntt="if(constraints.size &amp;gt; 0){"/>
				<comm cntt="}"/>
				<param name="out"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.collectUserConstraints(sandmark.program.Object, java.util.HashMap)" access="priv" jdoc="">
				<param name="obj"/>
				<param name="constraintMap"/>
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.readUserConstraints(java.io.InputStream, sandmark.program.Application)" access="pub" jdoc="">
				<param name="in"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.program.UserObjectConstraints.assignUserConstraints(sandmark.program.Object, java.util.HashMap)" access="priv" jdoc="">
				<param name="obj"/>
				<param name="constraintMap"/>
			</mth>
		</class>
		<class name="/:sandmark.program.Method" intfc="n" abs="y" inn="n" sloc="424" jdoc="Represents a single method within a class or interface. A &amp;lt;CODE&amp;gt;Method&amp;lt; CODE&amp;gt; object embeds a BCEL &amp;lt;CODE&amp;gt;MethodGen&amp;lt; CODE&amp;gt; object in a Sandmark program object. Most methods just call the corresponding BCEL method. Modification methods automatically call the{@link sandmark.program.Object#mark() mark} method to register their changes. &amp;lt;P&amp;gt;Here is a simple example of how to use the BCEL interfaces. This code adds a NOP instruction at the beginning of each method in a supplied class. &amp;lt;PRE&amp;gt; static void addNOPs(sandmark.program.Class c) { sandmark.program.Method[] mlist = c.getMethods(); java.util.Iterator it = c.methods(); while (it.hasNext()) { sandmark.program.Method m = (sandmark.program.Method) it.next(); System.out.println( &amp;quot; method &amp;quot; + m.getName() + &amp;quot; &amp;quot; + m.getSignature()); org.apache.bcel.generic.InstructionList ilist = m.getInstructionList(); ilist.insert(org.apache.bcel.generic.InstructionConstants.NOP); m.mark(); } } &amp;lt; PRE&amp;gt;">
			<comm cntt="package"/>
			<comm cntt="BCEL wrapper functions from class Method"/>
			<comm cntt="Lifted directly from BCEL&amp;apos;s setMaxLocals() in MethodGen.java ver 1.7"/>
			<comm cntt=""/>
			<const name="CFG_KEY" access="priv" jdoc=""/>
			<const name="IFG_KEY" access="priv" jdoc=""/>
			<const name="SS_KEY" access="priv" jdoc=""/>
			<field name="methodGen" access="pub" jdoc=""/>
			<mth name="/:sandmark.program.Method.Method(sandmark.program.Class, org.apache.bcel.classfile.Method)" access="pub" jdoc="Constructs a SandMark Method from a BCEL Method and adds it to a class.">
				<comm cntt="package"/>
				<param name="parent"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.Method.Method(sandmark.program.Class, org.apache.bcel.generic.MethodGen, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="gen"/>
				<param name="orig"/>
			</mth>
			<mth name="/:sandmark.program.Method.fixLDC_WBug()" access="pub" jdoc="This method addresses a bug in BCEL that causes LDC_W instructions to have bad internal state combinations. This method need only be called on BCEL-parsed methods.">
				<comm cntt="package"/>
			</mth>
			<mth name="/:sandmark.program.Method.constructName()" access="pub" jdoc="Returns the unique name under which this Method is registered in the parent Class object.">
				<comm cntt="package"/>
			</mth>
			<mth name="/:sandmark.program.Method.getCanonicalName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getMethod()" access="pub" jdoc="Returns a BCEL Method corresponding to this SandMark Method.">
				<comm cntt="package"/>
			</mth>
			<mth name="/:sandmark.program.Method.copy()" access="pub" jdoc="Returns a copy of this method. The new method has a random name and is a member of the same class as this method. The new method is always an instance of LocalMethod, and mutable, even if copied from a LibraryMethod instance.">
			</mth>
			<mth name="/:sandmark.program.Method.getEnclosingClass()" access="pub" jdoc="Returns the class that contains this method. @return the class object for the enclosing class">
			</mth>
			<mth name="/:sandmark.program.Method.getSuperMethod()" access="pub" jdoc="Returns the method in the superclass that this method overrides. @return the superclass method that is overridden or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if no method exists">
				<comm cntt="traverse up the parent classes"/>
			</mth>
			<mth name="/:sandmark.program.Method.getCFG()" access="pub" jdoc="Returns the control flow graph for this method. Paths due to exceptions are included. @return a control flow graph">
			</mth>
			<mth name="/:sandmark.program.Method.getCFG(boolean)" access="pub" jdoc="Returns the control flow graph for this method. The parameter specifies whether paths due to exceptions are included. @return a control flow graph">
				<param name="withExceptions"/>
			</mth>
			<mth name="/:sandmark.program.Method.getIFG()" access="pub" jdoc="Returns the interference graph for this method&amp;apos;s local variables. @return an interference graph">
			</mth>
			<mth name="/:sandmark.program.Method.getStack()" access="pub" jdoc="Returns information about the state of the data stack at each point in the method. @return a simulation of the data stack throughout the method">
			</mth>
			<mth name="/:sandmark.program.Method.isMain()" access="pub" jdoc="Returns true if this method has the right name (&amp;lt;CODE&amp;gt;main&amp;lt; CODE&amp;gt;) and signature (&amp;lt;CODE&amp;gt;public static void (String[])&amp;lt; CODE&amp;gt;) to be the initial entry point of a Java program.">
			</mth>
			<mth name="/:sandmark.program.Method.getConstantPool()" access="pub" jdoc="Returns the ConstantPoolGen associated with this method and its class.">
			</mth>
			<mth name="/:sandmark.program.Method.getCPG()" access="pub" jdoc="Returns the ConstantPoolGen associated with this method and its class.">
			</mth>
			<mth name="/:sandmark.program.Method.setCPG(sandmark.program.ConstantPoolGen)" access="pub" jdoc="Sets the ConstantPoolGen associated with this method. It is only safe to do this for a whole class at a time, so this method is restricted although there is a similar public method at the class level.">
				<comm cntt="package"/>
				<param name="cpg"/>
			</mth>
			<mth name="/:sandmark.program.Method.getAccessFlags()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getExceptionTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getLocalVariableTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getSignature()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getArgumentName(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.program.Method.getArgumentNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getArgumentType(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.program.Method.getArgumentTypes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getClassName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getCodeAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getExceptionHandlers()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getExceptions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getInstructionList()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getLineNumbers()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getLineNumberTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getLocalVariables()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getMaxLocals()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.calcMaxLocals()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getMaxStack()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.getReturnType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.addAttribute(org.apache.bcel.classfile.Attribute)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Method.removeAttribute(org.apache.bcel.classfile.Attribute)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Method.removeAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.setAccessFlags(int)" access="pub" jdoc="">
				<param name="access_flags"/>
			</mth>
			<mth name="/:sandmark.program.Method.setAttributes(org.apache.bcel.classfile.Attribute[])" access="pub" jdoc="">
				<comm cntt="methodGen.setAttributes(attributes);"/>
				<comm cntt="I find it very strange that methodGen has removeAttributes and"/>
				<comm cntt="addAttribute, but no setAttributes"/>
				<comm cntt="I am doing this the &amp;quot;less efficient&amp;quot; way to avoid the conversion"/>
				<comm cntt="to Method and back to MethodGen"/>
				<param name="attributes"/>
			</mth>
			<mth name="/:sandmark.program.Method.setName(String)" access="pub" jdoc="">
				<comm cntt="need to rehash the member in its parent"/>
				<param name="newName"/>
			</mth>
			<mth name="/:sandmark.program.Method.setType(org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.program.Method.removeLineNumber(org.apache.bcel.generic.LineNumberGen)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.program.Method.removeLineNumbers()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.removeLocalVariable(org.apache.bcel.generic.LocalVariableGen)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.program.Method.removeLocalVariables()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.removeNOPs()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.addCodeAttribute(org.apache.bcel.classfile.Attribute)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Method.addException(String)" access="pub" jdoc="">
				<param name="class_name"/>
			</mth>
			<mth name="/:sandmark.program.Method.addExceptionHandler(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.ObjectType)" access="pub" jdoc="">
				<param name="start_pc"/>
				<param name="end_pc"/>
				<param name="handler_pc"/>
				<param name="catch_type"/>
			</mth>
			<mth name="/:sandmark.program.Method.addLineNumber(org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="ih"/>
				<param name="src_line"/>
			</mth>
			<mth name="/:sandmark.program.Method.addLocalVariable(String, org.apache.bcel.generic.Type, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="start"/>
				<param name="end"/>
			</mth>
			<mth name="/:sandmark.program.Method.addLocalVariable(String, org.apache.bcel.generic.Type, int, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="slot"/>
				<param name="start"/>
				<param name="end"/>
			</mth>
			<mth name="/:sandmark.program.Method.removeCodeAttribute(org.apache.bcel.classfile.Attribute)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Method.removeCodeAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.removeException(String)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.program.Method.removeExceptionHandler(org.apache.bcel.generic.CodeExceptionGen)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.program.Method.removeExceptionHandlers()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.removeExceptions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.setArgumentName(int, String)" access="pub" jdoc="">
				<param name="i"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.program.Method.setArgumentNames(String[])" access="pub" jdoc="">
				<param name="arg_names"/>
			</mth>
			<mth name="/:sandmark.program.Method.setArgumentType(int, org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="i"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.program.Method.setArgumentTypes(org.apache.bcel.generic.Type[])" access="pub" jdoc="">
				<param name="arg_types"/>
			</mth>
			<mth name="/:sandmark.program.Method.setInstructionList(org.apache.bcel.generic.InstructionList)" access="pub" jdoc="">
				<param name="il"/>
			</mth>
			<mth name="/:sandmark.program.Method.setMaxLocals()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.setMaxLocals(int)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.program.Method.setMaxStack()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Method.setMaxStack(int)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.program.Method.setReturnType(org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="return_type"/>
			</mth>
			<mth name="/:sandmark.program.Method.stripAttributes(boolean)" access="pub" jdoc="">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.isPublic()" access="pub" jdoc="Returns true if the ACC_PUBLIC access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isPrivate()" access="pub" jdoc="Returns true if the ACC_PRIVATE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isProtected()" access="pub" jdoc="Returns true if the ACC_PROTECTED access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isStatic()" access="pub" jdoc="Returns true if the ACC_STATIC access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isFinal()" access="pub" jdoc="Returns true if the ACC_FINAL access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isSynchronized()" access="pub" jdoc="Returns true if the ACC_SYNCHRONIZED access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isVolatile()" access="pub" jdoc="Returns true if the ACC_VOLATILE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isTransient()" access="pub" jdoc="Returns true if the ACC_TRANSIENT access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isNative()" access="pub" jdoc="Returns true if the ACC_NATIVE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isInterface()" access="pub" jdoc="Returns true if the ACC_INTERFACE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isAbstract()" access="pub" jdoc="Returns true if the ACC_ABSTRACT access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.isStrictfp()" access="pub" jdoc="Returns true if the ACC_STRICTFP access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Method.setPublic(boolean)" access="pub" jdoc="Sets or clears the ACC_PUBLIC access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setPrivate(boolean)" access="pub" jdoc="Sets or clears the ACC_PRIVATE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setProtected(boolean)" access="pub" jdoc="Sets or clears the ACC_PROTECTED access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setStatic(boolean)" access="pub" jdoc="Sets or clears the ACC_STATIC access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setFinal(boolean)" access="pub" jdoc="Sets or clears the ACC_FINAL access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setSynchronized(boolean)" access="pub" jdoc="Sets or clears the ACC_SYNCHRONIZED access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setVolatile(boolean)" access="pub" jdoc="Sets or clears the ACC_VOLATILE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setTransient(boolean)" access="pub" jdoc="Sets or clears the ACC_TRANSIENT access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setNative(boolean)" access="pub" jdoc="Sets or clears the ACC_NATIVE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setInterface(boolean)" access="pub" jdoc="Sets or clears the ACC_INTERFACE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setAbstract(boolean)" access="pub" jdoc="Sets or clears the ACC_ABSTRACT access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Method.setStrictfp(boolean)" access="pub" jdoc="Sets or clears the ACC_STRICTFP access flag.">
				<param name="flag"/>
			</mth>
		</class>
		<class name="/:sandmark.program.File" intfc="n" abs="n" inn="n" sloc="39" jdoc="Represents arbitrary data stored as a &amp;quot;file&amp;quot; within a jar archive, such as an image or a sound clip. &amp;lt;P&amp;gt; Modification methods in this class automatically call the{@link sandmark.program.Object#mark() mark} method to register their changes.">
			<comm cntt="file contents"/>
			<field name="data" access="priv" jdoc=""/>
			<mth name="/:sandmark.program.File.File(sandmark.program.Application, String, byte[])" access="pub" jdoc="Constructs a File object from an array of bytes. @param parent the containing application @param name the filename in the jar file @param data the file contents">
				<param name="parent"/>
				<param name="name"/>
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.program.File.File(sandmark.program.Application, String, java.io.InputStream)" access="pub" jdoc="Constructs a File object from an input stream of data. @param parent the containing application @param name the filename in the jar file @param istr the file contents">
				<param name="parent"/>
				<param name="name"/>
				<param name="istr"/>
			</mth>
			<mth name="/:sandmark.program.File.getJarName()" access="pub" jdoc="Gets the name used in the jar file.">
			</mth>
			<mth name="/:sandmark.program.File.getCanonicalName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.File.getBytes()" access="pub" jdoc="Gets a copy of the file data as byte array.">
			</mth>
			<mth name="/:sandmark.program.File.getStream()" access="pub" jdoc="Gets a copy of the file data as an InputStream.">
			</mth>
			<mth name="/:sandmark.program.File.save(java.io.OutputStream)" access="pub" jdoc="Saves the data to an output stream.">
				<param name="ostream"/>
			</mth>
			<mth name="/:sandmark.program.File.setData(byte[])" access="pub" jdoc="Sets the data by copying from a byte array.">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.program.File.setData(java.io.InputStream)" access="pub" jdoc="Sets the data by reading from an InputStream.">
				<param name="istream"/>
			</mth>
		</class>
		<class name="/:sandmark.program.LocalMethod" intfc="n" abs="n" inn="n" sloc="36" jdoc="Represents a modifiable method within a class or interface. &amp;lt;P&amp;gt; Modification methods in this class automatically call the{@link sandmark.program.Object#mark() mark} method to register their changes. @see sandmark.program.Method">
			<mth name="/:sandmark.program.LocalMethod.LocalMethod(sandmark.program.Class, int, org.apache.bcel.generic.Type, org.apache.bcel.generic.Type[], String[], String, org.apache.bcel.generic.InstructionList)" access="pub" jdoc="Constructs a LocalMethod and adds it to a class. The arguments mimic a BCEL MethodGen constructor.">
				<param name="parent"/>
				<param name="access_flags"/>
				<param name="return_type"/>
				<param name="arg_types"/>
				<param name="arg_names"/>
				<param name="method_name"/>
				<param name="il"/>
			</mth>
			<mth name="/:sandmark.program.LocalMethod.makeMethod(sandmark.program.Class, int, org.apache.bcel.generic.Type, org.apache.bcel.generic.Type[], String[], String, org.apache.bcel.generic.InstructionList)" access="priv" jdoc="">
				<param name="parent"/>
				<param name="access_flags"/>
				<param name="return_type"/>
				<param name="arg_types"/>
				<param name="arg_names"/>
				<param name="method_name"/>
				<param name="il"/>
			</mth>
			<mth name="/:sandmark.program.LocalMethod.LocalMethod(sandmark.program.Class, org.apache.bcel.classfile.Method)" access="pub" jdoc="Constructs a LocalMethod from a BCEL Method and adds it to a class.">
				<param name="parent"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.LocalMethod.LocalMethod(sandmark.program.Class, org.apache.bcel.generic.MethodGen, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="mg"/>
				<param name="orig"/>
			</mth>
		</class>
		<class name="/:sandmark.program.LibraryMethod" intfc="n" abs="n" inn="n" sloc="7" jdoc="Represents a method within a class or interface found on the CLASSPATH. Such methods are immutable; modification attempts produce a java.lang.UnsupportedOperationException. @see sandmark.program.Method">
			<mth name="/:sandmark.program.LibraryMethod.LibraryMethod(sandmark.program.Class, org.apache.bcel.classfile.Method)" access="pub" jdoc="Constructs a LibraryMethod from a BCEL Method and adds it to a class.">
				<comm cntt="package"/>
				<param name="parent"/>
				<param name="method"/>
			</mth>
		</class>
		<class name="/:sandmark.program.LibraryClass" intfc="n" abs="n" inn="n" sloc="36" jdoc="Represents a class found on the CLASSPATH. Such classes are created lazily and automatically as needed, and are immutable. Modification attempts produce a java.lang.UnsupportedOperationException. @see sandmark.program.Class">
			<comm cntt="Caches library classes for reuse, since they&amp;apos;re immutable."/>
			<field name="classtab" access="priv" jdoc=""/>
			<mth name="/:sandmark.program.LibraryClass.find(String)" access="pub" jdoc="Finds a class on $CLASSPATH and returns a LibraryClass object. Such classes are not considered part of the application, and are immutable. Returns null if the class cannot be found or loaded.">
				<param name="classname"/>
			</mth>
			<mth name="/:sandmark.program.LibraryClass.LibraryClass(org.apache.bcel.classfile.JavaClass)" access="pub" jdoc="Constructs a LibraryClass from a BCEL JavaClass. The new class is not part of any application.">
				<param name="jclass"/>
			</mth>
			<mth name="/:sandmark.program.LibraryClass.makeCPG(sandmark.program.Class, org.apache.bcel.classfile.ConstantPool)" access="pub" jdoc="Constructs a LibraryCPG for this class.">
				<comm cntt="package"/>
				<param name="c"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.program.LibraryClass.makeField(sandmark.program.Class, org.apache.bcel.classfile.Field)" access="pub" jdoc="Constructs a LibraryField for this class.">
				<comm cntt="package"/>
				<param name="c"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.program.LibraryClass.makeMethod(sandmark.program.Class, org.apache.bcel.classfile.Method)" access="pub" jdoc="Constructs a LibraryMethod for this class.">
				<comm cntt="package"/>
				<param name="c"/>
				<param name="m"/>
			</mth>
		</class>
		<class name="/:sandmark.program.Object" intfc="n" abs="y" inn="n" sloc="206" jdoc="The superclass of all program objects. For more specific editing operation and access methods, see specific subclasses. For more background, see the {@link sandmark.program} package overview. &amp;lt;P&amp;gt; Program objects maintain an notion of &amp;lt;i&amp;gt;versions&amp;lt; i&amp;gt; to allow for a clean implementation of caching. The methods listed here keep this information and all internal caching information consistent. After making any change through other means (for example, editing the BCEL instruction list), the user must call the program object&amp;apos;s{@link sandmark.program.Object#mark() mark()} method to inform the object that it has changed. &amp;lt;P&amp;gt; There is a cache associated with each program object that stores information that is useful to internal code and external packages such as the Statistics package. When available, an application object&amp;apos;s getX() method should be called to access information rather than constructing a new X object. The cache is cleared whenever the object&amp;apos;s mark() method is called. &amp;lt;P&amp;gt; Operations on these objects act locally. Changing a method name does not change any of the references to that method. Global editing methods are provided in the{@link sandmark.program.util sandmark.program.util}package. @author Gregg Townsend and Kelly Heffner">
			<comm cntt="mapping from name to object"/>
			<comm cntt="package"/>
			<comm cntt="package"/>
			<comm cntt="get the associated Application object"/>
			<comm cntt="package"/>
			<comm cntt="package"/>
			<comm cntt="package"/>
			<comm cntt="package"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="versionNumber" access="priv" jdoc=""/>
			<field name="name" access="priv" jdoc=""/>
			<field name="mutable" access="priv" jdoc=""/>
			<field name="application" access="priv" jdoc=""/>
			<field name="parent" access="priv" jdoc=""/>
			<field name="cacheMap" access="priv" jdoc=""/>
			<field name="members" access="priv" jdoc=""/>
			<field name="constraints" access="priv" jdoc=""/>
			<field name="imStack" access="pub" jdoc="Marks this object as immutable. This action is irreversible."/>
			<field name="addStack" access="pub" jdoc="Adds the given object as a child of this object."/>
			<field name="mMemberChangeListeners" access="priv" jdoc=""/>
			<field name="mMarkListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.program.Object.Object()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Object.Object(sandmark.program.Object)" access="pub" jdoc="">
				<param name="orig"/>
			</mth>
			<mth name="/:sandmark.program.Object.getName()" access="pub" jdoc="Returns the name of this object. @return this objects name">
			</mth>
			<mth name="/:sandmark.program.Object.getCanonicalName()" access="pub" jdoc="Returns the canonical representation for the application object, guaranteed to be unique across the application. For example, a method&amp;apos;s canonical name is classname.methodname(signature) whereas a class&amp;apos;s canonical name is simply classname. @return a unique name for the object within the application">
			</mth>
			<mth name="/:sandmark.program.Object.setName(String)" access="pub" jdoc="Renames this object. Changing the name of an object is only a local change; the code for the underlying object will change but any references to the object will not be updated. To make a global change to the name of this object see{@link sandmark.program.util.Renamer sandmark.program.util.Renamer}. @param newName the new name for the object">
				<param name="newName"/>
			</mth>
			<mth name="/:sandmark.program.Object.toString()" access="pub" jdoc="Returns a concise representation for this object. @return a one line representation">
			</mth>
			<mth name="/:sandmark.program.Object.setImmutable()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Object.isMutable()" access="pub" jdoc="Returns &amp;lt;CODE&amp;gt;true&amp;lt; CODE&amp;gt; if this object can be edited. Objects loaded from the CLASSPATH are not editable. @return true if this is a mutable object">
			</mth>
			<mth name="/:sandmark.program.Object.mark()" access="pub" jdoc="Marks that this object has been modified. The object&amp;apos;s cache is invalidated, its version number is incremented, and its parent&amp;apos;s {@link sandmark.program.Object#mark() mark} method is called. &amp;lt;P&amp;gt; For the cache to be useful, this method must be called after any change to the object&amp;apos;s data. &amp;lt;P&amp;gt; Only mutable objects can be marked. Attempting to mark an immutable object throws &amp;lt;CODE&amp;gt;java.lang.UnsupportedOperationException&amp;lt; CODE&amp;gt;.">
				<comm cntt="throws java.lang.UnsupportedOperationException"/>
				<comm cntt="flush cache"/>
			</mth>
			<mth name="/:sandmark.program.Object.getVersion()" access="pub" jdoc="Returns the version number of the object. The version number of the object is incremented each time a change has occurred within the object either from a call to {@link sandmark.program.Object#mark()mark()} or from one of the editing methods provided by this object. @return the number of mark() calls">
			</mth>
			<mth name="/:sandmark.program.Object.delete()" access="pub" jdoc="Deletes this component from its parent, and from the jar file. A deleted object is invalid and should not be used further.">
			</mth>
			<mth name="/:sandmark.program.Object.getApplication()" access="pub" jdoc="Gets a reference to the Application that this object is part of. @return the associated Application object">
			</mth>
			<mth name="/:sandmark.program.Object.getParent()" access="pub" jdoc="Returns the parent of this object, if any. @return this object&amp;apos;s parent, or null">
			</mth>
			<mth name="/:sandmark.program.Object.getSize()" access="pub" jdoc="Returns the number of member (child) objects this object has. @return a count of this object&amp;apos;s members">
			</mth>
			<mth name="/:sandmark.program.Object.getMember(String)" access="pub" jdoc="Gets a member by name (one of possibly many). @param searchName the name of the member @return the program object for the specified member">
				<param name="searchName"/>
			</mth>
			<mth name="/:sandmark.program.Object.getMembers()" access="pub" jdoc="Returns a list of members (children) of this object, if any. @return this object&amp;apos;s members, or null">
			</mth>
			<mth name="/:sandmark.program.Object.members()" access="pub" jdoc="Returns an iterator over the members of this object. @return the members of this object">
			</mth>
			<mth name="/:sandmark.program.Object.cache(java.lang.Object, java.lang.Object)" access="pub" jdoc="Stores a value in this object&amp;apos;s cache. &amp;lt;b&amp;gt;Note:&amp;lt; b&amp;gt; This cache is flushed on a call to {@link sandmark.program.Object#mark() mark()}. @param key the key for this cache data @param value the value to cache">
				<param name="key"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.program.Object.retrieve(java.lang.Object)" access="pub" jdoc="Retrieves a value from this object&amp;apos;s cache. &amp;lt;b&amp;gt;Note:&amp;lt; b&amp;gt; This cache is flushed on a call to {@link sandmark.program.Object#mark() mark()}. @param key the key used to cache this data @return cached data">
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.program.Object.add(sandmark.program.Object)" access="pub" jdoc="">
				<param name="object"/>
			</mth>
			<mth name="/:sandmark.program.Object.add(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<comm cntt="check duplicates"/>
				<comm cntt="kheffner &amp; ash adding to an application should mark it"/>
				<param name="object"/>
				<param name="orig"/>
			</mth>
			<mth name="/:sandmark.program.Object.delete(sandmark.program.Object)" access="pub" jdoc="Deletes the given child of this object.">
				<comm cntt="package"/>
				<param name="subobject"/>
			</mth>
			<mth name="/:sandmark.program.Object.setApplication(sandmark.program.Application)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Object.getUserConstraints()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Object.hasUserConstraints()" access="pub" jdoc="Used for serializing the user preference data, checks to see if there has been changes from the default prefrence settings.">
				<comm cntt="package"/>
				<comm cntt="Added by kheffner on 11 18 03"/>
			</mth>
			<mth name="/:sandmark.program.Object.setUserConstraints(UserObjectConstraints)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.program.Object.unsupp()" access="pub" jdoc="Throws &amp;lt;CODE&amp;gt;java.lang.UnsupportedOperationException&amp;lt; CODE&amp;gt;.">
				<comm cntt="package"/>
			</mth>
			<mth name="/:sandmark.program.Object.getStackTrace(StackTraceElement)" access="priv" jdoc="">
				<param name="trace"/>
			</mth>
			<mth name="/:sandmark.program.Object.onDelete()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Object.addObjectMemberChangeListener(ObjectMemberChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.program.Object.removeObjectMemberChangeListener(ObjectMemberChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.program.Object.notifyDeletingMember(sandmark.program.Object)" access="priv" jdoc="">
				<param name="member"/>
			</mth>
			<mth name="/:sandmark.program.Object.notifyAddedMember(sandmark.program.Object)" access="priv" jdoc="">
				<param name="member"/>
			</mth>
			<mth name="/:sandmark.program.Object.notifyCopiedMember(sandmark.program.Object, sandmark.program.Object)" access="priv" jdoc="">
				<param name="orig"/>
				<param name="copy"/>
			</mth>
			<mth name="/:sandmark.program.Object.addMarkListener(MarkListener)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.program.Object.removeMarkListener(MarkListener)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.program.Object.notifyMarkListeners()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.program.Field" intfc="n" abs="y" inn="n" sloc="195" jdoc="Represents one field in a Java class or interface. A &amp;lt;CODE&amp;gt;Field&amp;lt; CODE&amp;gt; object embeds a BCEL &amp;lt;CODE&amp;gt;FieldGen&amp;lt; CODE&amp;gt; object in a Sandmark program object. Most methods just call the corresponding BCEL method. Modification methods automatically call the{@link sandmark.program.Object#mark() mark} method to register their changes.">
			<comm cntt="package"/>
			<comm cntt="BCEL wrapper methods"/>
			<comm cntt=""/>
			<comm cntt="These wrapper methods all begin by calling mark() to verify"/>
			<comm cntt="that this object is mutable."/>
			<field name="fieldGen" access="pub" jdoc=""/>
			<mth name="/:sandmark.program.Field.Field(sandmark.program.Class, org.apache.bcel.classfile.Field)" access="pub" jdoc="Constructs a SandMark Field from a BCEL Field and adds it to a class.">
				<comm cntt="package"/>
				<param name="parent"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.program.Field.constructName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getCanonicalName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getField()" access="pub" jdoc="Returns the BCEL Field corresponding to this SandMark Field.">
				<comm cntt="package"/>
				<comm cntt="NOTE: This is a hack! FieldGen and Field seem to share underlying"/>
				<comm cntt="attribute data. When a FieldGen is converted to a Field, this data"/>
				<comm cntt="is duplicated. In the event that this bug is ever fixed in BCEL,"/>
				<comm cntt="this code can be removed."/>
			</mth>
			<mth name="/:sandmark.program.Field.copy()" access="pub" jdoc="Returns a copy of this field.. The new field has a random name and is a member of the same class as this field. The new method is always an instance of LocalField, and mutable, even if copied from a LibraryField instance.">
			</mth>
			<mth name="/:sandmark.program.Field.getEnclosingClass()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getConstantPool()" access="pub" jdoc="Returns the ConstantPoolGen associated with this field and its class.">
			</mth>
			<mth name="/:sandmark.program.Field.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.setCPG(sandmark.program.ConstantPoolGen)" access="pub" jdoc="Sets the ConstantPoolGen associated with this field. It is only safe to do this for a whole class at a time, so this method is restricted although there is a similar public method at the class level.">
				<comm cntt="package"/>
				<param name="cpg"/>
			</mth>
			<mth name="/:sandmark.program.Field.getAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getConstantValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getAccessFlags()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getInitValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getNameIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getSignature()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getSignatureIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.addAttribute(org.apache.bcel.classfile.Attribute)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Field.cancelInitValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.removeAttribute(org.apache.bcel.classfile.Attribute)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Field.removeAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Field.setAccessFlags(int)" access="pub" jdoc="">
				<param name="flags"/>
			</mth>
			<mth name="/:sandmark.program.Field.setAttributes(org.apache.bcel.classfile.Attribute[])" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInitValue(boolean)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInitValue(byte)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInitValue(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInitValue(double)" access="pub" jdoc="">
				<param name="d"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInitValue(float)" access="pub" jdoc="">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInitValue(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInitValue(long)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInitValue(short)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInitValue(String)" access="pub" jdoc="">
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.program.Field.setName(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.program.Field.setNameIndex(int)" access="pub" jdoc="">
				<param name="name_index"/>
			</mth>
			<mth name="/:sandmark.program.Field.setSignatureIndex(int)" access="pub" jdoc="">
				<param name="signature_index"/>
			</mth>
			<mth name="/:sandmark.program.Field.setType(org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.program.Field.isPublic()" access="pub" jdoc="Returns true if the ACC_PUBLIC access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isPrivate()" access="pub" jdoc="Returns true if the ACC_PRIVATE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isProtected()" access="pub" jdoc="Returns true if the ACC_PROTECTED access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isStatic()" access="pub" jdoc="Returns true if the ACC_STATIC access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isFinal()" access="pub" jdoc="Returns true if the ACC_FINAL access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isSynchronized()" access="pub" jdoc="Returns true if the ACC_SYNCHRONIZED access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isVolatile()" access="pub" jdoc="Returns true if the ACC_VOLATILE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isTransient()" access="pub" jdoc="Returns true if the ACC_TRANSIENT access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isNative()" access="pub" jdoc="Returns true if the ACC_NATIVE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isInterface()" access="pub" jdoc="Returns true if the ACC_INTERFACE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isAbstract()" access="pub" jdoc="Returns true if the ACC_ABSTRACT access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.isStrictfp()" access="pub" jdoc="Returns true if the ACC_STRICTFP access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Field.setPublic(boolean)" access="pub" jdoc="Sets or clears the ACC_PUBLIC access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setPrivate(boolean)" access="pub" jdoc="Sets or clears the ACC_PRIVATE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setProtected(boolean)" access="pub" jdoc="Sets or clears the ACC_PROTECTED access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setStatic(boolean)" access="pub" jdoc="Sets or clears the ACC_STATIC access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setFinal(boolean)" access="pub" jdoc="Sets or clears the ACC_FINAL access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setSynchronized(boolean)" access="pub" jdoc="Sets or clears the ACC_SYNCHRONIZED access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setVolatile(boolean)" access="pub" jdoc="Sets or clears the ACC_VOLATILE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setTransient(boolean)" access="pub" jdoc="Sets or clears the ACC_TRANSIENT access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setNative(boolean)" access="pub" jdoc="Sets or clears the ACC_NATIVE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setInterface(boolean)" access="pub" jdoc="Sets or clears the ACC_INTERFACE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setAbstract(boolean)" access="pub" jdoc="Sets or clears the ACC_ABSTRACT access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Field.setStrictfp(boolean)" access="pub" jdoc="Sets or clears the ACC_STRICTFP access flag.">
				<param name="flag"/>
			</mth>
		</class>
		<class name="/:sandmark.program.JarElement" intfc="n" abs="y" inn="n" sloc="15" jdoc="Parent class of any jar file component.">
			<mth name="/:sandmark.program.JarElement.getJarName()" access="pub" jdoc="Gets the name under which this component should be stored.">
			</mth>
			<mth name="/:sandmark.program.JarElement.save(java.io.OutputStream)" access="pub" jdoc="Writes this component to the specified output stream.">
				<param name="ostream"/>
			</mth>
			<mth name="/:sandmark.program.JarElement.compareTo(java.lang.Object)" access="pub" jdoc="Compares this JarElement with another. Files come first, then classes, both ordered lexically by name.">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.program.Class" intfc="n" abs="y" inn="n" sloc="482" jdoc="Represents a single class or interface in a Java program. A &amp;lt;CODE&amp;gt;Class&amp;lt; CODE&amp;gt; object embeds a BCEL &amp;lt;CODE&amp;gt;JavaClass&amp;lt; CODE&amp;gt; object in a Sandmark program object. Most methods just call the corresponding BCEL method. Modification methods automatically call the{@link sandmark.program.Object#mark() mark} method to register their changes.">
			<comm cntt="INVARIANT: We always have a JavaClass or ClassGen, but never both."/>
			<comm cntt="Check to see which; the other one is null."/>
			<comm cntt="Maintain the same ConstantPoolGen for the lifetime of the class object"/>
			<comm cntt="Flags when initialization is complete."/>
			<comm cntt="Subclasses provide these to call constructors of the appropriate classes."/>
			<comm cntt="BCEL wrapper functions for JavaClass methods"/>
			<comm cntt="(much of the documentation also comes from there)"/>
			<comm cntt="BCEL wrapper functions for ClassGen methods, excluding duplicates of above"/>
			<field name="jclass" access="priv" jdoc=""/>
			<field name="cgen" access="priv" jdoc=""/>
			<field name="cpg" access="priv" jdoc=""/>
			<field name="initialized" access="priv" jdoc=""/>
			<mth name="/:sandmark.program.Class.makeCPG(sandmark.program.Class, org.apache.bcel.classfile.ConstantPool)" access="pub" jdoc="">
				<param name="c"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.program.Class.makeField(sandmark.program.Class, org.apache.bcel.classfile.Field)" access="pub" jdoc="">
				<param name="c"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.program.Class.makeMethod(sandmark.program.Class, org.apache.bcel.classfile.Method)" access="pub" jdoc="">
				<param name="c"/>
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.program.Class.Class(sandmark.program.Application, org.apache.bcel.classfile.JavaClass, sandmark.program.Object)" access="pub" jdoc="Constructs a SandMark Class from a BCEL JavaClass and adds it to an application.">
				<comm cntt="package"/>
				<comm cntt="add sandmark subclass of ConstantPoolGen to catch changes"/>
				<comm cntt="create SandMark objects for fields"/>
				<comm cntt="create SandMark objects for methods"/>
				<param name="parent"/>
				<param name="c"/>
				<param name="orig"/>
			</mth>
			<mth name="/:sandmark.program.Class.needClass()" access="priv" jdoc="Converts BCEL data, if necessary, to JavaClass form, and returns the JavaClass.">
			</mth>
			<mth name="/:sandmark.program.Class.needGen()" access="priv" jdoc="Converts BCEL data, if necessary, to ClassGen form, and returns the ClassGen.">
			</mth>
			<mth name="/:sandmark.program.Class.getJarName()" access="pub" jdoc="Gets the filename used for saving in a jar file.">
			</mth>
			<mth name="/:sandmark.program.Class.getCanonicalName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Class.updateJavaClass()" access="priv" jdoc="Makes the jclass member consistent with changes to methods, fields, CPG, etc.">
				<comm cntt="register the latest versions of all underlying bcel.Method objects"/>
				<comm cntt="register the latest versions of all underlying bcel.Field objects"/>
			</mth>
			<mth name="/:sandmark.program.Class.save(java.io.OutputStream)" access="pub" jdoc="Saves this object as a classfile on an output stream.">
				<comm cntt="package"/>
				<comm cntt="work with JavaClass representation"/>
				<param name="ostream"/>
			</mth>
			<mth name="/:sandmark.program.Class.find(String)" access="priv" jdoc="">
				<param name="classname"/>
			</mth>
			<mth name="/:sandmark.program.Class.copy()" access="pub" jdoc="Returns a copy of this class. The new class has a random name and is a member of the same application as this class. The new class is always an instance of LocalClass, and mutable, even if copied from a LibraryClass instance.">
			</mth>
			<mth name="/:sandmark.program.Class.add(sandmark.program.Object)" access="pub" jdoc="Adds a method or field to this class.">
				<comm cntt="package"/>
				<comm cntt="must be Method"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.program.Class.delete(sandmark.program.Object)" access="pub" jdoc="Removes a method or field from this class.">
				<comm cntt="package"/>
				<comm cntt="must be Method"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.program.Class.setName(String)" access="pub" jdoc="Renames this class. This is a local change and does not alter any references. To make a global change, see{@link sandmark.program.util.Renamer sandmark.program.util.Renamer}. @param newName the new class name">
				<param name="newName"/>
			</mth>
			<mth name="/:sandmark.program.Class.getBytes()" access="pub" jdoc="Get the byte array representation of this class in a form suitable for writing to a .class file">
			</mth>
			<mth name="/:sandmark.program.Class.getMethod(String, String)" access="pub" jdoc="Gets a method by name and signature. @return the method in this class with the given name and signature">
				<param name="name"/>
				<param name="sig"/>
			</mth>
			<mth name="/:sandmark.program.Class.getMethods()" access="pub" jdoc="Returns an array of all methods within this class. @return a list of Method objects representing the methods of this class">
			</mth>
			<mth name="/:sandmark.program.Class.methods()" access="pub" jdoc="Returns an iterator over all methods within this class. @return an iterator of &amp;lt;code&amp;gt;sandmark.program.Method&amp;lt; code&amp;gt; objects">
			</mth>
			<mth name="/:sandmark.program.Class.getField(String, String)" access="pub" jdoc="Gets a field by name. @return the field in this class with the given name">
				<comm cntt="this will find only fields,"/>
				<comm cntt="because method names include a signature"/>
				<param name="name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.Class.getFields()" access="pub" jdoc="Returns a list of the fields in this class. @return an array of Field objects">
			</mth>
			<mth name="/:sandmark.program.Class.fields()" access="pub" jdoc="Returns an iterator over all fields within this class. @return an iterator of &amp;lt;code&amp;gt;sandmark.program.Field&amp;lt; code&amp;gt; objects">
			</mth>
			<mth name="/:sandmark.program.Class.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.Class.getAccessFlags()" access="pub" jdoc="Gets the access flags for this object. See &amp;lt;a href=&amp;quot;http: jakarta.apache.org bcel apidocs org apache bcel classfile AccessFlags.html&amp;quot;&amp;gt; the BCEL API documentation&amp;lt; a&amp;gt; for more info.">
			</mth>
			<mth name="/:sandmark.program.Class.getAttributes()" access="pub" jdoc="Returns a list of the attributes for this class. For more information on Attribute objects see the &amp;lt;a href=&amp;quot;http: jakarta.apache.org bcel apidocs index.html&amp;quot;&amp;gt; BCEL documentation.&amp;lt; a&amp;gt; @return an array of attribute objects">
			</mth>
			<mth name="/:sandmark.program.Class.getClassNameIndex()" access="pub" jdoc="Returns the index of the class name in this class&amp;apos;s constant pool. @return the index of this class&amp;apos; name">
			</mth>
			<mth name="/:sandmark.program.Class.getConstantPool()" access="pub" jdoc="Returns the constant pool for this class in an editable form. @return a &amp;lt;a href=&amp;quot;http: jakarta.apache.org bcel apidocs org apache bcel generic ConstantPoolGen.html&amp;quot;&amp;gt; ConstantPoolGen&amp;lt; a&amp;gt; object">
			</mth>
			<mth name="/:sandmark.program.Class.getFileName()" access="pub" jdoc="Returns the name of the source file that this class file was created from. @return the name of the source file for this class, &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if the information is not present">
			</mth>
			<mth name="/:sandmark.program.Class.getInterfaceNames()" access="pub" jdoc="Returns a list of names of the interfaces that this class implements. @return a list of the implemented interfaces (as Strings)">
			</mth>
			<mth name="/:sandmark.program.Class.getInterfaces()" access="pub" jdoc="Gets the interfaces that this class implements. A null entry in the results indicates an interface that could not be found.">
			</mth>
			<mth name="/:sandmark.program.Class.getMajor()" access="pub" jdoc="Returns the major version number of the class file.">
			</mth>
			<mth name="/:sandmark.program.Class.getMinor()" access="pub" jdoc="Returns the minor version number of the class file.">
			</mth>
			<mth name="/:sandmark.program.Class.getPackageName()" access="pub" jdoc="Returns the name of the package that contains this class.">
			</mth>
			<mth name="/:sandmark.program.Class.getSourceFileName()" access="pub" jdoc="Returns the absolute path of the file from which this class was read.">
			</mth>
			<mth name="/:sandmark.program.Class.getSuperClass()" access="pub" jdoc="Returns the superclass of this class.">
			</mth>
			<mth name="/:sandmark.program.Class.getSuperClasses()" access="pub" jdoc="Returns the list of superclasses of this class. The immediate superclass is first, and the list always ends with java.lang.Object.">
			</mth>
			<mth name="/:sandmark.program.Class.getSuperclassName()" access="pub" jdoc="Returns the name of the superclass of this class.">
			</mth>
			<mth name="/:sandmark.program.Class.getSuperclassNameIndex()" access="pub" jdoc="Returns the index in the constant pool of the name of the superclass of this class.">
			</mth>
			<mth name="/:sandmark.program.Class.instanceOf(sandmark.program.Class)" access="pub" jdoc="Returns true if this class is derived from the given class. Equivalent to the &amp;quot;instanceof&amp;quot; operator.">
				<param name="super_class"/>
			</mth>
			<mth name="/:sandmark.program.Class.isClass()" access="pub" jdoc="Returns true if this is a class, not an interface.">
				<comm cntt="implemented locally to avoid heavyweight conversion to JavaClass"/>
			</mth>
			<mth name="/:sandmark.program.Class.setAccessFlags(int)" access="pub" jdoc="Replaces the access flags associated with this class.">
				<param name="flags"/>
			</mth>
			<mth name="/:sandmark.program.Class.setAttributes(org.apache.bcel.classfile.Attribute[])" access="pub" jdoc="Replaces the array of attributes associated with this class.">
				<param name="attributes"/>
			</mth>
			<mth name="/:sandmark.program.Class.setClassName(String)" access="pub" jdoc="Sets the name of this class.">
				<param name="class_name"/>
			</mth>
			<mth name="/:sandmark.program.Class.setClassNameIndex(int)" access="pub" jdoc="Sets the class name index, and consequently the class name. The argument value must reference a valid entry in the constant pool.">
				<comm cntt="verify mutability"/>
				<comm cntt="call setName to get everything updated properly"/>
				<comm cntt="but also call setClassNameIndex to be sure of setting the right index"/>
				<comm cntt="in case there are multiple entries for the string in the constant pool"/>
				<param name="class_name_index"/>
			</mth>
			<mth name="/:sandmark.program.Class.setFileName(String)" access="pub" jdoc="Sets the file name of the class, also known as the SourceFile attribute.">
				<param name="file_name"/>
			</mth>
			<mth name="/:sandmark.program.Class.setInterfaceNames(String[])" access="pub" jdoc="Sets the list of interfaces implemented by this class.">
				<param name="interface_names"/>
			</mth>
			<mth name="/:sandmark.program.Class.setMajor(int)" access="pub" jdoc="Sets the major version number of the class file. The usual argument is org.apache.bcel.Constants.MAJOR.">
				<param name="major"/>
			</mth>
			<mth name="/:sandmark.program.Class.setMinor(int)" access="pub" jdoc="Sets the minor version number of the class file. The usual argument is org.apache.bcel.Constants.MINOR.">
				<param name="minor"/>
			</mth>
			<mth name="/:sandmark.program.Class.setSourceFileName(String)" access="pub" jdoc="Sets the value that represents the absolute path of the file from which this class was read.">
				<param name="source_file_name"/>
			</mth>
			<mth name="/:sandmark.program.Class.setSuperclassName(String)" access="pub" jdoc="Sets the name of the superclass from which this class is derived.">
				<param name="superclass_name"/>
			</mth>
			<mth name="/:sandmark.program.Class.setSuperclassNameIndex(int)" access="pub" jdoc="Sets the index of the superclass name in the constant pool.">
				<param name="superclass_name_index"/>
			</mth>
			<mth name="/:sandmark.program.Class.addAttribute(org.apache.bcel.classfile.Attribute)" access="pub" jdoc="Adds an attribute to this class.">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Class.addEmptyConstructor(int)" access="pub" jdoc="Adds an empty constructor to this class.">
				<comm cntt="now we must find the thing to make a sandmark Method object"/>
				<param name="access_flags"/>
			</mth>
			<mth name="/:sandmark.program.Class.addField(sandmark.program.Field)" access="pub" jdoc="Adds a field to this class.">
				<comm cntt="if not already there"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.program.Class.addInterface(String)" access="pub" jdoc="Adds a new interface implemented by this class.">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.program.Class.addMethod(sandmark.program.Method)" access="pub" jdoc="Adds a method to this class.">
				<comm cntt="if not already there"/>
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.program.Class.containsField(sandmark.program.Field)" access="pub" jdoc="Returns true if the specified field is registered as part of this class.">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.program.Class.containsField(String, String)" access="pub" jdoc="Returns the specified field, if part of this class; otherwise returns null.">
				<param name="name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.Class.containsMethod(String, String)" access="pub" jdoc="Returns the specified method, if part of this class; otherwise returns null.">
				<param name="name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.Class.removeAttribute(org.apache.bcel.classfile.Attribute)" access="pub" jdoc="Removes an attribute from this class.">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.program.Class.removeField(sandmark.program.Field)" access="pub" jdoc="Removes a field from this class.">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.program.Class.removeMethod(sandmark.program.Method)" access="pub" jdoc="Removes a method from this class.">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.program.Class.removeInterface(String)" access="pub" jdoc="Removes an interface from the list of those implemented by this class.">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.program.Class.replaceField(sandmark.program.Field, sandmark.program.Field)" access="pub" jdoc="Replaces a field in this class.">
				<param name="oldField"/>
				<param name="newField"/>
			</mth>
			<mth name="/:sandmark.program.Class.replaceMethod(sandmark.program.Method, sandmark.program.Method)" access="pub" jdoc="Replaces a method in this class.">
				<param name="oldMethod"/>
				<param name="newMethod"/>
			</mth>
			<mth name="/:sandmark.program.Class.setConstantPool(org.apache.bcel.classfile.ConstantPool)" access="pub" jdoc="Replaces the constant pool used by this class. A new SandMark ConstantPoolGen is created and installed in this class and all constituent methods and fields. References in those components are &amp;lt;STRONG&amp;gt; not &amp;lt; STRONG&amp;gt; updated. The new ConstantPoolGen is returned.">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.program.Class.isPublic()" access="pub" jdoc="Returns true if the ACC_PUBLIC access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isPrivate()" access="pub" jdoc="Returns true if the ACC_PRIVATE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isProtected()" access="pub" jdoc="Returns true if the ACC_PROTECTED access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isStatic()" access="pub" jdoc="Returns true if the ACC_STATIC access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isFinal()" access="pub" jdoc="Returns true if the ACC_FINAL access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isSynchronized()" access="pub" jdoc="Returns true if the ACC_SYNCHRONIZED access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isVolatile()" access="pub" jdoc="Returns true if the ACC_VOLATILE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isTransient()" access="pub" jdoc="Returns true if the ACC_TRANSIENT access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isNative()" access="pub" jdoc="Returns true if the ACC_NATIVE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isInterface()" access="pub" jdoc="Returns true if the ACC_INTERFACE access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isAbstract()" access="pub" jdoc="Returns true if the ACC_ABSTRACT access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isStrictfp()" access="pub" jdoc="Returns true if the ACC_STRICTFP access flag is set.">
			</mth>
			<mth name="/:sandmark.program.Class.isSuper()" access="pub" jdoc="Returns true if the ACC_SUPER access flag is set.">
				<comm cntt="implemented locally to avoid heavyweight conversion to JavaClass"/>
			</mth>
			<mth name="/:sandmark.program.Class.setPublic(boolean)" access="pub" jdoc="Sets or clears the ACC_PUBLIC access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setPrivate(boolean)" access="pub" jdoc="Sets or clears the ACC_PRIVATE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setProtected(boolean)" access="pub" jdoc="Sets or clears the ACC_PROTECTED access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setStatic(boolean)" access="pub" jdoc="Sets or clears the ACC_STATIC access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setFinal(boolean)" access="pub" jdoc="Sets or clears the ACC_FINAL access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setSynchronized(boolean)" access="pub" jdoc="Sets or clears the ACC_SYNCHRONIZED access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setVolatile(boolean)" access="pub" jdoc="Sets or clears the ACC_VOLATILE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setTransient(boolean)" access="pub" jdoc="Sets or clears the ACC_TRANSIENT access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setNative(boolean)" access="pub" jdoc="Sets or clears the ACC_NATIVE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setInterface(boolean)" access="pub" jdoc="Sets or clears the ACC_INTERFACE access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setAbstract(boolean)" access="pub" jdoc="Sets or clears the ACC_ABSTRACT access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setStrictfp(boolean)" access="pub" jdoc="Sets or clears the ACC_STRICTFP access flag.">
				<param name="flag"/>
			</mth>
			<mth name="/:sandmark.program.Class.setSuper(boolean)" access="pub" jdoc="Sets or clears the ACC_SUPER access flag.">
				<param name="flag"/>
			</mth>
		</class>
		<class name="/:sandmark.program.LibraryCPG" intfc="n" abs="n" inn="n" sloc="70" jdoc="Wraps the ConstantPoolGen class in order to intercept method calls and throw exceptions on modification attempts.">
			<comm cntt="These stubs just throw exceptions, because a LibraryCPG is immutable."/>
			<mth name="/:sandmark.program.LibraryCPG.LibraryCPG(sandmark.program.Class, org.apache.bcel.classfile.ConstantPool)" access="pub" jdoc="Constructs a Sandmark LibraryCPG from a BCEL ConstantPool.">
				<param name="c"/>
				<param name="cp"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addString(String)" access="pub" jdoc="">
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addClass(String)" access="pub" jdoc="">
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addClass(org.apache.bcel.generic.ObjectType)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addArrayClass(org.apache.bcel.generic.ArrayType)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addInteger(int)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addFloat(float)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addUtf8(String)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addLong(long)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addDouble(double)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addNameAndType(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addMethodref(String, String, String)" access="pub" jdoc="">
				<param name="class_name"/>
				<param name="method_name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addMethodref(org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addMethodref(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addInterfaceMethodref(String, String, String)" access="pub" jdoc="">
				<param name="class_name"/>
				<param name="method_name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addInterfaceMethodref(org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addInterfaceMethodref(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addFieldref(String, String, String)" access="pub" jdoc="">
				<param name="class_name"/>
				<param name="field_name"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.setConstant(int, org.apache.bcel.classfile.Constant)" access="pub" jdoc="">
				<param name="i"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.addConstant(org.apache.bcel.classfile.Constant, ConstantPoolGen)" access="pub" jdoc="">
				<param name="c"/>
				<param name="cp"/>
			</mth>
			<mth name="/:sandmark.program.LibraryCPG.unsupp()" access="priv" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.program.util">
		<class name="/:sandmark.program.util.Reference" intfc="n" abs="n" inn="n" sloc="33" jdoc="Represents an instruction that references a program object such as a class, method, or field. Also provides static methods for locating and modifying such references. &amp;lt;STRONG&amp;gt;The methods in this class have been specified but not yet implemented.&amp;lt; STRONG&amp;gt;">
			<field name="meth" access="priv" jdoc=""/>
			<field name="ilist" access="priv" jdoc=""/>
			<field name="handle" access="priv" jdoc=""/>
			<mth name="/:sandmark.program.util.Reference.Reference(sandmark.program.Method, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="Constructs a reference for an instruction in a method. @param m the method containing the instruction @param il the instruction list that contains the instruction @param ih the instruction handle for the instruction">
				<param name="m"/>
				<param name="il"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.program.util.Reference.getMethod()" access="pub" jdoc="Returns the method that contains this instruction. @return the enclosing method of this reference">
			</mth>
			<mth name="/:sandmark.program.util.Reference.getInstructionList()" access="pub" jdoc="Returns the instruction list that contains this instruction. @return the enclosing instruction list for this reference">
			</mth>
			<mth name="/:sandmark.program.util.Reference.getInstructionHandle()" access="pub" jdoc="Returns the instruction handle that encapsulates this instruction. @return the instruction handle for this reference">
			</mth>
			<mth name="/:sandmark.program.util.Reference.references(sandmark.program.Class)" access="pub" jdoc="Returns an iterator over all references to the given class. &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param c the class to find references for @return an iterator that on each call to &amp;lt;code&amp;gt;next()&amp;lt; code&amp;gt; will produce a new &amp;lt;code&amp;gt;sandmark.program.util.Reference&amp;lt; code&amp;gt; object.">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.program.util.Reference.references(sandmark.program.Field)" access="pub" jdoc="Returns an iterator over all references to the given field. Note: this method does not guarantee that the iterator will return &amp;quot;hardwired&amp;quot; references to a field. &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param f the field to find references for @return an iterator that on each call to &amp;lt;code&amp;gt;next()&amp;lt; code&amp;gt; will produce a new &amp;lt;code&amp;gt;sandmark.program.util.Reference&amp;lt; code&amp;gt; object.">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.program.util.Reference.references(sandmark.program.Method)" access="pub" jdoc="Returns an iterator over all references to the given method. &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param m the method to find references for @return an iterator that on each call to &amp;lt;code&amp;gt;next()&amp;lt; code&amp;gt; will produce a new &amp;lt;code&amp;gt;sandmark.program.util.Reference&amp;lt; code&amp;gt; object.">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.program.util.Reference.deleteAll(sandmark.program.Method)" access="pub" jdoc="Removes all references to a method. Each invoke instruction is replaced by code that pops the arguments, then pushes 0 or null if the method has a return value (the default value for the return type). &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param m the method to remove reference to">
				<param name="m"/>
			</mth>
		</class>
		<class name="/:sandmark.program.util.Renamer" intfc="n" abs="n" inn="n" sloc="193" jdoc="Provides a set of operations for moving and renaming program objects. These are heavyweight methods that operate on the whole application, altering all references. &amp;lt;P&amp;gt;&amp;lt;STRONG&amp;gt;The methods in this class have been specified but not yet implemented.&amp;lt; STRONG&amp;gt; The interface is based on various suggestions, rounded out for completeness; it&amp;apos;s not clear which of these we really need, and they&amp;apos;re not trivial.">
			<comm cntt="no public constructor; instances not useful"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.program.util.Renamer.Renamer()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.program.util.Renamer.rename(sandmark.program.Class, String)" access="pub" jdoc="Renames a class to a new name and updates all references to the class. Changing the package denotation of a class will move it to a new package. &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param c the class to rename @param newname the fully qualified new name (ex java.lang.Object)">
				<param name="c"/>
				<param name="newname"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.rename(sandmark.program.Method, String)" access="pub" jdoc="Renames a method and updates all references to the method. Note that this does not do analysis of dynamic dispatch. References to a method are determined by matching classname methodname signature. To ensure change to a method called via dynamic dispatch, you must rename &amp;lt;i&amp;gt;all&amp;lt; i&amp;gt; all of the overrides of the method. For help with this see {@link sandmark.analysis.classhierarchy.ClassHierarchysandmark.analysis.classhierarchy.ClassHierarchy}. @param m the method to rename @param newname the new name for the method">
				<param name="m"/>
				<param name="newname"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.rename(sandmark.program.Method, String, sandmark.analysis.classhierarchy.ClassHierarchy)" access="pub" jdoc="">
				<param name="m"/>
				<param name="newname"/>
				<param name="ch"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.rename(sandmark.program.Field, String)" access="pub" jdoc="Renames a field and updates all references to the field. This method currently does not ensure that a hard-wired reference to the field will be updated accordingly. @param f the field to rename @param newname the new name for this field">
				<param name="f"/>
				<param name="newname"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.rename(sandmark.program.Field, String, sandmark.analysis.classhierarchy.ClassHierarchy)" access="pub" jdoc="">
				<param name="f"/>
				<param name="newname"/>
				<param name="ch"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.renamePackage(sandmark.program.Application, String, String)" access="pub" jdoc="Changes all members of a package to a new name, including subpackages. If the new package already exists, the contents of the packages will be merged - &amp;lt;i&amp;gt;if a conflict arises, an exception will be raised?&amp;lt; i&amp;gt;. &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param a the application containing the package @param old the old package name @param newName the new package name">
				<param name="a"/>
				<param name="old"/>
				<param name="newName"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.renameClasses(java.util.Map)" access="pub" jdoc="Renames several classes and updates all references to the classes. This method does the same thing as{@link sandmark.program.util.Renamer#rename(sandmark.program.Class,String)rename(Class, String)}in batch. &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param map A mapping of (sandmark.program.Class, String) pairs">
				<param name="map"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.renameMethods(java.util.Map)" access="pub" jdoc="Renames several methods and updates all references to the methods. This method does the same thing as{@link sandmark.program.util.Renamer#rename(sandmark.program.Method,String)rename(Method, String)}in batch. @param map A mapping of (sandmark.program.Method, String) pairs">
				<param name="map"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.renameMethods(java.util.Map, sandmark.analysis.classhierarchy.ClassHierarchy)" access="pub" jdoc="">
				<param name="map"/>
				<param name="ch"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.renameFields(java.util.Map)" access="pub" jdoc="Renames several fields and updates all references to the fields. This method does the same thing as{@link sandmark.program.util.Renamer#rename(sandmark.program.Field,String)rename(Field, String)}in batch. &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param map A mapping of (sandmark.program.Field, String) pairs">
				<param name="map"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.renameFields(java.util.Map, sandmark.analysis.classhierarchy.ClassHierarchy)" access="pub" jdoc="">
				<param name="map"/>
				<param name="ch"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.renamePackages(sandmark.program.Application, java.util.Map)" access="pub" jdoc="Changes all members of multiple packages to new names, including subpackages. This method does the same thing as{@link sandmark.program.util.Renamer#renamePackage(sandmark.program.Application,String,String)renamePackage(Application, String, String)}in batch. &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param a the application containing the package @param map a mapping of (String, String) pairs">
				<param name="a"/>
				<param name="map"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.move(sandmark.program.Method, sandmark.program.Class)" access="pub" jdoc="Moves a method from one class to another and updates all references to that method in the application. @param m the method to move @param newClass the destination for the method">
				<param name="m"/>
				<param name="newClass"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.moveMethods(java.util.Map)" access="pub" jdoc="Moves several methods to another class and updates all references to each method in the application. This method does the same thing as {@link sandmark.program.util.Renamer#move(sandmark.program.Method,sandmark.program.Class) move(Method, Class)}in batch. &amp;lt;STRONG&amp;gt;Not yet implemented.&amp;lt; STRONG&amp;gt; @param map a mapping of (Method, Class) pairs">
				<param name="map"/>
			</mth>
			<mth name="/:sandmark.program.util.Renamer.setConstantPoolName(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
		</class>
		<class name="/:sandmark.program.util.AllMethods" intfc="n" abs="n" inn="n" sloc="28" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="next" access="priv" jdoc=""/>
			<field name="methodIt" access="priv" jdoc=""/>
			<field name="classIt" access="priv" jdoc=""/>
			<mth name="/:sandmark.program.util.AllMethods.AllMethods(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.program.util.AllMethods.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.util.AllMethods.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.util.AllMethods.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.program.util.AllMethods.setNext()" access="priv" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.smash">
		<class name="/:sandmark.smash.SandmarkCLI" intfc="n" abs="n" inn="n" sloc="390" jdoc="">
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="optSpec" access="priv" jdoc=""/>
			<mth name="/:sandmark.smash.SandmarkCLI.SandmarkCLI()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.doEmbed(sandmark.util.Options)" access="priv" jdoc="">
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.doDynamicEmbed(sandmark.watermark.DynamicWatermarker, sandmark.program.Application, java.io.File, String, sandmark.util.Options)" access="priv" jdoc="">
				<param name="alg"/>
				<param name="app"/>
				<param name="output"/>
				<param name="wm"/>
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.doStaticEmbed(sandmark.watermark.StaticWatermarker, sandmark.program.Application, java.io.File, String, sandmark.util.Options)" access="priv" jdoc="">
				<param name="alg"/>
				<param name="app"/>
				<param name="output"/>
				<param name="wm"/>
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.doObfuscate(sandmark.util.Options)" access="priv" jdoc="">
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.doRecognize(sandmark.util.Options)" access="priv" jdoc="">
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.doDynamicRecognize(sandmark.watermark.DynamicWatermarker, sandmark.program.Application, sandmark.util.Options)" access="priv" jdoc="">
				<param name="alg"/>
				<param name="app"/>
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.doStaticRecognize(sandmark.watermark.StaticWatermarker, sandmark.program.Application, sandmark.util.Options)" access="priv" jdoc="">
				<param name="alg"/>
				<param name="app"/>
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.doTrace(sandmark.util.Options)" access="priv" jdoc="">
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.setExtraProperties(sandmark.Algorithm, sandmark.util.Options)" access="priv" jdoc="">
				<comm cntt="getCP may return null, or the specified property may"/>
				<comm cntt="not apply to this Alg"/>
				<param name="alg"/>
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.getAlg(sandmark.util.Options)" access="priv" jdoc="">
				<param name="opts"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.getAlg(String)" access="priv" jdoc="">
				<param name="algname"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.showAlgHelp(String)" access="priv" jdoc="">
				<param name="algName"/>
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.showSWMs()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.showDWMs()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.smash.SandmarkCLI.showObfs()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.smash.Smash" intfc="n" abs="n" inn="n" sloc="142" jdoc="Smash.java -- @author Jasvir Nagra &amp;lt;jas@cs.auckland.ac.nz&amp;gt; Created On : Thu Jun 5 15:10:39 2003 Last Modified : &amp;lt;03 05 22 22:42:10 jas&amp;gt; Description : Sandmark (again) shell Keywords : sandmark shell PURPOSE | Sandmark project |">
			<const name="DEBUG" access="pub" jdoc=""/>
			<field name="algo" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="inputJar" access="pub" jdoc=""/>
			<field name="outputJar" access="pub" jdoc=""/>
			<field name="wmKey" access="pub" jdoc=""/>
			<field name="wmVal" access="pub" jdoc=""/>
			<field name="wmRetrieveIter" access="pub" jdoc=""/>
			<field name="traceInProgress" access="pub" jdoc=""/>
			<mth name="/:sandmark.smash.Smash.initVariables(koala.dynamicjava.interpreter.TreeInterpreter)" access="pub" jdoc="">
				<param name="intr"/>
			</mth>
			<mth name="/:sandmark.smash.Smash.initScript(koala.dynamicjava.interpreter.TreeInterpreter)" access="pub" jdoc="">
				<param name="intr"/>
			</mth>
			<mth name="/:sandmark.smash.Smash.source(String, koala.dynamicjava.interpreter.TreeInterpreter)" access="pub" jdoc="">
				<param name="file"/>
				<param name="intr"/>
			</mth>
			<mth name="/:sandmark.smash.Smash.main(String)" access="pub" jdoc="">
				<comm cntt="String dummystr = &amp;quot;help(\&amp;quot;helloW\&amp;quot;);&amp;quot;; interpreter.interpret(new java.io.StringReader(dummystr), &amp;quot;STDIN&amp;quot;);"/>
				<comm cntt="list = list + &amp;quot;\n&amp;quot; + line;"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.smash.Smash.findAlgorithms(int)" access="pub" jdoc="">
				<param name="algType"/>
			</mth>
			<mth name="/:sandmark.smash.Smash.getAlgorithmObj(String)" access="pub" jdoc="">
				<param name="className"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util">
		<class name="/:sandmark.util.MethodMerger" intfc="n" abs="n" inn="n" sloc="146" jdoc="MethodMerger can be applied on a class to merge all the private static methods with the same signature into a common method. The common method will have an extra integer argument to select which block of code from the source methods should be executed. @author Srinivas Visvanathan">
			<comm cntt="create an empty method into which all methods with signature sig will be"/>
			<comm cntt="merged"/>
			<field name="rand" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.MethodMerger.MethodMerger()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.MethodMerger.apply(sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="collect merge info"/>
				<comm cntt="MethodID of old method -&amp;gt;"/>
				<comm cntt="(Method object of merged method, int value to select the old code)"/>
				<comm cntt="do merge"/>
				<comm cntt="no point merging one method"/>
				<comm cntt="fix invokations to the old methods"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.util.MethodMerger.fixInvokes(sandmark.program.Class, java.util.Map)" access="priv" jdoc="">
				<comm cntt="scan through all the methods"/>
				<comm cntt="scan thru instructions of the method"/>
				<comm cntt="only looking for invoke static"/>
				<comm cntt="check if the method being invoked was merged"/>
				<comm cntt="was merged, add a load and fix the invoke"/>
				<comm cntt="redirect branches to the iload"/>
				<param name="cls"/>
				<param name="old2new"/>
			</mth>
			<mth name="/:sandmark.util.MethodMerger.merge(sandmark.program.Class, String, java.util.List, java.util.Map)" access="priv" jdoc="">
				<comm cntt="make a new empty method"/>
				<comm cntt="compute the local var index of the last int variable"/>
				<comm cntt="collect instruction list of src methods into new method"/>
				<comm cntt="add src&amp;apos;s instruction list to dest, before the NOP"/>
				<comm cntt="copy src&amp;apos;s exceptions to dest"/>
				<comm cntt="keep mapping from name &amp; sig of src to merged method dest"/>
				<comm cntt="delete the src method"/>
				<comm cntt="if src is the first method to be merged, then we&amp;apos;re done"/>
				<comm cntt="from second method onwards, include instructions to branch to the"/>
				<comm cntt="appropriate code block depending on the value of the first arg"/>
				<param name="cls"/>
				<param name="sig"/>
				<param name="mlist"/>
				<param name="old2new"/>
			</mth>
			<mth name="/:sandmark.util.MethodMerger.createEmptyMethod(String, sandmark.program.Class)" access="priv" jdoc="">
				<comm cntt="compute argument info of new method"/>
				<comm cntt="generate name for the new method"/>
				<comm cntt="instruction list with just a NOP; since LocalMethod constructor chokes"/>
				<comm cntt="on a completely empty list"/>
				<param name="sig"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.util.MethodMerger.collectMergeInfo(sandmark.program.Class)" access="priv" jdoc="">
				<comm cntt="to keep a mapping: method sig -&amp;gt; list of methods with that sig"/>
				<comm cntt="scan thru methods"/>
				<comm cntt="only interested in private, static methods"/>
				<comm cntt="store info about method, indexed by its signature"/>
				<param name="cls"/>
			</mth>
		</class>
		<class name="/:sandmark.util.Options" intfc="n" abs="n" inn="n" sloc="228" jdoc="The sandmark.util.Options class parses command-line options according to the Unix standard (POSIX .2 section 2.10.2) utility syntax guidelines. While the end-user sees behavior consistent with the C getopt() function, the programming interface is completely different. @author Gregg Townsend, University of Arizona @version February, 2001">
			<comm cntt="number of specs, equals size of arrays:"/>
			<comm cntt="specification keys"/>
			<comm cntt="variable names; null for non-valued"/>
			<comm cntt="defaults; null if not specified"/>
			<comm cntt="descriptions"/>
			<comm cntt="specified value"/>
			<comm cntt="header for usage message"/>
			<comm cntt="footer for usage message."/>
			<comm cntt="option letters seen during parsing"/>
			<comm cntt="index of first positional argument"/>
			<comm cntt="------------------------------------------------------------"/>
			<field name="nspecs" access="priv" jdoc=""/>
			<field name="key" access="priv" jdoc=""/>
			<field name="var" access="priv" jdoc=""/>
			<field name="dflt" access="priv" jdoc=""/>
			<field name="descr" access="priv" jdoc=""/>
			<field name="value" access="priv" jdoc=""/>
			<field name="header" access="priv" jdoc=""/>
			<field name="footer" access="priv" jdoc=""/>
			<field name="seen" access="priv" jdoc=""/>
			<field name="firstpos" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.Options.Options(String[], String, String[])" access="pub" jdoc="Constructs an Options object and parses a list of arguments. If a usage error is detected, the program is aborted with a message. After parsing, option values are found by calling {@link #getValue}and positional arguments are found by calling {@link #getIndex}. &amp;lt;P&amp;gt; @param speclist parameter specifications (see {@link #Options(String[])}) @param cmdname command name, for usage message if needed @param arglist argument list (see {@link #parse})">
				<param name="speclist"/>
				<param name="cmdname"/>
				<param name="arglist"/>
			</mth>
			<mth name="/:sandmark.util.Options.Options(String[])" access="pub" jdoc="Constructs an Options object for parsing an argument list. The single argument is a list of strings, which are interpreted in pairs; thus the length of the argument array should be even. In each pair, the first string specifies argument and the second provides a very brief description for a usage message. There are three types of argument specifications. &amp;lt;P&amp;gt; A command option that does not take an argument is specified by a two-character string, a hyphen followed by the option letter (or, rarely, other character). &amp;lt;P&amp;gt; A command option that takes an argument is specified by a string consisting of: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; a hyphen followed by the option letter and a space &amp;lt;LI&amp;gt; a variable name characterizing the option value &amp;lt;LI&amp;gt; optionally, another space and a default value &amp;lt; UL&amp;gt; &amp;lt;P&amp;gt; A positional argument is specified by a variable name that does not begin with a hyphen. Positional arguments are used only for generating usage messages, and are not interpreted. All positional arguments must follow all command options. &amp;lt;P&amp;gt; Here is a somewhat contrived specification example: &amp;lt;PRE&amp;gt; Options o = new Options(new String[] { &amp;quot;-d&amp;quot;, &amp;quot;delete afterwards&amp;quot;, &amp;quot;-n nproc 1&amp;quot;, &amp;quot;use N parallel processes&amp;quot;, 1 is default &amp;quot;-p&amp;quot;, &amp;quot;preserve dates and times&amp;quot;, &amp;quot;-v&amp;quot;, &amp;quot;provide verbose commentary&amp;quot;, &amp;quot;src&amp;quot;, &amp;quot;data source&amp;quot;, &amp;quot;...&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;dst&amp;quot;, &amp;quot;destination&amp;quot;, }); &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt;">
				<param name="speclist"/>
			</mth>
			<mth name="/:sandmark.util.Options.setHeader(String)" access="pub" jdoc="Defines a header string to be output at the start of any usage message, such as a string announcing the full program name and version number. &amp;lt;P&amp;gt; @see #usage">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.util.Options.setFooter(String)" access="pub" jdoc="Defines a footer string to be output at the end of any usage message, such as a copyright notice. &amp;lt;P&amp;gt; @see #usage">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.util.Options.usage(java.io.PrintStream, String)" access="pub" jdoc="Synthesizes a usage message and writes it to the specified stream. The usage message is composed of: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; a header, if one was set by {@link #setHeader}&amp;lt;LI&amp;gt; &amp;quot;usage: cmdname [options] positionals&amp;quot; &amp;lt;LI&amp;gt; a list of options, omitting any having no description &amp;lt;LI&amp;gt; a footer, if one was set by {@link #setFooter}&amp;lt; UL&amp;gt;">
				<comm cntt="print header"/>
				<comm cntt="header"/>
				<comm cntt="print synopsis"/>
				<comm cntt="usage: cmdname"/>
				<comm cntt="[options]"/>
				<comm cntt="positional parameters"/>
				<comm cntt="terminate synopsis"/>
				<comm cntt="calculate width needed for first column of option list"/>
				<comm cntt="print option list"/>
				<comm cntt="print footer"/>
				<param name="p"/>
				<param name="cmdname"/>
			</mth>
			<mth name="/:sandmark.util.Options.parse(String[])" access="pub" jdoc="Parses an argument list and returns the index of the first non-option argument. This is an argument that is not an option value, and that does not begin with &amp;quot;-&amp;quot;, or is exactly &amp;quot;-&amp;quot;, or follows &amp;quot;--&amp;quot;. &amp;lt;P&amp;gt; After parsing, option values can be retrieved by calling{@link #getValue}. &amp;lt;P&amp;gt; An Exception is thrown, with an explanatory message, if an invalid argument is found.">
				<comm cntt="this option takes no argument"/>
				<comm cntt="this option takes an argument"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.Options.getValue(char)" access="pub" jdoc="Retrieves the value specified for the given option letter in the most recently parsed argument list. &amp;lt;P&amp;gt; For an option that accepts an argument, the argument value is returned. If no value was specified, the default value is returned. If no default was specified, the null value is returned. &amp;lt;P&amp;gt; For an option that does not accept an argument, the empty string is returned if the option was invoked, and the null value is returned if not.">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.Options.findKey(char)" access="priv" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.Options.getIndex()" access="pub" jdoc="Returns the index of the first positional argument in the most recently parsed argument list. This is an argument that is not an option value, and that does not begin with &amp;quot;-&amp;quot;, or is exactly &amp;quot;-&amp;quot;, or follows &amp;quot;--&amp;quot;. If no argument list has been parsed, or if an error was detected, the return value is indeterminate.">
			</mth>
			<mth name="/:sandmark.util.Options.getWhich()" access="pub" jdoc="Returns a string containing the option letters specified in the most recently parsed argument list. Letters appear in the order seen, and duplicates may be present. If no argument list has been parsed, or if an error was detected, the return value is indeterminate.">
			</mth>
			<mth name="/:sandmark.util.Options.main(String)" access="pub" jdoc="Tests the Options code. When run with arguments, parses them using a predefined options specification. When run with no arguments, executes a canned test set.">
				<comm cntt="1 is default"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.Options.test(Options, String)" access="priv" jdoc="">
				<param name="o"/>
				<param name="cmdline"/>
			</mth>
			<mth name="/:sandmark.util.Options.dump(Options, String[])" access="priv" jdoc="">
				<param name="o"/>
				<param name="arglist"/>
			</mth>
		</class>
		<class name="/:sandmark.util.IdentifierIterator" intfc="n" abs="n" inn="n" sloc="55" jdoc="IdentifierIterator provides a straightforward interface for generating new java identifiers for methods, classes, etc. Identifiers are returned in lexicographic order (basically). @author Kelly Heffner">
			<const name="MAX_VALUE" access="priv" jdoc=""/>
			<const name="MIN_VALUE" access="priv" jdoc=""/>
			<field name="namePrefix" access="priv" jdoc=""/>
			<field name="nameSuffix" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.IdentifierIterator.hasNext()" access="pub" jdoc="Checks to see if there are more identifiers available. This will always return true. @return true">
			</mth>
			<mth name="/:sandmark.util.IdentifierIterator.remove()" access="pub" jdoc="Not implemented.">
			</mth>
			<mth name="/:sandmark.util.IdentifierIterator.next()" access="pub" jdoc="Returns the next unique identifier. @return an identifier that is unique from any other identifier returned from this instance of the iterator so far">
				<comm cntt="now move to the next letter"/>
			</mth>
			<mth name="/:sandmark.util.IdentifierIterator.IdentifierIterator()" access="pub" jdoc="Constructs a new identifier iterator. Reset an IdentifierIterator by reconstructing it.">
			</mth>
		</class>
		<class name="/:sandmark.util.StackFrame" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<const name="MISSING_long" access="pub" jdoc=""/>
			<field name="location" access="priv" jdoc=""/>
			<field name="threadID" access="priv" jdoc=""/>
			<field name="frameID" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.StackFrame.StackFrame(sandmark.util.ByteCodeLocation, long)" access="pub" jdoc="">
				<param name="location"/>
				<param name="threadID"/>
			</mth>
			<mth name="/:sandmark.util.StackFrame.StackFrame(sandmark.util.ByteCodeLocation, long, long)" access="pub" jdoc="">
				<param name="location"/>
				<param name="threadID"/>
				<param name="frameID"/>
			</mth>
			<mth name="/:sandmark.util.StackFrame.getLocation()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.StackFrame.getFrameID()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.StackFrame.getThreadID()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.StackFrame.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.StackFrame.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.util.StackFrame.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.Random" intfc="n" abs="n" inn="n" sloc="9" jdoc="">
			<field name="sRand" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.Random.Random()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Random.getRandom()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.Inliner" intfc="n" abs="n" inn="n" sloc="213" jdoc="">
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="mCallingMethod" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.Inliner.Inliner(sandmark.program.Method)" access="pub" jdoc="">
				<param name="caller"/>
			</mth>
			<mth name="/:sandmark.util.Inliner.inline(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;inlining &amp;quot; +"/>
				<comm cntt="sandmark.analysis.controlflowgraph.ProgramCFG.fieldOrMethodName(callee) +"/>
				<comm cntt="&amp;quot; into &amp;quot; +"/>
				<comm cntt="sandmark.analysis.controlflowgraph.ProgramCFG.fieldOrMethodName(mCallingMethod));"/>
				<comm cntt="We want to leave the method to be inlined unchanged and insert a munged copy of it into its caller, so make a copy"/>
				<comm cntt="These methods could be in different classes, so the constant pool values referenced by the callee may not exist in the caller, and may have different indices. So add all constants referenced by callee to constant pool of caller, and update indices"/>
				<comm cntt="An exception could be thrown and caught inside the callee. This would destroy the stack, so we better have a way to restore the stack at the exit of the callee. Also, the callee expects to get its arguments in locals. So save the entire stack into locals"/>
				<comm cntt="Local variables have to be renumbered to fit into the caller, and we have to restore the stack at every exit of the callee"/>
				<comm cntt="Before we can remove the call site, we have to move all the targeters of the call to a different target"/>
				<param name="callee"/>
				<param name="callSite"/>
			</mth>
			<mth name="/:sandmark.util.Inliner.typeArraySize(org.apache.bcel.generic.Type[])" access="priv" jdoc="">
				<param name="typeArray"/>
			</mth>
			<mth name="/:sandmark.util.Inliner.updateTargeters(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;updating &amp;quot; + curIH);"/>
				<comm cntt="System.out.println(&amp;quot;targeter: &amp;quot; + targeters[i]);"/>
				<param name="curIH"/>
				<param name="newIH"/>
			</mth>
			<mth name="/:sandmark.util.Inliner.rewriteCPInstrs(sandmark.program.Method, sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="System.out.println(ihs[i]);"/>
				<param name="oldMeth"/>
				<param name="newMeth"/>
			</mth>
			<mth name="/:sandmark.util.Inliner.addExceptionHandlersToCaller(org.apache.bcel.generic.CodeExceptionGen, sandmark.program.Method)" access="priv" jdoc="">
				<param name="exceptions"/>
				<param name="caller"/>
			</mth>
			<mth name="/:sandmark.util.Inliner.insertStackSaveInstrs(org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, sandmark.analysis.stacksimulator.Context, InlinedStackFrame, sandmark.program.Method, sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="Adding this check cast for dynamic inlining --zach"/>
				<comm cntt="System.out.println(il);"/>
				<comm cntt="try{System.in.read();}catch(Exception e){ e.printStackTrace();}"/>
				<param name="il"/>
				<param name="site"/>
				<param name="siteCx"/>
				<param name="isf"/>
				<param name="callee"/>
				<param name="caller"/>
			</mth>
			<mth name="/:sandmark.util.Inliner.fixupSlotAccessInstruction(org.apache.bcel.generic.InstructionHandle, InlinedStackFrame)" access="priv" jdoc="">
				<param name="ih"/>
				<param name="isf"/>
			</mth>
			<mth name="/:sandmark.util.Inliner.fixupReturnInstruction(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, sandmark.program.Method, sandmark.analysis.stacksimulator.Context, sandmark.analysis.stacksimulator.Context, InlinedStackFrame)" access="priv" jdoc="">
				<comm cntt="Update all targeters of this instruction to target the first instruction inserted by this method"/>
				<comm cntt="Save the return value to a local"/>
				<comm cntt="Pop any remaining garbage from the stack"/>
				<comm cntt="Reload the stack that was saved at the top of the inlined method"/>
				<comm cntt="Reload the return value that just got saved"/>
				<comm cntt="This instruction could be in the middle of the method to be inlined. Jump to the instruction after the inlined method, the call site (which will subsequently be removed, with all targeters retargetted)"/>
				<param name="returnIH"/>
				<param name="callSiteIH"/>
				<param name="method"/>
				<param name="returnCx"/>
				<param name="callSiteCx"/>
				<param name="isf"/>
			</mth>
		</class>
		<class name="/:sandmark.util.InlinedStackFrame" intfc="n" abs="n" inn="n" sloc="38" jdoc="">
			<field name="mRvFirstSlot" access="pub" jdoc=""/>
			<field name="mSavedStackFirstSlot" access="pub" jdoc=""/>
			<field name="mArgsFirstSlot" access="pub" jdoc=""/>
			<field name="mLocalsFirstSlot" access="pub" jdoc=""/>
			<field name="mUnusedFirstSlot" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.InlinedStackFrame.InlinedStackFrame(sandmark.analysis.stacksimulator.Context, sandmark.program.Method, int)" access="pub" jdoc="">
				<param name="cx"/>
				<param name="callee"/>
				<param name="firstUnusedSlot"/>
			</mth>
			<mth name="/:sandmark.util.InlinedStackFrame.cxSize(sandmark.analysis.stacksimulator.Context, int)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;cxSize: &amp;quot; + size);"/>
				<param name="cx"/>
				<param name="startStackItem"/>
			</mth>
			<mth name="/:sandmark.util.InlinedStackFrame.argCount(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;argc: &amp;quot; + count);"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.FieldID" intfc="n" abs="n" inn="n" sloc="42" jdoc="This class represents a method. &amp;lt;P&amp;gt; All fields are public, but should be treated as read-only.">
			<field name="name" access="prot" jdoc="The name of the method that called Annotate.mark()."/>
			<field name="signature" access="prot" jdoc="The signature of the method that called Annotate.mark()."/>
			<field name="className" access="prot" jdoc="The name of the class the calling method was in. This is the fully qualified class name, such as &amp;lt;code&amp;gt;java.lang.Object&amp;lt; code&amp;gt;."/>
			<mth name="/:sandmark.util.FieldID.FieldID(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="signature"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.util.FieldID.FieldID(sandmark.program.Field)" access="pub" jdoc="Convienence constructor, creates a FieldID from a Field object.">
				<param name="field"/>
			</mth>
			<mth name="/:sandmark.util.FieldID.equals(Object)" access="pub" jdoc="Compare for equality.">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.util.FieldID.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.FieldID.getName()" access="pub" jdoc="Return the name of this method.">
			</mth>
			<mth name="/:sandmark.util.FieldID.getSignature()" access="pub" jdoc="Return the signature of this method.">
			</mth>
			<mth name="/:sandmark.util.FieldID.getClassName()" access="pub" jdoc="Return the fully qualified class name of this method.">
			</mth>
			<mth name="/:sandmark.util.FieldID.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.MethodSignatureChanger" intfc="n" abs="y" inn="n" sloc="111" jdoc="Abstract super class for a number of simple method obfuscators. All these obfuscators operate on specified method M (from a particular class C) and change its signature in the process. If M is implemented by other classes in C&amp;apos;s inheritance tree (i.e. M is part of the interface of several classes in C&amp;apos;s hierarchy), then all the other implementations of M in these other classes must also be fixed automatically. This base super class provides a pattern and common methods for performing this kind of obfuscation. Subclasses only need to implement certain key abstract methods to provide an implementation for their particular obfuscation. @author Srinivas Visvanathan">
			<comm cntt="Subclass obfuscators must implement this method which will be called by the &amp;quot;apply&amp;quot; method. They should perform custom initialization and error checking in this method. If the obfuscation cannot be applied for some reason (i.e. error checks fail), this method should return false. &amp;quot;apply&amp;quot; will terminate. Otherwise true should be returned and &amp;quot;apply&amp;quot; will continue."/>
			<comm cntt="actual obfuscation routine"/>
			<comm cntt="Goes through set of classes that define declate mg and fixes them"/>
			<comm cntt="Should be implemented by the subclass obfuscators. This method is invoked to fix the signture (i.e. argument and return types) of the given method meth"/>
			<comm cntt="Should be implementated by subclass obfuscators. This method is invoked to fix the code of a subclass method meth"/>
			<comm cntt="Goes through list of callers that can invoke mID and fixes the invokations"/>
			<comm cntt="Looks for invokations to the methods being fixed in the class meth"/>
			<comm cntt="This method is called to fix an invokation to a method that&amp;apos;s being fixed in the method meth. A number of additional parameters are passed which must be used while fixing the invokation: Parameters are: ih - handle of invoke instruction il - instruction list of meth&amp;apos;s instructions iF - factory that should be used to create instructions cpg - constant pool of meth&amp;apos;s class meth - method containing the invoke The implementation must return the instruction handle of the last instruction it creates modifies so that fixInvokations can look for invokes from the next instruction onwards."/>
			<comm cntt="Useful method that computes the local variable array indices of the for the argument list AT. isStatic is used to specify whether the method containing these arguments is static or not. Returns an integer array containing the indices of the args in AT"/>
			<field name="mg" access="priv" jdoc=""/>
			<field name="cg" access="priv" jdoc=""/>
			<field name="app" access="priv" jdoc=""/>
			<field name="ch" access="priv" jdoc=""/>
			<field name="mID" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.MethodSignatureChanger.apply(sandmark.program.Method)" access="pub" jdoc="Applies the obfuscation on the given method meth. The obfuscation is automatically applied on all other implementations of meth in the same inheritance tree">
				<comm cntt="kheffner possible bugs in obfuscations caused by a stale ch"/>
				<comm cntt="if (ch.overridesLibraryMethod(mID))"/>
				<comm cntt="return false;"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.MethodSignatureChanger.customInit(sandmark.program.Method)" access="prot" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.MethodSignatureChanger.doIt()" access="priv" jdoc="">
				<comm cntt="find all classes that define declare mg"/>
				<comm cntt="find all classes that can invoke mg"/>
				<comm cntt="fix stuff"/>
			</mth>
			<mth name="/:sandmark.util.MethodSignatureChanger.fixMethodImplementations(java.util.Set)" access="priv" jdoc="">
				<comm cntt="cls declares mID, fix its signature"/>
				<comm cntt="also defines it, fix the code"/>
				<param name="rcvrs"/>
			</mth>
			<mth name="/:sandmark.util.MethodSignatureChanger.fixMethodSignature(sandmark.program.Method)" access="prot" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.MethodSignatureChanger.fixMethodCode(sandmark.program.Method)" access="prot" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.MethodSignatureChanger.fixMethodInvokations(java.util.List, java.util.Set)" access="priv" jdoc="">
				<param name="callers"/>
				<param name="rNames"/>
			</mth>
			<mth name="/:sandmark.util.MethodSignatureChanger.fixInvokations(sandmark.program.Method, java.util.Set)" access="priv" jdoc="">
				<comm cntt="name and sig of method invokation we are looking for"/>
				<comm cntt="look for invokes only"/>
				<comm cntt="ensure name &amp; sig of method being invoked match mName &amp; mSig"/>
				<comm cntt="ensure class to which invoke is being sent is among the receivers"/>
				<comm cntt="of mID"/>
				<comm cntt="fix the invoke instruction"/>
				<param name="meth"/>
				<param name="rNames"/>
			</mth>
			<mth name="/:sandmark.util.MethodSignatureChanger.fixInvoke(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionFactory, org.apache.bcel.generic.ConstantPoolGen, sandmark.program.Method)" access="prot" jdoc="">
				<param name="ih"/>
				<param name="il"/>
				<param name="iF"/>
				<param name="cpg"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.MethodSignatureChanger.computeIndices(org.apache.bcel.generic.Type, boolean)" access="prot" jdoc="">
				<param name="AT"/>
				<param name="isStatic"/>
			</mth>
		</class>
		<class name="/:sandmark.util.PriorityQueue" intfc="n" abs="n" inn="n" sloc="92" jdoc="">
			<field name="int2object" access="pub" jdoc=""/>
			<field name="object2int" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.PriorityQueue.PriorityQueue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.copy()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.put(int, Object)" access="pub" jdoc="">
				<param name="prio"/>
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.priority(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.deleteMin()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.deleteMax()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.isEmpty()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.containsKey(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.ascending()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.descending()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		<class name="/:sandmark.util.PriorityQueue$Ascending" intfc="n" abs="n" inn="y" sloc="25" jdoc="">
			<field name="iter" access="pub" jdoc=""/>
			<field name="nextElmt" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.PriorityQueue$Ascending.Ascending()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue$Ascending.get()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue$Ascending.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue$Ascending.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue$Ascending.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.PriorityQueue$Descending" intfc="n" abs="n" inn="y" sloc="25" jdoc="">
			<field name="iter" access="pub" jdoc=""/>
			<field name="nextElmt" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.PriorityQueue$Descending.Descending()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue$Descending.get()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue$Descending.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue$Descending.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.PriorityQueue$Descending.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.StringInt" intfc="n" abs="n" inn="n" sloc="39" jdoc="The sandmark.util.StringInt class encodes strings as BigIntegers. Strings having the form of non-negative integers are encoded with minimal overhead.">
			<comm cntt="------------------------------------------------------------"/>
			<mth name="/:sandmark.util.StringInt.encode(String)" access="pub" jdoc="Encodes a string to produce a BigInteger.">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.util.StringInt.decode(java.math.BigInteger)" access="pub" jdoc="Decodes a BigInteger to produce the corresponding string.">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.StringInt.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.util.Combinations" intfc="n" abs="n" inn="n" sloc="53" jdoc="">
			<field name="last" access="priv" jdoc=""/>
			<field name="n" access="priv" jdoc=""/>
			<field name="hasNext" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.Combinations.Combinations(int, int)" access="pub" jdoc="">
				<param name="n"/>
				<param name="k"/>
			</mth>
			<mth name="/:sandmark.util.Combinations.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Combinations.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Combinations.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Combinations.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.StaticSplit" intfc="n" abs="n" inn="n" sloc="54" jdoc="StaticSplit splits all the static and dynamic methods of a class into two methods, a private static method that does all the work of the original method and a stub with the same interface as the original method that simply calls the private static one. @author Srinivas Visvanathan">
			<comm cntt="perform the static split on class cls"/>
			<mth name="/:sandmark.util.StaticSplit.apply(sandmark.program.Class)" access="pub" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.util.StaticSplit.split(sandmark.program.Method, sandmark.program.Class)" access="priv" jdoc="">
				<comm cntt="compute arg types of the new method"/>
				<comm cntt="create a private, static copy of meth. meth.copy also makes lm a"/>
				<comm cntt="member of cls"/>
				<comm cntt="before changing the arg types, ensure no method with same name:sig"/>
				<comm cntt="already exists; if it does, pick a new random name for lm"/>
				<comm cntt="rewrite meth as a stub that calls lm"/>
				<comm cntt="add code to simply push this and the args on the stack"/>
				<comm cntt="add an invokation to lm"/>
				<comm cntt="add return"/>
				<param name="meth"/>
				<param name="cls"/>
			</mth>
		</class>
		<class name="/:sandmark.util.ConfigPropertyChangeListener" intfc="y" abs="n" inn="n" sloc="4" jdoc="">
			<mth name="/:sandmark.util.ConfigPropertyChangeListener.propertyChanged(ConfigProperties, String, Object, Object)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
		</class>
		<class name="/:sandmark.util.Node" intfc="n" abs="n" inn="n" sloc="5" jdoc="Implements a circular queue of K elements. &amp;apos;add(O)&amp;apos; adds a new element at the current position in the queue, possibly overwriting an earlier element (if more then K elements have been added).">
			<field name="data" access="pub" jdoc=""/>
			<field name="prev" access="pub" jdoc=""/>
			<field name="next" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.util.CircularBuffer" intfc="n" abs="n" inn="n" sloc="64" jdoc="">
			<comm cntt="------------------------------------------------------------"/>
			<comm cntt="------------------------------------------------------------"/>
			<field name="buffer" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.CircularBuffer.CircularBuffer(int)" access="pub" jdoc="Create a new Buffer. @param size The number of elements in the queue.">
				<param name="size"/>
			</mth>
			<mth name="/:sandmark.util.CircularBuffer.add(java.lang.Object)" access="pub" jdoc="Add a new element at the current position of the queue. @param obj The new element.">
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.util.CircularBuffer.iterator()" access="pub" jdoc="Generate the elements of the queue, in reverse order by time. I.e. the last added element is produced first.">
			</mth>
			<mth name="/:sandmark.util.CircularBuffer.toString()" access="pub" jdoc="Generate a printable version of the queue.">
			</mth>
			<mth name="/:sandmark.util.CircularBuffer.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		<class name="/:sandmark.util.CircularBuffer$Iterator" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<field name="current" access="pub" jdoc=""/>
			<field name="firstTime" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.CircularBuffer$Iterator.Iterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.CircularBuffer$Iterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.CircularBuffer$Iterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.CircularBuffer$Iterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.Math" intfc="n" abs="n" inn="n" sloc="73" jdoc="">
			<mth name="/:sandmark.util.Math.combinations(int, int)" access="pub" jdoc="Returns the value C(n,k). @param n number of elements to choose from @param k number of elements to choose @return number of possible combinations">
				<param name="n"/>
				<param name="k"/>
			</mth>
			<mth name="/:sandmark.util.Math.factorial(long)" access="pub" jdoc="@return n! @throws IllegalArgumentException if n &amp;lt; 0">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.Math.factorial(java.math.BigInteger)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.Math.combinations(java.math.BigInteger, java.math.BigInteger)" access="pub" jdoc="Returns the value C(n,k). @param n number of elements to choose from @param k number of elements to choose @return number of possible combinations">
				<param name="n"/>
				<param name="k"/>
			</mth>
			<mth name="/:sandmark.util.Math.getCombination(java.math.BigInteger, int, int)" access="pub" jdoc="">
				<param name="val"/>
				<param name="n"/>
				<param name="k"/>
			</mth>
			<mth name="/:sandmark.util.Math.getCombination(java.math.BigInteger, int, int, int)" access="priv" jdoc="">
				<param name="val"/>
				<param name="n"/>
				<param name="k"/>
				<param name="smallest"/>
			</mth>
			<mth name="/:sandmark.util.Math.decodeCombination(java.util.Set, int)" access="pub" jdoc="">
				<param name="c"/>
				<param name="n"/>
			</mth>
		</class>
		<class name="/:sandmark.util.MethodCaller" intfc="n" abs="n" inn="n" sloc="50" jdoc="Given a method mg that is defined declared by one or more classes (all part of the same inheritance tree), this class can be used to find all the classes in the application that can invoke mg, based on its access settings. @author Srinivas Visvanathan">
			<mth name="/:sandmark.util.MethodCaller.findMethodCallers(sandmark.program.Method)" access="pub" jdoc="mg is some method that is implemented by one or more classes (all part of the same inheritance tree). This method returns the list of classes (sandmark.program.Class) that can invoke mg based on mg&amp;apos;s access settings. If mg is: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; public: the list will contain all the classes in the application &amp;lt;li&amp;gt; private: the list will only containing the class defining mg &amp;lt;li&amp;gt; protected: the list will contain all the classes in cg&amp;apos;s hierarchy (cg is the class owning mg), that can receive the message mg &amp;lt;li&amp;gt; has no access modifiers: the list will contain all the classes in the same package as cg (class owning mg). &amp;lt; ul&amp;gt;">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.MethodCaller.findMethodCallers(sandmark.program.Method, java.util.Set)" access="pub" jdoc="Basically does the same thing as the other version of findMethodCallers. Takes an extra argument &amp;quot;receivers&amp;quot; which is the set of classes that can receive message mg as computed by findMethodReceivers (see package {@link sandmark.util.MethodReceiver}). If you just used findMethodReceivers to compute the set of classes that can receive mg as a message, then you can pass this set to findMethodCallers so that it doesn&amp;apos;t have to recompute it itself (as is done in the other version of this method)">
				<comm cntt="if mg is private, only cg&amp;apos;s members can invoke mg"/>
				<comm cntt="if public, all classes in the app can invoke mg"/>
				<comm cntt="if protected, all subclasses and superclasses that can receive the"/>
				<comm cntt="method call can also call this method. All classes in this package can"/>
				<comm cntt="also call the method"/>
				<comm cntt="make a shallow copy of the set, so that we don&amp;apos;t modify the"/>
				<comm cntt="set passed as input to this method. Elements are not cloned"/>
				<comm cntt="and so will be referenced by both sets. Further additions"/>
				<comm cntt="to rcvrs will add to the clone set"/>
				<comm cntt="if no modifier has been given, then all classes in the same package"/>
				<comm cntt="can invoke this method"/>
				<param name="mg"/>
				<param name="receivers"/>
			</mth>
		</class>
		<class name="/:sandmark.util.InstructionTree" intfc="n" abs="n" inn="n" sloc="59" jdoc="">
			<comm cntt="This method is the helper method that recursively builds the"/>
			<comm cntt="String representation of the Thesaurus."/>
			<field name="root" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.InstructionTree.InstructionTree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.InstructionTree.add(Comparable)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.InstructionTree.add(BTN, Comparable)" access="priv" jdoc="">
				<param name="curr"/>
				<param name="newElem"/>
			</mth>
			<mth name="/:sandmark.util.InstructionTree.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.InstructionTree.buildString(BTN)" access="priv" jdoc="">
				<param name="curr"/>
			</mth>
			<mth name="/:sandmark.util.InstructionTree.lineUp(String)" access="priv" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:sandmark.util.InstructionTree.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		<class name="/:sandmark.util.InstructionTree$BTN" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<field name="left" access="pub" jdoc=""/>
			<field name="right" access="pub" jdoc=""/>
			<field name="data" access="pub" jdoc=""/>
			<field name="numAccess" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.InstructionTree$BTN.BTN(Comparable)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.InstructionTree$BTN.BTN(Comparable, BTN, BTN)" access="pub" jdoc="">
				<param name="data"/>
				<param name="left"/>
				<param name="right"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.ByteCodeLocation" intfc="n" abs="n" inn="n" sloc="42" jdoc="This class represents the location of a bytecode instruction in the code. &amp;lt;P&amp;gt; All fields are public, but should be treated as read-only.">
			<comm cntt="public static ByteCodeLocation parse(String input) { java.util.StringTokenizer tok = new java.util.StringTokenizer(input); String name = tok.nextToken(); String callerSignature = tok.nextToken(); String sourceName = tok.nextToken(); int lineNumber = java.lang.Integer.parseInt(tok.nextToken()); int codeIndex = java.lang.Integer.parseInt(tok.nextToken()); sandmark.util.MethodID method = new sandmark.util.MethodID(name, callerSignature, sourceName); return new ByteCodeLocation(method, lineNumber, codeIndex); }"/>
			<const name="MISSING_long" access="pub" jdoc=""/>
			<field name="method" access="priv" jdoc="The method in which the bytecode instruction resides."/>
			<field name="lineNumber" access="priv" jdoc="The line-number of the bytecode instruction. (May be ==-1 if there was no line-number information present.)"/>
			<field name="codeIndex" access="priv" jdoc="The bytecode offset where the call was made."/>
			<mth name="/:sandmark.util.ByteCodeLocation.ByteCodeLocation(sandmark.util.MethodID, long, long)" access="pub" jdoc="">
				<param name="method"/>
				<param name="lineNumber"/>
				<param name="codeIndex"/>
			</mth>
			<mth name="/:sandmark.util.ByteCodeLocation.getMethod()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ByteCodeLocation.getCodeIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ByteCodeLocation.getLineNumber()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ByteCodeLocation.equals(Object)" access="pub" jdoc="Compare for equality.">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.util.ByteCodeLocation.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ByteCodeLocation.toString()" access="pub" jdoc="Format the data in an easy to parse form.">
			</mth>
			<mth name="/:sandmark.util.ByteCodeLocation.toStringShortFormat()" access="pub" jdoc="Format the data in a compact form.">
			</mth>
			<mth name="/:sandmark.util.ByteCodeLocation.toStringDotFormat()" access="pub" jdoc="Format the data in a format suitable for dot.">
			</mth>
			<mth name="/:sandmark.util.ByteCodeLocation.toStringShortDotFormat()" access="pub" jdoc="Format the data in a format suitable for dot.">
			</mth>
		</class>
		<class name="/:sandmark.util.SparseVector" intfc="n" abs="n" inn="n" sloc="48" jdoc="This is similar to java.util.Vector. However, &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; we count from 1; &amp;lt;LI&amp;gt; we ignore missing elements. So, get(i) will return null rather than throw an exception if element i does not exist; &amp;lt;LI&amp;gt; the vector grows automatically. So, whenever we try to set(i,obj) the vector is grown to accomodate object number i; &amp;lt;LI&amp;gt; When iterating over a vector we ignore (i.e. don&amp;apos;t return) null elements. &amp;lt; OL&amp;gt;">
			<field name="elements" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.SparseVector.SparseVector()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SparseVector.SparseVector(int)" access="pub" jdoc="">
				<param name="initialCapacity"/>
			</mth>
			<mth name="/:sandmark.util.SparseVector.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SparseVector.copy()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SparseVector.get(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.util.SparseVector.set(int, Object)" access="pub" jdoc="">
				<param name="index"/>
				<param name="elmt"/>
			</mth>
			<mth name="/:sandmark.util.SparseVector.size()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SparseVector.iterator()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.util.SparseVector$Iterator" intfc="n" abs="n" inn="y" sloc="25" jdoc="">
			<field name="nextElmt" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.SparseVector$Iterator.Iterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SparseVector$Iterator.get()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SparseVector$Iterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SparseVector$Iterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SparseVector$Iterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.Dot" intfc="n" abs="n" inn="n" sloc="138" jdoc="Visualize a graph using the &amp;apos;dot&amp;apos; tool. Just do &amp;lt;PRE&amp;gt; sandmark.util.Misc.writeToFile(&amp;quot;file.dot&amp;quot;, dot-prog); &amp;lt; PRE&amp;gt; run dot on the resulting file &amp;lt;PRE&amp;gt; dot -Tps file.dot &amp;gt; file.ps &amp;lt; PRE&amp;gt; and then view the postscript file &amp;lt;PRE&amp;gt; gv file.ps &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt;">
			<const name="TURQUOISE" access="pub" jdoc=""/>
			<const name="ANTIQUEWHITE" access="pub" jdoc=""/>
			<const name="CORAL" access="pub" jdoc=""/>
			<const name="DARKGOLDENROD" access="pub" jdoc=""/>
			<const name="AZURE" access="pub" jdoc=""/>
			<const name="CRIMSON" access="pub" jdoc=""/>
			<const name="GOLD" access="pub" jdoc=""/>
			<const name="BISQUE" access="pub" jdoc=""/>
			<const name="DARKSALMON" access="pub" jdoc=""/>
			<const name="GOLDENROD" access="pub" jdoc=""/>
			<const name="ALICEBLUE" access="pub" jdoc=""/>
			<const name="BLANCHEDALMOND" access="pub" jdoc=""/>
			<const name="DEEPPINK" access="pub" jdoc=""/>
			<const name="GREENYELLOW" access="pub" jdoc=""/>
			<const name="BLUE" access="pub" jdoc=""/>
			<const name="CORNSILK" access="pub" jdoc=""/>
			<const name="FIREBRICK" access="pub" jdoc=""/>
			<const name="LIGHTGOLDENROD" access="pub" jdoc=""/>
			<const name="BLUEVIOLET" access="pub" jdoc=""/>
			<const name="FLORALWHITE" access="pub" jdoc=""/>
			<const name="HOTPINK" access="pub" jdoc=""/>
			<const name="LIGHTGOLDENRODYELLOW" access="pub" jdoc=""/>
			<const name="CADETBLUE" access="pub" jdoc=""/>
			<const name="GAINSBORO" access="pub" jdoc=""/>
			<const name="INDIANRED" access="pub" jdoc=""/>
			<const name="LIGHTYELLOW" access="pub" jdoc=""/>
			<const name="CORNFLOWERBLUE" access="pub" jdoc=""/>
			<const name="GHOSTWHITE" access="pub" jdoc=""/>
			<const name="LIGHTPINK" access="pub" jdoc=""/>
			<const name="PALEGOLDENROD" access="pub" jdoc=""/>
			<const name="DARKSLATEBLUE" access="pub" jdoc=""/>
			<const name="HONEYDEW" access="pub" jdoc=""/>
			<const name="LIGHTSALMON" access="pub" jdoc=""/>
			<const name="YELLOW" access="pub" jdoc=""/>
			<const name="DEEPSKYBLUE" access="pub" jdoc=""/>
			<const name="IVORY" access="pub" jdoc=""/>
			<const name="MAROON" access="pub" jdoc=""/>
			<const name="YELLOWGREEN" access="pub" jdoc=""/>
			<const name="DODGERBLUE" access="pub" jdoc=""/>
			<const name="LAVENDER" access="pub" jdoc=""/>
			<const name="INDIGO" access="pub" jdoc=""/>
			<const name="LAVENDERBLUSH" access="pub" jdoc=""/>
			<const name="ORANGERED" access="pub" jdoc=""/>
			<const name="LIGHTBLUE" access="pub" jdoc=""/>
			<const name="LEMONCHIFFON" access="pub" jdoc=""/>
			<const name="CHARTREUSE" access="pub" jdoc=""/>
			<const name="LIGHTSKYBLUE" access="pub" jdoc=""/>
			<const name="LINEN" access="pub" jdoc=""/>
			<const name="PINK" access="pub" jdoc=""/>
			<const name="DARKGREEN" access="pub" jdoc=""/>
			<const name="LIGHTSLATEBLUE" access="pub" jdoc=""/>
			<const name="MINTCREAM" access="pub" jdoc=""/>
			<const name="RED" access="pub" jdoc=""/>
			<const name="DARKOLIVEGREEN" access="pub" jdoc=""/>
			<const name="MEDIUMBLUE" access="pub" jdoc=""/>
			<const name="MISTYROSE" access="pub" jdoc=""/>
			<const name="SALMON" access="pub" jdoc=""/>
			<const name="DARKSEAGREEN" access="pub" jdoc=""/>
			<const name="MEDIUMSLATEBLUE" access="pub" jdoc=""/>
			<const name="MOCCASIN" access="pub" jdoc=""/>
			<const name="TOMATO" access="pub" jdoc=""/>
			<const name="FORESTGREEN" access="pub" jdoc=""/>
			<const name="MIDNIGHTBLUE" access="pub" jdoc=""/>
			<const name="NAVAJOWHITE" access="pub" jdoc=""/>
			<const name="VIOLETRED" access="pub" jdoc=""/>
			<const name="GREEN" access="pub" jdoc=""/>
			<const name="NAVY" access="pub" jdoc=""/>
			<const name="OLDLACE" access="pub" jdoc=""/>
			<const name="NAVYBLUE" access="pub" jdoc=""/>
			<const name="PAPAYAWHIP" access="pub" jdoc=""/>
			<const name="BROWNS" access="pub" jdoc=""/>
			<const name="LAWNGREEN" access="pub" jdoc=""/>
			<const name="POWDERBLUE" access="pub" jdoc=""/>
			<const name="PEACHPUFF" access="pub" jdoc=""/>
			<const name="BEIGE" access="pub" jdoc=""/>
			<const name="LIGHTSEAGREEN" access="pub" jdoc=""/>
			<const name="ROYALBLUE" access="pub" jdoc=""/>
			<const name="SEASHELL" access="pub" jdoc=""/>
			<const name="BROWN" access="pub" jdoc=""/>
			<const name="LIMEGREEN" access="pub" jdoc=""/>
			<const name="SKYBLUE" access="pub" jdoc=""/>
			<const name="SNOW" access="pub" jdoc=""/>
			<const name="BURLYWOOD" access="pub" jdoc=""/>
			<const name="MEDIUMSEAGREEN" access="pub" jdoc=""/>
			<const name="SLATEBLUE" access="pub" jdoc=""/>
			<const name="THISTLE" access="pub" jdoc=""/>
			<const name="CHOCOLATE" access="pub" jdoc=""/>
			<const name="MEDIUMSPRINGGREEN" access="pub" jdoc=""/>
			<const name="STEELBLUE" access="pub" jdoc=""/>
			<const name="WHEAT" access="pub" jdoc=""/>
			<const name="DARKKHAKI" access="pub" jdoc=""/>
			<const name="WHITE" access="pub" jdoc=""/>
			<const name="KHAKI" access="pub" jdoc=""/>
			<const name="OLIVEDRAB" access="pub" jdoc=""/>
			<const name="WHITESMOKE" access="pub" jdoc=""/>
			<const name="PERU" access="pub" jdoc=""/>
			<const name="PALEGREEN" access="pub" jdoc=""/>
			<const name="ROSYBROWN" access="pub" jdoc=""/>
			<const name="SEAGREEN" access="pub" jdoc=""/>
			<const name="DARKORCHID" access="pub" jdoc=""/>
			<const name="SADDLEBROWN" access="pub" jdoc=""/>
			<const name="SPRINGGREEN" access="pub" jdoc=""/>
			<const name="DARKVIOLET" access="pub" jdoc=""/>
			<const name="DARKSLATEGRAY" access="pub" jdoc=""/>
			<const name="SANDYBROWN" access="pub" jdoc=""/>
			<const name="MAGENTA" access="pub" jdoc=""/>
			<const name="DIMGRAY" access="pub" jdoc=""/>
			<const name="SIENNA" access="pub" jdoc=""/>
			<const name="MEDIUMORCHID" access="pub" jdoc=""/>
			<const name="TAN" access="pub" jdoc=""/>
			<const name="MEDIUMPURPLE" access="pub" jdoc=""/>
			<const name="GRAY" access="pub" jdoc=""/>
			<const name="AQUAMARINE" access="pub" jdoc=""/>
			<const name="MEDIUMVIOLETRED" access="pub" jdoc=""/>
			<const name="LIGHTGRAY" access="pub" jdoc=""/>
			<const name="CYAN" access="pub" jdoc=""/>
			<const name="ORCHID" access="pub" jdoc=""/>
			<const name="LIGHTSLATEGRAY" access="pub" jdoc=""/>
			<const name="DARKORANGE" access="pub" jdoc=""/>
			<const name="DARKTURQUOISE" access="pub" jdoc=""/>
			<const name="PALEVIOLETRED" access="pub" jdoc=""/>
			<const name="SLATEGRAY" access="pub" jdoc=""/>
			<const name="ORANGE" access="pub" jdoc=""/>
			<const name="LIGHTCYAN" access="pub" jdoc=""/>
			<const name="PLUM" access="pub" jdoc=""/>
			<const name="MEDIUMAQUAMARINE" access="pub" jdoc=""/>
			<const name="PURPLE" access="pub" jdoc=""/>
			<const name="MEDIUMTURQUOISE" access="pub" jdoc=""/>
			<const name="VIOLET" access="pub" jdoc=""/>
			<const name="BLACK" access="pub" jdoc=""/>
			<const name="PALETURQUOISE" access="pub" jdoc=""/>
			<const name="SOLID" access="pub" jdoc=""/>
			<const name="DASHED" access="pub" jdoc=""/>
			<const name="DOTTED" access="pub" jdoc=""/>
			<const name="BOLD" access="pub" jdoc=""/>
			<const name="INIVS" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.util.MethodID" intfc="n" abs="n" inn="n" sloc="60" jdoc="This class represents a method. &amp;lt;P&amp;gt; All fields are public, but should be treated as read-only.">
			<comm cntt="public static MethodID parse(String input) { java.util.StringTokenizer tok = new java.util.StringTokenizer(input); String name = tok.nextToken(); String signature = tok.nextToken(); String className = tok.nextToken(); return new MethodID(name, signature, className); }"/>
			<field name="name" access="priv" jdoc="The name of the method that called Annotate.mark()."/>
			<field name="signature" access="priv" jdoc="The signature of the method that called Annotate.mark()."/>
			<field name="className" access="priv" jdoc="The name of the class the calling method was in. This is the fully qualified class name, such as &amp;lt;code&amp;gt;java.lang.Object&amp;lt; code&amp;gt;."/>
			<mth name="/:sandmark.util.MethodID.MethodID(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="signature"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.util.MethodID.MethodID(org.apache.bcel.generic.MethodGen)" access="pub" jdoc="Convienence constructor, creates a MethodID from a BCEL &amp;lt;a href=&amp;quot;http: bcel.sourceforge.net doc de fub bytecode generic MethodGen.html&amp;quot;&amp;gt; MethodGen&amp;lt; a&amp;gt; object. @param method a MethodGen to build a MethodID from">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.util.MethodID.MethodID(sandmark.program.Method)" access="pub" jdoc="Convienence constructor, creates a MethodID from a BCEL &amp;lt;a href=&amp;quot;http: bcel.sourceforge.net doc de fub bytecode generic MethodGen.html&amp;quot;&amp;gt; MethodGen&amp;lt; a&amp;gt; object. @param method a MethodGen to build a MethodID from">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.util.MethodID.equals(Object)" access="pub" jdoc="Compare for equality.">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.util.MethodID.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.MethodID.toString()" access="pub" jdoc="Format the data in an easy to parse form.">
			</mth>
			<mth name="/:sandmark.util.MethodID.toStringShortFormat()" access="pub" jdoc="Format the data in a compact form.">
			</mth>
			<mth name="/:sandmark.util.MethodID.toStringDotFormat()" access="pub" jdoc="Format the data in a format suitable for dot.">
			</mth>
			<mth name="/:sandmark.util.MethodID.toStringShortDotFormat()" access="pub" jdoc="Format the data in a format suitable for dot.">
			</mth>
			<mth name="/:sandmark.util.MethodID.getName()" access="pub" jdoc="Return the name of this method.">
			</mth>
			<mth name="/:sandmark.util.MethodID.getSignature()" access="pub" jdoc="Return the signature of this method.">
			</mth>
			<mth name="/:sandmark.util.MethodID.getClassName()" access="pub" jdoc="Return the fully qualified class name of this method.">
			</mth>
		</class>
		<class name="/:sandmark.util.ParamReorder" intfc="n" abs="n" inn="n" sloc="121" jdoc="Reorders the parameters of a method. To use the class use the &amp;quot;apply&amp;quot; method defined by its super class (@see sandmark.util.MethodSignatureChanger) @author Srinivas Visvanathn">
			<comm cntt="old param types"/>
			<comm cntt="new param types"/>
			<comm cntt="old local var indices of args"/>
			<comm cntt="new local var indices of args"/>
			<comm cntt="mapping from old to new new to old of local var indices"/>
			<comm cntt="pop args off and push them in the new order. also fix invoke to refer to"/>
			<comm cntt="the updated method"/>
			<comm cntt="restore args into the old order in the local var array"/>
			<comm cntt="compute reordering info that will be used by other methods"/>
			<field name="oldAT" access="priv" jdoc=""/>
			<field name="newAT" access="priv" jdoc=""/>
			<field name="oldIndices" access="pub" jdoc=""/>
			<field name="newIndices" access="pub" jdoc=""/>
			<field name="old2new" access="pub" jdoc=""/>
			<field name="new2old" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.ParamReorder.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.ParamReorder.customInit(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="can&amp;apos;t reorder unless we have at least 2 args"/>
				<comm cntt="shuffle the args and compute info needed for reordering"/>
				<comm cntt="ensure method with new signature doesn&amp;apos;t already exist"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.ParamReorder.fixInvoke(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionFactory, org.apache.bcel.generic.ConstantPoolGen, sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="if method is not static and all values in new oldIndices will be"/>
				<comm cntt="larger by 1 for the &amp;quot;this&amp;quot; ref"/>
				<comm cntt="pop all args off into local array beyond max locals"/>
				<comm cntt="push args in new order"/>
				<comm cntt="fix invoke instruction"/>
				<comm cntt="redirect branches to the start of the wrapup sequence"/>
				<param name="ih"/>
				<param name="il"/>
				<param name="iF"/>
				<param name="cpg"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.ParamReorder.fixMethodSignature(sandmark.program.Method)" access="prot" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.ParamReorder.fixMethodCode(sandmark.program.Method)" access="prot" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.ParamReorder.computeReordering(sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="loop to randomly reorder the args and maintain reordering info"/>
				<comm cntt="will swap arg i and arg (i + 1)"/>
				<comm cntt="swap types of args i and (i + 1)"/>
				<comm cntt="change indices of args i and (i + 1); only index of arg (i + 1)"/>
				<comm cntt="actually changes"/>
				<comm cntt="update mapping between old and new indices"/>
				<comm cntt="compute old2new based on new2old"/>
				<param name="meth"/>
			</mth>
		</class>
		<class name="/:sandmark.util.Misc" intfc="n" abs="n" inn="n" sloc="263" jdoc="The sandmark.util.Misc class holds utility methods that don&amp;apos;t fit anywhere else.">
			<comm cntt="Throws an Error exception to abort the current action."/>
			<comm cntt="Format en integer matrix."/>
			<comm cntt="Concatenates an argument list to form a single string. Each argument is preceded by a single space character. A space or backslash in an argument is preceded by an escaping backslash."/>
			<comm cntt="Splits an argument list created by {@link #joinArgs}."/>
			<comm cntt="------------------------------------------------------------"/>
			<comm cntt="------------------------------------------------------------"/>
			<const name="RETURN_STDOUT" access="pub" jdoc=""/>
			<const name="RETURN_STDERR" access="pub" jdoc=""/>
			<const name="RETURN_STDOUT_STDERR" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.Misc.getKeyForClass(String)" access="pub" jdoc="Returns a String to use as a hashkey to hash a class.">
				<param name="classname"/>
			</mth>
			<mth name="/:sandmark.util.Misc.getKeyForMethod(String, String, String)" access="pub" jdoc="Returns a String to use as a hashkey to hash a method.">
				<param name="classname"/>
				<param name="methodname"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.util.Misc.getKeyForMethod(sandmark.util.MethodID)" access="pub" jdoc="">
				<param name="mid"/>
			</mth>
			<mth name="/:sandmark.util.Misc.getKeyForMethod(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.util.Misc.getMethodForKey(String)" access="pub" jdoc="Given the hashkey from getKeyForMethod, returns an array of Strings {class name, method name, signature} for the method. If a malformed key is passed to this method, the result is not defined.">
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.util.Misc.getClassForKey(String)" access="pub" jdoc="">
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.util.Misc.getKeyForApp()" access="pub" jdoc="Returns a String to use as a hashkey to hash the whole application.">
			</mth>
			<mth name="/:sandmark.util.Misc.abort(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/:sandmark.util.Misc.exit(int, String)" access="pub" jdoc="">
				<param name="val"/>
				<param name="msg"/>
			</mth>
			<mth name="/:sandmark.util.Misc.matrix2String(int[][])" access="pub" jdoc="">
				<param name="M"/>
			</mth>
			<mth name="/:sandmark.util.Misc.row2String(int[])" access="pub" jdoc="">
				<param name="row"/>
			</mth>
			<mth name="/:sandmark.util.Misc.int2String(int)" access="pub" jdoc="">
				<param name="k"/>
			</mth>
			<mth name="/:sandmark.util.Misc.joinArgs(String[], int, int)" access="pub" jdoc="">
				<param name="arglist"/>
				<param name="first"/>
				<param name="len"/>
			</mth>
			<mth name="/:sandmark.util.Misc.splitArgs(String)" access="pub" jdoc="">
				<param name="argstring"/>
			</mth>
			<mth name="/:sandmark.util.Misc.buildArray(java.util.Iterator, java.lang.Object[])" access="pub" jdoc="Returns an array of the items returned by a java.util.Iterator. If the supplied array is large enough, it is used; otherwise a new array of the same type and exactly adequate size is created.">
				<param name="it"/>
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.util.Misc.instanceFilter(java.util.Iterator, java.lang.Class)" access="pub" jdoc="Returns an iterator that filters another iterator to produce only objects that are instances of a given class. @param it underlying iterator @param c class to select for">
				<param name="it"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.Misc.loadBytes(java.io.InputStream)" access="pub" jdoc="Loads a file into a byte array.">
				<comm cntt="arbitrary size"/>
				<param name="instream"/>
			</mth>
			<mth name="/:sandmark.util.Misc.writeToFile(String, String)" access="pub" jdoc="Write a string to a file. &amp;lt;P&amp;gt; @param fileName The name of the file to be written. @param string The string to be written.">
				<param name="fileName"/>
				<param name="string"/>
			</mth>
			<mth name="/:sandmark.util.Misc.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.Misc.argtest(String[])" access="priv" jdoc="">
				<param name="arglist"/>
			</mth>
			<mth name="/:sandmark.util.Misc.dumpargs(String, String[])" access="priv" jdoc="">
				<param name="label"/>
				<param name="slist"/>
			</mth>
			<mth name="/:sandmark.util.Misc.stringReplace(String, String, String)" access="pub" jdoc="Return the string that results by replacing the first occurence of string &amp;lt;code&amp;gt;pattern&amp;lt; code&amp;gt; with string &amp;lt;code&amp;gt;rep&amp;lt; code&amp;gt; in string &amp;lt;code&amp;gt;from&amp;lt; code&amp;gt;. &amp;lt;P&amp;gt; @param from The target string. @param pattern What we&amp;apos;re looking for. @param rep What we&amp;apos;re replacing with.">
				<param name="from"/>
				<param name="pattern"/>
				<param name="rep"/>
			</mth>
			<mth name="/:sandmark.util.Misc.readResult(java.io.BufferedReader)" access="pub" jdoc="Return the result of reading the entire conents of text file. &amp;lt;P&amp;gt; @param in The file we&amp;apos;re reading from.">
				<param name="in"/>
			</mth>
			<mth name="/:sandmark.util.Misc.readStdOut(java.lang.Process)" access="pub" jdoc="Return the result of reading the entire conents of &amp;lt;code&amp;gt;stdout&amp;lt; code&amp;gt;. &amp;lt;P&amp;gt; @param proc The process we&amp;apos;re reading from.">
				<param name="proc"/>
			</mth>
			<mth name="/:sandmark.util.Misc.readStdErr(java.lang.Process)" access="pub" jdoc="Return the result of reading the entire contents of &amp;lt;code&amp;gt;stderr&amp;lt; code&amp;gt;. &amp;lt;P&amp;gt; @param proc The process we&amp;apos;re reading from.">
				<param name="proc"/>
			</mth>
			<mth name="/:sandmark.util.Misc.execute(String, int)" access="pub" jdoc="Execute a command, wait for termination, return stdout and or stderr depending on the value of &amp;lt;code&amp;gt;returnWhat&amp;lt; code&amp;gt;. &amp;lt;P&amp;gt; @param cmd The command to be executed. @param returnWhat Return stdout and or stderr.">
				<param name="cmd"/>
				<param name="returnWhat"/>
			</mth>
		</class>
		<class name="/:sandmark.util.WeakBuffer" intfc="n" abs="n" inn="n" sloc="30" jdoc="WeakBuffer.java -- @author Jasvir Nagra &amp;lt;jas@cs.auckland.ac.nz&amp;gt; Created On : Fri May 2 11:27:31 2003 Last Modified : &amp;lt;03 05 09 11:46:32 jas&amp;gt; Description : Implements a buffer with weak objects that will be gc&amp;apos;ed if not in ordinary use Keywords : gc weak buffer PURPOSE | Sandmark project |">
			<field name="buffer" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.WeakBuffer.WeakBuffer()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.WeakBuffer.add(java.lang.Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.util.WeakBuffer.iterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.WeakBuffer.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.WeakBuffer.size()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.WeakBuffer.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.util.SignatureBludgeoner" intfc="n" abs="n" inn="n" sloc="141" jdoc="Modifies a method so that it takes an Object[] as an argument and returns Object. To use the class use the &amp;quot;apply&amp;quot; method defined by its super class (@see sandmark.util.MethodSignatureChanger) @author Srinivas Visvanathn">
			<field name="oldAT" access="pub" jdoc=""/>
			<field name="oldRType" access="pub" jdoc=""/>
			<field name="oldIndices" access="pub" jdoc=""/>
			<const name="newAT" access="pub" jdoc=""/>
			<const name="newRType" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.SignatureBludgeoner.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.SignatureBludgeoner.customInit(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="ensure its not main or &amp;lt;init&amp;gt; or &amp;lt;clinit&amp;gt;"/>
				<comm cntt="ensure args are all of reference type"/>
				<comm cntt="no args"/>
				<comm cntt="ensure return type is a reference type or void"/>
				<comm cntt="ensure method with new signature doesn&amp;apos;t already exist"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.SignatureBludgeoner.fixMethodSignature(sandmark.program.Method)" access="prot" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.SignatureBludgeoner.fixMethodCode(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="if method used to return void, now should return null"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.SignatureBludgeoner.unwrapArgs(sandmark.program.Method, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.ConstantPoolGen, org.apache.bcel.generic.InstructionFactory)" access="priv" jdoc="">
				<param name="meth"/>
				<param name="il"/>
				<param name="cpg"/>
				<param name="iF"/>
			</mth>
			<mth name="/:sandmark.util.SignatureBludgeoner.fixReturns(sandmark.program.Method, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionFactory)" access="priv" jdoc="">
				<comm cntt="replace returns with an areturn"/>
				<comm cntt="looking for returns"/>
				<comm cntt="add instruction to push null and areturn it"/>
				<param name="meth"/>
				<param name="il"/>
				<param name="iF"/>
			</mth>
			<mth name="/:sandmark.util.SignatureBludgeoner.fixInvoke(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionFactory, org.apache.bcel.generic.ConstantPoolGen, sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="create the Object array"/>
				<comm cntt="add instructions to store each of the args in the array"/>
				<comm cntt="fix the invoke"/>
				<comm cntt="redirect branches to the start of the wrapup sequence"/>
				<comm cntt="if return type was VOID, add pop, else cast result back to actual"/>
				<comm cntt="return type"/>
				<param name="ih"/>
				<param name="il"/>
				<param name="iF"/>
				<param name="cpg"/>
				<param name="meth"/>
			</mth>
		</class>
		<class name="/:sandmark.util.ArrayIterator" intfc="n" abs="n" inn="n" sloc="20" jdoc="">
			<field name="a" access="priv" jdoc=""/>
			<field name="curr" access="priv" jdoc=""/>
			<field name="length" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.ArrayIterator.ArrayIterator(java.lang.Object, int, int)" access="pub" jdoc="">
				<param name="a"/>
				<param name="fromIndex"/>
				<param name="toIndex"/>
			</mth>
			<mth name="/:sandmark.util.ArrayIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ArrayIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ArrayIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.MultiIter" intfc="n" abs="y" inn="n" sloc="61" jdoc="">
			<comm cntt="Start enumerator number k. elmts[0..k-1] hold the current generated values for the first k enumerators."/>
			<comm cntt="Create the object to be returned by the enumerator. Throws an exception if no element could be generated."/>
			<comm cntt="Return the number of enumerators."/>
			<field name="enums" access="pub" jdoc=""/>
			<field name="result" access="pub" jdoc=""/>
			<field name="elmts" access="pub" jdoc=""/>
			<field name="firstTime" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.MultiIter.MultiIter()" access="pub" jdoc="Compose several iterators into a new iterator. Extend this class and override &amp;lt;code&amp;gt;start&amp;lt; code&amp;gt; with a method which starts the k:th enumerator and &amp;lt;code&amp;gt;create&amp;lt; code&amp;gt; which creates the new element to yield out of the elements yielded by the individual enumerators.">
			</mth>
			<mth name="/:sandmark.util.MultiIter.init()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.MultiIter.genNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.MultiIter.start(int, java.lang.Object[])" access="pub" jdoc="">
				<param name="k"/>
				<param name="elmts"/>
			</mth>
			<mth name="/:sandmark.util.MultiIter.create(java.lang.Object[])" access="pub" jdoc="">
				<param name="elmts"/>
			</mth>
			<mth name="/:sandmark.util.MultiIter.count()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.MultiIter.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.MultiIter.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.MultiIter.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.Log" intfc="n" abs="n" inn="n" sloc="49" jdoc="The sandmark.util.Log class handles logging for a SandMark application. Logging is considered a global aspect of the program, and all methods are static. &amp;lt;P&amp;gt; Every message has a level associated with it. Only messages meeting a specified threshold are seen by the user. &amp;lt;P&amp;gt; Multiple log files can be specified, each with its own threshold. Each message is logged to every file with an accepting threshold.">
			<const name="USER_MESSAGES" access="pub" jdoc=""/>
			<const name="USER_ERRORS" access="pub" jdoc=""/>
			<const name="DEVELOPER_MESSAGES" access="pub" jdoc=""/>
			<const name="DEVELOPER_ERRORS" access="pub" jdoc=""/>
			<const name="INTERNAL_EXCEPTION" access="pub" jdoc=""/>
			<field name="loggers" access="priv" jdoc=""/>
			<field name="messages" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.Log.addLog(String, int)" access="pub" jdoc="Opens and registers an output file for logging. @param fname filename for output @param thresh message threshold">
				<param name="fname"/>
				<param name="thresh"/>
			</mth>
			<mth name="/:sandmark.util.Log.addLog(java.io.OutputStream, int)" access="pub" jdoc="Registers an output stream for logging. @param o output stream @param thresh message threshold">
				<param name="o"/>
				<param name="thresh"/>
			</mth>
			<mth name="/:sandmark.util.Log.addLog(java.io.Writer, int)" access="pub" jdoc="Registers an output writer for logging. @param w output stream @param thresh message threshold">
				<param name="w"/>
				<param name="thresh"/>
			</mth>
			<mth name="/:sandmark.util.Log.message(int, String)" access="pub" jdoc="Sends a message to the log files. The message is sent to every log file that does not have a threshold higher than the stated message level. @param level message level @param msg message text">
				<param name="level"/>
				<param name="msg"/>
			</mth>
			<mth name="/:sandmark.util.Log.message(int, String, java.lang.Throwable)" access="pub" jdoc="Sends an exception message to the log files. @param level message level @param msg message text">
				<param name="level"/>
				<param name="msg"/>
				<param name="t"/>
			</mth>
			<mth name="/:sandmark.util.Log.run()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Log.Log()" access="priv" jdoc="">
			</mth>
		<class name="/:sandmark.util.Log$Logger" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<field name="logFile" access="pub" jdoc=""/>
			<field name="threshold" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.Log$Logger.Logger(java.io.PrintWriter, int)" access="pub" jdoc="">
				<param name="logFile"/>
				<param name="threshold"/>
			</mth>
			<mth name="/:sandmark.util.Log$Logger.log(int, String)" access="pub" jdoc="">
				<param name="level"/>
				<param name="msg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.Log$Message" intfc="n" abs="n" inn="y" sloc="5" jdoc="">
			<field name="message" access="pub" jdoc=""/>
			<field name="level" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.Log$Message.Message(String, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="l"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.SingleObjectIterator" intfc="n" abs="n" inn="n" sloc="8" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="o" access="priv" jdoc=""/>
			<field name="didReturn" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.SingleObjectIterator.SingleObjectIterator(Object)" access="pub" jdoc="">
				<param name="u"/>
			</mth>
			<mth name="/:sandmark.util.SingleObjectIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SingleObjectIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.SingleObjectIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.TempDir" intfc="n" abs="n" inn="n" sloc="26" jdoc="A TempDir object represents a temporary directory in the filesystem.">
			<mth name="/:sandmark.util.TempDir.TempDir(String)" access="pub" jdoc="Constructs a TempDir object and a corresponding directory in the temporary area specified by the java.io.tmpdir system property. The directory name is formed by appending random digits to the supplied prefix.">
				<param name="prefix"/>
			</mth>
			<mth name="/:sandmark.util.TempDir.finalize()" access="prot" jdoc="Removes the directory and its contents.">
			</mth>
			<mth name="/:sandmark.util.TempDir.delete()" access="pub" jdoc="Removes the directory and its contents.">
			</mth>
		</class>
		<class name="/:sandmark.util.ConfigProperties" intfc="n" abs="n" inn="n" sloc="141" jdoc="A ConfigProperties object allows properties to be queried and manipulated by name. Each property has a name, a value, a description, a type, and a phase. Properties of ConfigProperties objects are generally designed to be manipulated by an end-user. The type associated with an object is one of TYPE_ integers. The value of a property is an instance of the class corresponding to a given TYPE_ constant. For example, if a property has type TYPE_BOOLEAN, then the property&amp;apos;s value is an instance of java.lang.Boolean. A property&amp;apos;s phase is a bitwise OR of all the phases (as defined by the PHASE_ constants) in which it is relevant. For example, currently defined phases include PHASE_OBFUSCATE and PHASE_DYNAMIC_TRACE. Both phases require an input file that can be changed by the user. Therefore, there might be a property called &amp;quot;Input File&amp;quot; with phase PHASE_OBFUSCATE|PHASE_DYNAMIC_TRACE. A ConfigProperties object may have a parent. If so, a query for a property on the child ConfigProperties object will query the parent object for that property if the property is not found on the child. @author Andrew Huntwork &amp;lt;ash@cs.arizona.edu&amp;gt;">
			<comm cntt="sTypeClasses[0] is the class that every value of a property whose type is 0 (TYPE_FILE) must be assignable from."/>
			<comm cntt="Gets converted to ~0"/>
			<comm cntt="Gets converted to 0"/>
			<const name="TYPE_FILE" access="pub" jdoc="These constants indicate the types known to ConfigProperties. Any type that may be a value of a property must have a corresponding TYPE_ constant here."/>
			<const name="TYPE_JAR" access="pub" jdoc=""/>
			<const name="TYPE_PERCENT" access="pub" jdoc=""/>
			<const name="TYPE_INTEGER" access="pub" jdoc=""/>
			<const name="TYPE_RANDOM_INT" access="pub" jdoc=""/>
			<const name="TYPE_BOOLEAN" access="pub" jdoc=""/>
			<const name="TYPE_DOUBLE" access="pub" jdoc=""/>
			<const name="TYPE_STRING" access="pub" jdoc=""/>
			<const name="TYPE_METHOD" access="pub" jdoc=""/>
			<const name="TYPE_CLASS" access="pub" jdoc=""/>
			<field name="sTypeClasses" access="priv" jdoc=""/>
			<field name="sTypeDescs" access="priv" jdoc="These strings allow the types of properties to be specified in the String[] constructors to ConfigProperties. They appear in the same order as the TYPE_ constants to which they correspond. For example, &amp;quot;F&amp;quot; corresponds to TYPE_FILE because both are first in their lists."/>
			<field name="sTypeDescToVal" access="priv" jdoc=""/>
			<const name="PHASE_ALL" access="pub" jdoc=""/>
			<const name="PHASE_NONE" access="pub" jdoc=""/>
			<const name="PHASE_OBFUSCATE" access="pub" jdoc=""/>
			<const name="PHASE_DYNAMIC_TRACE" access="pub" jdoc=""/>
			<const name="PHASE_DYNAMIC_EMBED" access="pub" jdoc=""/>
			<const name="PHASE_DYNAMIC_RECOGNIZE" access="pub" jdoc=""/>
			<const name="PHASE_STATIC_EMBED" access="pub" jdoc=""/>
			<const name="PHASE_STATIC_RECOGNIZE" access="pub" jdoc=""/>
			<const name="PHASE_OPTIMIZE" access="pub" jdoc=""/>
			<const name="PHASE_STATIC_BIRTHMARK" access="pub" jdoc=""/>
			<const name="PHASE_DYNAMIC_BIRTHMARK" access="pub" jdoc=""/>
			<field name="sPhaseDescs" access="priv" jdoc="These strings allow the phases of properties to be specified in the String[] constructors to ConfigProperties. They appear in the same order as the PHASE_ constants to which they correspond."/>
			<field name="sPhaseDescToVal" access="priv" jdoc=""/>
			<field name="mPropSpecs" access="priv" jdoc=""/>
			<field name="mPropNameToIndex" access="priv" jdoc=""/>
			<field name="mParent" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.ConfigProperties.ConfigProperties(ConfigProperties)" access="pub" jdoc="">
				<param name="parent"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.ConfigProperties(String[][], ConfigProperties)" access="pub" jdoc="Constructs a ConfigProperties object with the indicated property names, types, values, descriptions, and phases (optional). See addProps for format details for args.">
				<param name="args"/>
				<param name="parent"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.addProps(String[][])" access="priv" jdoc="Adds properties to this ConfigProperites object based on the following format: arg[0] : property Name arg[1] : default property Value arg[2] : description arg[3] : ignored (backward compatibility) arg[4] : type. see sTypeDescs for possible values arg[5] : optional comma separated list of relevant phases. see sPhaseDescs for possible values">
				<comm cntt="This parses a possibly nicer format for specifying properties: &amp;quot;Type:Name=Default&amp;quot;,&amp;quot;Description&amp;quot; Someone else can rewrite the whole tree to get it into this format. I already did it once... if(args.length % 2 != 0) throw new ConfigPropertyException(); for(int i = 0 ; args != null &amp;&amp; i &amp;lt; args.length ; i+= 2) { String parts[] = args[i].split(&amp;quot;[:=]&amp;quot;); if(parts.length != 2 &amp;&amp; parts.length != 3) throw new ConfigPropertyException(); if(sTypeDescToVal.get(parts[0]) == null) throw new ConfigPropertyException(); mPropSpecs.add( new PropSpec(parts[1],args[i + 1], parts.length == 3 ? parts[2] : null, ((Integer)sTypeDescToVal.get(parts[0])).intValue())); mPropNameToIndex.put (args[1],new Integer(mPropSpecs.size() - 1)); }"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.properties()" access="pub" jdoc="@return An iterator containing String&amp;apos;s that are the names of properties in this ConfigProperties object and its ancestors">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.localProperties()" access="pub" jdoc="@return An iterator containing String&amp;apos;s that are the names of properties in this ConfigProperties object">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getPhases(String)" access="pub" jdoc="@return A bitmask with a bit set if this property is relevant to the the phase represented by that bit as described by the PHASE_ constants">
				<param name="property"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getType(String)" access="pub" jdoc="@return One of the TYPE_ constants indicating the type of this property">
				<param name="property"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getDescription(String)" access="pub" jdoc="@return A String description of this property">
				<param name="property"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getValue(String)" access="pub" jdoc="@return An Object whose concrete type is compatible with the type of this property. For example, if this property&amp;apos;s type is TYPE_BOOLEAN, Object is an instance of Boolean">
				<param name="property"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.setValue(String, Object)" access="pub" jdoc="">
				<param name="property"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getProperty(String)" access="pub" jdoc="@return getValue() converted to a string">
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getProperty(String, String)" access="pub" jdoc="">
				<param name="key"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.setProperty(String, String)" access="pub" jdoc="">
				<param name="key"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getPS(String)" access="prot" jdoc="">
				<param name="property"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getOrphanPS(String)" access="prot" jdoc="Returns the PropSpec for the given property, or null if the property does not exist. This method does not assume that the ConfigProp has a parent.">
				<param name="property"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.addPropertyChangeListener(String, ConfigPropertyChangeListener)" access="pub" jdoc="Adds an observer to a specific property. This listener will be notified when the specified property is set to a value not equal() to its previous value">
				<param name="property"/>
				<param name="listener"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.removePropertyChangeListener(String, ConfigPropertyChangeListener)" access="pub" jdoc="">
				<param name="property"/>
				<param name="listener"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.setChoices(String, boolean, java.util.List)" access="pub" jdoc="">
				<param name="property"/>
				<param name="exclusive"/>
				<param name="choices"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getExclusive(String)" access="pub" jdoc="">
				<param name="property"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties.getChoices(String)" access="pub" jdoc="">
				<param name="property"/>
			</mth>
		<class name="/:sandmark.util.ConfigProperties$PropSpec" intfc="n" abs="n" inn="y" sloc="110" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="description" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="value" access="pub" jdoc=""/>
			<field name="phases" access="pub" jdoc=""/>
			<field name="listeners" access="priv" jdoc=""/>
			<field name="exclusive" access="pub" jdoc=""/>
			<field name="choices" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.ConfigProperties$PropSpec.PropSpec(String, String, String, int, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="description"/>
				<param name="dflt"/>
				<param name="type"/>
				<param name="phases"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropSpec.setValue(String)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropSpec.setValue(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropSpec.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropSpec.addListener(ConfigPropertyChangeListener, ConfigProperties)" access="pub" jdoc="">
				<param name="listener"/>
				<param name="cp"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropSpec.removeListener(ConfigPropertyChangeListener, ConfigProperties)" access="pub" jdoc="">
				<param name="listener"/>
				<param name="cp"/>
			</mth>
		<class name="/:sandmark.util.ConfigProperties$PropSpec$Listener" intfc="n" abs="n" inn="y" sloc="17" jdoc="">
			<field name="configProps" access="pub" jdoc=""/>
			<field name="listener" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.ConfigProperties$PropSpec$Listener.Listener(ConfigProperties, ConfigPropertyChangeListener)" access="pub" jdoc="">
				<param name="cp"/>
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropSpec$Listener.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropSpec$Listener.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.ConfigProperties$LocalPropIter" intfc="n" abs="n" inn="y" sloc="15" jdoc="">
			<field name="psIter" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.ConfigProperties$LocalPropIter.LocalPropIter()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$LocalPropIter.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$LocalPropIter.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$LocalPropIter.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.ConfigProperties$PropIter" intfc="n" abs="n" inn="y" sloc="31" jdoc="">
			<field name="mCurrentIterator" access="pub" jdoc=""/>
			<field name="mIsParentIter" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.ConfigProperties$PropIter.PropIter()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropIter.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropIter.next()" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot; first : &amp;quot; + mIsParentIter + &amp;quot; ; class : &amp;quot; + o.getClass() + &amp;quot; ; value : &amp;quot; + o);"/>
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$PropIter.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.ConfigProperties$ConfigPropertyException" intfc="n" abs="n" inn="y" sloc="4" jdoc="">
			<mth name="/:sandmark.util.ConfigProperties$ConfigPropertyException.ConfigPropertyException()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.ConfigProperties$ConfigPropertyException.ConfigPropertyException(String)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.Publicizer" intfc="n" abs="n" inn="n" sloc="199" jdoc="">
			<comm cntt="Turn to true to print debugging messages."/>
			<comm cntt="Runs a quick test of this obfuscator."/>
			<comm cntt="Makes public the fields methods in this Application&amp;apos;s classes."/>
			<comm cntt="Returns the URL at which you can find information about this obfuscator."/>
			<comm cntt="Returns an HTML description of this obfuscator."/>
			<comm cntt="Returns a long description of this obfuscator&amp;apos;s name."/>
			<comm cntt="Returns a short description of this obfuscator&amp;apos;s name."/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.Publicizer.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.Publicizer.apply(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="publicize this class"/>
				<comm cntt="publicize all methods in this class"/>
				<comm cntt="publicize all fields in this class"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.util.Publicizer.publicizeMethod(sandmark.program.Method, sandmark.program.Class)" access="priv" jdoc="">
				<comm cntt="add in a fix in case of private superclass methods"/>
				<comm cntt="fix up all the method calls to this private method"/>
				<comm cntt="if this is a method call"/>
				<comm cntt="if this is the right method call"/>
				<param name="m"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.util.Publicizer.publicizeField(sandmark.program.Field, sandmark.program.Class)" access="priv" jdoc="">
				<comm cntt="check for remove ConstantValue attributes"/>
				<comm cntt="if no ConstantValue attributes, check for a FieldGen init value (same thing)"/>
				<comm cntt="if we found an init value and the field is nonstatic, put in the clinit assignment"/>
				<param name="f"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.util.Publicizer.isInJar(String, sandmark.program.Application)" access="priv" jdoc="">
				<param name="newname"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.util.Publicizer.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Publicizer.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Publicizer.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Publicizer.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Publicizer.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Publicizer.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Publicizer.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Publicizer.getAuthorEmail()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.MethodReceiver" intfc="n" abs="n" inn="n" sloc="64" jdoc="Given a method M in class C, MethodReceiver can be used to find all classes in C&amp;apos;s hierarchy on which M can be invoked i.e. all classes in C&amp;apos;s hierarchy which can receive message M. @author Srinivas Visvanathan">
			<comm cntt="returns a set containing the non-library base classes of cg. The method mg"/>
			<comm cntt="will be defined declared by one of these classes or their descendents."/>
			<comm cntt="This routine recursively goes up the inheritance tree from cg until it"/>
			<comm cntt="reaches classes interfaces whose superclasses interfaces are library"/>
			<comm cntt="classes (e.g. java.lang.Object)"/>
			<comm cntt="Given the set of base classes (bases), find the highest descendents that"/>
			<comm cntt="declare define mg. These classes and all their subclasses can receive the"/>
			<comm cntt="message mg"/>
			<mth name="/:sandmark.util.MethodReceiver.findMethodReceivers(sandmark.program.Method)" access="pub" jdoc="Given method mg, in some class cg, this routine finds all classes in cg&amp;apos;s hierarchy on which mg can be invoked. The set of classes returned all declare define mg or have a superclass interface that declars defins mg. It uses ClassHierarchy to look for the classes and hence is also limited to what ClassHierarchy offers. If mg is a library method, the routine returns null">
				<comm cntt="if mg overrides some library method, then return null, since there are classes outside this app which can receive the method call too and we can&amp;apos;t find those classes"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.MethodReceiver.findBaseClasses(sandmark.program.Class, sandmark.analysis.classhierarchy.ClassHierarchy)" access="priv" jdoc="">
				<comm cntt="indicates whether cg is a base class"/>
				<comm cntt="scan thru the parents of cg"/>
				<comm cntt="if par is not a library super class i.e. par is some super class in"/>
				<comm cntt="app, then cg is not a base class. Instead search thru par&amp;apos;s"/>
				<comm cntt="ancestors"/>
				<comm cntt="if cg has no pred or all its pred are java. classes, then its a base"/>
				<comm cntt="class"/>
				<param name="cg"/>
				<param name="ch"/>
			</mth>
			<mth name="/:sandmark.util.MethodReceiver.findReceiverClasses(java.util.Set, sandmark.program.Method, sandmark.analysis.classhierarchy.ClassHierarchy)" access="priv" jdoc="">
				<comm cntt="for each base class cg"/>
				<comm cntt="if cg declares defines mg"/>
				<comm cntt="cg and all its subclasses are potential receivers"/>
				<comm cntt="cg does not receive mg, but check its descendents"/>
				<param name="bases"/>
				<param name="mg"/>
				<param name="ch"/>
			</mth>
		</class>
		<class name="/:sandmark.util.Enum2Iter" intfc="n" abs="n" inn="n" sloc="17" jdoc="">
			<mth name="/:sandmark.util.Enum2Iter.Enum2Iter()" access="pub" jdoc="Convert a java.util.Enumeration to a java.util.Iterator.">
			</mth>
			<mth name="/:sandmark.util.Enum2Iter.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Enum2Iter.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.Enum2Iter.remove()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.classloading">
		<class name="/:sandmark.util.classloading.FileClassFinder" intfc="n" abs="n" inn="n" sloc="63" jdoc="Provides a list of classes, short descriptions of those classes, and which of the classes specified in sandmark.util.classloading.IClassFinder the classes derive from, based on the contents of Algorithms.txt, a text file found by a call to ClassLoader.getSystemClassLoader.getResource(&amp;quot;Algorithms.txt&amp;quot;) @see sandmark.util.classloading.IClassFinder @author Andrew Huntwork @version 1.0">
			<field name="initSucceeded" access="priv" jdoc=""/>
			<field name="sAlgNameToNdx" access="priv" jdoc=""/>
			<field name="sClassesByAncestor" access="priv" jdoc=""/>
			<field name="sClassShortNames" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.classloading.FileClassFinder.getClassesWithAncestor(int)" access="pub" jdoc="">
				<param name="algoType"/>
			</mth>
			<mth name="/:sandmark.util.classloading.FileClassFinder.getClassShortname(String)" access="pub" jdoc="">
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.util.classloading.FileClassFinder.loadClassList()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.classloading.FileClassFinder.FileClassFinder()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.classloading.ClassFinder" intfc="n" abs="n" inn="n" sloc="53" jdoc="Provides a unified interface for finding classes that extend certain interfaces. The class types that can be requested through the methods of this class are defined in sandmark.util.classloading.IClassFinder @see sandmark.util.classloading.IClassFinder @author Andrew Huntwork @version 1.0">
			<field name="debug" access="pub" jdoc=""/>
			<field name="sListGen" access="priv" jdoc=""/>
			<field name="sClassShortNames" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.classloading.ClassFinder.getClassesWithAncestor(int)" access="pub" jdoc="Get all the classes that sListGen knows about it that derive from the class indicated by &amp;apos;ancestor&amp;apos; @param ancestor one of the constants in IClassFinder @return Collection of String&amp;apos;s containing the names of classes derived from class specified by ancestor">
				<param name="ancestor"/>
			</mth>
			<mth name="/:sandmark.util.classloading.ClassFinder.getClassShortname(String)" access="pub" jdoc="Get a string suitable for display to the user that describes className @param className a String returned as a member of a Collection by getClassesWithAncestor @return A short String description of className">
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.util.classloading.ClassFinder.getClassByShortname(String)" access="pub" jdoc="">
				<param name="shortName"/>
			</mth>
		</class>
		<class name="/:sandmark.util.classloading.BuildClassList" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<mth name="/:sandmark.util.classloading.BuildClassList.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.classloading.DirClassFinder" intfc="n" abs="n" inn="n" sloc="96" jdoc="Provides a list of classes, short descriptions of those classes, and which of the classes specified in sandmark.util.classloading.IClassFinder the classes derive from, based on the contents of the directory specified in the system property &amp;quot;SMARK_ROOT&amp;quot; @see sandmark.util.classloading.IClassFinder @author Andrew Huntwork @version 1.0">
			<field name="sAncestorsByNumber" access="priv" jdoc=""/>
			<field name="sT" access="priv" jdoc=""/>
			<field name="didLoad" access="priv" jdoc=""/>
			<field name="sClassesByAncestor" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.classloading.DirClassFinder.getClassesWithAncestor(int)" access="pub" jdoc="">
				<param name="ancestor"/>
			</mth>
			<mth name="/:sandmark.util.classloading.DirClassFinder.getClassShortname(String)" access="pub" jdoc="">
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.util.classloading.DirClassFinder.DirClassFinder()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.classloading.DirClassFinder.loadClasses()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.classloading.DirClassFinder.findFiles(java.io.File, Class, java.util.Set, ClassLoader)" access="priv" jdoc="">
				<param name="dir"/>
				<param name="supers"/>
				<param name="subs"/>
				<param name="loader"/>
			</mth>
		</class>
		<class name="/:sandmark.util.classloading.IClassFinder" intfc="y" abs="n" inn="n" sloc="84" jdoc="An interface implemented by all classes suitable for use by sandmark.util.classloading.ClassFinder as sources of class names @see sandmark.util.classloading.ClassFinder @author Andrew Huntwork @version 1.0">
			<field name="ALGORITHM" access="pub" jdoc=""/>
			<field name="GEN_OBFUSCATOR" access="pub" jdoc=""/>
			<field name="APP_OBFUSCATOR" access="pub" jdoc=""/>
			<field name="METHOD_OBFUSCATOR" access="pub" jdoc=""/>
			<field name="CLASS_OBFUSCATOR" access="pub" jdoc=""/>
			<field name="DYN_WATERMARKER" access="pub" jdoc=""/>
			<field name="GEN_WATERMARKER" access="pub" jdoc=""/>
			<field name="STAT_WATERMARKER" access="pub" jdoc=""/>
			<field name="GRAPH_CODEC" access="pub" jdoc=""/>
			<field name="METHOD_ALGORITHM" access="pub" jdoc=""/>
			<field name="CLASS_ALGORITHM" access="pub" jdoc=""/>
			<field name="APP_ALGORITHM" access="pub" jdoc=""/>
			<field name="APP_METRIC" access="pub" jdoc=""/>
			<field name="METHOD_METRIC" access="pub" jdoc=""/>
			<field name="CLASS_METRIC" access="pub" jdoc=""/>
			<field name="PREDICATE_GENERATOR" access="pub" jdoc=""/>
			<field name="WRAPPER_CODEC" access="pub" jdoc=""/>
			<field name="GEN_OPTIMIZER" access="pub" jdoc=""/>
			<field name="APP_OPTIMIZER" access="pub" jdoc=""/>
			<field name="METHOD_OPTIMIZER" access="pub" jdoc=""/>
			<field name="CLASS_OPTIMIZER" access="pub" jdoc=""/>
			<field name="GEN_BIRTHMARK" access="pub" jdoc=""/>
			<field name="STAT_BIRTHMARK" access="pub" jdoc=""/>
			<field name="DYN_BIRTHMARK" access="pub" jdoc=""/>
			<field name="QUICK_PROTECT" access="pub" jdoc=""/>
			<field name="CLASS_COUNT" access="pub" jdoc=""/>
			<field name="CLASS_NAMES" access="pub" jdoc=""/>
			<field name="CLASS_IDS" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.classloading.IClassFinder.getClassesWithAncestor(int)" access="pub" jdoc="Get a Collection of String&amp;apos;s containing names of classes that derive from the type specified by ancestor. @param ancestor one of the constants above @return Collection of String&amp;apos;s containing names of classes derived from class specified by ancestor">
				<param name="ancestor"/>
			</mth>
			<mth name="/:sandmark.util.classloading.IClassFinder.getClassShortname(String)" access="pub" jdoc="Get a string suitable for display to the user that describes className @param className A String returned as a member of a Collection by getClassesWithAncestor @return A short String description of className">
				<param name="className"/>
			</mth>
		</class>
		<class name="/:sandmark.util.classloading.JarClassFinder" intfc="n" abs="n" inn="n" sloc="104" jdoc="Provides a list of classes, short descriptions of those classes, and which of the classes specified in sandmark.util.classloading.IClassFinder the classes derive from, based on the contents of the jar file specified by the system property &amp;quot;SMARK_PATH&amp;quot; @see sandmark.util.classloading.IClassFinder @author Andrew Huntwork @version 1.0">
			<field name="sJF" access="priv" jdoc=""/>
			<field name="sAncestorsByNumber" access="priv" jdoc=""/>
			<field name="sT" access="priv" jdoc=""/>
			<field name="sClassesByAncestor" access="priv" jdoc=""/>
			<field name="didLoad" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.classloading.JarClassFinder.JarClassFinder()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.classloading.JarClassFinder.loadClassFilesFromJar()" access="priv" jdoc="">
				<comm cntt="the name is too short or something, ignore it."/>
				<comm cntt="It&amp;apos;s not a class, just some random file. ignore it"/>
			</mth>
			<mth name="/:sandmark.util.classloading.JarClassFinder.getClassesWithAncestor(int)" access="pub" jdoc="">
				<param name="ancestor"/>
			</mth>
			<mth name="/:sandmark.util.classloading.JarClassFinder.getClassShortname(String)" access="pub" jdoc="">
				<param name="className"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.exec">
		<class name="/:sandmark.util.exec.MethodCallData" intfc="n" abs="n" inn="n" sloc="120" jdoc="The sandmark.util.exec.MethodCallData class contains information about a method call: which method was called, what it&amp;apos;s signature is, who called it, what thread it&amp;apos;s running in, etc. Public fields can be accessed directly but should be treated as read-only.">
			<comm cntt="This is the tricky part. We need to get a unique ID for each frame. To do this, we added some code to the beginning of each method, prior to tracing. void P() { long sm$stackID = sandmark.watermark.ct.trace.Annotator.stackFrameNumber++; ... } Now we look up the current value of sm$stackID in the current stack frame. For this to work the method has to have its LocalVariableTable intact. We will never be able to get a unique frame ID for system methods, but that&amp;apos;s OK. We&amp;apos;re just interested in building the call graph for methods in the user&amp;apos;s program."/>
			<comm cntt="Return a new stack-trace, with all incomplete frames removed. A frame is incomplete if we have no frameID for it. In effect, we&amp;apos;re removing all stack frames that belong to system classes as well as frames from sandmark.watermark.ct.trace.Annotator.MARK()."/>
			<field name="event" access="pub" jdoc=""/>
			<field name="method" access="pub" jdoc=""/>
			<field name="vm" access="pub" jdoc=""/>
			<field name="thread" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exec.MethodCallData.MethodCallData(com.sun.jdi.VirtualMachine, com.sun.jdi.event.LocatableEvent, com.sun.jdi.Method)" access="pub" jdoc="">
				<param name="vm"/>
				<param name="event"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getTypeName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getThreadName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getThreadID()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getObject()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getObjectID()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getCallersCaller()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getCaller()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getCallee()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getFrameID(com.sun.jdi.StackFrame)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;getFrameID:1=&amp;quot; + frame.toString());"/>
				<comm cntt="java.util.List locals = frame.visibleVariables();"/>
				<comm cntt="java.util.Iterator vars = locals.iterator();"/>
				<comm cntt="while (vars.hasNext()) {"/>
				<comm cntt="com.sun.jdi.LocalVariable L = (com.sun.jdi.LocalVariable)vars.next();"/>
				<comm cntt="System.out.println(&amp;quot;getFrameID:2:L=&amp;quot; + L.toString());"/>
				<comm cntt="}"/>
				<comm cntt="System.out.println(&amp;quot;getFrameID:6:frameID=&amp;quot; + frameID);"/>
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getCallData(int)" access="pub" jdoc="">
				<comm cntt="sourceName = location.sourceName();"/>
				<param name="frameNumber"/>
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.getCallStack()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.MethodCallData.deleteIncompleteStackFrames(sandmark.util.StackFrame[])" access="pub" jdoc="">
				<param name="stack"/>
			</mth>
		</class>
		<class name="/:sandmark.util.exec.Output" intfc="n" abs="n" inn="n" sloc="48" jdoc="">
			<field name="process" access="priv" jdoc=""/>
			<field name="outputCompleteCount" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.exec.Output.dumpStream(java.io.InputStream)" access="priv" jdoc="">
				<param name="stream"/>
			</mth>
			<mth name="/:sandmark.util.exec.Output.Output(java.lang.Process)" access="pub" jdoc="">
				<param name="process"/>
			</mth>
			<mth name="/:sandmark.util.exec.Output.displayRemoteOutput(java.io.InputStream)" access="priv" jdoc="Create a Thread that will retrieve and display any output. Needs to be high priority, else debugger may exit before it can be displayed.">
				<param name="stream"/>
			</mth>
			<mth name="/:sandmark.util.exec.Output.notifyOutputComplete()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Output.waitOutputComplete()" access="pub" jdoc="">
				<comm cntt="Wait for stderr and stdout"/>
			</mth>
		</class>
		<class name="/:sandmark.util.exec.HeapNode" intfc="n" abs="n" inn="n" sloc="13" jdoc="HeapNode.java -- @author Jasvir Nagra &amp;lt;jas@cs.auckland.ac.nz&amp;gt; Created On : Thu May 22 11:10:40 2003 Last Modified : &amp;lt;03 05 21 11:36:08 jas&amp;gt; Description : HeapNode Keywords : heap sandmark PURPOSE | Sandmark project |">
			<field name="data" access="prot" jdoc=""/>
			<mth name="/:sandmark.util.exec.HeapNode.HeapNode(sandmark.util.exec.HeapData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.exec.HeapNode.setData(sandmark.util.exec.HeapData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.exec.HeapNode.timestamp()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.exec.TracingException" intfc="n" abs="n" inn="n" sloc="8" jdoc="">
			<mth name="/:sandmark.util.exec.TracingException.TracingException()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.TracingException.TracingException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.exec.HeapData" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="uniqueID" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="refs" access="pub" jdoc=""/>
			<field name="timestamp" access="pub" jdoc=""/>
			<const name="NULL" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exec.HeapData.HeapData(String, long, String, long[], long)" access="pub" jdoc="">
				<param name="name"/>
				<param name="uniqueID"/>
				<param name="type"/>
				<param name="refs"/>
				<param name="timestamp"/>
			</mth>
			<mth name="/:sandmark.util.exec.HeapData.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.exec.DumpAll" intfc="n" abs="n" inn="n" sloc="74" jdoc="">
			<field name="allocCount" access="pub" jdoc=""/>
			<field name="writer" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exec.DumpAll.DumpAll(String[], String[], java.io.PrintWriter, String[])" access="pub" jdoc="">
				<param name="includeClasses"/>
				<param name="excludeClasses"/>
				<param name="writer"/>
				<param name="argv"/>
			</mth>
			<mth name="/:sandmark.util.exec.DumpAll.onMethodEntry(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.exec.DumpAll.onMethodExit(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.exec.DumpAll.onProgramExit(com.sun.jdi.VirtualMachine)" access="pub" jdoc="">
				<param name="vm"/>
			</mth>
			<mth name="/:sandmark.util.exec.DumpAll.methodEvent(String, sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="what"/>
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.exec.DumpAll.printLegend(java.io.PrintWriter)" access="pub" jdoc="">
				<param name="writer"/>
			</mth>
			<mth name="/:sandmark.util.exec.DumpAll.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.exec.EventHandler" intfc="n" abs="n" inn="n" sloc="12" jdoc="">
			<field name="excludeClasses" access="pub" jdoc=""/>
			<field name="includeClasses" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exec.EventHandler.EventHandler(String[], String[])" access="pub" jdoc="">
				<param name="includeClasses"/>
				<param name="excludeClasses"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventHandler.onMethodEntry(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventHandler.onMethodExit(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventHandler.onProgramExit(com.sun.jdi.VirtualMachine)" access="pub" jdoc="">
				<param name="vm"/>
			</mth>
		</class>
		<class name="/:sandmark.util.exec.Breakpoint" intfc="n" abs="y" inn="n" sloc="54" jdoc="">
			<comm cntt="Set one breakpoint at the beginning of method className.methodName."/>
			<comm cntt="Set breakpoints at the beginning of all methods methodName, whose type is signature, except those in excludeClasses."/>
			<comm cntt="Set breakpoints at the beginning of all methods methodName, except those in excludeClasses."/>
			<comm cntt="Set breakpoints at the beginning of all methods methodName, except those in the standard set of exclude classes."/>
			<const name="standardExclude" access="pub" jdoc=""/>
			<const name="noExclude" access="pub" jdoc=""/>
			<field name="className" access="pub" jdoc=""/>
			<field name="methodName" access="pub" jdoc=""/>
			<field name="signature" access="pub" jdoc=""/>
			<field name="excludeClasses" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exec.Breakpoint.Breakpoint(String, String)" access="pub" jdoc="">
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.util.exec.Breakpoint.Breakpoint(String, String, String)" access="pub" jdoc="">
				<param name="className"/>
				<param name="methodName"/>
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.util.exec.Breakpoint.Breakpoint(String, String, String[])" access="pub" jdoc="">
				<param name="methodName"/>
				<param name="signature"/>
				<param name="excludeClasses"/>
			</mth>
			<mth name="/:sandmark.util.exec.Breakpoint.Breakpoint(String, String[])" access="pub" jdoc="">
				<param name="methodName"/>
				<param name="excludeClasses"/>
			</mth>
			<mth name="/:sandmark.util.exec.Breakpoint.Breakpoint(String)" access="pub" jdoc="">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.util.exec.Breakpoint.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Breakpoint.Action(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
		</class>
		<class name="/:sandmark.util.exec.Overseer" intfc="n" abs="n" inn="n" sloc="106" jdoc="The sandmark.util.exec.Overseer class contains methods for running another program using the Java Debugger Interface (JDI). &amp;lt;P&amp;gt; To use this class you would typically extend it, and override one or more of the methods onMethodEntry, onMethodExit, and onProgramExit: &amp;lt;P&amp;gt; &amp;lt;PRE&amp;gt; public class MyOverseer extends sandmark.util.exec.Overseer { public MyOverseer( java.util.Properties props) { super(includeClasses,excludeClasses, constructArgv(props)); } public void onMethodEntry ( sandmark.util.exec.MethodCallData data) { } public void onMethodExit ( sandmark.util.exec.MethodCallData data) { } public void onProgramExit ( com.sun.jdi.VirtualMachine vm) { } } &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt; The methods &amp;apos;run&amp;apos; and &amp;apos;waitToComplete&amp;apos; are used to start the program and wait for it to exit: &amp;lt;PRE&amp;gt; MyOverseer O = new MyOverseer(includeClasses,excludeClasses,argv); O.run(); ... O.waitToComplete(); &amp;lt; PRE&amp;gt;">
			<field name="vm" access="prot" jdoc=""/>
			<field name="excludeClasses" access="prot" jdoc=""/>
			<field name="includeClasses" access="prot" jdoc=""/>
			<field name="breakPoints" access="prot" jdoc=""/>
			<field name="argv" access="pub" jdoc=""/>
			<field name="out" access="pub" jdoc=""/>
			<field name="eventThread" access="pub" jdoc=""/>
			<field name="mExited" access="priv" jdoc="Override this method if you want some action to take place when the program is exiting. @param vm A handle to the virtual machine running the program."/>
			<mth name="/:sandmark.util.exec.Overseer.Overseer(String[], String[], String[])" access="pub" jdoc="Prepare to run a program under JDI debugging. @param includeClasses Classes which should be traced. @param excludeClasses Classes which should not be traced. @param argv Command-line arguments to the program to be executed. &amp;lt;P&amp;gt; Note: Only one of includeClasses and excludeClasses can be non-empty!">
				<param name="includeClasses"/>
				<param name="excludeClasses"/>
				<param name="argv"/>
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.Overseer(String[])" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.registerBreakpoint(sandmark.util.exec.Breakpoint)" access="pub" jdoc="">
				<param name="bp"/>
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.onMethodEntry(sandmark.util.exec.MethodCallData)" access="prot" jdoc="Override this method if you want some action to take place when a method is called. @param data Information about which method was called, where it&amp;apos;s declared, who called it, etc.">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.onDisconnect()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.onMethodExit(sandmark.util.exec.MethodCallData)" access="prot" jdoc="Override this method if you want some action to take place when a method is exiting. @param data Information about which method is exiting, where it was declared from, who called it, etc.">
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.onExit()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.exited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.onProgramExit(com.sun.jdi.VirtualMachine)" access="prot" jdoc="">
				<param name="vm"/>
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.findConnector(String)" access="priv" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.createVM(String)" access="priv" jdoc="">
				<param name="argv"/>
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.startVM()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.waitToComplete()" access="pub" jdoc="Wait for the program to finish executing. Shutdown begins when event thread terminates">
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.run()" access="pub" jdoc="Start running the program.">
			</mth>
			<mth name="/:sandmark.util.exec.Overseer.STOP()" access="pub" jdoc="Stop the running program.">
			</mth>
		</class>
		<class name="/:sandmark.util.exec.Heap" intfc="n" abs="n" inn="n" sloc="247" jdoc="">
			<comm cntt="----------------------------------------------------------"/>
			<comm cntt="----------------------------------------------------------"/>
			<comm cntt="----------------------------------------------------------"/>
			<comm cntt="May have to change fields() to allFields() once we"/>
			<comm cntt="allow Watermark.java to extend a preexisting class."/>
			<comm cntt="----------------------------------------------------------"/>
			<comm cntt="----------------------------------------------------------"/>
			<comm cntt="----------------------------------------------------------"/>
			<field name="seen" access="pub" jdoc=""/>
			<field name="queue" access="pub" jdoc=""/>
			<field name="objects" access="pub" jdoc=""/>
			<field name="nextObject" access="pub" jdoc=""/>
			<field name="vm" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exec.Heap.Heap(com.sun.jdi.VirtualMachine)" access="pub" jdoc="">
				<param name="vm"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.Heap(com.sun.jdi.VirtualMachine, com.sun.jdi.ObjectReference)" access="pub" jdoc="">
				<param name="vm"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.Heap(com.sun.jdi.VirtualMachine, java.util.List)" access="pub" jdoc="">
				<param name="vm"/>
				<param name="roots"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.size()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Heap.get()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Heap.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Heap.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Heap.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Heap.dumpRoots()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Heap.dumpClasses()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Heap.dumpStaticFields(com.sun.jdi.ReferenceType)" access="pub" jdoc="">
				<param name="Class"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.dumpThreads()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.Heap.dumpThread(com.sun.jdi.ThreadReference)" access="pub" jdoc="">
				<comm cntt="e.printStackTrace();"/>
				<param name="thread"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.dumpFrame(com.sun.jdi.StackFrame)" access="pub" jdoc="">
				<comm cntt="System.out.println( &amp;quot; &amp;quot; + frame.location().method() );"/>
				<comm cntt="e.printStackTrace();"/>
				<param name="frame"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.dumpLocal(com.sun.jdi.StackFrame, com.sun.jdi.LocalVariable)" access="pub" jdoc="">
				<comm cntt="e.printStackTrace();"/>
				<param name="frame"/>
				<param name="var"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.outgoingRefs(com.sun.jdi.Value)" access="pub" jdoc="">
				<comm cntt="System.out.println( &amp;quot;Outgoing refs:&amp;quot; + newRefs );"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.outgoingRefsObject(com.sun.jdi.ObjectReference)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &amp;quot; + refType.name() + &amp;quot; : &amp;quot; + object.uniqueID());"/>
				<comm cntt="System.out.print(&amp;quot; &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &amp;quot; + name);"/>
				<comm cntt="System.out.println(&amp;quot; == null&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;(&amp;quot; + ID + &amp;quot;) = &amp;quot; + val);"/>
				<comm cntt="System.out.println( &amp;quot;Outgoing objectrefs:&amp;quot; + newRefs );"/>
				<param name="object"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.outgoingRefsArray(com.sun.jdi.ArrayReference)" access="pub" jdoc="">
				<comm cntt="System.out.println( &amp;quot;Outgoing arrayrefs:&amp;quot; + newRefs );"/>
				<param name="array"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.processVar(String, com.sun.jdi.Type, com.sun.jdi.Value)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Refs size:&amp;quot; + newRefs.size() );"/>
				<param name="name"/>
				<param name="type"/>
				<param name="ref"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.saveVar(String, com.sun.jdi.Type, com.sun.jdi.Value, java.util.LinkedList)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="value"/>
				<param name="refs"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.excludeType(com.sun.jdi.Type)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.excludeStandardClass(String)" access="pub" jdoc="">
				<param name="sig"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.print(com.sun.jdi.VirtualMachine, com.sun.jdi.ObjectReference)" access="pub" jdoc="">
				<param name="vm"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.print(com.sun.jdi.VirtualMachine)" access="pub" jdoc="">
				<param name="vm"/>
			</mth>
			<mth name="/:sandmark.util.exec.Heap.print(com.sun.jdi.VirtualMachine, java.util.List)" access="pub" jdoc="">
				<param name="vm"/>
				<param name="roots"/>
			</mth>
		</class>
		<class name="/:sandmark.util.exec.EventThread" intfc="n" abs="n" inn="n" sloc="192" jdoc="">
			<comm cntt="Running VM"/>
			<comm cntt="Connected to VM"/>
			<comm cntt="-----------------------------------------------------------------------"/>
			<comm cntt="When a breakpoint event is generated we run through our list of breakpoint handlers and invoke the ones that pertain to this breakpoint."/>
			<comm cntt="-----------------------------------------------------------------------"/>
			<comm cntt="When a class is finally loaded, we can see if there are any pending requests to set breakpoints in this class. If so, we do it. We also keep track of the breakpoints we&amp;apos;ve set so we can perform the requested actions when a breakpoint is hit."/>
			<comm cntt="-----------------------------------------------------------------------"/>
			<comm cntt="Register breakpoints which should be set as soon as possible. However, a breakpoint can&amp;apos;t be set until the corresponding class has been loaded. So, we have to request an event when the class is loaded, and wait to set the breakpoint until then."/>
			<comm cntt="-----------------------------------------------------------------------"/>
			<comm cntt="When a class is loaded we check to see if there are any pending requests to set breakpoints in this class. If so, we do it."/>
			<comm cntt="-----------------------------------------------------------------------"/>
			<comm cntt="Detect exiting program"/>
			<comm cntt="-----------------------------------------------------------------------"/>
			<comm cntt="In JDI 1.3 there is no simple way to detect that the debugee is exiting. So, we do it the hard way: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; put a breakpoint on java.lang.Runtime.exit(), &amp;lt;li&amp;gt; when a thread dies we check if all other threads are daemon threads. &amp;lt; ul&amp;gt; This doesn&amp;apos;t work well. If jdk1.4 is available we use the new VMDeathRequest, if we can."/>
			<comm cntt="This method is called whenever a thread dies. If, at this point, all threads are daemon threads, we can conclude that the program is about to exit. We call onExit()."/>
			<comm cntt="Return a handle to the method className.methodName. Can be used to call this method using &amp;apos;invokeMethod&amp;apos;. This method assumes there is no overloading: there&amp;apos;s only one class named className and only one method in this class named methodName."/>
			<comm cntt="Return true if a thread is a daemon thread."/>
			<comm cntt="We set a breakpoint on java.lang.Runtime.exit(). If it is called we can conclude that the program is about to exit. We call onExit()."/>
			<const name="vm" access="priv" jdoc=""/>
			<const name="handler" access="priv" jdoc=""/>
			<field name="breakpointRequestList" access="priv" jdoc=""/>
			<field name="breakpointTable" access="priv" jdoc=""/>
			<field name="connected" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.exec.EventThread.EventThread(com.sun.jdi.VirtualMachine, sandmark.util.exec.Overseer, java.util.List)" access="pub" jdoc="">
				<param name="vm"/>
				<param name="handler"/>
				<param name="breakpointRequests"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.run()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.STOP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.handleEvent(com.sun.jdi.event.Event)" access="priv" jdoc="">
				<comm cntt="do nothing"/>
				<comm cntt="throw new Error(&amp;quot;Unexpected event type&amp;quot;);"/>
				<param name="event"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.onExit()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.breakpointEvent(com.sun.jdi.event.BreakpointEvent)" access="pub" jdoc="">
				<param name="event"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.methodExitEvent(com.sun.jdi.event.MethodExitEvent)" access="pub" jdoc="">
				<comm cntt="String methodName = method.name();"/>
				<comm cntt="if (methodName.equals(&amp;quot;main&amp;quot;)) This is wrong."/>
				<comm cntt="onExit();"/>
				<param name="event"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.disconnectEvent()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.methodEntryEvent(com.sun.jdi.event.MethodEntryEvent)" access="pub" jdoc="">
				<param name="event"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.setBreakpoint(com.sun.jdi.ReferenceType, sandmark.util.exec.Breakpoint)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="bp"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.registerBreakpoint(sandmark.util.exec.Breakpoint)" access="pub" jdoc="">
				<param name="bp"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.registerBreakpoints(java.util.List)" access="pub" jdoc="">
				<param name="bpl"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.classPrepareEvent(com.sun.jdi.event.ClassPrepareEvent)" access="pub" jdoc="">
				<param name="event"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.initExitDetector()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.oldInitExitDetector()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.detectProgramExit(com.sun.jdi.ThreadReference)" access="pub" jdoc="">
				<param name="dyingThread"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.lookupMethod(String, String)" access="pub" jdoc="">
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread.threadIsDaemon(com.sun.jdi.ThreadReference)" access="pub" jdoc="">
				<param name="thread"/>
			</mth>
		<class name="/:sandmark.util.exec.EventThread$BreakpointEvent" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="breakpoint" access="pub" jdoc=""/>
			<field name="request" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exec.EventThread$BreakpointEvent.BreakpointEvent(sandmark.util.exec.Breakpoint, com.sun.jdi.request.BreakpointRequest)" access="pub" jdoc="">
				<param name="breakpoint"/>
				<param name="request"/>
			</mth>
		</class>
		<class name="/:sandmark.util.exec.EventThread$ExitBreakpoint" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<mth name="/:sandmark.util.exec.EventThread$ExitBreakpoint.ExitBreakpoint(String)" access="pub" jdoc="">
				<param name="exitclass"/>
			</mth>
			<mth name="/:sandmark.util.exec.EventThread$ExitBreakpoint.Action(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.exprtree">
		<class name="/:sandmark.util.exprtree.NodeInfo" intfc="n" abs="n" inn="n" sloc="59" jdoc="This class is used to get the information associated with each node in the expression tree. @author Kamlesh Kantilal (kamlesh@cs.arizona.edu)">
			<field name="ih" access="pub" jdoc=""/>
			<field name="cn" access="pub" jdoc=""/>
			<field name="gr" access="pub" jdoc=""/>
			<field name="outsideBlock" access="pub" jdoc=""/>
			<field name="mark" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exprtree.NodeInfo.NodeInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.setIH(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="ihandle"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.getIH()" access="pub" jdoc="Returns the instruction handle associated with this node in the expression tree If a node is outside the basic block it is set to null">
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.setGraph(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="grh"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.getGraph()" access="pub" jdoc="Returns the graph associated with this node in the expression tree">
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.setContext(sandmark.analysis.stacksimulator.Context)" access="pub" jdoc="">
				<param name="context"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.getContext()" access="pub" jdoc="Returns the context provided by stack simulator for the instruction associated with this node in the expression tree">
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.setOutsideBlock()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.isOutsideBlock()" access="pub" jdoc="Returns whether this node is associated with an instruction outside the basic block">
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.isMarked()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.setMark()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.NodeInfo.clearMark()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.exprtree.DependencyGraph" intfc="n" abs="n" inn="n" sloc="355" jdoc="">
			<comm cntt=""/>
			<comm cntt="public void writeback (sandmark.analysis.controlflowgraph.MethodCFG reorderGraph, java.util.HashMap NToG, org.apache.bcel.generic.InstructionHandle lastih) { java.util.ArrayList parse; java.util.ArrayList ilist; sandmark.analysis.controlflowgraph.MethodCFG myGr=null; sandmark.analysis.controlflowgraph.BasicBlock myGn=null; sandmark.analysis.controlflowgraph.MethodCFG tempGr; org.apache.bcel.generic.InstructionHandle ih1; org.apache.bcel.generic.InstructionHandle ih2; org.apache.bcel.generic.InstructionList myList; org.apache.bcel.generic.InstructionHandle myIh[]; int j; java.util.HashMap NToM=new java.util.HashMap(); for(int i=0;i&amp;lt;reorderGraph.nodes().size();i++) { NToM.put(reorderGraph.nodes().get(i),new Boolean(false)); } while(true) { parse=getTopological(reorderGraph,NToM); if(parse.size()==0) break; for(int i=0;i&amp;lt;parse.size();i++) { myGn=(sandmark.analysis.controlflowgraph.BasicBlock)parse.get(i); myGr=(sandmark.analysis.controlflowgraph.MethodCFG) NToG.get(parse.get(i)); ilist=et.getInstList(myGr); ih1=(org.apache.bcel.generic.InstructionHandle)ilist.get(0); for(j=0;j&amp;lt;parse.size();j++) { tempGr=(sandmark.analysis.controlflowgraph.MethodCFG) NToG.get(parse.get(j)); ilist=et.getInstList(tempGr); ih2=(org.apache.bcel.generic.InstructionHandle)ilist.get(0); if(ih1.getPosition()&amp;lt;ih2.getPosition()) break; } if(j==parse.size()) break; } NToM.put(myGn,new Boolean(true)); same myIh=il.getInstructionHandles(); ilist=et.getInstList(myGr); ih1=(org.apache.bcel.generic.InstructionHandle)ilist.get(0); ih2=(org.apache.bcel.generic.InstructionHandle)ilist.get(ilist.size()-1); System.out.println(&amp;quot;lastih &amp;quot;+lastih); if(lastih==null) { if(ih1==myIh[0]) { lastih=ih2; continue; } } if(lastih!=null &amp;&amp; lastih.getNext()==ih1) { lastih=ih2; continue; } if(lastih!=null) {il.redirectBranches(lastih.getNext(),ih1) ; } else {il.redirectBranches(myIh[0],ih1); } il.move(ih1,ih2,lastih); lastih=ih2; il.setPositions(true); il.update(); } } public java.util.ArrayList getTopological( sandmark.analysis.controlflowgraph.MethodCFG reorderGraph, java.util.HashMap NToM) { int j; java.util.ArrayList retlist= new java.util.ArrayList(); java.util.List succlist; sandmark.analysis.controlflowgraph.BasicBlock myGn; for(int i=0;i&amp;lt;reorderGraph.nodes().size();i++) { myGn=(sandmark.analysis.controlflowgraph.BasicBlock)reorderGraph.nodes().get(i); if( ((Boolean)NToM.get(myGn)).booleanValue()==true) continue; succlist=myGn.getSuccessors(); for(j=0;j&amp;lt;succlist.size();j++) if( ((Boolean)NToM.get(succlist.get(j))).booleanValue()==false) break; if(j==succlist.size()) retlist.add(myGn); } return retlist; }"/>
			<field name="myCpg" access="pub" jdoc=""/>
			<field name="cfg" access="pub" jdoc=""/>
			<field name="et" access="pub" jdoc=""/>
			<field name="il" access="pub" jdoc=""/>
			<field name="ih" access="pub" jdoc=""/>
			<field name="exceptions" access="pub" jdoc=""/>
			<field name="ihandle" access="pub" jdoc=""/>
			<field name="BToG" access="pub" jdoc=""/>
			<field name="NToG" access="pub" jdoc=""/>
			<field name="GToN" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.DependencyGraph(sandmark.program.Method, org.apache.bcel.generic.ConstantPoolGen, sandmark.analysis.controlflowgraph.MethodCFG)" access="pub" jdoc="">
				<comm cntt="dependency Graph for each block"/>
				<comm cntt="System.out.println(et);"/>
				<comm cntt="System.out.println(et);"/>
				<comm cntt="createlist();"/>
				<param name="method"/>
				<param name="c"/>
				<param name="mycfg"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getDependencyGraph(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="tempblock"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getExpressionTree(sandmark.util.exprtree.Node)" access="pub" jdoc="">
				<param name="tempgn"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.getExpressionTree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.doMethod(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="java.util.ArrayList reorderlist;"/>
				<comm cntt="for(int j=0; j&amp;lt;myIh2.length; j++) System.out.println(&amp;quot;writingin in=&amp;quot;+myIh2[j]);"/>
				<comm cntt="System.out.println(et.toString(curr));"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.issubnull(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="myGr"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.adddependence(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.exprtree.Node, java.util.HashMap, java.util.HashMap, boolean, int)" access="pub" jdoc="">
				<comm cntt="lastGn=myGn;"/>
				<comm cntt="newly added"/>
				<param name="reorderGraph"/>
				<param name="myGr"/>
				<param name="lastGn"/>
				<param name="NToG"/>
				<param name="GToN"/>
				<param name="last"/>
				<param name="debug"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.callfunc(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="tempGr"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.refoutside(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="tempGr"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.dependence(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<comm cntt="optimization new code"/>
				<comm cntt="end optimization new code"/>
				<comm cntt="ch"/>
				<comm cntt="ch"/>
				<comm cntt="check if needed ?"/>
				<comm cntt="if(in1 instanceof org.apache.bcel.generic.LSTORE || in1 instanceof org.apache.bcel.generic.DSTORE || in2 instanceof org.apache.bcel.generic.LSTORE || in2 instanceof org.apache.bcel.generic.DSTORE || in1 instanceof org.apache.bcel.generic.LLOAD || in1 instanceof org.apache.bcel.generic.DLOAD || in2 instanceof org.apache.bcel.generic.LLOAD || in2 instanceof org.apache.bcel.generic.DLOAD ) { System.out.println(&amp;quot;args LONG&amp;quot;); if( ((org.apache.bcel.generic.LocalVariableInstruction)in1).getIndex() != ((org.apache.bcel.generic.LocalVariableInstruction)in2).getIndex()) if( ((org.apache.bcel.generic.LocalVariableInstruction)in1).getIndex()+1 != ((org.apache.bcel.generic.LocalVariableInstruction)in2).getIndex()) if( ((org.apache.bcel.generic.LocalVariableInstruction)in1).getIndex()-1 != ((org.apache.bcel.generic.LocalVariableInstruction)in2).getIndex()) continue; } else"/>
				<comm cntt="System.out.println(&amp;quot;Dep=&amp;quot;+in1+&amp;quot; &amp; &amp;quot; + in2);"/>
				<comm cntt="System.out.println(&amp;quot;Dep=&amp;quot;+in1+&amp;quot; &amp; &amp;quot; + in2);"/>
				<param name="tempGr"/>
				<param name="myGr"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.isequallist(java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="i2"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.DependencyGraph.validity()" access="pub" jdoc="">
				<comm cntt="String S=&amp;quot;START of Method&amp;quot;;"/>
				<comm cntt="for(int l=0;l&amp;lt;i2.size();l++) { System.out.println( &amp;quot;u=&amp;quot;+(org.apache.bcel.generic.InstructionHandle)i1.get(l)); } for(int l=0;l&amp;lt;i2.size();l++) { System.out.println(&amp;quot;m=&amp;quot;+(org.apache.bcel.generic.InstructionHandle)i2.get(l)); }"/>
			</mth>
		<class name="/:sandmark.util.exprtree.DependencyGraph$BlockComparator" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<mth name="/:sandmark.util.exprtree.DependencyGraph$BlockComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.exprtree.Node" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<field name="mg" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exprtree.Node.Node()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.exprtree.Node.setGraph(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="gr"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.Node.graph()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.exprtree.ExprTree" intfc="n" abs="n" inn="n" sloc="593" jdoc="ExprTree is a utility that creates expression tree for all blocks in the controlflowgraph. It creates expression tree by adding edges between the instruction that consumes elements from the stack and the instructions which produce those element on the stack. @author Kamlesh Kantilal (kamlesh@cs.arizona.edu)">
			<comm cntt="public String toString() { String S=&amp;quot;START of Method&amp;quot;; sandmark.analysis.controlflowgraph.MethodCFG myGr; java.util.ArrayList Grlist; for(int j=0; j&amp;lt;cfg.nodes().size(); j++) { Grlist=(java.util.ArrayList) BToL.get(cfg.nodes().get(j)); for(int k=0;k&amp;lt;Grlist.size();k++) { myGr=(sandmark.analysis.controlflowgraph.MethodCFG)Grlist.get(k); for(int i=0;i&amp;lt;getRootNodes(myGr).size();i++) { S+=doPrintPostOrder((sandmark.util.exprtree.Node) getRootNodes(myGr).get(i),0,2); } S+=&amp;quot;\nEnd Tree\n&amp;quot;; } S+=&amp;quot;---------End of BLk---------\n&amp;quot;; } return S; }"/>
			<comm cntt="It returns the node associated with an instruction"/>
			<comm cntt="It returns the instruction associated with a node"/>
			<field name="myCpg" access="pub" jdoc=""/>
			<field name="cfg" access="pub" jdoc=""/>
			<field name="il" access="pub" jdoc=""/>
			<field name="ih" access="pub" jdoc=""/>
			<field name="curr" access="pub" jdoc=""/>
			<field name="block" access="pub" jdoc=""/>
			<field name="IToN" access="pub" jdoc=""/>
			<field name="NToI" access="pub" jdoc=""/>
			<field name="NToInfo" access="pub" jdoc=""/>
			<field name="BToG" access="pub" jdoc=""/>
			<field name="BToL" access="pub" jdoc=""/>
			<field name="st" access="pub" jdoc=""/>
			<field name="ihandle" access="pub" jdoc=""/>
			<field name="gn" access="pub" jdoc=""/>
			<field name="cn" access="pub" jdoc=""/>
			<field name="gr" access="pub" jdoc=""/>
			<field name="ilist" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exprtree.ExprTree.ExprTree(sandmark.program.Method, org.apache.bcel.generic.ConstantPoolGen, sandmark.analysis.controlflowgraph.MethodCFG)" access="pub" jdoc="Constructs an expression tree for a method represented by some method control flow graph. @param method - the method to analyze @param c - the ConstantPoolGen created from the class that this method is in @param mycfg - the controlflowgraph of that method">
				<param name="method"/>
				<param name="c"/>
				<param name="mycfg"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.initialize()" access="priv" jdoc="">
				<comm cntt="converts a single forest into multiple graph"/>
				<comm cntt="Fills in BToL"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.add(int)" access="priv" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.doBlock()" access="priv" jdoc="">
				<comm cntt="if(block.getIH()==null) return;"/>
				<comm cntt="context.pop();"/>
				<comm cntt="context.pop();"/>
				<comm cntt="do nothing"/>
				<comm cntt="context.pop();"/>
				<comm cntt="context.pop(); remove object ref"/>
				<comm cntt="no break here on purpose!"/>
				<comm cntt="context.pop(); value for put"/>
				<comm cntt="context.pop(); object ref"/>
				<comm cntt="no break here on purpose!"/>
				<comm cntt="context.pop(); extra for object ref"/>
				<comm cntt="no break here on purpose"/>
				<comm cntt="pop the arguments"/>
				<comm cntt="DO NOTHING"/>
				<comm cntt="DO NOTHING"/>
				<comm cntt="END of FOR"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.doStack(org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<comm cntt="new code"/>
				<comm cntt="new code"/>
				<param name="instH"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.doArithmetic(org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<comm cntt="if(((org.apache.bcel.generic.StackConsumer)inst).consumeStack (myCpg) == 1){ add(1); } else{ add(2); }"/>
				<comm cntt="added newly"/>
				<param name="instH"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.doArray(org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.display()" access="pub" jdoc="">
				<comm cntt="java.util.List succ = block.getSuccessors();"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.toString()" access="pub" jdoc="Returns the String representation of the expression tree of all the blocks in the CFG.">
				<comm cntt="display();"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.doPrintPostOrder(sandmark.util.exprtree.Node, int, int)" access="priv" jdoc="">
				<param name="myGn"/>
				<param name="level"/>
				<param name="up"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.toString(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="Returns the String representation of a particular expression tree. @param myGr a graph representing the expression tree">
				<param name="myGr"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.toString(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="Returns the String representation of all expression trees within a block. @param bblock a basic block whose representation is needed">
				<param name="bblock"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.getInstList(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="Returns the instruction handle list(list of &amp;quot;org.apache.bcel.generic.InstructionHandle&amp;quot; ) associated with a particular expression tree. @param dg a graph representing the expression tree">
				<param name="dg"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.getRootNodes(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="dg"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.generateGraph(java.util.ArrayList)" access="priv" jdoc="">
				<comm cntt="sort based on position"/>
				<comm cntt="TO add Edges to the new set of graph"/>
				<param name="newmygrlist"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.blockToGrlist(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="Returns a list of sandmark.util.newgraph.MutableGraph representing the expression trees associated with a basicblock @param block a basicblock whose expression tree list is needed">
				<comm cntt="check for il==null"/>
				<param name="block"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.nodeToInfo(sandmark.util.exprtree.Node)" access="pub" jdoc="Returns the sandmark.util.Exprtree.NodeInfo associated with a sandmark.util.exprtree.Node . @param tempgn a node in the expression tree whose corresponding information is desired">
				<param name="tempgn"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.iToNode(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree.nodeToI(sandmark.util.exprtree.Node)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
		<class name="/:sandmark.util.exprtree.ExprTree$NodeComparator" intfc="n" abs="n" inn="y" sloc="22" jdoc="">
			<field name="NToInfo" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exprtree.ExprTree$NodeComparator.NodeComparator(java.util.HashMap)" access="pub" jdoc="">
				<param name="tt"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree$NodeComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.util.exprtree.ExprTree$GraphComparator" intfc="n" abs="n" inn="y" sloc="36" jdoc="">
			<field name="nc" access="pub" jdoc=""/>
			<field name="NToInfo" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.exprtree.ExprTree$GraphComparator.GraphComparator(java.util.HashMap)" access="pub" jdoc="">
				<param name="tt"/>
			</mth>
			<mth name="/:sandmark.util.exprtree.ExprTree$GraphComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="gr1"/>
				<param name="gr2"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.graph.graphview">
		<class name="/:sandmark.util.graph.graphview.GraphLayout" intfc="n" abs="y" inn="n" sloc="139" jdoc="Abstract class representing a general layout for a graph. @author Andrzej">
			<comm cntt="types of layout"/>
			<field name="graph" access="prot" jdoc=""/>
			<field name="graphStyle" access="prot" jdoc=""/>
			<field name="nodeMap" access="prot" jdoc=""/>
			<field name="edgeMap" access="prot" jdoc=""/>
			<const name="TREE_LAYOUT" access="pub" jdoc="Layout for tree graphs."/>
			<const name="HIERARCHY_TREE_LAYOUT" access="pub" jdoc="Similar to tree layout, but for class inheritance hierarchy."/>
			<const name="SIMPLE_GRAPH_LAYOUT" access="pub" jdoc="Random layout."/>
			<const name="SPRING_EMBEDDER_LAYOUT" access="pub" jdoc="Layout that uses a force directed algorithm."/>
			<const name="LAYERED_DRAWING_LAYOUT" access="pub" jdoc="Layout that draws the graph in layers."/>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.GraphLayout(sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style)" access="pub" jdoc="Creates a new GraphLayout. Lays out the graph if it can be laid out using this algorithm. @param g graph to layout @param style style of the graph">
				<comm cntt="resizeGraph(0.5);"/>
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.layout()" access="pub" jdoc="Assigns positions to the nodes, so they could be drawn on the screen.">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.canLayout()" access="pub" jdoc="Returns whether this graph can be laid out using this algorithm. @return true if this algorithm can lay out the graph, false otherwise">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.getNodeMap(java.lang.Object)" access="pub" jdoc="Returns the display information for the particular node. @param node node of the graph @return information how to display the node">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.getEdgeMap(sandmark.util.newgraph.Edge)" access="pub" jdoc="Returns the display information for the particular edge. @param edge edge of the graph @return information how to display the edge">
				<param name="edge"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.assignEdgeInformation()" access="pub" jdoc="Creates display information for each edge.">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.getMaximumX()" access="pub" jdoc="Returns the maximum x coordinate of a node in the graph. @return max x coordinate of a node in the graph">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.getMaximumY()" access="pub" jdoc="Returns the maximum y coordinate of a node in the graph. @return max y coordinate of a node in the graph">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.getMinimumX()" access="pub" jdoc="Returns the minimum x coordinate of a node in the graph. @return min x coordinate of a node in the graph">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.getMinimumY()" access="pub" jdoc="Returns the minimum y coordinate of a node in the graph. @return min y coordinate of a node in the graph">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.placeGraphAt(int, int)" access="pub" jdoc="Moves the whole graph to the given minimum x and y coordinates. @param x minimum x coordinate @param y minimum y coordinate">
				<param name="x"/>
				<param name="y"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.resizeGraph(double)" access="pub" jdoc="">
				<param name="factor"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.nodeIterator()" access="pub" jdoc="Returns an iterator over the display information of each node in the graph. @return iterator over the display info of each node in the graph">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphLayout.edgeIterator()" access="pub" jdoc="Returns an iterator over the display information of each edge in the graph. @return iterator over the display info of each edge in the graph">
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.DummyNode" intfc="n" abs="n" inn="n" sloc="4" jdoc="Dummy Node used for {@link LayeredDrawingLayout} type of layout.">
			<mth name="/:sandmark.util.graph.graphview.DummyNode.DummyNode()" access="pub" jdoc="Constructs a new DummyNode.">
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.CreateGraph" intfc="n" abs="n" inn="n" sloc="186" jdoc="">
			<mth name="/:sandmark.util.graph.graphview.CreateGraph.main(String[])" access="pub" jdoc="">
				<comm cntt="GraphList list = new GraphList();"/>
				<comm cntt="sandmark.util.newgraph.Graph g = createTree();"/>
				<comm cntt="sandmark.util.newgraph.Graph g = createSelfMultiGraph();"/>
				<comm cntt="sandmark.util.newgraph.Graphs.dotInFile(g, gstyle, &amp;quot;testgraph.dot&amp;quot;);"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.CreateGraph.createSelfMultiGraph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.CreateGraph.createCycleGraph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.CreateGraph.createMultiGraph()" access="pub" jdoc="">
				<comm cntt="g = g.addEdge(n1, n2); .addEdge(n1, n2);"/>
				<comm cntt="g = g.addEdge(n1, n2).addEdge(n1, n2);"/>
				<comm cntt="g = g.addEdge(n1, n2).addEdge(n1, n2);"/>
				<comm cntt="g = g.addEdge(n1, n2).addEdge(n1, n2);"/>
				<comm cntt="g = g.addEdge(n1, n2).addEdge(n1, n2);"/>
				<comm cntt="g = g.addEdge(n1, n2).addEdge(n1, n2);"/>
				<comm cntt="g = g.addEdge(n1, n2).addEdge(n1, n2);"/>
				<comm cntt="g = g.addEdge(n1, n3);"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.CreateGraph.createCrossGraph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.CreateGraph.createTestGraph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.CreateGraph.createTree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.CreateGraph.createGraph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.CreateGraph.createSimpleGraph()" access="pub" jdoc="">
				<comm cntt="n3 = new java.lang.Integer(3);"/>
				<comm cntt="g = g.addEdge(n1, n1).addEdge(n1, n1);"/>
				<comm cntt="g = g.addEdge(n2, n2).addEdge(n2, n2);"/>
				<comm cntt="java.lang.Integer n1 = new java.lang.Integer(1), n2 = new java.lang.Integer(2), n3 = new java.lang.Integer(3), n4 = new java.lang.Integer(4), n5 = new java.lang.Integer(5), n6 = new java.lang.Integer(6); g = g.addEdge(n1, n2).addEdge(n2, n3).addEdge(n3, n1); g = g.addEdge(n4, n5).addEdge(n5, n4); .addEdge(n6, n4); g = g.addEdge(n6, n6);"/>
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.SimpleGraphLayout" intfc="n" abs="n" inn="n" sloc="19" jdoc="Layout that places nodes in random positions. @author Andrzej">
			<mth name="/:sandmark.util.graph.graphview.SimpleGraphLayout.SimpleGraphLayout(sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style)" access="pub" jdoc="Constructs a new layout. @param g graph to be laid out @param style style of the graph">
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.SimpleGraphLayout.layout()" access="pub" jdoc="Assigns positions to the nodes, so they could be drawn on the screen.">
				<comm cntt="while (nodes.hasNext()) { java.lang.Object node = nodes.next(); nodeMap.put(node, new sandmark.util.graph.graphview.NodeDisplayInfo(node, x, y, 30, 30, sandmark.util.graph.graphview.NodeDisplayInfo.CIRCLE)); b = !b; if (b) x = 500; else { x = 100; y += 100; } }"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.SimpleGraphLayout.canLayout()" access="pub" jdoc="Returns whether this graph can be laid out using this algorithm. @return true if this algorithm can lay out the graph, false otherwise">
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.GraphViewFrame" intfc="n" abs="n" inn="n" sloc="196" jdoc="This is a frame for visualizing graphs. The user needs to create an object of type {@link GraphList}, that contains graphs that can later be drawn. The list will also contain styles and names of the graphs. @author Andrzej">
			<comm cntt="creates controls"/>
			<comm cntt="creates the menu bar for this window"/>
			<const name="WINDOW_SIZE" access="priv" jdoc=""/>
			<const name="PANEL_SIZE" access="priv" jdoc=""/>
			<const name="TEXT_AREA_SIZE" access="priv" jdoc=""/>
			<const name="CONTROLS_PANEL_SIZE" access="priv" jdoc=""/>
			<field name="myGraph" access="priv" jdoc=""/>
			<field name="myGraphStyle" access="priv" jdoc=""/>
			<field name="myGraphList" access="priv" jdoc=""/>
			<field name="myLayoutStyle" access="priv" jdoc=""/>
			<field name="myGraphDisplayPanel" access="priv" jdoc=""/>
			<field name="textArea" access="priv" jdoc=""/>
			<field name="myUserControls" access="priv" jdoc=""/>
			<field name="mySaveGraphItem" access="priv" jdoc=""/>
			<field name="myAboutItem" access="priv" jdoc=""/>
			<field name="myExitItem" access="priv" jdoc=""/>
			<field name="mySlider" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.GraphViewFrame.GraphViewFrame(javax.swing.JFrame, GraphList)" access="pub" jdoc="Creates a new frame with a list of graphs. @param parent the parent window of this frame @param graphList list of graphs that can be drawn">
				<comm cntt="node Information area"/>
				<comm cntt="user controls"/>
				<comm cntt="graph display area"/>
				<comm cntt="contentPane.add(scrollPane, java.awt.BorderLayout.CENTER);"/>
				<comm cntt="contentPane.add(sp, java.awt.BorderLayout.SOUTH);"/>
				<comm cntt="contentPane.add(myUserControls, java.awt.BorderLayout.WEST);"/>
				<comm cntt="java.awt.Dimension parentDim = parent.getSize();"/>
				<comm cntt="setLocation(parentLoc.x + (parentDim.width - getSize().width) 2,"/>
				<comm cntt="parentLoc.y + (parentDim.height - getSize().height) 2);"/>
				<param name="parent"/>
				<param name="graphList"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphViewFrame.GraphViewFrame(GraphList)" access="pub" jdoc="Creates a new frame with a list of graphs. @param graphList list of graphs that can be drawn">
				<param name="graphList"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphViewFrame.createUserControls()" access="priv" jdoc="">
				<comm cntt="list of graphs"/>
				<comm cntt="south controls"/>
				<comm cntt="comboBox with layout styles"/>
				<comm cntt="java.lang.String[] layoutStyles = {&amp;quot;Layered Drawing&amp;quot;, &amp;quot;Force Directed&amp;quot;, &amp;quot;Tree Layout&amp;quot;, &amp;quot;Class Hierarchy&amp;quot;, &amp;quot;Random&amp;quot;};"/>
				<comm cntt="southPanel.setLayout(new java.awt.GridLayout(6, 1));"/>
				<comm cntt="southPanel.add(new javax.swing.JLabel());"/>
				<comm cntt="button to draw a graph"/>
				<comm cntt="drawGraphButtonPanel.setPreferredSize(new java.awt.Dimension(100, 40));"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphViewFrame.createMenuBar()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphViewFrame.actionPerformed(java.awt.event.ActionEvent)" access="pub" jdoc="Invoked when an action occurs in this frame. @param e event that occured">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.TreeLayout" intfc="n" abs="n" inn="n" sloc="44" jdoc="Layout algorithm for trees. @author Andrzej">
			<comm cntt="assigns positions to the nodes in the tree"/>
			<mth name="/:sandmark.util.graph.graphview.TreeLayout.TreeLayout(sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style)" access="pub" jdoc="Constructs a new layout. @param g graph to be laid out @param style style of the graph">
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.TreeLayout.layout()" access="pub" jdoc="Assigns positions to the nodes, so they could be drawn on the screen.">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.TreeLayout.layoutTree(java.lang.Object, int, int, int, int, int)" access="priv" jdoc="">
				<param name="n"/>
				<param name="min"/>
				<param name="y"/>
				<param name="width"/>
				<param name="height"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.TreeLayout.canLayout()" access="pub" jdoc="Returns whether this graph can be laid out using this algorithm. @return true if this algorithm can lay out the graph, false otherwise">
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.MutableGraphPanel" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<field name="myGraph" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.MutableGraphPanel.MutableGraphPanel(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Style, int, javax.swing.JTextArea)" access="pub" jdoc="Constructs a new Panel for drawing the graph. @param g graph to be drawn @param style style containing information about the nodes @param type type of the layout, see {@link GraphLayout} for different types @param nodeInfo text area where node information can be displayed">
				<param name="g"/>
				<param name="style"/>
				<param name="type"/>
				<param name="nodeInfo"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.MutableGraphPanel.graphChanged(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.LayeredDrawingLayout" intfc="n" abs="n" inn="n" sloc="536" jdoc="Graph Layout algorithm that places the nodes in layers. @author Andrzej">
			<comm cntt="class representing crossings information for each layer"/>
			<comm cntt="Class that represents an edge that spans over more than one layer"/>
			<comm cntt="with dummy nodes"/>
			<comm cntt="removes self edges"/>
			<comm cntt="removes cycles in the graph"/>
			<comm cntt="removes cycles"/>
			<comm cntt="reverses edges back that have been reversed to remove cycles"/>
			<comm cntt="private void reverseEdgesBack() { java.util.Iterator iter = myReversedEdges.iterator(); while (iter.hasNext()) { ReversedEdge re = (ReversedEdge)iter.next(); graph = graph.removeEdge(re.reversed); graph = graph.addEdge(re.edge); } }"/>
			<comm cntt="assign bends in the graph in place of the dummy nodes"/>
			<comm cntt="assign nodes to different layers"/>
			<comm cntt="add a node to a layer"/>
			<comm cntt="returns the length of the longest path from the given node"/>
			<comm cntt="inserts dummy nodes on the edges spanning over more than one layer"/>
			<comm cntt="private void assignInitialXPos() { java.util.Iterator nodes = graph.nodes(); while (nodes.hasNext()) { java.lang.Object node = nodes.next(); LayerInfo nodeInfo = (LayerInfo)myNodes.get(node); } }"/>
			<comm cntt="Minimizes crossings in between layers"/>
			<comm cntt="TODO: figure out the complexity of this algorithm and then"/>
			<comm cntt="find a better algorithm. This takes many seconds to run for"/>
			<comm cntt="TTT"/>
			<comm cntt="switch positions of two nodes in the given layer"/>
			<comm cntt="check if node n intersects with other nodes in the layer"/>
			<comm cntt="eliminates intersection between two nodes"/>
			<comm cntt="minimize Barycenter is a method for reducing crossings between the"/>
			<comm cntt="layers"/>
			<comm cntt="sorts the nodes in layers based on their x coordinates"/>
			<comm cntt="calculates crossings in each layer"/>
			<comm cntt="computes number of crossings in the given layer"/>
			<comm cntt="calculate crossings between each node in the given layer"/>
			<comm cntt="calculate number of crossings between u and v nodes"/>
			<const name="USE_SLOW_MINIMIZE_CROSSINGS_ALGORITHM" access="priv" jdoc=""/>
			<field name="myNodes" access="priv" jdoc=""/>
			<field name="myLayers" access="priv" jdoc=""/>
			<field name="myNumLayers" access="priv" jdoc=""/>
			<field name="myRemovedEdges" access="priv" jdoc=""/>
			<field name="myReversedEdges" access="priv" jdoc=""/>
			<const name="NODE_DEFAULT_WIDTH" access="priv" jdoc=""/>
			<const name="NODE_DEFAULT_HEIGHT" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.LayeredDrawingLayout(sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style)" access="pub" jdoc="Constructs a new layout. @param g graph to be laid out @param style style of the graph">
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.layout()" access="pub" jdoc="Assigns positions to the nodes, so they could be drawn on the screen.">
				<comm cntt="remove self edges"/>
				<comm cntt="remove cycles"/>
				<comm cntt="assign layers"/>
				<comm cntt="insert dummy nodes"/>
				<comm cntt="minimize crossings"/>
				<comm cntt="minimizeBarycenter(1);"/>
				<comm cntt="minimizeBarycenter(0);"/>
				<comm cntt="minimizeCrossings();"/>
				<comm cntt="reverseEdgesBack();"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.elimIntersections()" access="priv" jdoc="">
				<comm cntt="java.lang.Object node1 = layer.get(i - 1);"/>
				<comm cntt="java.lang.Object node2 = layer.get(i);"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.removeSelfEdges()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.removeCycles()" access="priv" jdoc="">
				<comm cntt="myReversedEdges.add(new ReversedEdge(edge, reversed));"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.greedyCycleRemoval()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.assignBendsInEdges()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.assignLayers()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.addToLayer(java.lang.Object, int)" access="priv" jdoc="">
				<param name="node"/>
				<param name="layerNum"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.findLongestPath(java.lang.Object)" access="priv" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.insertDummyNodes()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.minimizeCrossings()" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;total crossings before = &amp;quot; + calculateTotalCrossings());"/>
				<comm cntt="System.out.println(counter + &amp;quot;: total crossings after top to bottom = &amp;quot; + calculateTotalCrossings());"/>
				<comm cntt="System.out.println(counter + &amp;quot;: total crossings after bottom to top = &amp;quot; + calculateTotalCrossings());"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.switchLayerPositions(sandmark.util.SparseVector, int, java.lang.Object, java.lang.Object)" access="priv" jdoc="">
				<param name="layer"/>
				<param name="j"/>
				<param name="u"/>
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.checkIntersectNodes(NodeDisplayInfo, int, java.util.ArrayList)" access="priv" jdoc="">
				<param name="n"/>
				<param name="layer"/>
				<param name="nodesVisited"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.eliminateIntersection(NodeDisplayInfo, NodeDisplayInfo)" access="priv" jdoc="">
				<comm cntt="System.out.println(move + &amp;quot; &amp;quot; + n);"/>
				<comm cntt="System.out.println(&amp;quot;moveX &amp;quot; + moveX + &amp;quot; dif &amp;quot; + dif + &amp;quot; m width &amp;quot; + move.getWidth() + &amp;quot; n width &amp;quot; + n.getWidth());"/>
				<comm cntt="System.out.println(&amp;quot;moving &amp;quot; + move + &amp;quot; left by &amp;quot; + (moveX - dif - move.getWidth() 2 - n.getWidth() 2 - 10));"/>
				<comm cntt="System.out.println(&amp;quot;moveX &amp;quot; + moveX + &amp;quot; nX &amp;quot; + nX + &amp;quot; dif &amp;quot; + dif + &amp;quot; m width &amp;quot; + move.getWidth() + &amp;quot; n width &amp;quot; + n.getWidth());"/>
				<comm cntt="System.out.println(&amp;quot;moving &amp;quot; + move + &amp;quot; right by &amp;quot; + (moveX + dif + move.getWidth() 2 + n.getWidth() 2 + 10));"/>
				<param name="move"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.minimizeBarycenter(int)" access="priv" jdoc="">
				<comm cntt="downward sweep"/>
				<comm cntt="checkIntersection(nodeInfo, i, nodesVisited);"/>
				<comm cntt="upward sweep"/>
				<comm cntt="checkIntersection(nodeInfo, i, nodesVisited);"/>
				<comm cntt="fix layer positions"/>
				<param name="dir"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.assignLayerPositions()" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;layer &amp;quot; + counter + &amp;quot; pos &amp;quot; + i + &amp;quot; node &amp;quot; + node);"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.calculateTotalCrossings()" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;layer &amp;quot; + i + &amp;quot; : &amp;quot; + computeNumCross((sandmark.util.SparseVector)myLayers.get(i)));"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.computeNumCross(sandmark.util.SparseVector)" access="priv" jdoc="">
				<comm cntt="System.out.println(u + &amp;quot; &amp;quot; + v + &amp;quot; : &amp;quot; + uvCross + &amp;quot; layer size: &amp;quot; + layer.size());"/>
				<param name="layer"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.calculateCrossings(int)" access="priv" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.calculateCrossings(java.lang.Object, java.lang.Object)" access="priv" jdoc="">
				<param name="u"/>
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.layoutNodesNewest(int)" access="priv" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.calculateNodeDimension(java.lang.Object)" access="priv" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout.canLayout()" access="pub" jdoc="Returns whether this graph can be laid out using this algorithm. @return true if this algorithm can lay out the graph, false otherwise">
			</mth>
		<class name="/:sandmark.util.graph.graphview.LayeredDrawingLayout$LayerInfo" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<field name="layer" access="pub" jdoc=""/>
			<field name="pos" access="pub" jdoc=""/>
			<field name="x" access="pub" jdoc=""/>
			<field name="crossings" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout$LayerInfo.LayerInfo(int, int)" access="pub" jdoc="">
				<param name="layerNum"/>
				<param name="layerPos"/>
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.LayeredDrawingLayout$EdgeInfo" intfc="n" abs="n" inn="y" sloc="9" jdoc="">
			<field name="edge" access="pub" jdoc=""/>
			<field name="dummyNodes" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.LayeredDrawingLayout$EdgeInfo.EdgeInfo(sandmark.util.newgraph.Edge, java.util.ArrayList)" access="pub" jdoc="">
				<param name="e"/>
				<param name="dummys"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.graph.graphview.GraphZoomSlider" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<field name="myGraphDisplayPanel" access="priv" jdoc=""/>
			<field name="mySlider" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.GraphZoomSlider.GraphZoomSlider(sandmark.util.graph.graphview.GraphPanel)" access="pub" jdoc="">
				<comm cntt="mySlider.setPaintTicks(true);"/>
				<comm cntt="mySlider.setPaintLabels(true);"/>
				<comm cntt="setPreferredSize(new java.awt.Dimension(200, 100));"/>
				<param name="panel"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphZoomSlider.setGraphDisplayPanel(sandmark.util.graph.graphview.GraphPanel)" access="pub" jdoc="">
				<param name="panel"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphZoomSlider.reset()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.GraphList" intfc="n" abs="n" inn="n" sloc="68" jdoc="This class represents the list of graphs to be drawn. The user creates the list of graphs: &amp;lt;pre&amp;gt; GraphList list = new GraphList(); &amp;lt; pre&amp;gt; and then can add graphs along with style and the name of the graph to the list. &amp;lt;pre&amp;gt; list.add(graph, style, name); &amp;lt; pre&amp;gt; @author Andrzej">
			<comm cntt="private class that stores the graph, style and name of the graph"/>
			<comm cntt="Constructs an empty list of graphs."/>
			<comm cntt="the unique instance of this class"/>
			<comm cntt="adds a graph to the list of graphs"/>
			<field name="gl_instance" access="priv" jdoc=""/>
			<field name="myGraphList" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.GraphList.GraphList()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.instance()" access="pub" jdoc="Returns the unique instance of this class. @return the unique instance of this class">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.clear()" access="pub" jdoc="Deletes all graphs from the list.">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.add(sandmark.util.newgraph.Graph, sandmark.util.newgraph.GraphStyle, java.lang.String)" access="pub" jdoc="Adds a graph to the list of graphs. @param graph graph to be added to the list @param style style of the graph @param name name of the graph">
				<param name="graph"/>
				<param name="style"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.add(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.GraphStyle, java.lang.String)" access="pub" jdoc="Adds a mutable graph to the list of graphs. @param graph graph to be added to the list @param style style of the graph @param name name of the graph">
				<param name="graph"/>
				<param name="style"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.add(sandmark.util.newgraph.Graph, java.lang.String)" access="pub" jdoc="Adds a graph with a default style to the list of graphs. @param graph graph to be added to the list @param name name of the graph">
				<param name="graph"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.add(sandmark.util.newgraph.MutableGraph, java.lang.String)" access="pub" jdoc="Adds a mutable graph with a default style to the list of graphs. @param graph graph to be added to the list @param name name of the graph">
				<param name="graph"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.add(sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style, java.lang.String)" access="priv" jdoc="">
				<param name="g"/>
				<param name="s"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.getGraph(int)" access="pub" jdoc="Returns the graph associated with the index. @param index index of the graph in the list">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.getStyle(int)" access="pub" jdoc="Returns the style of the graph associated with the index. @param index index of the graph in the list">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphList.getGraphNames()" access="pub" jdoc="Returns an array of the graph names.">
			</mth>
		<class name="/:sandmark.util.graph.graphview.GraphList$GraphInfo" intfc="n" abs="n" inn="y" sloc="12" jdoc="">
			<field name="graph" access="pub" jdoc=""/>
			<field name="style" access="pub" jdoc=""/>
			<field name="name" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.GraphList$GraphInfo.GraphInfo(sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style, java.lang.String)" access="pub" jdoc="">
				<param name="g"/>
				<param name="s"/>
				<param name="n"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.graph.graphview.GraphPanel" intfc="n" abs="n" inn="n" sloc="388" jdoc="This is a panel for diplaying graphs. It displays the graph according to the type of layout that was passed in the constructor. @author Andrzej">
			<comm cntt="This is a mouse listener allowing the user to drag the nodes of the"/>
			<comm cntt="graph."/>
			<comm cntt="checks if the user clicked inside any of the nodes of the graph."/>
			<comm cntt="draws multiple edges between two nodes"/>
			<comm cntt="computes control point for the curve of an edge between nodes that contain multiple edges"/>
			<comm cntt="draws a node in a graph"/>
			<comm cntt="draw an edge"/>
			<comm cntt="draw an arrow at the end of an edge"/>
			<comm cntt="compute the start of the edge between two nodes"/>
			<comm cntt="variables used for dragging a node with a mouse"/>
			<field name="myGraph" access="priv" jdoc=""/>
			<field name="myGraphStyle" access="priv" jdoc=""/>
			<field name="myLayout" access="priv" jdoc=""/>
			<field name="myLayoutType" access="priv" jdoc=""/>
			<field name="myNodeInfoArea" access="priv" jdoc=""/>
			<field name="myDrawnEdges" access="priv" jdoc=""/>
			<field name="myZoomFactor" access="priv" jdoc=""/>
			<field name="myDragNode" access="priv" jdoc=""/>
			<field name="myDX" access="priv" jdoc=""/>
			<field name="myDY" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.GraphPanel(sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style, int, javax.swing.JTextArea)" access="pub" jdoc="Constructs a new Panel for drawing the graph. @param g graph to be drawn @param style style containing information about the nodes @param type type of the layout, see {@link GraphLayout} for different types @param nodeInfo text area where node information can be displayed">
				<comm cntt="add mouse listener for moving nodes around"/>
				<param name="g"/>
				<param name="style"/>
				<param name="type"/>
				<param name="nodeInfo"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.setLayout(int, sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style)" access="pub" jdoc="Sets a new layout, graph and style for this panel. @param type type of the layout (see {@link GraphLayout} for types) @param g graph @param style style of the graph">
				<param name="type"/>
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.checkMouseClick(int, int)" access="priv" jdoc="">
				<param name="x"/>
				<param name="y"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.paintComponent(java.awt.Graphics)" access="pub" jdoc="Draws the graph on the panel, using the information from the layout of the graph and style of the graph. @param g the Graphics context in which to paint">
				<comm cntt="draw nodes"/>
				<comm cntt="draw edges"/>
				<comm cntt="draw other edges between source and sink"/>
				<comm cntt="draw self edges"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.drawSelfEdges(java.awt.Graphics2D)" access="priv" jdoc="">
				<param name="g2"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.drawOtherEdges(java.awt.Graphics2D, java.lang.Object, java.lang.Object)" access="priv" jdoc="">
				<comm cntt="draw curved edge"/>
				<comm cntt="so undirected graphs just show up as double sided arrow: (interference graphs)"/>
				<comm cntt="System.out.println(ctrlPoint);"/>
				<param name="g2"/>
				<param name="source"/>
				<param name="sink"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.computeControlPoint(java.awt.Point, java.awt.Point, int, int)" access="priv" jdoc="">
				<param name="start"/>
				<param name="end"/>
				<param name="distance"/>
				<param name="dir"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.drawNode(java.awt.Graphics2D, sandmark.util.graph.graphview.NodeDisplayInfo)" access="priv" jdoc="">
				<comm cntt="draw node"/>
				<comm cntt="draw label"/>
				<comm cntt="calculate size of label"/>
				<comm cntt="TODO: support right and left justification in addition to"/>
				<comm cntt="centering."/>
				<param name="g2"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.drawBendEdge(java.awt.Graphics2D, sandmark.util.graph.graphview.NodeDisplayInfo, sandmark.util.graph.graphview.NodeDisplayInfo)" access="priv" jdoc="">
				<param name="g2"/>
				<param name="start"/>
				<param name="end"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.drawEdge(java.awt.Graphics2D, sandmark.util.graph.graphview.EdgeDisplayInfo, sandmark.util.graph.graphview.NodeDisplayInfo, sandmark.util.graph.graphview.NodeDisplayInfo)" access="priv" jdoc="">
				<comm cntt="draw bends"/>
				<param name="g2"/>
				<param name="edge"/>
				<param name="start"/>
				<param name="end"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.drawArrow(java.awt.Graphics2D, int, int, int, int)" access="priv" jdoc="">
				<comm cntt="g2.draw(new java.awt.geom.Line2D.Double(x2, y2, side1X, side1Y));"/>
				<comm cntt="g2.draw(new java.awt.geom.Line2D.Double(x2, y2, side2X, side2Y));"/>
				<comm cntt="g2.draw(new java.awt.geom.Line2D.Double(side1X, side1Y, side2X, side2Y);"/>
				<param name="g2"/>
				<param name="x1"/>
				<param name="y1"/>
				<param name="x2"/>
				<param name="y2"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.computeEdgeStart(int, int, int, int, int, int, int)" access="priv" jdoc="">
				<param name="startX"/>
				<param name="startY"/>
				<param name="endX"/>
				<param name="endY"/>
				<param name="width"/>
				<param name="height"/>
				<param name="shapeType"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.getStyleColor(int)" access="priv" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.resizeGraph(double)" access="pub" jdoc="">
				<param name="factor"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel.setGraph(sandmark.util.newgraph.Graph)" access="prot" jdoc="">
				<param name="g"/>
			</mth>
		<class name="/:sandmark.util.graph.graphview.GraphPanel$MyMouseListener" intfc="n" abs="n" inn="y" sloc="32" jdoc="">
			<mth name="/:sandmark.util.graph.graphview.GraphPanel$MyMouseListener.mousePressed(java.awt.event.MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel$MyMouseListener.mouseDragged(java.awt.event.MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.GraphPanel$MyMouseListener.mouseReleased(java.awt.event.MouseEvent)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.graph.graphview.NodeDisplayInfo" intfc="n" abs="n" inn="n" sloc="120" jdoc="This class represents the node in the display of the graph. @author Andrzej">
			<comm cntt="creates shape representing this node"/>
			<const name="CIRCLE" access="pub" jdoc="Round shape of the node."/>
			<const name="RECTANGLE" access="pub" jdoc="Rectangular shape of the node."/>
			<field name="myNode" access="priv" jdoc=""/>
			<field name="myShape" access="priv" jdoc=""/>
			<field name="myShapeType" access="priv" jdoc=""/>
			<field name="myX" access="priv" jdoc=""/>
			<field name="myY" access="priv" jdoc=""/>
			<field name="myWidth" access="priv" jdoc=""/>
			<field name="myHeight" access="priv" jdoc=""/>
			<field name="myOriginalX" access="priv" jdoc=""/>
			<field name="myOriginalY" access="priv" jdoc=""/>
			<field name="myOriginalWidth" access="priv" jdoc=""/>
			<field name="myOriginalHeight" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.NodeDisplayInfo(java.lang.Object, int, int, int, int, int)" access="pub" jdoc="Constructs display information about a particular node. @param node node of the graph @param x x coordinate of the node @param y y coordinate of the node @param width width of the node @param height height of the node @param type shape of the node">
				<param name="node"/>
				<param name="x"/>
				<param name="y"/>
				<param name="width"/>
				<param name="height"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.NodeDisplayInfo(java.lang.Object, int, int, int, int)" access="pub" jdoc="Constructs display information about a particular node. @param node node of the graph @param x x coordinate of the node @param y y coordinate of the node @param diameter diameter of the node @param type shape of the node">
				<param name="node"/>
				<param name="x"/>
				<param name="y"/>
				<param name="diameter"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.compareTo(java.lang.Object)" access="pub" jdoc="Compares the x coordinates of this node and another node. @param o node to be compared @return the value 0 if the coordinates are equal, less than 0 if the coordinate of this node is less than other, and greater than 0 if the coordinate of this node is greater than other">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getX()" access="pub" jdoc="Returns the x coordinate of this node. @return x coordinate of this node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getY()" access="pub" jdoc="Returns the y coordinate of this node. @return y coordinate of this node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getOriginalX()" access="pub" jdoc="Returns the x coordinate of this node. @return x coordinate of this node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getOriginalY()" access="pub" jdoc="Returns the y coordinate of this node. @return y coordinate of this node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.setX(int)" access="pub" jdoc="Sets the x coordinate of this node. @param x new x coordinate of the node">
				<param name="x"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.setY(int)" access="pub" jdoc="Sets the y coordinate of this node. @param y new y coordinate of the node">
				<param name="y"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getWidth()" access="pub" jdoc="Returns the width of the node. @return width of the node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getHeight()" access="pub" jdoc="Returns the height of the node. @return height of the node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getOriginalWidth()" access="pub" jdoc="Returns the width of the node. @return width of the node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getOriginalHeight()" access="pub" jdoc="Returns the height of the node. @return height of the node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.updatePosition(int, int)" access="pub" jdoc="Updates the position of this node. @param x x coordinate @param y y coordinate">
				<param name="x"/>
				<param name="y"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.updatePositionAndSize(int, int, int, int)" access="pub" jdoc="">
				<param name="x"/>
				<param name="y"/>
				<param name="width"/>
				<param name="height"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.updateOriginalPositions(double)" access="pub" jdoc="">
				<param name="factor"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.createShape(int, int, int, int, int)" access="priv" jdoc="">
				<param name="x"/>
				<param name="y"/>
				<param name="w"/>
				<param name="h"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getShape()" access="pub" jdoc="Returns the shape of this node. @return shape of this node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getShapeType()" access="pub" jdoc="Returns the type of the shape of this node. @return type of the shape of this node">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.contains(int, int)" access="pub" jdoc="Returns true if this node contains the point [x, y] @param x x coordinate of the point @param y y coordinate of the point @return true if the node contains point [x, y], false otherwise">
				<param name="x"/>
				<param name="y"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.contains(java.awt.Point)" access="pub" jdoc="Returns true if this node contains the point p @param p point to check if it is inside the node @return true if the node contains point p, false otherwise">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.intersects(NodeDisplayInfo)" access="pub" jdoc="Returns true if this node intersects node n @param n node to check for intersections with @return true if this node intersects node n, false otherwise">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.NodeDisplayInfo.getNode()" access="pub" jdoc="Returns the node object associated with this display information. @return node of the graph">
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.EdgeDisplayInfo" intfc="n" abs="n" inn="n" sloc="25" jdoc="Information about displaying an edge. @author Andrzej">
			<field name="myEdge" access="priv" jdoc=""/>
			<field name="myBends" access="priv" jdoc=""/>
			<field name="myOriginalBends" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.EdgeDisplayInfo.EdgeDisplayInfo(sandmark.util.newgraph.Edge)" access="pub" jdoc="Constructs a new info about an edge. @param e edge of the graph">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.EdgeDisplayInfo.getEdgeBends()" access="pub" jdoc="Returns an ArrayList of bends in the edge. @return a list of bends in the edge">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.EdgeDisplayInfo.getOriginalEdgeBends()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.EdgeDisplayInfo.addBend(java.awt.Point)" access="pub" jdoc="Adds a point representing a bend in the visual representation of the edge. @param p point that represents a bend in the edge">
				<param name="p"/>
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.HierarchyTreeLayout" intfc="n" abs="n" inn="n" sloc="27" jdoc="Layout algorithm for trees, like class inheritance hierarchy. @author Andrzej">
			<comm cntt="lays out the tree"/>
			<mth name="/:sandmark.util.graph.graphview.HierarchyTreeLayout.HierarchyTreeLayout(sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style)" access="pub" jdoc="Constructs a new layout. @param g graph to be laid out @param style style of the graph">
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.HierarchyTreeLayout.layout()" access="pub" jdoc="Assigns positions to the nodes, so they could be drawn on the screen.">
			</mth>
			<mth name="/:sandmark.util.graph.graphview.HierarchyTreeLayout.layoutTree(java.lang.Object, int, int, int, int, int)" access="priv" jdoc="">
				<param name="node"/>
				<param name="x"/>
				<param name="y"/>
				<param name="width"/>
				<param name="height"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.HierarchyTreeLayout.canLayout()" access="pub" jdoc="Returns whether this graph can be laid out using this algorithm. @return true if this algorithm can lay out the graph, false otherwise">
			</mth>
		</class>
		<class name="/:sandmark.util.graph.graphview.SpringEmbedderLayout" intfc="n" abs="n" inn="n" sloc="118" jdoc="Layout that places nodes based on the force directed algorithm. It uses springs between nodes to determine forces between nodes in the graph. @author Andrzej">
			<comm cntt="class that stores the x and y coordinate and x and y force for a"/>
			<comm cntt="particular node"/>
			<mth name="/:sandmark.util.graph.graphview.SpringEmbedderLayout.SpringEmbedderLayout(sandmark.util.newgraph.Graph, sandmark.util.newgraph.Style)" access="pub" jdoc="Constructs a new layout. @param g graph to be laid out @param style style of the graph">
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.SpringEmbedderLayout.layout()" access="pub" jdoc="Assigns positions to the nodes, so they could be drawn on the screen.">
				<comm cntt="double xCoord = 100; double yCoord = 100; boolean b = false; while (iter.hasNext()) { nodes.put(iter.next(), new NodeInfo(xCoord, yCoord)); b = !b; if (b) xCoord = 110; else { xCoord = 100; yCoord += 10; } }"/>
				<comm cntt="double k = java.lang.Math.sqrt(area graph.nodeCount());"/>
				<comm cntt="calculate repulsive forces"/>
				<comm cntt="vInfo.xDisp += (dx dxAbs) (k dxAbs) (dxAbs distance(dx, dy));"/>
				<comm cntt="vInfo.yDisp += (dy dyAbs) (k dyAbs) (dyAbs distance(dx, dy));"/>
				<comm cntt="System.out.println(&amp;quot;repulsive &amp;quot; + v + &amp;quot;\nxDisp &amp;quot; + vInfo.xDisp + &amp;quot; yDisp &amp;quot; + vInfo.yDisp);"/>
				<comm cntt="vertices = graph.nodes(); while (vertices.hasNext()) { NodeInfo info = (NodeInfo)nodes.get(vertices.next()); System.out.println(&amp;quot;xDisp &amp;quot; + info.xDisp); System.out.println(&amp;quot;yDisp &amp;quot; + info.yDisp); info.x += info.xDisp; info.y += info.yDisp; info.xDisp = 0.0; info.yDisp = 0.0; }"/>
				<comm cntt="calculate attractive forces"/>
				<comm cntt="vInfo.xDisp -= (dx dxAbs) (dxAbs k) (dxAbs distance(dx, dy));"/>
				<comm cntt="vInfo.yDisp -= (dy dyAbs) (dyAbs k) (dyAbs distance(dx, dy));"/>
				<comm cntt="uInfo.xDisp += (dx dxAbs) (dxAbs k) (dxAbs distance(dx, dy));"/>
				<comm cntt="uInfo.yDisp += (dy dyAbs) (dyAbs k) (dyAbs distance(dx, dy));"/>
				<comm cntt="System.out.println(&amp;quot;repulsive &amp;quot; + v + &amp;quot;\nxDisp &amp;quot; + vInfo.xDisp + &amp;quot; yDisp &amp;quot; + vInfo.yDisp);"/>
				<comm cntt="System.out.println(&amp;quot;repulsive &amp;quot; + u + &amp;quot;\nxDisp &amp;quot; + vInfo.xDisp + &amp;quot; yDisp &amp;quot; + vInfo.yDisp);"/>
				<comm cntt="vertices = graph.nodes(); while (vertices.hasNext()) { NodeInfo info = (NodeInfo)nodes.get(vertices.next()); System.out.println(&amp;quot;xDisp &amp;quot; + info.xDisp); System.out.println(&amp;quot;yDisp &amp;quot; + info.yDisp); info.x += info.xDisp; info.y += info.yDisp; }"/>
				<comm cntt="update positions"/>
				<comm cntt="System.out.println(&amp;quot;xDisp &amp;quot; + info.xDisp);"/>
				<comm cntt="System.out.println(&amp;quot;yDisp &amp;quot; + info.yDisp);"/>
				<comm cntt="info.x += info.xDisp java.lang.Math.abs(info.xDisp)"/>
				<comm cntt="java.lang.Math.min(info.xDisp, t);"/>
				<comm cntt="info.y += info.yDisp java.lang.Math.abs(info.yDisp)"/>
				<comm cntt="java.lang.Math.min(info.yDisp, t);"/>
				<comm cntt="if (info.xDisp &amp;gt;= 0) info.x += java.lang.Math.min(java.lang.Math.abs(info.xDisp), t); else info.x -= java.lang.Math.min(java.lang.Math.abs(info.xDisp), t); if (info.yDisp &amp;gt;= 0) info.y += java.lang.Math.min(java.lang.Math.abs(info.yDisp), t); else info.y -= java.lang.Math.min(java.lang.Math.abs(info.yDisp), t);"/>
				<comm cntt="System.out.println(&amp;quot;iter &amp;quot; + i + &amp;quot;: x &amp;quot; + info.x);"/>
				<comm cntt="System.out.println(&amp;quot;iter &amp;quot; + i + &amp;quot;: y &amp;quot; + info.y);"/>
				<comm cntt="t -= 1;"/>
				<comm cntt="t = java.lang.Math.max(1, t);"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.SpringEmbedderLayout.distance(double, double)" access="priv" jdoc="">
				<param name="dx"/>
				<param name="dy"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.SpringEmbedderLayout.removeAllMultipleEdges(sandmark.util.newgraph.Graph)" access="priv" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.graph.graphview.SpringEmbedderLayout.canLayout()" access="pub" jdoc="Returns whether this graph can be laid out using this algorithm. @return true if this algorithm can lay out the graph, false otherwise">
			</mth>
		<class name="/:sandmark.util.graph.graphview.SpringEmbedderLayout$NodeInfo" intfc="n" abs="n" inn="y" sloc="9" jdoc="">
			<field name="x" access="pub" jdoc=""/>
			<field name="y" access="pub" jdoc=""/>
			<field name="xDisp" access="pub" jdoc=""/>
			<field name="yDisp" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.graph.graphview.SpringEmbedderLayout$NodeInfo.NodeInfo(double, double)" access="pub" jdoc="">
				<param name="_x"/>
				<param name="_y"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.javagen">
		<class name="/:sandmark.util.javagen.Return" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<field name="expr" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Return.Return(sandmark.util.javagen.Expression)" access="pub" jdoc="">
				<param name="expr"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Return.Return()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.Return.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Return.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Return.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.StaticFunCall" intfc="n" abs="n" inn="n" sloc="86" jdoc="">
			<field name="Class" access="pub" jdoc=""/>
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="args" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.StaticFunCall.StaticFunCall(String, String, String, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticFunCall.StaticFunCall(String, String, String, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="arg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticFunCall.StaticFunCall(String, String, String)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticFunCall.StaticFunCall(String, String, String, sandmark.util.javagen.Java, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="arg1"/>
				<param name="arg2"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticFunCall.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticFunCall.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticFunCall.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.StaticRef" intfc="n" abs="n" inn="n" sloc="35" jdoc="">
			<field name="Class" access="pub" jdoc=""/>
			<field name="field" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.StaticRef.StaticRef(String, String, String)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="field"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticRef.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticRef.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticRef.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.AssignStatic" intfc="n" abs="n" inn="n" sloc="44" jdoc="">
			<field name="Class" access="pub" jdoc=""/>
			<field name="field" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="right" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.AssignStatic.AssignStatic(String, String, String, sandmark.util.javagen.Expression)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="field"/>
				<param name="type"/>
				<param name="right"/>
			</mth>
			<mth name="/:sandmark.util.javagen.AssignStatic.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.AssignStatic.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.AssignStatic.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.LiteralString" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<field name="value" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.LiteralString.LiteralString(String)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LiteralString.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LiteralString.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LiteralString.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.EmptyStatement" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<mth name="/:sandmark.util.javagen.EmptyStatement.EmptyStatement()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.EmptyStatement.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.EmptyStatement.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.EmptyStatement.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.IfNotNull" intfc="n" abs="n" inn="n" sloc="57" jdoc="">
			<field name="expr" access="pub" jdoc=""/>
			<field name="stats" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.IfNotNull.IfNotNull(sandmark.util.javagen.Expression, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="expr"/>
				<param name="stats"/>
			</mth>
			<mth name="/:sandmark.util.javagen.IfNotNull.IfNotNull(sandmark.util.javagen.Expression, sandmark.util.javagen.Statement)" access="pub" jdoc="">
				<param name="expr"/>
				<param name="stat"/>
			</mth>
			<mth name="/:sandmark.util.javagen.IfNotNull.toString(String)" access="pub" jdoc="">
				<comm cntt="System.out.println(expr);"/>
				<comm cntt="System.out.println(stats);"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.IfNotNull.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.IfNotNull.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.LocalRef" intfc="n" abs="n" inn="n" sloc="35" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.LocalRef.LocalRef(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LocalRef.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LocalRef.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LocalRef.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LocalRef.findLocal(String, org.apache.bcel.generic.LocalVariableGen[])" access="pub" jdoc="">
				<param name="name"/>
				<param name="locals"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Method" intfc="n" abs="n" inn="n" sloc="87" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="attributes" access="pub" jdoc=""/>
			<field name="formals" access="pub" jdoc=""/>
			<field name="stats" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Method.Method(String, String, String[], sandmark.util.javagen.List, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="attributes"/>
				<param name="formals"/>
				<param name="stats"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Method.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Method.toByteCode(org.apache.bcel.generic.ClassGen)" access="pub" jdoc="">
				<comm cntt="il.append(org.apache.bcel.generic.InstructionConstants.RETURN);"/>
				<param name="cg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Method.toCode(sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="il.append(org.apache.bcel.generic.InstructionConstants.RETURN);"/>
				<param name="cl"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.New" intfc="n" abs="n" inn="n" sloc="75" jdoc="">
			<field name="args" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.New.New(String, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="type"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.javagen.New.New(String, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="type"/>
				<param name="arg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.New.New(String)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.New.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.New.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.New.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Block" intfc="n" abs="n" inn="n" sloc="28" jdoc="">
			<field name="stats" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Block.Block(sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="stats"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Block.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Block.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Block.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.LoadIndex" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<field name="array" access="pub" jdoc=""/>
			<field name="idx" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.LoadIndex.LoadIndex(sandmark.util.javagen.Expression, sandmark.util.javagen.Expression, String)" access="pub" jdoc="">
				<param name="array"/>
				<param name="idx"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LoadIndex.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LoadIndex.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LoadIndex.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Field" intfc="n" abs="n" inn="n" sloc="56" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="attributes" access="pub" jdoc=""/>
			<field name="init" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Field.Field(String, String, String[])" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="attributes"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Field.Field(String, String, String[], sandmark.util.javagen.Expression)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="attributes"/>
				<param name="init"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Field.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Field.toByteCode(org.apache.bcel.generic.ClassGen)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Field.type=&amp;quot; + field_type.toString());"/>
				<comm cntt="System.out.println(&amp;quot;Field.sig=&amp;quot; + fg.getSignature());"/>
				<comm cntt="System.out.println(&amp;quot;Field.decl=&amp;quot; + fg.toString());"/>
				<param name="cg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Field.toCode(sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Field.type=&amp;quot; + field_type.toString());"/>
				<comm cntt="org.apache.bcel.generic.ConstantPoolGen cp = cg.getConstantPool();"/>
				<comm cntt="System.out.println(&amp;quot;Field.sig=&amp;quot; + fg.getSignature());"/>
				<comm cntt="System.out.println(&amp;quot;Field.decl=&amp;quot; + fg.toString());"/>
				<comm cntt="cg.addField(fg.getField());"/>
				<param name="cl"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.VirtualFunCall" intfc="n" abs="n" inn="n" sloc="97" jdoc="">
			<field name="Class" access="pub" jdoc=""/>
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="obj" access="pub" jdoc=""/>
			<field name="args" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.VirtualFunCall.VirtualFunCall(sandmark.util.javagen.Expression, String, String, String, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="obj"/>
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualFunCall.VirtualFunCall(sandmark.util.javagen.Expression, String, String, String, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="obj"/>
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="arg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualFunCall.VirtualFunCall(sandmark.util.javagen.Expression, String, String, String)" access="pub" jdoc="">
				<param name="obj"/>
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualFunCall.VirtualFunCall(sandmark.util.javagen.Expression, String, String, String, sandmark.util.javagen.Java, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="obj"/>
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="arg1"/>
				<param name="arg2"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualFunCall.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualFunCall.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualFunCall.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Local" intfc="n" abs="n" inn="n" sloc="51" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="init" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Local.Local(String, String, sandmark.util.javagen.Expression)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="init"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Local.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Local.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<comm cntt="mg.setMaxLocals(mg.getMaxLocals()+1); UNTESTED"/>
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Local.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="mg.setMaxLocals(mg.getMaxLocals()+1); UNTESTED"/>
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Expression" intfc="n" abs="y" inn="n" sloc="15" jdoc="">
			<field name="type" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Expression.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.Expression.getSig()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.Expression.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Expression.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Java" intfc="n" abs="n" inn="n" sloc="116" jdoc="">
			<comm cntt="-----------------------------------------------------------------------------"/>
			<field name="comment" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Java.setComment(String)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.renderListTerminate(sandmark.util.javagen.List, String, String)" access="prot" jdoc="">
				<param name="L"/>
				<param name="terminator"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.renderListTerminate(String, String, String)" access="prot" jdoc="">
				<param name="L"/>
				<param name="terminator"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.renderListSeparate(sandmark.util.javagen.List, String, String)" access="prot" jdoc="">
				<param name="L"/>
				<param name="separator"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.renderStat(sandmark.util.javagen.Java, String)" access="prot" jdoc="">
				<param name="stat"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.renderStats(sandmark.util.javagen.List, String)" access="prot" jdoc="">
				<param name="stats"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.renderBlock(sandmark.util.javagen.List, String)" access="prot" jdoc="">
				<comm cntt="String P = &amp;quot;&amp;quot;;"/>
				<comm cntt="if (stats.size() == 1)"/>
				<comm cntt="P = &amp;quot;\n&amp;quot; + renderStat(stats.car(), indent);"/>
				<comm cntt="else"/>
				<param name="stats"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.inlineComment(String, sandmark.util.javagen.Java)" access="prot" jdoc="">
				<param name="P"/>
				<param name="prog"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.commentText(String, String)" access="prot" jdoc="">
				<param name="C"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.outlineComment()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.Java.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.Java.accessFlagsToByteCode(String[])" access="pub" jdoc="">
				<param name="flags"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Java.typeToByteCode(String)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.AssignIndex" intfc="n" abs="n" inn="n" sloc="42" jdoc="">
			<field name="array" access="pub" jdoc=""/>
			<field name="idx" access="pub" jdoc=""/>
			<field name="right" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.AssignIndex.AssignIndex(sandmark.util.javagen.Expression, sandmark.util.javagen.Expression, sandmark.util.javagen.Expression)" access="pub" jdoc="">
				<param name="array"/>
				<param name="idx"/>
				<param name="right"/>
			</mth>
			<mth name="/:sandmark.util.javagen.AssignIndex.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.AssignIndex.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.AssignIndex.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.MyClass" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<field name="F1" access="pub" jdoc=""/>
			<field name="F2" access="pub" jdoc=""/>
			<field name="F3" access="pub" jdoc=""/>
			<field name="F4" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.MyClass.M1()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Formal" intfc="n" abs="n" inn="n" sloc="53" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Formal.Formal(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Formal.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Formal.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<comm cntt="mg.setMaxLocals(mg.getMaxLocals()+1); UNTESTED"/>
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Formal.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Formal.toCode:mg=&amp;quot; + mg.getName());"/>
				<comm cntt="System.out.println(&amp;quot;Formal.toCode:0:&amp;quot; + mg.getMaxLocals());"/>
				<comm cntt="System.out.println(&amp;quot;Formal.toCode:1:&amp;quot; + names[i]);"/>
				<comm cntt="for(int i=0; i&amp;lt;namesX.length; i++) {"/>
				<comm cntt="System.out.println(&amp;quot;Formal.toCode:2:&amp;quot; + namesX[i]);"/>
				<comm cntt="}"/>
				<comm cntt="System.out.println(&amp;quot;Formal.toCode:3:&amp;quot; + mg.getMaxLocals());"/>
				<comm cntt="mg.setMaxLocals(mg.getMaxLocals()+1); UNTESTED"/>
				<param name="cl"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Try" intfc="n" abs="n" inn="n" sloc="82" jdoc="">
			<field name="body" access="pub" jdoc=""/>
			<field name="exception" access="pub" jdoc=""/>
			<field name="Catch" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Try.Try(sandmark.util.javagen.List, String, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="body"/>
				<param name="exception"/>
				<param name="Catch"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Try.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Try.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<comm cntt="The exception is on the stack when entering"/>
				<comm cntt="the catch block. Pop it."/>
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Try.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="The exception is on the stack when entering"/>
				<comm cntt="the catch block. Pop it."/>
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Statement" intfc="n" abs="y" inn="n" sloc="8" jdoc="">
			<mth name="/:sandmark.util.javagen.Statement.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Statement.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cl"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.AssignField" intfc="n" abs="n" inn="n" sloc="53" jdoc="">
			<field name="left" access="pub" jdoc=""/>
			<field name="right" access="pub" jdoc=""/>
			<field name="Class" access="pub" jdoc=""/>
			<field name="field" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.AssignField.AssignField(sandmark.util.javagen.Expression, String, String, String, sandmark.util.javagen.Expression)" access="pub" jdoc="">
				<param name="left"/>
				<param name="Class"/>
				<param name="field"/>
				<param name="type"/>
				<param name="right"/>
			</mth>
			<mth name="/:sandmark.util.javagen.AssignField.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.AssignField.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.AssignField.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Class" intfc="n" abs="n" inn="n" sloc="121" jdoc="">
			<field name="parent" access="pub" jdoc=""/>
			<field name="name" access="pub" jdoc=""/>
			<field name="Package" access="pub" jdoc=""/>
			<field name="fields" access="pub" jdoc=""/>
			<field name="methods" access="pub" jdoc=""/>
			<field name="attributes" access="pub" jdoc=""/>
			<field name="staticStats" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Class.Class(String, String, sandmark.util.javagen.List, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="name"/>
				<param name="fields"/>
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Class.Class(String, String, String, sandmark.util.javagen.List, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="name"/>
				<param name="Package"/>
				<param name="fields"/>
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Class.addStaticStat(sandmark.util.javagen.Statement)" access="pub" jdoc="">
				<param name="stat"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Class.createStaticMethod()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.Class.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Class.toByteCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.Class.toCode(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="org.apache.bcel.generic.ClassGen cg = new org.apache.bcel.generic.ClassGen( class_name, super_class_name, file_name,class_name, access_flags, interfaces); sandmark.program.LocalClass cl = new sandmark.program.LocalClass(app,cg.getJavaClass());"/>
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.NewArray" intfc="n" abs="n" inn="n" sloc="40" jdoc="">
			<field name="count" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.NewArray.NewArray(String, int)" access="pub" jdoc="">
				<param name="type"/>
				<param name="count"/>
			</mth>
			<mth name="/:sandmark.util.javagen.NewArray.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.NewArray.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.NewArray.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Test" intfc="n" abs="n" inn="n" sloc="240" jdoc="">
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<comm cntt="=================================================================="/>
			<field name="stats" access="pub" jdoc=""/>
			<field name="Int55" access="pub" jdoc=""/>
			<field name="Int66" access="pub" jdoc=""/>
			<field name="Int77" access="pub" jdoc=""/>
			<field name="Int88" access="pub" jdoc=""/>
			<field name="Int99" access="pub" jdoc=""/>
			<field name="dynamicAttributes" access="pub" jdoc=""/>
			<field name="staticAttributes" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Test.printInteger(sandmark.util.javagen.Expression)" access="pub" jdoc="">
				<comm cntt="java.lang.System.out.println(&amp;lt;expr&amp;gt;.toString());"/>
				<param name="expr"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.dumpClass(sandmark.util.javagen.List, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="fields"/>
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeLocals()" access="pub" jdoc="">
				<comm cntt="Local variables."/>
				<comm cntt="java.lang.Integer L1 = new java.lang.Integer(55);"/>
				<comm cntt="java.lang.Integer L2 = new java.lang.Integer(66);"/>
				<comm cntt="java.lang.Integer L3 = (java.lang.Integer)L1;"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeCall1()" access="pub" jdoc="">
				<comm cntt="Virtual function calls."/>
				<comm cntt="java.lang.System.out.println(L1.toString());"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeBranches()" access="pub" jdoc="">
				<comm cntt="Branches."/>
				<comm cntt="java.lang.Integer L4 = (L1 != null)?L2:L3;"/>
				<comm cntt="if (L1 != null)"/>
				<comm cntt="java.lang.Integer L5 = new java.lang.Integer(77);"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeFields()" access="pub" jdoc="">
				<comm cntt="Declare and reference class fields."/>
				<comm cntt="public java.lang.Integer F1;"/>
				<comm cntt="public static java.lang.Integer F2;"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeAssignStaticField()" access="pub" jdoc="">
				<comm cntt="MyClass.F2 = L2;"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeCall2()" access="pub" jdoc="">
				<comm cntt="java.lang.System.out.println(MyClass.F2.toString());"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeNew()" access="pub" jdoc="">
				<comm cntt="MyClass L7 = new MyClass();"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeAssignDynamicField()" access="pub" jdoc="">
				<comm cntt="L7.F1 = L1;"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeCall3()" access="pub" jdoc="">
				<comm cntt="java.lang.System.out.println(L7.F1.toString());"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeCall4()" access="pub" jdoc="">
				<comm cntt="java.lang.System.out.println(MyClass.F2.toString());"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeNewArray()" access="pub" jdoc="">
				<comm cntt="MyClass.F3 = new java.lang.Integer[10];"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeAssignIndex()" access="pub" jdoc="">
				<comm cntt="MyClass.F3[3] = new java.lang.Integer(88);"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeCall5()" access="pub" jdoc="">
				<comm cntt="java.lang.System.out.println(MyClass.F3[3].toString());"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeStaticCall1()" access="pub" jdoc="">
				<comm cntt="java.lang.System.out.println(MyClass.F3[3].toString());"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeTry()" access="pub" jdoc="">
				<comm cntt="try {"/>
				<comm cntt="java.lang.System.out.println(MyClass.F3[3].toString());"/>
				<comm cntt="java.lang.System.out.println(MyClass.F2.toString());"/>
				<comm cntt="} catch (Exception e) {"/>
				<comm cntt="}"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Test.makeStaticInitializer()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.Test.main(String[])" access="pub" jdoc="">
				<param name="sargs"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.StaticCall" intfc="n" abs="n" inn="n" sloc="87" jdoc="">
			<field name="Class" access="pub" jdoc=""/>
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="args" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.StaticCall.StaticCall(String, String, String, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticCall.StaticCall(String, String, String, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="arg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticCall.StaticCall(String, String, String)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticCall.StaticCall(String, String, String, sandmark.util.javagen.Java, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="arg1"/>
				<param name="arg2"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticCall.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticCall.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.StaticCall.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Cast" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<field name="expr" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Cast.Cast(String, sandmark.util.javagen.Expression)" access="pub" jdoc="">
				<param name="typeName"/>
				<param name="expr"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Cast.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Cast.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Cast.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Discard" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<field name="expr" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Discard.Discard(sandmark.util.javagen.Expression)" access="pub" jdoc="">
				<param name="expr"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Discard.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Discard.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Discard.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.VirtualCall" intfc="n" abs="n" inn="n" sloc="97" jdoc="">
			<field name="Class" access="pub" jdoc=""/>
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="obj" access="pub" jdoc=""/>
			<field name="args" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.VirtualCall.VirtualCall(sandmark.util.javagen.Expression, String, String, String, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="obj"/>
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualCall.VirtualCall(sandmark.util.javagen.Expression, String, String, String, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="obj"/>
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="arg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualCall.VirtualCall(sandmark.util.javagen.Expression, String, String, String)" access="pub" jdoc="">
				<param name="obj"/>
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualCall.VirtualCall(sandmark.util.javagen.Expression, String, String, String, sandmark.util.javagen.Java, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="obj"/>
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="arg1"/>
				<param name="arg2"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualCall.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualCall.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.VirtualCall.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.CondNotNullExpr" intfc="n" abs="n" inn="n" sloc="62" jdoc="">
			<field name="cond" access="pub" jdoc=""/>
			<field name="expr1" access="pub" jdoc=""/>
			<field name="expr2" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.CondNotNullExpr.CondNotNullExpr(sandmark.util.javagen.Expression, sandmark.util.javagen.Expression, sandmark.util.javagen.Expression, String)" access="pub" jdoc="">
				<param name="cond"/>
				<param name="expr1"/>
				<param name="expr2"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.CondNotNullExpr.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.CondNotNullExpr.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.CondNotNullExpr.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.FieldRef" intfc="n" abs="n" inn="n" sloc="43" jdoc="">
			<field name="left" access="pub" jdoc=""/>
			<field name="field" access="pub" jdoc=""/>
			<field name="Class" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.FieldRef.FieldRef(sandmark.util.javagen.Expression, String, String, String)" access="pub" jdoc="">
				<param name="left"/>
				<param name="Class"/>
				<param name="field"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.javagen.FieldRef.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.FieldRef.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.FieldRef.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Comment" intfc="n" abs="n" inn="n" sloc="19" jdoc="">
			<field name="code" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.Comment.Comment(String)" access="pub" jdoc="">
				<param name="code"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Comment.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Comment.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Comment.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.LiteralInt" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<field name="value" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.LiteralInt.LiteralInt(int)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LiteralInt.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LiteralInt.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.LiteralInt.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.Null" intfc="n" abs="n" inn="n" sloc="24" jdoc="">
			<mth name="/:sandmark.util.javagen.Null.Null()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.Null.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Null.toByteCode(org.apache.bcel.generic.ClassGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.javagen.Null.toCode(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<param name="cg"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.javagen.List" intfc="n" abs="n" inn="n" sloc="96" jdoc="">
			<field name="list" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.javagen.List.List()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.List.List(sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.List(sandmark.util.javagen.Java, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.List(sandmark.util.javagen.Java, sandmark.util.javagen.Java, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
				<param name="r3"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.List(sandmark.util.javagen.Java, sandmark.util.javagen.Java, sandmark.util.javagen.Java, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
				<param name="r3"/>
				<param name="r4"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.cons(sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="r1"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.cons(sandmark.util.javagen.Java, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.cons(sandmark.util.javagen.Java, sandmark.util.javagen.Java, sandmark.util.javagen.Java)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
				<param name="r3"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.cons(List)" access="pub" jdoc="">
				<param name="l1"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.car()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.List.size()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.List.cons(List, List)" access="pub" jdoc="">
				<param name="l1"/>
				<param name="l2"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.cons(List, List, List)" access="pub" jdoc="">
				<param name="l1"/>
				<param name="l2"/>
				<param name="l3"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.iterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.javagen.List.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.util.javagen.List.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.newexprtree">
		<class name="/:sandmark.util.newexprtree.ComputeExprTree" intfc="n" abs="n" inn="n" sloc="591" jdoc="ExprTree is a utility that creates expression tree for all blocks in the controlflowgraph. It creates expression tree by adding edges between the instruction that consumes elements from the stack and the instructions which produce those element on the stack. @author Kamlesh Kantilal (kamlesh@cs.arizona.edu)">
			<comm cntt="public String toString() { String S=&amp;quot;START of Method&amp;quot;; sandmark.analysis.controlflowgraph.MethodCFG myGr; java.util.ArrayList Grlist; for(int j=0; j&amp;lt;cfg.nodes().size(); j++) { Grlist=(java.util.ArrayList) BToL.get(cfg.nodes().get(j)); for(int k=0;k&amp;lt;Grlist.size();k++) { myGr=(sandmark.analysis.controlflowgraph.MethodCFG)Grlist.get(k); for(int i=0;i&amp;lt;getRootNodes(myGr).size();i++) { S+=doPrintPostOrder((sandmark.util.newexprtree.Node) getRootNodes(myGr).get(i),0,2); } S+=&amp;quot;\nEnd Tree\n&amp;quot;; } S+=&amp;quot;---------End of BLk---------\n&amp;quot;; } return S; }"/>
			<comm cntt="It returns the node associated with an instruction"/>
			<comm cntt="It returns the instruction associated with a node"/>
			<field name="myCpg" access="pub" jdoc=""/>
			<field name="cfg" access="pub" jdoc=""/>
			<field name="il" access="pub" jdoc=""/>
			<field name="ih" access="pub" jdoc=""/>
			<field name="curr" access="pub" jdoc=""/>
			<field name="block" access="pub" jdoc=""/>
			<field name="IToN" access="pub" jdoc=""/>
			<field name="NToI" access="pub" jdoc=""/>
			<field name="NToInfo" access="pub" jdoc=""/>
			<field name="BToG" access="pub" jdoc=""/>
			<field name="BToL" access="pub" jdoc=""/>
			<field name="st" access="pub" jdoc=""/>
			<field name="ihandle" access="pub" jdoc=""/>
			<field name="gn" access="pub" jdoc=""/>
			<field name="cn" access="pub" jdoc=""/>
			<field name="gr" access="pub" jdoc=""/>
			<field name="ilist" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.ComputeExprTree(sandmark.program.Method, sandmark.analysis.controlflowgraph.MethodCFG)" access="pub" jdoc="Constructs an expression tree for a method represented by some method control flow graph. @param m - the method to analyze @param cpg - the ConstantPoolGen created from the class that this method is in @param cfg - the controlflowgraph of that method">
				<comm cntt="cfg=method.getCFG();"/>
				<param name="method"/>
				<param name="mcfg"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.initialize()" access="priv" jdoc="">
				<comm cntt="converts a single forest into multiple graph"/>
				<comm cntt="Fills in BToL"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.add(int)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;ihandle====&amp;quot;+ihandle+&amp;quot;kk&amp;quot;+j);"/>
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.doBlock()" access="priv" jdoc="">
				<comm cntt="if(block.getIH()==null) return;"/>
				<comm cntt="context.pop();"/>
				<comm cntt="context.pop();"/>
				<comm cntt="do nothing"/>
				<comm cntt="context.pop();"/>
				<comm cntt="context.pop(); remove object ref"/>
				<comm cntt="no break here on purpose!"/>
				<comm cntt="context.pop(); value for put"/>
				<comm cntt="context.pop(); object ref"/>
				<comm cntt="no break here on purpose!"/>
				<comm cntt="context.pop(); extra for object ref"/>
				<comm cntt="no break here on purpose"/>
				<comm cntt="pop the arguments"/>
				<comm cntt="DO NOTHING"/>
				<comm cntt="DO NOTHING"/>
				<comm cntt="END of FOR"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.doStack(org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<comm cntt="new code"/>
				<comm cntt="new code"/>
				<param name="instH"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.doArithmetic(org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<comm cntt="if(((org.apache.bcel.generic.StackConsumer)inst).consumeStack (myCpg) == 1){ add(1); } else{ add(2); }"/>
				<comm cntt="added newly"/>
				<param name="instH"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.doArray(org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.display()" access="pub" jdoc="">
				<comm cntt="java.util.List succ = block.getSuccessors();"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.toString()" access="pub" jdoc="Returns the String representation of the expression tree of all the blocks in the CFG.">
				<comm cntt="display();"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.doPrintPostOrder(sandmark.util.newexprtree.Node, int, int)" access="priv" jdoc="">
				<param name="myGn"/>
				<param name="level"/>
				<param name="up"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.toString(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="Returns the String representation of a particular expression tree. @param myGr a graph representing the expression tree">
				<param name="myGr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.toString(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="Returns the String representation of all expression trees within a block. @param bblock a basic block whose representation is needed">
				<param name="bblock"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.getInstList(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="Returns the instruction handle list(list of &amp;quot;org.apache.bcel.generic.InstructionHandle&amp;quot; ) associated with a particular expression tree. @param dg a graph representing the expression tree">
				<param name="dg"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.getRootNodes(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="dg"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.generateGraph(java.util.ArrayList)" access="priv" jdoc="">
				<comm cntt="sort based on position"/>
				<comm cntt="TO add Edges to the new set of graph"/>
				<param name="newmygrlist"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.blockToGrlist(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="Returns a list of sandmark.util.newgraph.MutableGraph representing the expression trees associated with a basicblock @param block a basicblock whose expression tree list is needed">
				<comm cntt="check for il==null"/>
				<param name="block"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.nodeToInfo(sandmark.util.newexprtree.Node)" access="pub" jdoc="Returns the sandmark.util.newexprtree.NodeInfo associated with a sandmark.util.newexprtree.Node . @param tempgn a node in the expression tree whose corresponding information is desired">
				<param name="tempgn"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.iToNode(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree.nodeToI(sandmark.util.newexprtree.Node)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
		<class name="/:sandmark.util.newexprtree.ComputeExprTree$NodeComparator" intfc="n" abs="n" inn="y" sloc="22" jdoc="">
			<field name="NToInfo" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree$NodeComparator.NodeComparator(java.util.HashMap)" access="pub" jdoc="">
				<param name="tt"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree$NodeComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ComputeExprTree$GraphComparator" intfc="n" abs="n" inn="y" sloc="36" jdoc="">
			<field name="nc" access="pub" jdoc=""/>
			<field name="NToInfo" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree$GraphComparator.GraphComparator(java.util.HashMap)" access="pub" jdoc="">
				<param name="tt"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComputeExprTree$GraphComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="gr1"/>
				<param name="gr2"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newexprtree.ExprTreeCFG" intfc="n" abs="n" inn="n" sloc="1651" jdoc="This class is a CFG of expression trees. Each basic block is made up of a sequential list of expression trees (Expr objects) that represent the actions of the code. The actual nodes in this graph are ArrayLists of Exprs. The edges are those used in MethodCFG (i.e. EdgeImpl, FallthroughEdge, and ExceptionEdge). This class does not rely on InstructionHandles, so it must make copies of the CodeExceptionGen information. These are encapsulated in the ExceptionInfo class. For each CodeExceptionGen in the original method, there will be a corresponding ExceptionInfo instance in this graph, pointing to the target Exprs rather than the target handles. When re-creating the method (rewriteMethod), the old CodeExceptionGens are scrapped and re-created based on the ExceptionInfos. Also, the LocalVariable and LineNumber tables must be scrapped. As soon as an ExprTreeCFG instance is created, the method&amp;apos;s instruction list may be altered.">
			<comm cntt="add the nodes and edges to this graph"/>
			<comm cntt="helper method, just so that buildTrees doesn&amp;apos;t get ginormous."/>
			<comm cntt="this handles arithmetic exprs."/>
			<comm cntt="helper method, so that buildTrees doesn&amp;apos;t get ginormous."/>
			<comm cntt="this one handles array instructions (load and store)"/>
			<comm cntt="builds the trees for each basic block."/>
			<comm cntt="returns an array that will be parallel to &amp;apos;blocks&amp;apos;"/>
			<comm cntt="helper method for fixInstructions"/>
			<field name="method" access="priv" jdoc=""/>
			<field name="ilist" access="priv" jdoc=""/>
			<field name="maxlocals" access="priv" jdoc=""/>
			<field name="source" access="priv" jdoc=""/>
			<field name="sink" access="priv" jdoc=""/>
			<field name="exceptionInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.ExprTreeCFG(sandmark.program.Method)" access="pub" jdoc="Builds an ExprTreeCFG for the given method.">
				<comm cntt="the list of handles making up the blocks, in top-down order."/>
				<comm cntt="copy out the handle indexes for each exception handler"/>
				<comm cntt="add the arraylist nodes to this graph, and build the edges between them."/>
				<comm cntt="get the Expr trees that correspond to the basic blocks."/>
				<comm cntt="(this array is parallel to &amp;apos;blocks&amp;apos;, and we make use of that fact)"/>
				<comm cntt="create the ExceptionInfo instances, now that we have the trees."/>
				<comm cntt="right now the nodes are ArrayLists of handles..."/>
				<comm cntt="replace them with ArrayLists of Exprs, leaving the edges the same."/>
				<param name="_method"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.getExceptionHandlers()" access="pub" jdoc="Returns the exception handlers for this method.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.fixGraph(BasicBlock[], java.util.ArrayList[], java.util.ArrayList, java.util.ArrayList)" access="priv" jdoc="This method replaces the handle list nodes with Expr list nodes, and sets branch targets correctly. &amp;apos;treelists&amp;apos; and &amp;apos;blocks&amp;apos; are parallel arrays.">
				<comm cntt="reset BranchExpr targets"/>
				<comm cntt="now we&amp;apos;re basically done... replace the blocks in the"/>
				<comm cntt="graph with their corresponding trees"/>
				<comm cntt="save the edges (we&amp;apos;re about to clear the graph!)"/>
				<comm cntt="clear the graph!"/>
				<comm cntt="add back in the source and sink"/>
				<comm cntt="add back in"/>
				<comm cntt="find the new source for this edge"/>
				<comm cntt="find the new sink for this edge"/>
				<comm cntt="replace the edge with an equivalent one"/>
				<param name="treelists"/>
				<param name="blocks"/>
				<param name="sourceList"/>
				<param name="sinkList"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.buildBlocks()" access="priv" jdoc="Chunks up the method into basic blocks. We ignore some of the division that would happen inside exception handlers, after each ExceptionThrower. This must be called after fixInstructions, not before.">
				<comm cntt="will be the set of leaders"/>
				<comm cntt="all &amp;apos;try&amp;apos; blocks are leaders and all &amp;apos;handler&amp;apos; blocks are leaders"/>
				<comm cntt="the master list of basic blocks (an ArrayList of ArrayLists of handles)"/>
				<comm cntt="branch targets are leaders"/>
				<comm cntt="instrucions after branches are leaders"/>
				<comm cntt="instructions after unconditional control jumps are leaders"/>
				<comm cntt="identified all leaders, now start chunking!"/>
				<comm cntt="if the last block has stuff in it, make it another block"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.buildEdges(java.util.ArrayList[], java.util.ArrayList, java.util.ArrayList)" access="priv" jdoc="">
				<comm cntt="Select"/>
				<comm cntt="stupid version"/>
				<comm cntt="not a control-transfer instruction"/>
				<param name="blocks"/>
				<param name="sourceList"/>
				<param name="sinkList"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.buildArithmetic(org.apache.bcel.generic.Instruction, java.util.ArrayList, java.util.Stack)" access="priv" jdoc="">
				<comm cntt="got the type now"/>
				<param name="inst"/>
				<param name="result"/>
				<param name="stack"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.buildArray(org.apache.bcel.generic.Instruction, java.util.ArrayList, java.util.Stack)" access="priv" jdoc="">
				<param name="inst"/>
				<param name="result"/>
				<param name="stack"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.buildTrees(java.util.ArrayList[])" access="priv" jdoc="">
				<comm cntt="if this block starts a subroutine or a handler,"/>
				<comm cntt="push the magic value into the stack"/>
				<comm cntt="simulate instructions"/>
				<comm cntt="Select"/>
				<comm cntt="StoreInstruction"/>
				<comm cntt="end for each instruction"/>
				<comm cntt="end for each block"/>
				<param name="blocks"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.rewriteMethod()" access="pub" jdoc="Recreates the bytecode and exception handlers based on the expression trees.">
				<comm cntt="java.util.IdentityHashMap block2fallthroughto = new java.util.IdentityHashMap(); java.util.IdentityHashMap block2fallthroughfrom = new java.util.IdentityHashMap(); for (java.util.Iterator edgeiter=edges();edgeiter.hasNext();){ sandmark.util.newgraph.Edge edge = (sandmark.util.newgraph.Edge)edgeiter.next(); if (edge instanceof sandmark.analysis.controlflowgraph.FallthroughEdge){ block2fallthroughto.put(edge.sourceNode(), edge.sinkNode()); block2fallthroughfrom.put(edge.sinkNode(), edge.sourceNode()); } }"/>
				<comm cntt="foreach Expr in block"/>
				<comm cntt="now find who else can be written"/>
				<comm cntt="fix branch targets"/>
				<comm cntt="fix exception handlers"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.mapType(org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.fixInstructions(sandmark.analysis.stacksimulator.StackSimulator)" access="priv" jdoc="This is a first pass over the instructions of a method, to do a few things: 1. get rid of all stack instructions (DUP, POP, SWAP, etc). 2. put store load right after all invokes that have return values. (this will make sure that they are not reordered in the Expr tree). This cleans up the tree-making immensely.">
				<comm cntt="for each nonvoid INVOKE, immediately store, then load again."/>
				<comm cntt="replace DUP and SWAP with a combination of loads and stores"/>
				<comm cntt="1, 2"/>
				<comm cntt="1, 1, 1"/>
				<comm cntt="2,2 or 1,1,2"/>
				<comm cntt="2,2"/>
				<comm cntt="1,1,2"/>
				<comm cntt="2,1,1 or 1,1,1,1"/>
				<comm cntt="2,1,1"/>
				<comm cntt="1,1,1,1"/>
				<comm cntt="2"/>
				<comm cntt="1,1"/>
				<param name="stack"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeCFG.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ComparisonExpr" intfc="n" abs="n" inn="n" sloc="56" jdoc="Represents an operation that compares two values and leaves a boolean result on the stack. ComparisonExpr.getType() returns Type.INT. Emits: DCMPL, DCMPG, FCMPL, FCMPG, LCMP.">
			<field name="code" access="priv" jdoc=""/>
			<field name="left" access="priv" jdoc=""/>
			<field name="right" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ComparisonExpr.ComparisonExpr(ValueExpr, ValueExpr, short)" access="pub" jdoc="Constructs a ComparisonExpr with the given operands, and the comparison type. @param _left the &amp;apos;left&amp;apos; or first operand. @param _right the &amp;apos;right&amp;apos; or second operand. @param _code the type of comparison to do (one of Constants.DCMPL, Constants.DCMPG, Constants.FCMPL, Constants.FCMPG, Constants.LCMP).">
				<param name="_left"/>
				<param name="_right"/>
				<param name="_code"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComparisonExpr.getLeftValue()" access="pub" jdoc="Returns the &amp;apos;left&amp;apos; or first operand.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComparisonExpr.setLeftValue(ValueExpr)" access="pub" jdoc="Sets the left value">
				<param name="_left"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComparisonExpr.getRightValue()" access="pub" jdoc="Returns the &amp;apos;right&amp;apos; or second operand.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComparisonExpr.setRightValue(ValueExpr)" access="pub" jdoc="Sets the right value">
				<param name="_right"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComparisonExpr.getCode()" access="pub" jdoc="Returns the comparison type code value.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComparisonExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ComparisonExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.InstanceofExpr" intfc="n" abs="n" inn="n" sloc="29" jdoc="Performs the instanceof test on a reference. InstanceofExpr.getType() return Type.INT. Emits: INSTANCEOF.">
			<field name="ref" access="priv" jdoc=""/>
			<field name="totype" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.InstanceofExpr.InstanceofExpr(ValueExpr, org.apache.bcel.generic.ReferenceType)" access="pub" jdoc="Constructs an InstanceofExpr with the given value to test and type. @param _ref the reference value to test. @param type the target type.">
				<param name="_ref"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.InstanceofExpr.getTestValue()" access="pub" jdoc="Returns the reference to be tested.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InstanceofExpr.setTestValue(ValueExpr)" access="pub" jdoc="Sets the value to test.">
				<param name="test"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.InstanceofExpr.getTestType()" access="pub" jdoc="Returns the target type of the INSTANCEOF.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InstanceofExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InstanceofExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.BinaryArithmeticExpr" intfc="n" abs="n" inn="n" sloc="87" jdoc="Represents a binary arithmetic operation (i.e. ADD). If you merely specify the type and the operation class, this uniquely determines which bytecode instruction to emit later. Emits: DADD, DSUB, DMUL, DDIV, DREM, FADD, FSUB, FMUL, FDIV, FREM, IADD, ISUB, IMUL, IDIV, IREM, IAND, IOR, IXOR, ISHL, ISHR, IUSHR, LADD, LSUB, LMUL, LDIV, LREM, LAND, LOR, LXOR, LSHL, LSHR, LUSHR.">
			<field name="OPS" access="priv" jdoc=""/>
			<field name="left" access="priv" jdoc=""/>
			<field name="right" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.BinaryArithmeticExpr.BinaryArithmeticExpr(org.apache.bcel.generic.BasicType, int, ValueExpr, ValueExpr)" access="pub" jdoc="Creates a BinaryArithmeticExpr with the given operand types, operator code, and child expressions. @param type the type of the operands involved. @param binoptype the operator code (one of the constants defined in ArithmeticExpr). @param _left the &amp;apos;left&amp;apos; or first operand. @param _right the &amp;apos;right&amp;apos; or second operand.">
				<param name="type"/>
				<param name="binoptype"/>
				<param name="_left"/>
				<param name="_right"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.BinaryArithmeticExpr.getLeftValue()" access="pub" jdoc="Returns the &amp;apos;left&amp;apos; or first operand of this operation.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.BinaryArithmeticExpr.setLeftValue(ValueExpr)" access="pub" jdoc="Sets the left value">
				<param name="_left"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.BinaryArithmeticExpr.getRightValue()" access="pub" jdoc="Returns the &amp;apos;right&amp;apos; or second operand of this operation.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.BinaryArithmeticExpr.setRightValue(ValueExpr)" access="pub" jdoc="Sets the right value">
				<param name="_right"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.BinaryArithmeticExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.BinaryArithmeticExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ConversionExpr" intfc="n" abs="n" inn="n" sloc="82" jdoc="Represents the conversion of one type to another, either BasicType-to-BasicType or ReferenceType-to-ReferenceType. ConversionExpr.getType() will return the convert-to type (the target type). Emits D2F, D2I, D2L, F2D, F2I, F2L, L2D, L2F, L2I, I2D, I2F, I2L, I2S, I2B, I2C, and CHECKCAST.">
			<field name="OPS" access="priv" jdoc=""/>
			<field name="from" access="priv" jdoc=""/>
			<field name="totype" access="priv" jdoc=""/>
			<field name="fromtype" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ConversionExpr.ConversionExpr(ValueExpr, org.apache.bcel.generic.BasicType, org.apache.bcel.generic.BasicType)" access="pub" jdoc="Makes a new ConversionExpr between fromtype and totype (both assumed to be BasicTypes) @param _from the ValueExpr that is being converted. @param _fromtype the type of _from (should be equal to _from.getType()). @param _totype the type to convert to">
				<param name="_from"/>
				<param name="_fromtype"/>
				<param name="_totype"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ConversionExpr.ConversionExpr(ValueExpr, org.apache.bcel.generic.ReferenceType, org.apache.bcel.generic.ReferenceType)" access="pub" jdoc="Makes a new ConversionExpr between fromtype and totype (both assumed to be ReferenceTypes) @param _from the ValueExpr that is being converted. @param _fromtype the type of _from (should be equal to _from.getType()). (this value is mostly unnecessary and can easily be filled in with Type.OBJECT) @param _totype the type to convert to">
				<param name="_from"/>
				<param name="_fromtype"/>
				<param name="_totype"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ConversionExpr.getToType()" access="pub" jdoc="Returns the type to convert TO.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ConversionExpr.getFromType()" access="pub" jdoc="Returns the type to convert FROM.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ConversionExpr.getConvertValue()" access="pub" jdoc="The ValueExpr being converted.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ConversionExpr.setConvertValue(ValueExpr)" access="pub" jdoc="Sets the value being converted">
				<param name="conv"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ConversionExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ConversionExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<comm cntt="CHECKCAST"/>
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.IfExpr" intfc="n" abs="n" inn="n" sloc="157" jdoc="Represents a conditional branch operation. Conditional branches will take either one or two operands. If the branch takes only one, it will be considered the &amp;apos;right&amp;apos; operand. Emits: IF_ACMPEQ, IF_ACMPNE, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE, IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, IFNONNULL, IFNULL.">
			<comm cntt="package"/>
			<comm cntt="package"/>
			<field name="left" access="priv" jdoc=""/>
			<field name="right" access="priv" jdoc=""/>
			<field name="code" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.IfExpr.isOneArg(short)" access="priv" jdoc="">
				<param name="code"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.isTwoArg(short)" access="priv" jdoc="">
				<param name="code"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.IfExpr(short, ValueExpr, ValueExpr, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="_code"/>
				<param name="_left"/>
				<param name="_right"/>
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.IfExpr(short, ValueExpr, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="_code"/>
				<param name="_right"/>
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.IfExpr(short, ValueExpr, ValueExpr, Expr)" access="pub" jdoc="Constructs an IfExpr for a conditional branch with two operands. @param _code the type of the if-statement. (one of IF_ACMPEQ, IF_ACMPNE, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE). @param _left the &amp;apos;left&amp;apos; or first operand. @param _right the &amp;apos;right&amp;apos; or second operand. @param target the branch target.">
				<param name="_code"/>
				<param name="_left"/>
				<param name="_right"/>
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.IfExpr(short, ValueExpr, Expr)" access="pub" jdoc="Constructs an IfExpr for a conditional branch with one operand. @param _code the type of the if-statement. (one of IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, IFNONNULL, IFNULL). @param _value the operand. @param target the branch target.">
				<param name="_code"/>
				<param name="value"/>
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.getCode()" access="pub" jdoc="Returns the if-statement type code.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.getRightTestValue()" access="pub" jdoc="Returns the &amp;apos;right&amp;apos; or second operand. If this is a single-operand if-statement, this returns the single operand.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.setRightTestValue(ValueExpr)" access="pub" jdoc="Sets the right operand value.">
				<param name="_right"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.getLeftTestValue()" access="pub" jdoc="Returns the &amp;apos;left&amp;apos; or first operand. If this is a singe-operand if-statement, this returns null.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.setLeftTestValue(ValueExpr)" access="pub" jdoc="Sets the left test value">
				<param name="_left"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.getTestValue()" access="pub" jdoc="Returns the operand of a 1-operand if-statement. If this is a 2-operand if-statement, this returns the &amp;apos;right&amp;apos; operand.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.setTestValue(ValueExpr)" access="pub" jdoc="Sets the test value for this if-statement">
				<param name="test"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.IfExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ArithmeticExpr" intfc="n" abs="y" inn="n" sloc="25" jdoc="Represents the entire range of arithmetic java instructions. There are 2 subclasses: BinaryArithmeticExpr and NegateArithmeticExpr (negation is the only unary operation). The integer constants defined in this class are used in BinaryArithmeticExpr.">
			<const name="ADD" access="pub" jdoc=""/>
			<const name="SUB" access="pub" jdoc=""/>
			<const name="MUL" access="pub" jdoc=""/>
			<const name="DIV" access="pub" jdoc=""/>
			<const name="REM" access="pub" jdoc=""/>
			<const name="NEG" access="pub" jdoc=""/>
			<const name="AND" access="pub" jdoc=""/>
			<const name="OR" access="pub" jdoc=""/>
			<const name="XOR" access="pub" jdoc=""/>
			<const name="SHL" access="pub" jdoc=""/>
			<const name="SHR" access="pub" jdoc=""/>
			<const name="USHR" access="pub" jdoc=""/>
			<field name="optype" access="priv" jdoc="This will be one of the predefined constants in this class."/>
			<mth name="/:sandmark.util.newexprtree.ArithmeticExpr.ArithmeticExpr(org.apache.bcel.generic.BasicType, int)" access="pub" jdoc="Creates an ArithmeticExpr. @param _type the result type of this operation. @param _optype one of the integer constants defined in this class.">
				<param name="_type"/>
				<param name="_optype"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArithmeticExpr.getOperatorType()" access="pub" jdoc="Returns the operator type (one of the constants defined in this class).">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.JsrExpr" intfc="n" abs="n" inn="n" sloc="17" jdoc="Represents a jump-to-subroutine operation. Emits: JSR_W.">
			<comm cntt="package"/>
			<mth name="/:sandmark.util.newexprtree.JsrExpr.JsrExpr(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.JsrExpr.JsrExpr(Expr)" access="pub" jdoc="">
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.JsrExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.JsrExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.NewExpr" intfc="n" abs="n" inn="n" sloc="15" jdoc="Represents the creation of a new non-array reference type. NewExpr.getType() returns the type of the new object. Emits: NEW">
			<mth name="/:sandmark.util.newexprtree.NewExpr.NewExpr(org.apache.bcel.generic.ObjectType)" access="pub" jdoc="Constructs a NewExpr for the given ObjectType.">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.NewExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NewExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.PutFieldExpr" intfc="n" abs="n" inn="n" sloc="61" jdoc="Represents storing a value into a field of a class. PutField.getType() returns the type of this field. Emits PUTFIELD, PUTSTATIC.">
			<field name="classname" access="priv" jdoc=""/>
			<field name="fieldname" access="priv" jdoc=""/>
			<field name="fieldtype" access="priv" jdoc=""/>
			<field name="ref" access="priv" jdoc=""/>
			<field name="value" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.PutFieldExpr(String, String, org.apache.bcel.generic.Type, ValueExpr, ValueExpr)" access="pub" jdoc="Constructs a PutFieldExpr for a non-static field. @param _classname the name of the class that owns this field. @param _fieldname the name of the field. @param _fieldtype the type of the field. @param _value the value to store into this field. @param _ref the class instance whose field gets changed.">
				<param name="_classname"/>
				<param name="_fieldname"/>
				<param name="_fieldtype"/>
				<param name="_value"/>
				<param name="_ref"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.PutFieldExpr(String, String, org.apache.bcel.generic.Type, ValueExpr)" access="pub" jdoc="Constructs a PutFieldExpr for static fields. @param _classname the name of the class that owns this field. @param _fieldname the name of the field. @param _fieldtype the type of the field. @param _value the value to store into this field.">
				<param name="_classname"/>
				<param name="_fieldname"/>
				<param name="_fieldtype"/>
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.getClassName()" access="pub" jdoc="Returns the name of the class owning this field.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.getFieldName()" access="pub" jdoc="Returns the name of the field.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.getFieldType()" access="pub" jdoc="Returns the type of the field (equal to getType()).">
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.getOwnerValue()" access="pub" jdoc="Returns the class instance that owns the field. If it is a static field, this returns null.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.setOwnerValue(ValueExpr)" access="pub" jdoc="Sets the reference on which this putfield works. Null implies static field.">
				<param name="owner"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.getFieldValue()" access="pub" jdoc="Returns the value to be assigned to the field.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.setFieldValue(ValueExpr)" access="pub" jdoc="Sets the value to be assigned to the field.">
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.PutFieldExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.BranchExpr" intfc="n" abs="y" inn="n" sloc="19" jdoc="Parent class for the branch operations. Branches have other Exprs as their targets. When a branch targets a given Expr, that means that when you reproduce the bytecode, the resulting branch instruction will target the first instruction generated by the target Expr. Initially, BranchExprs created by ExprTreeCFG will point to InstructionHandles, but only until they are patched with the corresponding Exprs. BranchExprs are the only mutable Exprs, since their targets can be changed.">
			<field name="handleTarget" access="prot" jdoc=""/>
			<field name="exprTarget" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.BranchExpr.BranchExpr(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.BranchExpr.BranchExpr(Expr)" access="pub" jdoc="">
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.BranchExpr.getHandleTarget()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.BranchExpr.setTarget(Expr)" access="pub" jdoc="Resets the target of this BranchExpr.">
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.BranchExpr.getTarget()" access="pub" jdoc="Returns the target expression of this BranchExpr.">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ExprTreeBlock" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<comm cntt="list of expression trees for block"/>
			<comm cntt="the MethodExprTree the block is associated with"/>
			<comm cntt="public methods"/>
			<field name="exprTreeList" access="pub" jdoc=""/>
			<field name="met" access="pub" jdoc=""/>
			<field name="bb" access="prot" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ExprTreeBlock.ExprTreeBlock(MethodExprTree, sandmark.analysis.controlflowgraph.BasicBlock)" access="prot" jdoc="This class contains all the expresssion trees associated within a basic blocks of the method">
				<param name="met"/>
				<param name="bb"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeBlock.getExprTrees()" access="pub" jdoc="Returns a list of the expression trees associated with this block.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeBlock.getMethodExprTree()" access="pub" jdoc="Returns the MethodExprTree this block is associated with.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeBlock.getBasicBlock()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeBlock.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.NodeInfo" intfc="n" abs="n" inn="n" sloc="59" jdoc="This class is used to get the information associated with each node in the expression tree. @author Kamlesh Kantilal (kamlesh@cs.arizona.edu)">
			<field name="ih" access="pub" jdoc=""/>
			<field name="cn" access="pub" jdoc=""/>
			<field name="gr" access="pub" jdoc=""/>
			<field name="outsideBlock" access="pub" jdoc=""/>
			<field name="mark" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.NodeInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.setIH(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="ihandle"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.getIH()" access="pub" jdoc="Returns the instruction handle associated with this node in the expression tree If a node is outside the basic block it is set to null">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.setGraph(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="grh"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.getGraph()" access="pub" jdoc="Returns the graph associated with this node in the expression tree">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.setContext(sandmark.analysis.stacksimulator.Context)" access="pub" jdoc="">
				<param name="context"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.getContext()" access="pub" jdoc="Returns the context provided by stack simulator for the instruction associated with this node in the expression tree">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.setOutsideBlock()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.isOutsideBlock()" access="pub" jdoc="Returns whether this node is associated with an instruction outside the basic block">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.isMarked()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.setMark()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NodeInfo.clearMark()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ArrayLengthExpr" intfc="n" abs="n" inn="n" sloc="23" jdoc="Represents an operation to get the length of an array. ArraylengthExpr.getType() gives Type.INT. Emits: ARRAYLENGTH.">
			<field name="array" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ArrayLengthExpr.ArrayLengthExpr(ValueExpr)" access="pub" jdoc="Constructs an ArrayLengthExpr for the given array. @param _array the array whose length you want to find.">
				<param name="_array"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLengthExpr.getArrayValue()" access="pub" jdoc="Returns the array to measure.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLengthExpr.setArrayValue(ValueExpr)" access="pub" jdoc="">
				<param name="_array"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLengthExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLengthExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.MonitorExpr" intfc="n" abs="n" inn="n" sloc="29" jdoc="This class represents an operation involving monitors. Emits: MONITORENTER, MONITOREXIT.">
			<field name="entering" access="priv" jdoc=""/>
			<field name="ref" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.MonitorExpr.MonitorExpr(ValueExpr, boolean)" access="pub" jdoc="Constructs a MonitorExpr with the given reference to lock unlock and a flag value specifying whether to lock or unlock that reference. @param _ref the reference to lock unlock. @param _enter true iff the reference should be locked, false iff it should be unlocked.">
				<param name="_ref"/>
				<param name="_enter"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.MonitorExpr.getValue()" access="pub" jdoc="Returns the reference to be locked unlocked.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.MonitorExpr.setValue(ValueExpr)" access="pub" jdoc="Sets the reference to be locked unlocked.">
				<param name="lock"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.MonitorExpr.isEntering()" access="pub" jdoc="Returns true iff this Expr is going to lock the reference.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.MonitorExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.MonitorExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.BasicBlock" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<field name="instList" access="pub" jdoc=""/>
			<field name="fallthroughTo" access="pub" jdoc=""/>
			<field name="fallthroughFrom" access="pub" jdoc=""/>
			<field name="graph" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.BasicBlock.BasicBlock(ExprTreeCFG)" access="pub" jdoc="">
				<param name="_graph"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.BasicBlock.graph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.BasicBlock.getInstList()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.BasicBlock.addExpr(Expr)" access="pub" jdoc="">
				<param name="expr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.BasicBlock.setFallthrough(BasicBlock)" access="pub" jdoc="">
				<param name="fallthrough"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.BasicBlock.fallthrough()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.BasicBlock.fallthroughFrom()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.BasicBlock.getExpr()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ArrayLoadExpr" intfc="n" abs="n" inn="n" sloc="55" jdoc="Represents loading from an array. ArrayLoadExpr.getType() returns the array element type. Emits: AALOAD, BALOAD, CALOAD, DALOAD, FALOAD, IALOAD, LALOAD, SALOAD.">
			<field name="array" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="elementType" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ArrayLoadExpr.ArrayLoadExpr(org.apache.bcel.generic.Type, ValueExpr, ValueExpr)" access="pub" jdoc="Constructs an ArrayLoadExpr. @param element the element type of this array. @param _array the array reference. @param _index the index to load from.">
				<param name="element"/>
				<param name="_array"/>
				<param name="_index"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLoadExpr.getElementType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLoadExpr.getArrayValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLoadExpr.setArrayValue(ValueExpr)" access="pub" jdoc="">
				<param name="_array"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLoadExpr.getIndexValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLoadExpr.setIndexValue(ValueExpr)" access="pub" jdoc="">
				<param name="_index"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLoadExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayLoadExpr.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.NegateArithmeticExpr" intfc="n" abs="n" inn="n" sloc="41" jdoc="Represents an arithmetic negation of a number. Emits INEG, DNEG, FNEG, LNEG.">
			<field name="value" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.NegateArithmeticExpr.NegateArithmeticExpr(org.apache.bcel.generic.BasicType, ValueExpr)" access="pub" jdoc="Creates a NegateArithmeticExpr for the given type, to be applied to the given ValueExpr. @param type the type of _value (should equal _value.getType()). @param _value the value to be negated.">
				<param name="type"/>
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.NegateArithmeticExpr.getValue()" access="pub" jdoc="Returns the value to be negated.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NegateArithmeticExpr.setValue(ValueExpr)" access="pub" jdoc="Sets the value to be negated.">
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.NegateArithmeticExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NegateArithmeticExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.SwitchExpr" intfc="n" abs="n" inn="n" sloc="79" jdoc="Represents a switch statement. The &amp;apos;default&amp;apos; target of a switch statement is accessed with getTarget and setTarget (from BranchExpr). Emits: LOOKUPSWITCH, TABLESWITCH.">
			<comm cntt="package"/>
			<comm cntt="package"/>
			<field name="index" access="priv" jdoc=""/>
			<field name="matches" access="priv" jdoc=""/>
			<field name="handleTargets" access="priv" jdoc=""/>
			<field name="exprTargets" access="priv" jdoc=""/>
			<field name="islookupswitch" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.SwitchExpr(ValueExpr, int[], org.apache.bcel.generic.InstructionHandle[], org.apache.bcel.generic.InstructionHandle, boolean)" access="pub" jdoc="">
				<param name="_index"/>
				<param name="_matches"/>
				<param name="_targets"/>
				<param name="_target"/>
				<param name="islookup"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.SwitchExpr(ValueExpr, int[], Expr[], Expr, boolean)" access="pub" jdoc="Constructs a SwitchExpr. @param _index the value to switch on. @param _matches the list of cases to match. @param targets the list of targets for the cases (parallel array to matches). @param defaultExpr the &amp;apos;default&amp;apos; target. @param islookup true iff this hould be a LOOKUPSWITCH and not a TABLESWITCH.">
				<param name="_index"/>
				<param name="_matches"/>
				<param name="targets"/>
				<param name="defaultExpr"/>
				<param name="islookup"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.getHandleTargets()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.isLookupSwitch()" access="pub" jdoc="Returns true iff this is a LOOKUPSWITCH, not a TABLESWITCH.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.setTargets(Expr[])" access="pub" jdoc="Resets the list of targets for the cases (not the default case). This list must be exactly as long as the list of cases.">
				<param name="targets"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.setMatches(int[])" access="pub" jdoc="Sets the list of &amp;apos;case&amp;apos; labels. This array is parallel to the array of branch targets.">
				<param name="_matches"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.getTargets()" access="pub" jdoc="Returns the list of targets for the cases (not the default case).">
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.getIndexValue()" access="pub" jdoc="Returns the value to be switched on.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.setIndexValue(ValueExpr)" access="pub" jdoc="Sets the expression to be switched on.">
				<param name="_index"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.getMatches()" access="pub" jdoc="Returns the list of case labels.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.SwitchExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ValueExpr" intfc="n" abs="y" inn="n" sloc="9" jdoc="ValueExpr is the abstract parent of all Exprs that can put values onto the stack. Only a ValueExpr can be the child of another Expr. Every ValueExpr can tell you what type of value it will put on the stack.">
			<field name="type" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ValueExpr.ValueExpr(org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="_type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ValueExpr.getType()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.InvokeExpr" intfc="n" abs="n" inn="n" sloc="68" jdoc="Represents a method call operaton. InvokeExpr.getType() returns the return type of this method. NOTE: technically, void methods should not be ValueExprs since they do not put values onto the stack. this means that you could potentially have a void method be the operand of some other Expr. don&amp;apos;t do that. Emits: INVOKESPECIAL, INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL.">
			<field name="classname" access="priv" jdoc=""/>
			<field name="methodname" access="priv" jdoc=""/>
			<field name="methodsig" access="priv" jdoc=""/>
			<field name="args" access="priv" jdoc=""/>
			<field name="ref" access="priv" jdoc=""/>
			<field name="code" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.InvokeExpr(String, String, String, ValueExpr[], ValueExpr, short)" access="pub" jdoc="Constructs an InvokeExpr with the given classname, methodname, method signature, argument values, target reference, and invoke type. This constructor is not for use with static method calls. @param _classname the name of the class owning the method to call. @param _methodname the name of the method to call. @param _methodsig the method signature. @param _args the argument values to pass. @param _ref the reference to call the method on. @param _code one of Constants.INVOKESPECIAL, Constants.INVOKEINTERFACE, Constants.INVOKEVIRTUAL.">
				<param name="_classname"/>
				<param name="_methodname"/>
				<param name="_methodsig"/>
				<param name="_args"/>
				<param name="_ref"/>
				<param name="_code"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.InvokeExpr(String, String, String, ValueExpr[])" access="pub" jdoc="Constructs an InvokeExpr that represents a static method call. @param _classname the name of the class owning the method to call. @param _methodname the name of the method to call. @param _methodsig the method signature. @param _args the argument values to pass.">
				<param name="_classname"/>
				<param name="_methodname"/>
				<param name="_methodsig"/>
				<param name="_args"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.getClassName()" access="pub" jdoc="Returns the name of the class that owns the method to call.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.getMethodName()" access="pub" jdoc="Returns the name of the method to call.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.getReferenceValue()" access="pub" jdoc="Returns the reference on which this method is called. If this is a static method, returns null.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.setReferenceValue(ValueExpr)" access="pub" jdoc="Sets the reference to be invoked on.">
				<param name="_ref"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.getSignature()" access="pub" jdoc="Returns the signature of the method to call.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.getArgumentValues()" access="pub" jdoc="Returns the argument values to pass tothe method call.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.setArgumentValues(ValueExpr[])" access="pub" jdoc="">
				<param name="_args"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.getCode()" access="pub" jdoc="Returns the invoke type (INVOKESTATIC, INVOKESPECIAL, etc).">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.InvokeExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.StringConstantExpr" intfc="n" abs="n" inn="n" sloc="19" jdoc="Represents pushing a String literal constant onto the stack. StringConstantExpr.getType() return Type.STRING. Emits LDC.">
			<field name="value" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.StringConstantExpr.StringConstantExpr(String)" access="pub" jdoc="">
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.StringConstantExpr.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.StringConstantExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.StringConstantExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.NullConstantExpr" intfc="n" abs="n" inn="n" sloc="17" jdoc="An Expr that will put the null reference on the stack. NullConstantExpr.getType() gives Type.NULL. Emits ACONST_NULL.">
			<mth name="/:sandmark.util.newexprtree.NullConstantExpr.NullConstantExpr()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NullConstantExpr.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NullConstantExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NullConstantExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ConstantExpr" intfc="n" abs="y" inn="n" sloc="6" jdoc="Represents an instruction that will push a constant onto the stack (i.e. an int, float, double, long, String, or null). Constant expressions have no children expressions.">
			<mth name="/:sandmark.util.newexprtree.ConstantExpr.ConstantExpr(org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ConstantExpr.getValue()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ReturnAddressDummyExpr" intfc="n" abs="n" inn="n" sloc="8" jdoc="Represents a ReturnAddress value on the stack, as from a JSR instruction. ReturnAddressDummyExpr.getType() return ReturnaddressType.NO_TARGET.">
			<mth name="/:sandmark.util.newexprtree.ReturnAddressDummyExpr.ReturnAddressDummyExpr()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ReturnAddressDummyExpr.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ObjectDummyExpr" intfc="n" abs="n" inn="n" sloc="11" jdoc="Represents a dummy value of a reference type. This includes arrays, but arrays are more properly represented by ArrayDummyExpr.">
			<mth name="/:sandmark.util.newexprtree.ObjectDummyExpr.ObjectDummyExpr(org.apache.bcel.generic.ReferenceType)" access="pub" jdoc="Constructs a dummy Expr for the given ObjectType.">
				<param name="_type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ObjectDummyExpr.ObjectDummyExpr()" access="pub" jdoc="Constructs a dummy Expr for an unknown Object type (i.e. Type.OBJECT).">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ObjectDummyExpr.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.DependencyGraph" intfc="n" abs="n" inn="n" sloc="345" jdoc="">
			<comm cntt=""/>
			<comm cntt="public void writeback (sandmark.analysis.controlflowgraph.MethodCFG reorderGraph, java.util.HashMap NToG, org.apache.bcel.generic.InstructionHandle lastih) { java.util.ArrayList parse; java.util.ArrayList ilist; sandmark.analysis.controlflowgraph.MethodCFG myGr=null; sandmark.analysis.controlflowgraph.BasicBlock myGn=null; sandmark.analysis.controlflowgraph.MethodCFG tempGr; org.apache.bcel.generic.InstructionHandle ih1; org.apache.bcel.generic.InstructionHandle ih2; org.apache.bcel.generic.InstructionList myList; org.apache.bcel.generic.InstructionHandle myIh[]; int j; java.util.HashMap NToM=new java.util.HashMap(); for(int i=0;i&amp;lt;reorderGraph.nodes().size();i++) { NToM.put(reorderGraph.nodes().get(i),new Boolean(false)); } while(true) { parse=getTopological(reorderGraph,NToM); if(parse.size()==0) break; for(int i=0;i&amp;lt;parse.size();i++) { myGn=(sandmark.analysis.controlflowgraph.BasicBlock)parse.get(i); myGr=(sandmark.analysis.controlflowgraph.MethodCFG) NToG.get(parse.get(i)); ilist=et.getInstList(myGr); ih1=(org.apache.bcel.generic.InstructionHandle)ilist.get(0); for(j=0;j&amp;lt;parse.size();j++) { tempGr=(sandmark.analysis.controlflowgraph.MethodCFG) NToG.get(parse.get(j)); ilist=et.getInstList(tempGr); ih2=(org.apache.bcel.generic.InstructionHandle)ilist.get(0); if(ih1.getPosition()&amp;lt;ih2.getPosition()) break; } if(j==parse.size()) break; } NToM.put(myGn,new Boolean(true)); same myIh=il.getInstructionHandles(); ilist=et.getInstList(myGr); ih1=(org.apache.bcel.generic.InstructionHandle)ilist.get(0); ih2=(org.apache.bcel.generic.InstructionHandle)ilist.get(ilist.size()-1); System.out.println(&amp;quot;lastih &amp;quot;+lastih); if(lastih==null) { if(ih1==myIh[0]) { lastih=ih2; continue; } } if(lastih!=null &amp;&amp; lastih.getNext()==ih1) { lastih=ih2; continue; } if(lastih!=null) {il.redirectBranches(lastih.getNext(),ih1) ; } else {il.redirectBranches(myIh[0],ih1); } il.move(ih1,ih2,lastih); lastih=ih2; il.setPositions(true); il.update(); } } public java.util.ArrayList getTopological( sandmark.analysis.controlflowgraph.MethodCFG reorderGraph, java.util.HashMap NToM) { int j; java.util.ArrayList retlist= new java.util.ArrayList(); java.util.List succlist; sandmark.analysis.controlflowgraph.BasicBlock myGn; for(int i=0;i&amp;lt;reorderGraph.nodes().size();i++) { myGn=(sandmark.analysis.controlflowgraph.BasicBlock)reorderGraph.nodes().get(i); if( ((Boolean)NToM.get(myGn)).booleanValue()==true) continue; succlist=myGn.getSuccessors(); for(j=0;j&amp;lt;succlist.size();j++) if( ((Boolean)NToM.get(succlist.get(j))).booleanValue()==false) break; if(j==succlist.size()) retlist.add(myGn); } return retlist; }"/>
			<field name="cfg" access="pub" jdoc=""/>
			<field name="met" access="pub" jdoc=""/>
			<field name="il" access="pub" jdoc=""/>
			<field name="ih" access="pub" jdoc=""/>
			<field name="exceptions" access="pub" jdoc=""/>
			<field name="ihandle" access="pub" jdoc=""/>
			<field name="BToG" access="pub" jdoc=""/>
			<field name="NToG" access="pub" jdoc=""/>
			<field name="GToN" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.DependencyGraph(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="dependency Graph for each block"/>
				<comm cntt="System.out.println(et);"/>
				<comm cntt="System.out.println(et);"/>
				<comm cntt="createlist();"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getDependencyGraph(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="tempblock"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getExpressionTree(sandmark.util.newexprtree.Node)" access="pub" jdoc="">
				<param name="tempgn"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.getExpressionTree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.doMethod(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="java.util.ArrayList reorderlist;"/>
				<comm cntt="for(int j=0; j&amp;lt;myIh2.length; j++) System.out.println(&amp;quot;writingin in=&amp;quot;+myIh2[j]);"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.issubnull(sandmark.util.newexprtree.ExprTree)" access="pub" jdoc="">
				<param name="myGr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.adddependence(sandmark.util.newgraph.MutableGraph, sandmark.util.newexprtree.ExprTree, sandmark.util.newexprtree.Node, java.util.HashMap, java.util.HashMap, boolean, int)" access="pub" jdoc="">
				<comm cntt="lastGn=myGn;"/>
				<comm cntt="newly added"/>
				<param name="reorderGraph"/>
				<param name="myGr"/>
				<param name="lastGn"/>
				<param name="NToG"/>
				<param name="GToN"/>
				<param name="last"/>
				<param name="debug"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.callfunc(sandmark.util.newexprtree.ExprTree)" access="pub" jdoc="">
				<param name="tempGr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.refoutside(sandmark.util.newexprtree.ExprTree)" access="pub" jdoc="">
				<param name="tempGr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.dependence(sandmark.util.newexprtree.ExprTree, sandmark.util.newexprtree.ExprTree)" access="pub" jdoc="">
				<comm cntt="optimization new code"/>
				<comm cntt="end optimization new code"/>
				<comm cntt="ch"/>
				<comm cntt="ch"/>
				<comm cntt="check if needed ?"/>
				<comm cntt="if(in1 instanceof org.apache.bcel.generic.LSTORE || in1 instanceof org.apache.bcel.generic.DSTORE || in2 instanceof org.apache.bcel.generic.LSTORE || in2 instanceof org.apache.bcel.generic.DSTORE || in1 instanceof org.apache.bcel.generic.LLOAD || in1 instanceof org.apache.bcel.generic.DLOAD || in2 instanceof org.apache.bcel.generic.LLOAD || in2 instanceof org.apache.bcel.generic.DLOAD ) { System.out.println(&amp;quot;args LONG&amp;quot;); if( ((org.apache.bcel.generic.LocalVariableInstruction)in1).getIndex() != ((org.apache.bcel.generic.LocalVariableInstruction)in2).getIndex()) if( ((org.apache.bcel.generic.LocalVariableInstruction)in1).getIndex()+1 != ((org.apache.bcel.generic.LocalVariableInstruction)in2).getIndex()) if( ((org.apache.bcel.generic.LocalVariableInstruction)in1).getIndex()-1 != ((org.apache.bcel.generic.LocalVariableInstruction)in2).getIndex()) continue; } else"/>
				<comm cntt="System.out.println(&amp;quot;Dep=&amp;quot;+in1+&amp;quot; &amp; &amp;quot; + in2);"/>
				<comm cntt="System.out.println(&amp;quot;Dep=&amp;quot;+in1+&amp;quot; &amp; &amp;quot; + in2);"/>
				<param name="tempGr"/>
				<param name="myGr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.isequallist(java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<param name="i1"/>
				<param name="i2"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DependencyGraph.validity()" access="pub" jdoc="">
				<comm cntt="String S=&amp;quot;START of Method&amp;quot;;"/>
				<comm cntt="for(int l=0;l&amp;lt;i2.size();l++) { System.out.println( &amp;quot;u=&amp;quot;+(org.apache.bcel.generic.InstructionHandle)i1.get(l)); } for(int l=0;l&amp;lt;i2.size();l++) { System.out.println(&amp;quot;m=&amp;quot;+(org.apache.bcel.generic.InstructionHandle)i2.get(l)); }"/>
			</mth>
		<class name="/:sandmark.util.newexprtree.DependencyGraph$BlockComparator" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<mth name="/:sandmark.util.newexprtree.DependencyGraph$BlockComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newexprtree.NumericConstantExpr" intfc="n" abs="n" inn="n" sloc="23" jdoc="Represents pushing a numeric constant onto the stack. One of {int,float,double,long}. NumericConstantExpr.getType() returns the type of the constant. Emits BIPUSH, SIPUSH, ICONST , FCONST , DCONST , LCONST , LDC , LDC2_W">
			<field name="value" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.NumericConstantExpr.NumericConstantExpr(org.apache.bcel.generic.BasicType, Number)" access="pub" jdoc="">
				<param name="_type"/>
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.NumericConstantExpr.getValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NumericConstantExpr.getNumericValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NumericConstantExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NumericConstantExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ThrowExpr" intfc="n" abs="n" inn="n" sloc="22" jdoc="Represents throwing an exception. Emits: ATHROW.">
			<field name="exception" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ThrowExpr.ThrowExpr(ValueExpr)" access="pub" jdoc="Constructs a ThrowExpr for the given exception. @param _exception the exception to throw.">
				<param name="_exception"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ThrowExpr.getExceptionValue()" access="pub" jdoc="Returns the exception to be thrown.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ThrowExpr.setExceptionValue(ValueExpr)" access="pub" jdoc="">
				<param name="_ex"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ThrowExpr.toSting()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ThrowExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ArrayStoreExpr" intfc="n" abs="n" inn="n" sloc="63" jdoc="Represents storing an element in an array. Emits: AASTORE, BASTORE, CASTORE, DASTORE, FASTORE, IASTORE, LASTORE, SASTORE.">
			<field name="array" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="value" access="priv" jdoc=""/>
			<field name="elementType" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.ArrayStoreExpr(org.apache.bcel.generic.Type, ValueExpr, ValueExpr, ValueExpr)" access="pub" jdoc="Constructs an ArrayStoreExpr. @param element the element type of this array (and the type of the value to be stored in it). @param _array the array to store into. @param _index the index value to store into. @param _value the value to store.">
				<param name="element"/>
				<param name="_array"/>
				<param name="_index"/>
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.getElementType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.getArrayValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.setArrayValue(ValueExpr)" access="pub" jdoc="">
				<param name="_array"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.getIndexValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.setIndexValue(ValueExpr)" access="pub" jdoc="">
				<param name="_index"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.getStoreValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.setStoreValue(ValueExpr)" access="pub" jdoc="">
				<param name="store"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayStoreExpr.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ExceptionInfo" intfc="n" abs="n" inn="n" sloc="35" jdoc="This class takes the place of CodeExceptionGen temporarily while the method is in expression tree form. It is necessary because CodeExceptionGens keep track of InstructionHandles, which are ignored by expression trees.">
			<field name="catchType" access="priv" jdoc=""/>
			<field name="startExpr" access="priv" jdoc=""/>
			<field name="endExpr" access="priv" jdoc=""/>
			<field name="handlerExpr" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ExceptionInfo.ExceptionInfo(org.apache.bcel.generic.ObjectType, Expr, Expr, Expr)" access="pub" jdoc="The range of the &amp;apos;try&amp;apos; is from the first instruction of the &amp;apos;start&amp;apos; Expr to the last instruction of the &amp;apos;end&amp;apos; Expr, inclusive. The handler begins at the first instruction of the &amp;apos;handler&amp;apos; Expr.">
				<param name="_catchType"/>
				<param name="start"/>
				<param name="end"/>
				<param name="handler"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionInfo.getCatchType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionInfo.setCatchType(org.apache.bcel.generic.ObjectType)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionInfo.getStartPC()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionInfo.setStartPC(Expr)" access="pub" jdoc="">
				<param name="expr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionInfo.getEndPC()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionInfo.setEndPC(Expr)" access="pub" jdoc="">
				<param name="expr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionInfo.getHandlerPC()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionInfo.setHandlerPC(Expr)" access="pub" jdoc="">
				<param name="expr"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.PrimitiveDummyExpr" intfc="n" abs="n" inn="n" sloc="8" jdoc="Represents a dummy value of a primitive type (int, short, double, etc). PrimitiveDummyExpr.getType() will return the given BasicType.">
			<mth name="/:sandmark.util.newexprtree.PrimitiveDummyExpr.PrimitiveDummyExpr(org.apache.bcel.generic.BasicType)" access="pub" jdoc="">
				<param name="_type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.PrimitiveDummyExpr.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.Node" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<field name="mg" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.Node.Node()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.Node.setGraph(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="gr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.Node.graph()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ArrayDummyExpr" intfc="n" abs="n" inn="n" sloc="17" jdoc="Represents a dummy expression for an array reference. This is implicitly a single-dimensional array, but can be made multi-dimensional by making the element type be an arraytype as well.">
			<field name="elementType" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ArrayDummyExpr.ArrayDummyExpr(org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="element"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayDummyExpr.ArrayDummyExpr()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayDummyExpr.getElementType()" access="pub" jdoc="Returns the element type of this array. If this is meant to represent a multi-dimensional array, then this will be an ArrayType.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ArrayDummyExpr.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.DummyExpr" intfc="n" abs="y" inn="n" sloc="9" jdoc="DummyExpr is the abstract parent of all dummy expressions. Dummy expressions correspond to no bytecode instructions. They are used as placeholders for stack operands that were not produced in the same basic block in which they were consumed. The emitBytecode method of any DummyExpr will give an empty ArrayList.">
			<mth name="/:sandmark.util.newexprtree.DummyExpr.DummyExpr(org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.DummyExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.StoreExpr" intfc="n" abs="n" inn="n" sloc="39" jdoc="Represents a store of a value to a local variable. Emits ASTORE , ISTORE , DSTORE , FSTORE , LSTORE .">
			<field name="type" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<field name="value" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.StoreExpr.StoreExpr(org.apache.bcel.generic.Type, int, ValueExpr)" access="pub" jdoc="Constructs a StoreExpr with the given register type, local variable index, and value to store. @param _type the type of the value being stored. @param _index the local variable index. @param _vlue the value to be stored.">
				<param name="_type"/>
				<param name="_index"/>
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.StoreExpr.getIndex()" access="pub" jdoc="Returns the local variable index to store to.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.StoreExpr.getLocalType()" access="pub" jdoc="Returns the type of the value being stored.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.StoreExpr.getStoreValue()" access="pub" jdoc="Returns the ValueExpr being stored.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.StoreExpr.setStoreValue(ValueExpr)" access="pub" jdoc="Sets the expression to be stored.">
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.StoreExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.StoreExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.StoreExpr.mapType(org.apache.bcel.generic.Type)" access="priv" jdoc="This is a helper method for use with InstructionFactory.createStore(), cuz it&amp;apos;s dumb.">
				<param name="type"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.IncExpr" intfc="n" abs="n" inn="n" sloc="25" jdoc="Represents a local variable integer increment operaion. Emits: IINC.">
			<field name="index" access="priv" jdoc=""/>
			<field name="increment" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.IncExpr.IncExpr(int, int)" access="pub" jdoc="Constructs an IncExpr with the given local variable index and increment value. @param _index the local variable index of the integer. @param _increment the value to increment it by (must be at most a 16-bit quantity).">
				<param name="_index"/>
				<param name="_increment"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.IncExpr.getIndex()" access="pub" jdoc="Returns the local variable index to increment.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.IncExpr.getIncrement()" access="pub" jdoc="Returns the value to increment by.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.IncExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.IncExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.LoadExpr" intfc="n" abs="n" inn="n" sloc="26" jdoc="Represents a load from a local variable. LoadExpr.getType() returns the type of the local variable. Emits: ALOAD , ILOAD , DLOAD , FLOAD , LLOAD .">
			<field name="index" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.LoadExpr.LoadExpr(org.apache.bcel.generic.Type, int)" access="pub" jdoc="Constructs a LoadExpr with the given type and local variable index. @param _type the type of the local. @param _index the local variable index.">
				<param name="_type"/>
				<param name="_index"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.LoadExpr.getIndex()" access="pub" jdoc="Returns the local variable index of this operation.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.LoadExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.LoadExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.LoadExpr.mapType(org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="type"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.NopExpr" intfc="n" abs="n" inn="n" sloc="12" jdoc="Represents the NO-OP instruction. Emits NOP.">
			<mth name="/:sandmark.util.newexprtree.NopExpr.NopExpr()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NopExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NopExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.RetExpr" intfc="n" abs="n" inn="n" sloc="18" jdoc="Represents a return-from-subroutine operation. Emits: RET">
			<field name="index" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.RetExpr.RetExpr(int)" access="pub" jdoc="Constructs a RetExpr with the given local variable index. @param _index the local variable index of the ReturnAddress value.">
				<param name="_index"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.RetExpr.getIndex()" access="pub" jdoc="Returns the local variable index for this RetExpr.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.RetExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.RetExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.GotoExpr" intfc="n" abs="n" inn="n" sloc="17" jdoc="Represents a goto operation. Emits: GOTO_W.">
			<comm cntt="package"/>
			<mth name="/:sandmark.util.newexprtree.GotoExpr.GotoExpr(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.GotoExpr.GotoExpr(Expr)" access="pub" jdoc="">
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.GotoExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.GotoExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.MethodExprTree" intfc="n" abs="n" inn="n" sloc="53" jdoc="">
			<comm cntt="It returns the node associated with an instruction"/>
			<comm cntt="It returns the instruction associated with a node"/>
			<field name="et" access="pub" jdoc=""/>
			<field name="exprTreeBlockList" access="pub" jdoc=""/>
			<field name="BlockToETB" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.MethodExprTree(sandmark.program.Method, boolean)" access="pub" jdoc="">
				<comm cntt="remove blocks that are completely unreachable since stack simulator"/>
				<comm cntt="gets confused and generates invalid contexts for them"/>
				<comm cntt="We don&amp;apos;t ever want to do this next line."/>
				<comm cntt="removeUnreachable(sink());"/>
				<comm cntt="build the exprTrees for the basic blocks"/>
				<param name="method"/>
				<param name="_exceptionsMatter"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.buildExprTrees(sandmark.program.Method)" access="pub" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.computeBlockList()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.getExprTreeBlocks()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.getExprTreeBlock(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="block"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.iToNode(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.nodeToInfo(sandmark.util.newexprtree.Node)" access="pub" jdoc="Returns the sandmark.util.newexprtree.NodeInfo associated with a sandmark.util.newexprtree.Node . @param tempgn a node in the expression tree whose corresponding information is desired">
				<param name="tempgn"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.nodeToI(sandmark.util.newexprtree.Node)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.MethodExprTree.getInstList(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="dg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.Expr" intfc="n" abs="y" inn="n" sloc="4" jdoc="This class is the abstract parent of all expression tree classes. An expression is roughly equivalent to a java bytecode instruction, but some of the details have been abstracted away. Some expressions may be thought of as having a &amp;apos;value&amp;apos; or &amp;apos;result&amp;apos;. These expressions are represented by the class &amp;apos;ValueExpr&amp;apos; and its subclasses. All other expressions do not have a value, but their sub-expressions do. Hence, only the root of an expression tree can be a non-ValueExpr.">
			<mth name="/:sandmark.util.newexprtree.Expr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="Abstract method to reproduce java bytecode from this expression tree. The InstructionFactory must be valid for the intended method. @param factory a factory using the CPG of the intended destination method of these instructions @return an ArrayList full of Instruction objects. If any are branches, their targets will be null.">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.NewArrayExpr" intfc="n" abs="n" inn="n" sloc="35" jdoc="Represents the creation of a new array type. This can be an array of basic types, an array of reference types, or a multidimensional array of any type. NewArrayExpr.getType() returns the full type of the created array. Emits NEWARRAY, ANEWARRAY, MULTIANEWARRAY.">
			<field name="counts" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.NewArrayExpr.NewArrayExpr(org.apache.bcel.generic.ArrayType, ValueExpr[])" access="pub" jdoc="Constructs a NewArrayExpr with the given type and list of dimension values. @param _type the total array type of the new array to be made (NOT THE ELEMENT TYPE!) @param _counts an array of ValueExprs that represent the size of each dimension. The number of dimensions of this array will be taken to be _counts.length.">
				<param name="_type"/>
				<param name="_counts"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.NewArrayExpr.getCounts()" access="pub" jdoc="Returns the array of dimension sizes.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NewArrayExpr.setCounts(ValueExpr[])" access="pub" jdoc="Sets the list of sizes for this array instruction.">
				<param name="_counts"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.NewArrayExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.NewArrayExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ExceptionDummyExpr" intfc="n" abs="n" inn="n" sloc="12" jdoc="Represents a dummy value of an exception on the stack. Among other things, this type of dummy expression is assumed to be on the stack at the start of an exception handler block.">
			<mth name="/:sandmark.util.newexprtree.ExceptionDummyExpr.ExceptionDummyExpr()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionDummyExpr.ExceptionDummyExpr(org.apache.bcel.generic.ObjectType)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExceptionDummyExpr.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ExprTree" intfc="n" abs="n" inn="n" sloc="94" jdoc="">
			<comm cntt="for the following instruction handles may work better than instructions"/>
			<comm cntt="list of instructions in the expr tree"/>
			<comm cntt="Tree instructionTree; tree of instructions reprsenting the expr tree"/>
			<comm cntt="list of the instructions that are defs"/>
			<comm cntt="list of the instructions that are uses"/>
			<comm cntt="end constructor"/>
			<comm cntt="private methods"/>
			<comm cntt="public methods"/>
			<field name="instructionList" access="pub" jdoc=""/>
			<field name="defs" access="pub" jdoc=""/>
			<field name="uses" access="pub" jdoc=""/>
			<field name="gr" access="pub" jdoc=""/>
			<field name="met" access="pub" jdoc=""/>
			<field name="exprTreeNodeList" access="pub" jdoc=""/>
			<field name="etb" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ExprTree.ExprTree(MethodExprTree, ExprTreeBlock, sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="This class contains a single expresssion tree">
				<param name="met"/>
				<param name="etb"/>
				<param name="gr"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.computeExprTreeNodeList()" access="priv" jdoc="Determines which instructions in the expression tree are defs.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.computeDefs()" access="priv" jdoc="Determines which instructions in the expression tree are defs.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.computeUses()" access="priv" jdoc="Determines which instructions in the expression tree are uses.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.getInstructionList()" access="pub" jdoc="Returns the list of instruction handles associated with the expression tree.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.getGraph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.roots()" access="pub" jdoc="@return The nodes in the graph that do not have predecessors.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.getDefs()" access="pub" jdoc="Returns a list of instruction handles that are the defs of the expression tree.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.getUses()" access="pub" jdoc="Returns a list of instruction handles that are the uses of the expression tree.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.getExprTreeBlock()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.getExprTreeNodes()" access="pub" jdoc="Returns a list of the expression trees nodes associated with this tree.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTree.compareTo(ExprTree)" access="pub" jdoc="">
				<param name="et"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.GetFieldExpr" intfc="n" abs="n" inn="n" sloc="48" jdoc="Represents loading a field of a class. GetFieldExpr.getType() returns the field type. Emits: GETFIELD, GETSTATIC.">
			<field name="classname" access="priv" jdoc=""/>
			<field name="fieldname" access="priv" jdoc=""/>
			<field name="fieldtype" access="priv" jdoc=""/>
			<field name="ref" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.GetFieldExpr.GetFieldExpr(String, String, org.apache.bcel.generic.Type, ValueExpr)" access="pub" jdoc="Constructs a GetFieldExpr for a non-static field. @param _classname the name of the class that owns this field. @param _fieldname the name of the field. @param _fieldtype the type of the field. @param _ref the instance of the class that owns this field.">
				<param name="_classname"/>
				<param name="_fieldname"/>
				<param name="_fieldtype"/>
				<param name="_ref"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.GetFieldExpr.GetFieldExpr(String, String, org.apache.bcel.generic.Type)" access="pub" jdoc="Constructs a GetFieldExpr for a static field. @param _classname the name of the class that owns this field. @param _fieldname the name of the field. @param _fieldtype the type of the field.">
				<param name="_classname"/>
				<param name="_fieldname"/>
				<param name="_fieldtype"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.GetFieldExpr.getClassName()" access="pub" jdoc="Returns the name of the class that owns this field.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.GetFieldExpr.getFieldName()" access="pub" jdoc="Returns the name of the field.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.GetFieldExpr.getOwnerValue()" access="pub" jdoc="Returns the instance of the class that owns this field. If this is a static field, this method returns null.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.GetFieldExpr.setOwnerValue(ValueExpr)" access="pub" jdoc="Sets the owner reference for this field">
				<param name="owner"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.GetFieldExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.GetFieldExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ReturnExpr" intfc="n" abs="n" inn="n" sloc="39" jdoc="Represents a return-from-method instruction, possibly with a return value. Emits RETURN, ARETURN, IRETURN, DRETURN, FRETURN, LRETURN.">
			<field name="value" access="priv" jdoc=""/>
			<field name="type" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ReturnExpr.ReturnExpr(ValueExpr, org.apache.bcel.generic.Type)" access="pub" jdoc="Represents a return operation with a return value (non-void). @param _value the return value. @param _type the return type (should equal _value.getType()).">
				<param name="_value"/>
				<param name="_type"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ReturnExpr.ReturnExpr()" access="pub" jdoc="Represents a void return.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ReturnExpr.getReturnValue()" access="pub" jdoc="Returns the return value of this operation. If this is a void return, it will be null.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ReturnExpr.setReturnValue(ValueExpr)" access="pub" jdoc="Sets the value being returned by this return statement.">
				<param name="_returnValue"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ReturnExpr.isVoid()" access="pub" jdoc="Returns true iff this is a void return.">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ReturnExpr.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ReturnExpr.emitBytecode(org.apache.bcel.generic.InstructionFactory)" access="pub" jdoc="">
				<param name="factory"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newexprtree.ExprTreeNode" intfc="n" abs="n" inn="n" sloc="40" jdoc="This class is used to get the information associated with each node in the expression tree. @author Kamlesh Kantilal (kamlesh@cs.arizona.edu)">
			<field name="exprtree" access="pub" jdoc=""/>
			<field name="ni" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newexprtree.ExprTreeNode.ExprTreeNode(ExprTree, sandmark.util.newexprtree.NodeInfo)" access="pub" jdoc="">
				<param name="exprtree"/>
				<param name="ni"/>
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeNode.getIH()" access="pub" jdoc="Returns the instruction handle associated with this node in the expression tree If a node is outside the basic block it is set to null">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeNode.getGraph()" access="pub" jdoc="Returns the graph associated with this node in the expression tree">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeNode.getContext()" access="pub" jdoc="Returns the context provided by stack simulator for the instruction associated with this node in the expression tree">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeNode.getExprTree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeNode.isOutsideBlock()" access="pub" jdoc="Returns whether this node is associated with an instruction outside the basic block">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeNode.isMarked()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeNode.setMark()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newexprtree.ExprTreeNode.clearMark()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.newgraph">
		<class name="/:sandmark.util.newgraph.Graph" intfc="n" abs="y" inn="n" sloc="628" jdoc="Immutable directed graphs. Nodes of these graphs are of type{@link java.lang.Object}. Nodes are regarded as a set: that is, only one copy of a given node can exist within a given graph. Whether or not two nodes are the same is determined by {@link java.lang.Object#equals(java.lang.Object)}. Adding a node to a graph that already contains that node has no effect. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt; Edges are of type {@link Edge}. Edges are also regarded as a set, so that any given edge can only exist once in a single graph and adding an edge to a graph a second time has no effect. Whether or not two edges are the same is also determined by {@link java.lang.Object#equals(java.lang.Object)}. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt; Since &amp;lt;code&amp;gt;Graphs&amp;lt; code&amp;gt; are immutable, modifier methods like{@link #addNode(java.lang.Object)} or {@link #removeEdge(Edge)} return a new &amp;lt;code&amp;gt;Graph&amp;lt; code&amp;gt; with the appropriate modifications done to it. To add nodes &amp;lt;code&amp;gt;n1&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;n2&amp;lt; code&amp;gt; to a &amp;lt;code&amp;gt;Graph&amp;lt; code&amp;gt; &amp;lt;code&amp;gt;g&amp;lt; code&amp;gt;, we can use the code: &amp;lt;pre&amp;gt; g = g.addNode(n1); g = g.addNode(n2); &amp;lt; pre&amp;gt; Or, equivalently, we could use: &amp;lt;pre&amp;gt; g = g.addNode(n1).addNode(n2); &amp;lt; pre&amp;gt; Had we also wanted to add an {@link Edge} from &amp;lt;code&amp;gt;n1&amp;lt; code&amp;gt; to &amp;lt;code&amp;gt;n2&amp;lt; code&amp;gt;, we could have done so by creating an instance of the class {@link EdgeImpl}: &amp;lt;pre&amp;gt; g = g.addNode(n1).addNode(n2).addEdge(new EdgeImpl(n1, n2)); &amp;lt; pre&amp;gt; or by using the method {@link #addEdge(java.lang.Object,java.lang.Object)}, which does the same thing: &amp;lt;pre&amp;gt; g = g.addNode(n1).addNode(n2).addEdge(n1, n2); &amp;lt; pre&amp;gt; However, since {@link #addEdge(java.lang.Object,java.lang.Object)} adds the source and sink nodes to the graph if necessary, this code would have been sufficient: &amp;lt;pre&amp;gt; g = g.addEdge(n1, n2); &amp;lt; pre&amp;gt; &amp;lt;br&amp;gt; To create a &amp;lt;code&amp;gt;Graph&amp;lt; code&amp;gt;, see{@link sandmark.util.newgraph.Graphs#createGraph(java.util.Iterator,java.util.Iterator)}. @author &amp;lt;a href=&amp;quot;mailto:ecarter@cs.arizona.edu&amp;quot;&amp;gt;Edward Carter&amp;lt; a&amp;gt; @see sandmark.util.newgraph.MutableGraph">
			<field name="reachableSets" access="priv" jdoc=""/>
			<const name="EMPTY_NODE" access="pub" jdoc=""/>
			<const name="EMPTY_EDGE" access="pub" jdoc=""/>
			<const name="EMPTY_ITER" access="pub" jdoc=""/>
			<const name="MAX_COUNT" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Graph.depth()" access="pub" jdoc="Returns (approximately) the number of levels of indirection in the internal representation of this graph. The return value of this method should be an indication of how much there is to gain in terms of performance by calling {@link #consolidate()}, with a higher value meaning there is more to gain. @see #consolidate()">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.consolidate()" access="pub" jdoc="Returns a copy of this graph with {@link #depth()} equal to zero. The return value of this method is usually of type{@link GraphImpl}. @see #depth()">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.addNode(java.lang.Object)" access="pub" jdoc="Returns a copy of the graph with the given node added. If the graph already contains the node, &amp;lt;code&amp;gt;this&amp;lt; code&amp;gt; is returned. @param n node to add to the graph @see #hasNode(java.lang.Object)">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.addAllNodes(java.util.Iterator)" access="pub" jdoc="Returns a copy of the graph with all nodes returned by the given{@link java.util.Iterator} added. @param i all nodes returned by {@link java.util.Iterator#next()} will be included as nodes in the return value">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.checkDepth(Graph)" access="priv" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.extraNodes(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.extraEdges(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.extraBase(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.extraConsolidate(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.missingNodes(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.missingEdges(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.missingBase(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.missingConsolidate(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.removeNode(java.lang.Object)" access="pub" jdoc="Returns a copy of the graph with the given node removed. If the graph does not contain the given node, &amp;lt;code&amp;gt;this&amp;lt; code&amp;gt; is returned. @param n node to remove from the graph @see #hasNode(java.lang.Object)">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.removeAllNodes(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._removeNode(NodeWrapper)" access="priv" jdoc="">
				<param name="nw"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._removeNode(NodeWrapper, boolean)" access="priv" jdoc="">
				<param name="nw"/>
				<param name="check"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.addEdge(Edge)" access="pub" jdoc="Returns a copy of the graph with the given edge added. If the graph already contains the edge, &amp;lt;code&amp;gt;this&amp;lt; code&amp;gt; is returned. @param e edge to add to the graph @see #hasEdge(Edge)">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.addEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="Returns a copy of the graph with an edge from &amp;lt;code&amp;gt;from&amp;lt; code&amp;gt; to &amp;lt;code&amp;gt;to&amp;lt; code&amp;gt; added. Even if the graph already contains such an edge, another one is added. @param from source node @param to sink node @see #hasEdge(java.lang.Object,java.lang.Object)">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.addAllEdges(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.removeEdge(Edge)" access="pub" jdoc="Returns a copy of the graph with the given edge removed. If the graph does not contain that edge, &amp;lt;code&amp;gt;this&amp;lt; code&amp;gt; is returned. @param e edge to remove @see #hasEdge(Edge)">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.removeAllEdges(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.removeEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="Returns a copy of the graph with some edge from &amp;lt;code&amp;gt;from&amp;lt; code&amp;gt; to &amp;lt;code&amp;gt;to&amp;lt; code&amp;gt; removed. If the graph contains no such edge, &amp;lt;code&amp;gt;this&amp;lt; code&amp;gt; is returned. @param from source node @param to sink node @see #hasEdge(java.lang.Object,java.lang.Object)">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.removeUnreachable(java.lang.Object)" access="pub" jdoc="Returns a copy of the graph with only those nodes that are reachable from &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt;. If &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt; is not a node of the graph, &amp;lt;code&amp;gt;this&amp;lt; code&amp;gt; is returned.">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.reachable(NodeWrapper, int)" access="priv" jdoc="">
				<param name="n"/>
				<param name="slot"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.reverse()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.inEdges(java.lang.Object)" access="pub" jdoc="Returns an iterator over the edges in the graph pointing to the given node. @param n sink node @see #preds(java.lang.Object)">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.outEdges(java.lang.Object)" access="pub" jdoc="Returns an iterator over the edges in the graph pointing from the given node. @param n source node @see #succs(java.lang.Object)">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.succs(java.lang.Object)" access="pub" jdoc="Returns an iterator over nodes &amp;lt;code&amp;gt;u&amp;lt; code&amp;gt; such that there is an edge in the graph from &amp;lt;code&amp;gt;n&amp;lt; code&amp;gt; to &amp;lt;code&amp;gt;u&amp;lt; code&amp;gt;. @param n source node @see #outEdges(java.lang.Object)">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._succs(NodeWrapper)" access="pub" jdoc="">
				<param name="nw"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.preds(java.lang.Object)" access="pub" jdoc="Returns an iterator over nodes &amp;lt;code&amp;gt;u&amp;lt; code&amp;gt; such that there is an edge in the graph from &amp;lt;code&amp;gt;u&amp;lt; code&amp;gt; to &amp;lt;code&amp;gt;n&amp;lt; code&amp;gt;. @param n sink node @see #inEdges(java.lang.Object)">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._preds(NodeWrapper)" access="pub" jdoc="">
				<param name="nw"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.succs(java.lang.Object, java.util.Comparator)" access="pub" jdoc="">
				<param name="n"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.preds(java.lang.Object, java.util.Comparator)" access="pub" jdoc="">
				<param name="n"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.sortedIterator(java.util.Iterator, java.util.Comparator)" access="priv" jdoc="">
				<param name="i"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.inDegree(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.outDegree(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.maxInDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.maxOutDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.numPreds(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.numSuccs(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.itemCount(java.util.Iterator)" access="priv" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.hasNode(java.lang.Object)" access="pub" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; iff the graph contains the given node. @param n node to look for">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.hasEdge(Edge)" access="pub" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; iff the graph contains the given edge. @param e edge to look for">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.hasEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; iff the graph contains some edge from &amp;lt;code&amp;gt;from&amp;lt; code&amp;gt; to &amp;lt;code&amp;gt;to&amp;lt; code&amp;gt;. @param from source node @param to sink node">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.getFirstEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.nodes()" access="pub" jdoc="Returns an iterator over all nodes in the graph.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.edges()" access="pub" jdoc="Returns an iterator over all the edges in the graph.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.nodeCount()" access="pub" jdoc="Returns the number of nodes in the graph.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.edgeCount()" access="pub" jdoc="Returns the number of edges in the graph.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.roots()" access="pub" jdoc="Returns an iterator over all root nodes in the graph. A &amp;lt;i&amp;gt;root node&amp;lt; i&amp;gt; is defined as a node with no incoming edges.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._roots()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.reverseRoots()" access="pub" jdoc="Return an iterator over all reverse root nodes in the graph. A &amp;lt;i&amp;gt;reverse root node&amp;lt; i&amp;gt; is defined as a node with no outgoing edges.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._reverseRoots()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.depthFirst(java.lang.Object)" access="pub" jdoc="Returns an iterator over nodes in the graph in depth-first order, starting with &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt;. If &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt; is not a node of the graph, the iterator will return no elements. Each node of the graph is returned by the iterator at most once. Nodes not reachable from &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt; are not returned. @param root starting point for depth-first search">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._depthFirst(NodeWrapper)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.postOrder(java.lang.Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._postOrder(NodeWrapper)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.breadthFirst(java.lang.Object)" access="pub" jdoc="Returns an iterator over nodes in the graph in breadth-first order, starting with &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt;. If &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt; is not a node of the graph, the iterator will return no elements. Each node of the graph is returned by the iterator at most once. Nodes not reachable from &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt; are not returned. @param root starting point for breadth-first search">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph._breadthFirst(NodeWrapper)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.depthFirstTree(java.lang.Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.reachable(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.reachable(NodeWrapper, NodeWrapper)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.union(Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.acyclicOrder(java.lang.Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.convertList(java.util.List)" access="priv" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.acyclicHamiltonianPath(java.lang.Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.acyclicOrder(NodeWrapper)" access="priv" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.acyclicHamiltonianPath(NodeWrapper)" access="priv" jdoc="">
				<comm cntt="find &amp;quot;shortest&amp;quot; paths from the root"/>
				<comm cntt="put nodes in Hamiltonian path order"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.removeMultipleEdges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.inducedSubgraph(java.util.Iterator)" access="pub" jdoc="">
				<param name="nodeIter"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.dominatorTree(java.lang.Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.setSlots(NodeWrapper, int, int, int, int)" access="pub" jdoc="">
				<param name="nw"/>
				<param name="slot1"/>
				<param name="slot2"/>
				<param name="slot3"/>
				<param name="val"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.getSlots(NodeWrapper, int, int, int)" access="pub" jdoc="">
				<param name="nw"/>
				<param name="slot1"/>
				<param name="slot2"/>
				<param name="slot3"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph.areSlotsSet(NodeWrapper, int, int, int)" access="pub" jdoc="">
				<param name="nw"/>
				<param name="slot1"/>
				<param name="slot2"/>
				<param name="slot3"/>
			</mth>
		<class name="/:sandmark.util.newgraph.Graph$SuccIterator" intfc="n" abs="n" inn="y" sloc="50" jdoc="">
			<field name="i" access="priv" jdoc=""/>
			<field name="n" access="priv" jdoc=""/>
			<field name="slot" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Graph$SuccIterator.SuccIterator(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$SuccIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$SuccIterator.unlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$SuccIterator.finalize()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.Graph$PredIterator" intfc="n" abs="n" inn="y" sloc="50" jdoc="">
			<field name="i" access="priv" jdoc=""/>
			<field name="n" access="priv" jdoc=""/>
			<field name="slot" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Graph$PredIterator.PredIterator(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$PredIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$PredIterator.unlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$PredIterator.finalize()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.Graph$DepthFirstIterator" intfc="n" abs="n" inn="y" sloc="70" jdoc="">
			<field name="root" access="priv" jdoc=""/>
			<field name="stack" access="priv" jdoc=""/>
			<field name="g" access="priv" jdoc=""/>
			<field name="slot" access="priv" jdoc=""/>
			<field name="marked" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Graph$DepthFirstIterator.DepthFirstIterator(NodeWrapper, boolean)" access="pub" jdoc="">
				<param name="root"/>
				<param name="buildTree"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$DepthFirstIterator.DepthFirstIterator(NodeWrapper)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$DepthFirstIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$DepthFirstIterator.tree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$DepthFirstIterator.unlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$DepthFirstIterator.finalize()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.Graph$PostOrderIterator" intfc="n" abs="n" inn="y" sloc="57" jdoc="">
			<field name="path" access="priv" jdoc=""/>
			<field name="visited" access="priv" jdoc=""/>
			<field name="slot" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Graph$PostOrderIterator.PostOrderIterator(NodeWrapper)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$PostOrderIterator.buildPath(NodeWrapper)" access="priv" jdoc="">
				<param name="nw"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$PostOrderIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$PostOrderIterator.unlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$PostOrderIterator.finalize()" access="prot" jdoc="">
			</mth>
		<class name="/:sandmark.util.newgraph.Graph$PostOrderIterator$PathElement" intfc="n" abs="n" inn="y" sloc="6" jdoc="">
			<field name="nw" access="pub" jdoc=""/>
			<field name="ewi" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Graph$PostOrderIterator$PathElement.PathElement(NodeWrapper, EdgeWrapperIterator)" access="pub" jdoc="">
				<param name="n"/>
				<param name="i"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.Graph$BreadthFirstIterator" intfc="n" abs="n" inn="y" sloc="52" jdoc="">
			<field name="nodes" access="priv" jdoc=""/>
			<field name="iterators" access="priv" jdoc=""/>
			<field name="slot" access="priv" jdoc=""/>
			<field name="marked" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Graph$BreadthFirstIterator.BreadthFirstIterator(NodeWrapper)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$BreadthFirstIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$BreadthFirstIterator.unlock()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Graph$BreadthFirstIterator.finalize()" access="prot" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.ImplNodeAttributes" intfc="n" abs="n" inn="n" sloc="10" jdoc="">
			<field name="nw" access="pub" jdoc=""/>
			<field name="st" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ImplNodeAttributes.ImplNodeAttributes(Status)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ImplNodeAttributes.createEdgeSet()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.ImplNodeWrapper" intfc="n" abs="n" inn="n" sloc="6" jdoc="">
			<field name="data" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ImplNodeWrapper.ImplNodeWrapper(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="n"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.GraphImpl" intfc="n" abs="n" inn="n" sloc="153" jdoc="">
			<field name="nodes" access="priv" jdoc=""/>
			<field name="edges" access="priv" jdoc=""/>
			<field name="s" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.GraphImpl.GraphImpl()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.GraphImpl(java.util.Iterator, java.util.Iterator)" access="prot" jdoc="">
				<param name="nodeIterator"/>
				<param name="edgeIterator"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.__addNode(java.lang.Object)" access="priv" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._addNode(java.lang.Object)" access="prot" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._addEdge(Edge)" access="prot" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.consolidate()" access="pub" jdoc="">
				<comm cntt="if the user accesses the consolidated graph, we will call"/>
				<comm cntt="s.setAccessed() anyway, so it&amp;apos;s not necessary here"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.depth()" access="pub" jdoc="">
				<comm cntt="calls to _addNode() and _addEdge() don&amp;apos;t change this value, so"/>
				<comm cntt="a call to s.setAccessed() isn&amp;apos;t necessary"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._preds(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._succs(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphImpl.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MissingEdgeWrapperIterator" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="e" access="priv" jdoc=""/>
			<field name="i" access="priv" jdoc=""/>
			<field name="num" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.MissingEdgeWrapperIterator.MissingEdgeWrapperIterator(EdgeWrapperIterator, EdgeWrapper)" access="pub" jdoc="">
				<param name="i"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeWrapperIterator.numEdges()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MutableIteratorWrapper" intfc="n" abs="y" inn="n" sloc="16" jdoc="">
			<field name="i" access="prot" jdoc=""/>
			<field name="last" access="prot" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.MutableIteratorWrapper.MutableIteratorWrapper(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableIteratorWrapper.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableIteratorWrapper.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableIteratorWrapper.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MutableGraph" intfc="n" abs="n" inn="n" sloc="171" jdoc="">
			<comm cntt="private java.util.LinkedList myListeners = new java.util.LinkedList();"/>
			<field name="g" access="priv" jdoc=""/>
			<field name="root" access="priv" jdoc=""/>
			<field name="header" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.MutableGraph.MutableGraph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.MutableGraph(java.util.Iterator, java.util.Iterator)" access="pub" jdoc="">
				<param name="nodeIter"/>
				<param name="edgeIter"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.MutableGraph(Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.consolidate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.depth()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.addNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.removeNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.removeAllNodes(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.inEdges(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.outEdges(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.succs(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.preds(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.succs(Object, java.util.Comparator)" access="pub" jdoc="">
				<param name="n"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.preds(Object, java.util.Comparator)" access="pub" jdoc="">
				<param name="n"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.inDegree(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.outDegree(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.maxInDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.maxOutDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.numPreds(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.numSuccs(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.addEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.addEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.removeEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.removeEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.hasEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.getFirstEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.roots()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.reverseRoots()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.graph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.depthFirst(Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.postOrder(Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.breadthFirst(Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.removeUnreachable(Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.depthFirstTree(Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.reachable(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.inducedSubgraph(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.getRoot()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.setRoot(java.lang.Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.copy()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.getHeader()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.setHeader(String)" access="pub" jdoc="">
				<param name="h"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.dominatorTree(java.lang.Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.graphChanged()" access="pub" jdoc="">
				<comm cntt="java.util.Iterator listeners = myListeners.iterator();"/>
				<comm cntt="while(listeners.hasNext()){"/>
				<comm cntt="sandmark.util.newgraph.GraphListener listener ="/>
				<comm cntt="(sandmark.util.newgraph.GraphListener)listeners.next();"/>
				<comm cntt="listener.graphChanged(this);"/>
				<comm cntt="}"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph.addGraphListener(sandmark.util.newgraph.GraphListener)" access="pub" jdoc="">
				<comm cntt="myListeners.add(listener);"/>
				<param name="listener"/>
			</mth>
		<class name="/:sandmark.util.newgraph.MutableGraph$EdgeIterator" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<mth name="/:sandmark.util.newgraph.MutableGraph$EdgeIterator.EdgeIterator(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph$EdgeIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MutableGraph$NodeIterator" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<mth name="/:sandmark.util.newgraph.MutableGraph$NodeIterator.NodeIterator(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MutableGraph$NodeIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.Path" intfc="n" abs="n" inn="n" sloc="111" jdoc="">
			<field name="path" access="pub" jdoc=""/>
			<field name="nodes" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Path.Path()" access="pub" jdoc="Construct an empty path.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.Path(sandmark.util.newgraph.Path)" access="pub" jdoc="Construct a copy of the path &amp;lt;code&amp;gt;P&amp;lt; code&amp;gt;.">
				<param name="P"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.add(java.lang.Object)" access="pub" jdoc="Add a node last to this path. @param node the node to be added.">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.addFirst(java.lang.Object)" access="pub" jdoc="Add a node first to this path. @param node the node to be added.">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.onPath(java.lang.Object)" access="pub" jdoc="Return true if &amp;lt;code&amp;gt;node&amp;lt; code&amp;gt; is on this path.">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.getPath()" access="pub" jdoc="Return an array of the nodes on this path.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.get(int)" access="pub" jdoc="Return the k:th node on this path.">
				<param name="k"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.firstNode()" access="pub" jdoc="Return the first node on this path.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.lastNode()" access="pub" jdoc="Return the first last on this path.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.segment(java.lang.Object, java.lang.Object)" access="pub" jdoc="Return the segment of this path between node &amp;lt;code&amp;gt;first&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;last&amp;lt; code&amp;gt;. @param first the first node on the path @param last the last node on the path">
				<param name="first"/>
				<param name="last"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.concatenate(sandmark.util.newgraph.Path)" access="pub" jdoc="Return a new path consisting of the nodes on the current path followed by the nodes on &amp;lt;code&amp;gt;P&amp;lt; code&amp;gt;. @param P the path to be added.">
				<param name="P"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.size()" access="pub" jdoc="Return the number of nodes on this path.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.elements()" access="pub" jdoc="Return an enumerator for the nodes on this path.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.iterator()" access="pub" jdoc="Return an iterator for the nodes on this path.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.equals(java.lang.Object)" access="pub" jdoc="Return true if &amp;lt;code&amp;gt;path2&amp;lt; code&amp;gt; is equal to this path.">
				<param name="path2"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.hashCode()" access="pub" jdoc="Return a hash value for this path.">
			</mth>
			<mth name="/:sandmark.util.newgraph.Path.toString()" access="pub" jdoc="Generate a string representation of this paths.">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.NodeWrapperIterator" intfc="n" abs="y" inn="n" sloc="21" jdoc="">
			<mth name="/:sandmark.util.newgraph.NodeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeWrapperIterator.iterator()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EdgeSet" intfc="n" abs="n" inn="n" sloc="71" jdoc="">
			<field name="edgeArray" access="priv" jdoc=""/>
			<field name="curr" access="priv" jdoc=""/>
			<const name="START_SIZE" access="priv" jdoc=""/>
			<field name="sourceList" access="priv" jdoc=""/>
			<field name="sinkList" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EdgeSet.EdgeSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeSet.addEdge(EdgeWrapper)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeSet.size()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeSet.iterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeSet.sourceIterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeSet.sinkIterator()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.util.newgraph.EdgeSet$WrapperListIterator" intfc="n" abs="n" inn="y" sloc="22" jdoc="">
			<field name="list" access="priv" jdoc=""/>
			<field name="curr" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EdgeSet$WrapperListIterator.WrapperListIterator(NodeWrapper)" access="pub" jdoc="">
				<param name="list"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeSet$WrapperListIterator.getNext()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.RecursiveGraph" intfc="n" abs="y" inn="n" sloc="19" jdoc="">
			<field name="g" access="pub" jdoc=""/>
			<field name="consolidated" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.RecursiveGraph.RecursiveGraph(Graph)" access="pub" jdoc="">
				<param name="innerGraph"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.RecursiveGraph.depth()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.RecursiveGraph.consolidate()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.NodeWrapper" intfc="n" abs="n" inn="n" sloc="97" jdoc="">
			<comm cntt="only use this field from a graph where this == originator"/>
			<field name="slots" access="priv" jdoc=""/>
			<field name="nextSlot" access="priv" jdoc=""/>
			<const name="FAST_SLOTS" access="priv" jdoc=""/>
			<const name="NUM_SLOTS" access="priv" jdoc=""/>
			<field name="s" access="priv" jdoc=""/>
			<field name="s0" access="priv" jdoc=""/>
			<field name="s1" access="priv" jdoc=""/>
			<field name="s2" access="priv" jdoc=""/>
			<field name="node" access="pub" jdoc=""/>
			<field name="originator" access="pub" jdoc=""/>
			<field name="mySlot" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.NodeWrapper.lockSlot()" access="pub" jdoc="">
				<comm cntt="Exception e2 = null;"/>
				<comm cntt="try {"/>
				<comm cntt="throw new RuntimeException();"/>
				<comm cntt="}"/>
				<comm cntt="catch (RuntimeException re) {"/>
				<comm cntt="e2 = re;"/>
				<comm cntt="}"/>
				<comm cntt="System.out.println(&amp;quot;locking slot &amp;quot; + (nextSlot - 1));"/>
				<comm cntt="e2.printStackTrace();"/>
				<comm cntt="System.out.println(&amp;quot;locking slot &amp;quot; + j.intValue());"/>
				<comm cntt="e2.printStackTrace();"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeWrapper.unlockSlot(int)" access="pub" jdoc="">
				<comm cntt="try {"/>
				<comm cntt="throw new RuntimeException();"/>
				<comm cntt="}"/>
				<comm cntt="catch (RuntimeException re) {"/>
				<comm cntt="System.out.println(&amp;quot;unlocking slot &amp;quot; + id);"/>
				<comm cntt="re.printStackTrace();"/>
				<comm cntt="}"/>
				<param name="id"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeWrapper.NodeWrapper(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="originator"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeWrapper.checkBounds(int)" access="priv" jdoc="">
				<param name="id"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeWrapper.getSlot(int)" access="pub" jdoc="">
				<param name="id"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeWrapper.setSlot(int, byte)" access="pub" jdoc="">
				<param name="id"/>
				<param name="val"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MissingGraph" intfc="n" abs="y" inn="n" sloc="42" jdoc="">
			<mth name="/:sandmark.util.newgraph.MissingGraph.MissingGraph(Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingGraph.addNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingGraph.addEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingGraph.missingNodes(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingGraph.missingEdges(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingGraph.missingBase(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingGraph.removeNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingGraph.removeEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingGraph.missingConsolidate(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.DoubleEdgeWrapperIterator" intfc="n" abs="n" inn="n" sloc="28" jdoc="">
			<field name="a" access="priv" jdoc=""/>
			<field name="b" access="priv" jdoc=""/>
			<field name="num" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.DoubleEdgeWrapperIterator.DoubleEdgeWrapperIterator(EdgeWrapperIterator, EdgeWrapperIterator)" access="pub" jdoc="">
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DoubleEdgeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.DoubleEdgeWrapperIterator.numEdges()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.Style" intfc="y" abs="n" inn="n" sloc="13" jdoc="">
			<mth name="/:sandmark.util.newgraph.Style.getNodeColor(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.getNodeShape(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.getNodeStyle(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.getNodeFontsize(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.isNodeLabeled(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.getNodeLabel(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.getNodeLongLabel(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.getEdgeColor(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.getEdgeStyle(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.getEdgeFontsize(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Style.isEdgeLabeled(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.SingleNodeWrapperIterator" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<field name="nw" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.SingleNodeWrapperIterator.SingleNodeWrapperIterator(NodeWrapper)" access="pub" jdoc="">
				<param name="nw"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.SingleNodeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.Status" intfc="n" abs="n" inn="n" sloc="17" jdoc="">
			<field name="accessed" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Status.Status()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Status.checkNotAccessed()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Status.setAccessed()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.DoubleNodeWrapperIterator" intfc="n" abs="n" inn="n" sloc="24" jdoc="">
			<field name="inner" access="priv" jdoc=""/>
			<field name="extra" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.DoubleNodeWrapperIterator.DoubleNodeWrapperIterator(NodeWrapperIterator, java.util.Iterator)" access="pub" jdoc="">
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DoubleNodeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.SingleEdgeWrapperIterator" intfc="n" abs="n" inn="n" sloc="14" jdoc="">
			<field name="ew" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.SingleEdgeWrapperIterator.SingleEdgeWrapperIterator(EdgeWrapper)" access="pub" jdoc="">
				<param name="w"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.SingleEdgeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.SingleEdgeWrapperIterator.numEdges()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.StatusEdgeSet" intfc="n" abs="n" inn="n" sloc="24" jdoc="">
			<field name="s" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.StatusEdgeSet.StatusEdgeSet(Status)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.StatusEdgeSet.iterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.StatusEdgeSet.sourceIterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.StatusEdgeSet.sinkIterator()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EdgeWrapper" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<field name="edge" access="pub" jdoc=""/>
			<field name="from" access="pub" jdoc=""/>
			<field name="to" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EdgeWrapper.EdgeWrapper(Edge, NodeWrapper, NodeWrapper)" access="pub" jdoc="">
				<param name="e"/>
				<param name="from"/>
				<param name="to"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.Afs" intfc="n" abs="n" inn="n" sloc="97" jdoc="">
			<field name="queue" access="pub" jdoc=""/>
			<field name="graph" access="pub" jdoc=""/>
			<field name="edgeIter" access="pub" jdoc=""/>
			<field name="nextPath" access="pub" jdoc=""/>
			<field name="hasNextPath" access="pub" jdoc=""/>
			<field name="parent" access="pub" jdoc=""/>
			<field name="seen" access="pub" jdoc=""/>
			<field name="distance" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Afs.Afs(Graph, java.lang.Object)" access="pub" jdoc="Perform a breadth-first-search on a graph from a particular &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt; node, generating all paths. &amp;lt;PRE&amp;gt; Afs d = new Afs(graph,root); while (d.hasNext()) { sandmark.util.newgraph.Path path = (sandmark.util.newgraph.Path) d.next(); } &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt; We generate a set of paths, where &amp;lt;code&amp;gt;path[0]==root&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;path[path.length-1]&amp;lt; code&amp;gt; is the node we&amp;apos;re currently visiting. @param graph the graph @param root the root node from which we start exploring.">
				<param name="graph"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.Afs(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.nextElement()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.getPath(java.lang.Object)" access="priv" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.onPath(java.lang.Object, java.lang.Object)" access="priv" jdoc="Return true if &amp;lt;code&amp;gt;node&amp;lt; code&amp;gt; is on the path from &amp;lt;code&amp;gt;root&amp;lt; code&amp;gt; up to the top of the three.">
				<param name="node"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.getDistance(java.lang.Object)" access="priv" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.setDistance(java.lang.Object, int)" access="priv" jdoc="">
				<param name="n"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Afs.setDistance(int)" access="priv" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.GraphListener" intfc="y" abs="n" inn="n" sloc="3" jdoc="">
			<mth name="/:sandmark.util.newgraph.GraphListener.graphChanged(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EdgeIteratorWrapper" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<field name="i" access="priv" jdoc=""/>
			<field name="num" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EdgeIteratorWrapper.EdgeIteratorWrapper(java.util.Iterator, int)" access="pub" jdoc="">
				<param name="i"/>
				<param name="num"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeIteratorWrapper.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeIteratorWrapper.numEdges()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.ExtraEdgeWrapperIterator" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<field name="i" access="priv" jdoc=""/>
			<field name="n" access="priv" jdoc=""/>
			<field name="num" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeWrapperIterator.ExtraEdgeWrapperIterator(EdgeWrapperIterator, EdgeWrapper)" access="pub" jdoc="">
				<param name="i"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeWrapperIterator.numEdges()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.ExtraNodeGraph" intfc="n" abs="n" inn="n" sloc="64" jdoc="">
			<field name="node" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.ExtraNodeGraph(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="_node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.hasEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.extraNodes(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.extraEdges(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeGraph.extraBase(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MissingNodeAttributes" intfc="n" abs="n" inn="n" sloc="4" jdoc="">
			<field name="missing" access="pub" jdoc=""/>
			<field name="nw" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.util.newgraph.MissingNodeIterator" intfc="n" abs="n" inn="n" sloc="29" jdoc="">
			<field name="n" access="priv" jdoc=""/>
			<field name="i" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.MissingNodeIterator.MissingNodeIterator(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeIterator.getNext()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MissingStuffGraph" intfc="n" abs="n" inn="n" sloc="154" jdoc="">
			<field name="edges" access="priv" jdoc=""/>
			<field name="nodes" access="priv" jdoc=""/>
			<field name="missingNodes" access="priv" jdoc=""/>
			<field name="missingThings" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.MissingStuffGraph(Graph, java.util.Map, java.util.Map, int, int)" access="priv" jdoc="">
				<param name="g"/>
				<param name="nodes"/>
				<param name="edges"/>
				<param name="missingNodes"/>
				<param name="missingThings"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.MissingStuffGraph(Graph, NodeWrapperIterator, EdgeWrapperIterator)" access="pub" jdoc="">
				<param name="g"/>
				<param name="ni"/>
				<param name="ei"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph._addNode(NodeWrapper, boolean)" access="priv" jdoc="">
				<param name="nw"/>
				<param name="missing"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph._addEdge(EdgeWrapper)" access="priv" jdoc="">
				<param name="ew"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.addNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.addEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.missingNodes(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.missingEdges(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph.missingBase(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
		<class name="/:sandmark.util.newgraph.MissingStuffGraph$MissingNodeWrapperIterator" intfc="n" abs="n" inn="y" sloc="22" jdoc="">
			<field name="i" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph$MissingNodeWrapperIterator.MissingNodeWrapperIterator(NodeWrapperIterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph$MissingNodeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MissingStuffGraph$MissingEdgeWrapperIterator" intfc="n" abs="n" inn="y" sloc="23" jdoc="">
			<field name="i" access="priv" jdoc=""/>
			<field name="num" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph$MissingEdgeWrapperIterator.MissingEdgeWrapperIterator(EdgeWrapperIterator, int)" access="pub" jdoc="">
				<param name="i"/>
				<param name="numMissing"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph$MissingEdgeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingStuffGraph$MissingEdgeWrapperIterator.numEdges()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.AbstractStyle" intfc="n" abs="y" inn="n" sloc="76" jdoc="">
			<field name="nodeAttrs" access="priv" jdoc=""/>
			<field name="edgeAttrs" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.AbstractStyle()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.addNode(java.lang.Object, int, int, int, int, boolean, java.lang.String, java.lang.String)" access="pub" jdoc="">
				<param name="node"/>
				<param name="color"/>
				<param name="shape"/>
				<param name="style"/>
				<param name="fontsize"/>
				<param name="labeled"/>
				<param name="label"/>
				<param name="longlabel"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.addEdge(Edge, int, int, int, boolean)" access="pub" jdoc="">
				<param name="edge"/>
				<param name="color"/>
				<param name="style"/>
				<param name="fontsize"/>
				<param name="labeled"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getNodeAttr(java.lang.Object)" access="priv" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getEdgeAttr(Edge)" access="priv" jdoc="">
				<param name="edge"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getNodeColor(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getNodeShape(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getNodeStyle(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getNodeFontsize(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.isNodeLabeled(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getNodeLabel(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getNodeLongLabel(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getEdgeColor(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getEdgeStyle(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.getEdgeFontsize(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractStyle.isEdgeLabeled(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		<class name="/:sandmark.util.newgraph.AbstractStyle$NodeAttributes" intfc="n" abs="n" inn="y" sloc="6" jdoc="">
			<field name="color" access="pub" jdoc=""/>
			<field name="shape" access="pub" jdoc=""/>
			<field name="style" access="pub" jdoc=""/>
			<field name="fontsize" access="pub" jdoc=""/>
			<field name="labeled" access="pub" jdoc=""/>
			<field name="label" access="pub" jdoc=""/>
			<field name="longlabel" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.util.newgraph.AbstractStyle$EdgeAttributes" intfc="n" abs="n" inn="y" sloc="4" jdoc="">
			<field name="color" access="pub" jdoc=""/>
			<field name="style" access="pub" jdoc=""/>
			<field name="fontsize" access="pub" jdoc=""/>
			<field name="labeled" access="pub" jdoc=""/>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.ImmutableGraphStyle" intfc="n" abs="n" inn="n" sloc="18" jdoc="">
			<mth name="/:sandmark.util.newgraph.ImmutableGraphStyle.ImmutableGraphStyle(GraphStyle, Graph)" access="pub" jdoc="">
				<param name="s"/>
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MutableGraphStyle" intfc="n" abs="n" inn="n" sloc="18" jdoc="">
			<mth name="/:sandmark.util.newgraph.MutableGraphStyle.MutableGraphStyle(GraphStyle, MutableGraph)" access="pub" jdoc="">
				<param name="s"/>
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.AbstractGraphStyle" intfc="n" abs="y" inn="n" sloc="8" jdoc="">
			<mth name="/:sandmark.util.newgraph.AbstractGraphStyle.localize(Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.AbstractGraphStyle.localize(MutableGraph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.Node" intfc="n" abs="n" inn="n" sloc="30" jdoc="">
			<field name="number" access="prot" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.Node.Node(int)" access="pub" jdoc="">
				<param name="number"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Node.Node()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Node.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Node.nodeNumber()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Node.setNodeNumber(int)" access="pub" jdoc="">
				<param name="number"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Node.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Node.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Node.name()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Node.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.Graphs" intfc="n" abs="n" inn="n" sloc="153" jdoc="">
			<comm cntt="static void printSlots(Graph g) {"/>
			<comm cntt="if (g instanceof AbstractGraph) {"/>
			<comm cntt="System.out.println(&amp;quot;----------------------------------------------&amp;quot;);"/>
			<comm cntt="AbstractGraph ag = (AbstractGraph)g;"/>
			<comm cntt="for (int slot = 0; slot &amp;lt; 4; slot++) {"/>
			<comm cntt="NodeWrapperIterator i = ag._nodes();"/>
			<comm cntt="NodeWrapper n = i.getNext();"/>
			<comm cntt="while (n != null) {"/>
			<comm cntt="System.out.println(&amp;quot;slot value on slot &amp;quot; + slot + &amp;quot; for node &amp;quot;"/>
			<comm cntt="+ n.node + &amp;quot;: &amp;quot; + n.getSlot(slot));"/>
			<comm cntt="n = i.getNext();"/>
			<comm cntt="}"/>
			<comm cntt="}"/>
			<comm cntt="}"/>
			<comm cntt="}"/>
			<comm cntt="this is the old reducibility test. it&amp;apos;s slow. public static boolean reducible(Graph g, java.lang.Object root, Graph domtree) { return !findBadCycles(g, root, domtree, new java.util.HashSet()); } private static boolean findBadCycles(Graph g, java.lang.Object n, Graph domtree, java.util.Set seen) { java.util.Iterator succs = g.succs(n); while (succs.hasNext()) { java.lang.Object dest = succs.next(); if (!domtree.reachable(dest, n)) { if (seen.contains(dest)) return true; seen.add(n); boolean found = findBadCycles(g, dest, domtree, seen); seen.remove(n); if (found) return true; } } return false; }"/>
			<mth name="/:sandmark.util.newgraph.Graphs.createGraph(java.util.Iterator, java.util.Iterator)" access="pub" jdoc="">
				<param name="nodeIterator"/>
				<param name="edgeIterator"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.dotColor(int)" access="priv" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.dotShape(int)" access="priv" jdoc="">
				<param name="shape"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.dotStyle(int)" access="priv" jdoc="">
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.toDot(MutableGraph, GraphStyle)" access="pub" jdoc="">
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.toDot(Graph, Style)" access="priv" jdoc="">
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.toDot(Graph, GraphStyle)" access="pub" jdoc="">
				<param name="g"/>
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.dotInFile(Graph, GraphStyle, String)" access="pub" jdoc="">
				<param name="g"/>
				<param name="style"/>
				<param name="filename"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.dotInFile(Graph, Style, String)" access="pub" jdoc="">
				<param name="g"/>
				<param name="style"/>
				<param name="filename"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.toDot(MutableGraph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.toDot(Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.dotInFile(MutableGraph, String)" access="pub" jdoc="">
				<param name="g"/>
				<param name="filename"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.dotInFile(Graph, String)" access="pub" jdoc="">
				<param name="g"/>
				<param name="filename"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.labelEdges(Graph, String[])" access="pub" jdoc="">
				<param name="g"/>
				<param name="names"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.reducible(Graph, Object, Graph)" access="pub" jdoc="Reducibility test: Step 1: remove all backedges Step 2: test the remaining graph for cycles the original graph is reducible iff there are no cycles in the remaining graph">
				<comm cntt="removed all backedges, the rest of the graph should be a DAG."/>
				<comm cntt="hunt for cycles"/>
				<param name="g"/>
				<param name="root"/>
				<param name="domtree"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.Graphs.hasCycles(Graph, java.util.LinkedList, java.util.HashSet, Object)" access="priv" jdoc="This method only works on a rooted graph!">
				<param name="g"/>
				<param name="path"/>
				<param name="nonCycleNodes"/>
				<param name="currentNode"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EdgelessGraph" intfc="n" abs="n" inn="n" sloc="115" jdoc="">
			<field name="nodes" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.EdgelessGraph()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.EdgelessGraph(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.consolidate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.depth()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.succs(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.preds(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.inDegree(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.outDegree(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.maxInDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.maxOutDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.removeEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.removeEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.hasEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._roots()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._reverseRoots()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._depthFirst(NodeWrapper)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._breadthFirst(NodeWrapper)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.removeUnreachable(java.lang.Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.reverse()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgelessGraph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.Edge" intfc="y" abs="n" inn="n" sloc="6" jdoc="">
			<mth name="/:sandmark.util.newgraph.Edge.sourceNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Edge.sinkNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.Edge.clone(Object, Object)" access="pub" jdoc="">
				<param name="source"/>
				<param name="sink"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MissingNodeGraph" intfc="n" abs="n" inn="n" sloc="94" jdoc="">
			<field name="node" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.MissingNodeGraph(Graph, NodeWrapper)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.hasEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.addNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.addEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.missingNodes(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.missingEdges(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingNodeGraph.missingBase(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.GraphStyle" intfc="y" abs="n" inn="n" sloc="35" jdoc="">
			<comm cntt="Colors"/>
			<comm cntt="Shapes"/>
			<comm cntt="Styles"/>
			<const name="BLACK" access="pub" jdoc=""/>
			<const name="BOX" access="pub" jdoc=""/>
			<const name="CIRCLE" access="pub" jdoc=""/>
			<const name="SOLID" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeColor(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeShape(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeStyle(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeFontsize(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.isNodeLabeled(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeLabel(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeLongLabel(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeColor(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeShape(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeStyle(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeFontsize(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.isNodeLabeled(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeLabel(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getNodeLongLabel(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getEdgeColor(Graph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getEdgeStyle(Graph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getEdgeFontsize(Graph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.isEdgeLabeled(Graph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getEdgeColor(MutableGraph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getEdgeStyle(MutableGraph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.getEdgeFontsize(MutableGraph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.isEdgeLabeled(MutableGraph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.localize(Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.GraphStyle.localize(MutableGraph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.NodeFactory" intfc="y" abs="n" inn="n" sloc="3" jdoc="">
			<mth name="/:sandmark.util.newgraph.NodeFactory.createNode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EmptyGraph" intfc="n" abs="n" inn="n" sloc="86" jdoc="">
			<mth name="/:sandmark.util.newgraph.EmptyGraph.consolidate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.depth()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.removeNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.succs(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.preds(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.inDegree(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.outDegree(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.maxInDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.maxOutDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.removeEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.removeEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.hasEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph._roots()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph._reverseRoots()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.removeUnreachable(java.lang.Object)" access="pub" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.reverse()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EmptyGraph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.DomNodeWrapper" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<field name="orig" access="pub" jdoc=""/>
			<field name="label" access="pub" jdoc=""/>
			<field name="parent" access="pub" jdoc=""/>
			<field name="ancestor" access="pub" jdoc=""/>
			<field name="idom" access="pub" jdoc=""/>
			<field name="tnw" access="pub" jdoc=""/>
			<field name="dfn" access="pub" jdoc=""/>
			<field name="sdno" access="pub" jdoc=""/>
			<field name="bucket" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.DomNodeWrapper.DomNodeWrapper(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="n"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.TreeNodeWrapper" intfc="n" abs="n" inn="n" sloc="17" jdoc="">
			<field name="up" access="pub" jdoc=""/>
			<field name="down" access="pub" jdoc=""/>
			<field name="downCount" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.TreeNodeWrapper.TreeNodeWrapper(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.TreeNodeWrapper.addDown(EdgeWrapper)" access="pub" jdoc="">
				<param name="ew"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EdgeWrapperArrayIterator" intfc="n" abs="n" inn="n" sloc="25" jdoc="">
			<field name="num" access="priv" jdoc=""/>
			<field name="a" access="priv" jdoc=""/>
			<field name="i" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EdgeWrapperArrayIterator.EdgeWrapperArrayIterator(EdgeWrapper, int)" access="pub" jdoc="">
				<param name="a"/>
				<param name="num"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeWrapperArrayIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeWrapperArrayIterator.numEdges()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.DomTree" intfc="n" abs="n" inn="n" sloc="222" jdoc="">
			<field name="nodes" access="priv" jdoc=""/>
			<field name="n0" access="priv" jdoc=""/>
			<field name="count" access="priv" jdoc=""/>
			<field name="wrappers" access="priv" jdoc=""/>
			<field name="edges" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.DomTree.immediateDominator(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.dominates(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="u"/>
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.dominators(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.dominated(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.DomTree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.DomTree(Graph, NodeWrapper)" access="pub" jdoc="">
				<param name="g"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.consolidate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.depth()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree._preds(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.reachable(NodeWrapper, NodeWrapper)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.dfs(Graph, NodeWrapper, DomNodeWrapper, int, int, int)" access="priv" jdoc="">
				<param name="g"/>
				<param name="v"/>
				<param name="parent"/>
				<param name="slot1"/>
				<param name="slot2"/>
				<param name="slot3"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.compress(DomNodeWrapper)" access="priv" jdoc="">
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.eval(DomNodeWrapper)" access="priv" jdoc="">
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.DomTree.link(DomNodeWrapper, DomNodeWrapper)" access="priv" jdoc="">
				<param name="v"/>
				<param name="w"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.ReversedGraph" intfc="n" abs="n" inn="n" sloc="74" jdoc="">
			<field name="reversedWrappers" access="priv" jdoc=""/>
			<field name="wrappers" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.reverse(EdgeWrapper)" access="priv" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.ReversedGraph(Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.hasEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.reachable(NodeWrapper, NodeWrapper)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.reverse()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
		<class name="/:sandmark.util.newgraph.ReversedGraph$ReversedEdgeIterator" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<field name="i" access="priv" jdoc=""/>
			<field name="num" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ReversedGraph$ReversedEdgeIterator.ReversedEdgeIterator(EdgeWrapperIterator)" access="pub" jdoc="">
				<param name="ei"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph$ReversedEdgeIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ReversedGraph$ReversedEdgeIterator.numEdges()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.ExtraNodeAttributes" intfc="n" abs="n" inn="n" sloc="4" jdoc="">
			<field name="extra" access="pub" jdoc=""/>
			<field name="nw" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.util.newgraph.ExtraNodeIterator" intfc="n" abs="n" inn="n" sloc="29" jdoc="">
			<field name="n" access="priv" jdoc=""/>
			<field name="i" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ExtraNodeIterator.ExtraNodeIterator(java.util.Iterator)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeIterator.getNext()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.ExtraStuffGraph" intfc="n" abs="n" inn="n" sloc="161" jdoc="">
			<field name="edges" access="priv" jdoc=""/>
			<field name="nodes" access="priv" jdoc=""/>
			<field name="extraNodes" access="priv" jdoc=""/>
			<field name="extraThings" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.ExtraStuffGraph(Graph, NodeWrapperIterator, EdgeWrapperIterator)" access="pub" jdoc="">
				<param name="g"/>
				<param name="ni"/>
				<param name="ei"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph._addNode(NodeWrapper, boolean)" access="priv" jdoc="">
				<param name="nw"/>
				<param name="extra"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph._addEdge(EdgeWrapper)" access="priv" jdoc="">
				<param name="ew"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<comm cntt="if (rval == null)"/>
				<comm cntt="throw new NullPointerException(&amp;quot;node = &amp;quot; + node"/>
				<comm cntt="+ &amp;quot;, nodes = &amp;quot; + nodes);"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.extraNodes(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.extraEdges(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraStuffGraph.extraBase(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EditableGraphStyle" intfc="n" abs="n" inn="n" sloc="358" jdoc="">
			<field name="nodeDefault" access="priv" jdoc=""/>
			<field name="edgeDefault" access="priv" jdoc=""/>
			<field name="nodePairs" access="priv" jdoc=""/>
			<field name="edgePairs" access="priv" jdoc=""/>
			<field name="graphs" access="priv" jdoc=""/>
			<field name="nodes" access="priv" jdoc=""/>
			<field name="edges" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.EditableGraphStyle(int, int, int, int, boolean, int, int, int, boolean)" access="pub" jdoc="">
				<param name="defaultNodeColor"/>
				<param name="defaultNodeShape"/>
				<param name="defaultNodeStyle"/>
				<param name="defaultNodeFontsize"/>
				<param name="defaultNodeLabeled"/>
				<param name="defaultEdgeColor"/>
				<param name="defaultEdgeStyle"/>
				<param name="defaultEdgeFontsize"/>
				<param name="defaultEdgeLabeled"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.EditableGraphStyle()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeAttributes(java.lang.Object, java.lang.Object, int)" access="priv" jdoc="">
				<param name="g"/>
				<param name="node"/>
				<param name="attribute"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getEdgeAttributes(java.lang.Object, Edge, int)" access="priv" jdoc="">
				<param name="g"/>
				<param name="e"/>
				<param name="attribute"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeColor(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeColor(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeShape(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeShape(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeStyle(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeStyle(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeFontsize(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeFontsize(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.isNodeLabeled(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.isNodeLabeled(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeLabel(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeLabel(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeLongLabel(Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getNodeLongLabel(MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getEdgeColor(Graph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getEdgeColor(MutableGraph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getEdgeStyle(Graph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getEdgeStyle(MutableGraph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getEdgeFontsize(Graph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.getEdgeFontsize(MutableGraph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.isEdgeLabeled(Graph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.isEdgeLabeled(MutableGraph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.createNodeAttributes(java.util.Map, java.lang.Object)" access="priv" jdoc="">
				<param name="map"/>
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.createEdgeAttributes(java.util.Map, java.lang.Object)" access="priv" jdoc="">
				<param name="map"/>
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeColor(int)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeColor(int, Graph)" access="pub" jdoc="">
				<param name="color"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeColor(int, MutableGraph)" access="pub" jdoc="">
				<param name="color"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeColor(int, java.lang.Object)" access="pub" jdoc="">
				<param name="color"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeColor(int, Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="color"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeColor(int, MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="color"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeShape(int)" access="pub" jdoc="">
				<param name="shape"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeShape(int, Graph)" access="pub" jdoc="">
				<param name="shape"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeShape(int, MutableGraph)" access="pub" jdoc="">
				<param name="shape"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeShape(int, java.lang.Object)" access="pub" jdoc="">
				<param name="shape"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeShape(int, Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="shape"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeShape(int, MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="shape"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeStyle(int)" access="pub" jdoc="">
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeStyle(int, Graph)" access="pub" jdoc="">
				<param name="style"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeStyle(int, MutableGraph)" access="pub" jdoc="">
				<param name="style"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeStyle(int, java.lang.Object)" access="pub" jdoc="">
				<param name="style"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeStyle(int, Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="style"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeStyle(int, MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="style"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeFontsize(int)" access="pub" jdoc="">
				<param name="fontsize"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeFontsize(int, Graph)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeFontsize(int, MutableGraph)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeFontsize(int, java.lang.Object)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeFontsize(int, Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeFontsize(int, MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabeled(boolean)" access="pub" jdoc="">
				<param name="labeled"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabeled(boolean, Graph)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabeled(boolean, MutableGraph)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabeled(boolean, java.lang.Object)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabeled(boolean, Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabeled(boolean, MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabel(java.lang.String)" access="pub" jdoc="">
				<param name="label"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabel(java.lang.String, Graph)" access="pub" jdoc="">
				<param name="label"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabel(java.lang.String, MutableGraph)" access="pub" jdoc="">
				<param name="label"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabel(java.lang.String, java.lang.Object)" access="pub" jdoc="">
				<param name="label"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabel(java.lang.String, Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="label"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLabel(java.lang.String, MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="label"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLongLabel(java.lang.String)" access="pub" jdoc="">
				<param name="label"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLongLabel(java.lang.String, Graph)" access="pub" jdoc="">
				<param name="label"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLongLabel(java.lang.String, MutableGraph)" access="pub" jdoc="">
				<param name="label"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLongLabel(java.lang.String, java.lang.Object)" access="pub" jdoc="">
				<param name="label"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLongLabel(java.lang.String, Graph, java.lang.Object)" access="pub" jdoc="">
				<param name="label"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setNodeLongLabel(java.lang.String, MutableGraph, java.lang.Object)" access="pub" jdoc="">
				<param name="label"/>
				<param name="g"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeColor(int)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeColor(int, Graph)" access="pub" jdoc="">
				<param name="color"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeColor(int, MutableGraph)" access="pub" jdoc="">
				<param name="color"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeColor(int, Edge)" access="pub" jdoc="">
				<param name="color"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeColor(int, Graph, Edge)" access="pub" jdoc="">
				<param name="color"/>
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeColor(int, MutableGraph, Edge)" access="pub" jdoc="">
				<param name="color"/>
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeStyle(int)" access="pub" jdoc="">
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeStyle(int, Graph)" access="pub" jdoc="">
				<param name="style"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeStyle(int, MutableGraph)" access="pub" jdoc="">
				<param name="style"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeStyle(int, Edge)" access="pub" jdoc="">
				<param name="style"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeStyle(int, Graph, Edge)" access="pub" jdoc="">
				<param name="style"/>
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeStyle(int, MutableGraph, Edge)" access="pub" jdoc="">
				<param name="style"/>
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeFontsize(int)" access="pub" jdoc="">
				<param name="fontsize"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeFontsize(int, Graph)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeFontsize(int, MutableGraph)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeFontsize(int, Edge)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeFontsize(int, Graph, Edge)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeFontsize(int, MutableGraph, Edge)" access="pub" jdoc="">
				<param name="fontsize"/>
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeLabeled(boolean)" access="pub" jdoc="">
				<param name="labeled"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeLabeled(boolean, Graph)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeLabeled(boolean, MutableGraph)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeLabeled(boolean, Edge)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeLabeled(boolean, Graph, Edge)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="g"/>
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle.setEdgeLabeled(boolean, MutableGraph, Edge)" access="pub" jdoc="">
				<param name="labeled"/>
				<param name="g"/>
				<param name="e"/>
			</mth>
		<class name="/:sandmark.util.newgraph.EditableGraphStyle$Pair" intfc="n" abs="n" inn="y" sloc="19" jdoc="">
			<field name="g" access="pub" jdoc=""/>
			<field name="o" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$Pair.Pair(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="_g"/>
				<param name="_o"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$Pair.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="_o"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$Pair.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EditableGraphStyle$NodeAttributes" intfc="n" abs="n" inn="y" sloc="46" jdoc="">
			<field name="color" access="pub" jdoc=""/>
			<field name="shape" access="pub" jdoc=""/>
			<field name="style" access="pub" jdoc=""/>
			<field name="fontsize" access="pub" jdoc=""/>
			<field name="labeled" access="pub" jdoc=""/>
			<field name="label" access="pub" jdoc=""/>
			<field name="longlabel" access="pub" jdoc=""/>
			<const name="COLOR" access="pub" jdoc=""/>
			<const name="SHAPE" access="pub" jdoc=""/>
			<const name="STYLE" access="pub" jdoc=""/>
			<const name="FONTSIZE" access="pub" jdoc=""/>
			<const name="LABELED" access="pub" jdoc=""/>
			<const name="LABEL" access="pub" jdoc=""/>
			<const name="LONGLABEL" access="pub" jdoc=""/>
			<const name="NUM_ATTRIBUTES" access="pub" jdoc=""/>
			<field name="attributesSet" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$NodeAttributes.NodeAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$NodeAttributes.setColor(int)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$NodeAttributes.setShape(int)" access="pub" jdoc="">
				<param name="shape"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$NodeAttributes.setStyle(int)" access="pub" jdoc="">
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$NodeAttributes.setFontsize(int)" access="pub" jdoc="">
				<param name="fontsize"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$NodeAttributes.setLabeled(boolean)" access="pub" jdoc="">
				<param name="labeled"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$NodeAttributes.setLabel(java.lang.String)" access="pub" jdoc="">
				<param name="label"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$NodeAttributes.setLongLabel(java.lang.String)" access="pub" jdoc="">
				<param name="label"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EditableGraphStyle$EdgeAttributes" intfc="n" abs="n" inn="y" sloc="29" jdoc="">
			<field name="color" access="pub" jdoc=""/>
			<field name="style" access="pub" jdoc=""/>
			<field name="fontsize" access="pub" jdoc=""/>
			<field name="labeled" access="pub" jdoc=""/>
			<const name="COLOR" access="pub" jdoc=""/>
			<const name="STYLE" access="pub" jdoc=""/>
			<const name="FONTSIZE" access="pub" jdoc=""/>
			<const name="LABELED" access="pub" jdoc=""/>
			<const name="NUM_ATTRIBUTES" access="pub" jdoc=""/>
			<field name="attributesSet" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$EdgeAttributes.EdgeAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$EdgeAttributes.setColor(int)" access="pub" jdoc="">
				<param name="color"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$EdgeAttributes.setStyle(int)" access="pub" jdoc="">
				<param name="style"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$EdgeAttributes.setFontsize(int)" access="pub" jdoc="">
				<param name="fontsize"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EditableGraphStyle$EdgeAttributes.setLabeled(boolean)" access="pub" jdoc="">
				<param name="labeled"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.NodeAttributes" intfc="n" abs="n" inn="n" sloc="20" jdoc="">
			<field name="inEdges" access="pub" jdoc=""/>
			<field name="outEdges" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.NodeAttributes.NodeAttributes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeAttributes.addEdge(EdgeWrapper, EdgeSet)" access="priv" jdoc="">
				<param name="e"/>
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeAttributes.createEdgeSet()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeAttributes.addOutEdge(EdgeWrapper)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.NodeAttributes.addInEdge(EdgeWrapper)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EdgeWrapperIterator" intfc="n" abs="y" inn="n" sloc="22" jdoc="">
			<mth name="/:sandmark.util.newgraph.EdgeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeWrapperIterator.numEdges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeWrapperIterator.iterator()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.LabeledEdge" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="label" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.LabeledEdge.LabeledEdge(java.lang.Object, java.lang.Object, String)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
				<param name="label"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.LabeledEdge.getLabel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.LabeledEdge.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.LabeledEdge.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.ExtraEdgeGraph" intfc="n" abs="n" inn="n" sloc="73" jdoc="">
			<field name="e" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.ExtraEdgeGraph(Graph, Edge)" access="pub" jdoc="">
				<param name="g"/>
				<param name="_e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="_e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.hasEdge(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="_e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.extraNodes(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.extraEdges(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraEdgeGraph.extraBase(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.MissingEdgeGraph" intfc="n" abs="n" inn="n" sloc="76" jdoc="">
			<field name="e" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.MissingEdgeGraph(Graph, EdgeWrapper)" access="pub" jdoc="">
				<param name="g"/>
				<param name="_e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph._inEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph._outEdges(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.hasNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.hasEdge(Edge)" access="pub" jdoc="">
				<param name="_e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph._nodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph._edges()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.nodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.edgeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.getWrapper(java.lang.Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.getEdgeWrapper(Edge)" access="pub" jdoc="">
				<param name="_e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph._inDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph._outDegree(NodeWrapper)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.addNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.addEdge(Edge)" access="pub" jdoc="">
				<param name="edge"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.missingNodes(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.missingEdges(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.MissingEdgeGraph.missingBase(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.LabeledNode" intfc="y" abs="n" inn="n" sloc="4" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.util.newgraph.LabeledNode.getLongLabel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.LabeledNode.getShortLabel()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.EdgeImpl" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="from" access="priv" jdoc=""/>
			<field name="to" access="priv" jdoc=""/>
			<field name="num" access="priv" jdoc=""/>
			<field name="count" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.EdgeImpl.EdgeImpl(java.lang.Object, java.lang.Object)" access="pub" jdoc="">
				<param name="_from"/>
				<param name="_to"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeImpl.getNum()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeImpl.sourceNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeImpl.sinkNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeImpl.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.EdgeImpl.clone(Object, Object)" access="pub" jdoc="">
				<param name="source"/>
				<param name="sink"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.ExtraGraph" intfc="n" abs="y" inn="n" sloc="27" jdoc="">
			<mth name="/:sandmark.util.newgraph.ExtraGraph.ExtraGraph(Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraGraph.addNode(java.lang.Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraGraph.addEdge(Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraGraph.extraConsolidate(int)" access="pub" jdoc="">
				<param name="sofar"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.ExtraNodeWrapperIterator" intfc="n" abs="n" inn="n" sloc="17" jdoc="">
			<field name="i" access="priv" jdoc=""/>
			<field name="n" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.ExtraNodeWrapperIterator.ExtraNodeWrapperIterator(NodeWrapperIterator, NodeWrapper)" access="pub" jdoc="">
				<param name="i"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.ExtraNodeWrapperIterator.getNext()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.TypedEdge" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<field name="mType" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.TypedEdge.TypedEdge(Object, Object, int)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.TypedEdge.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.TypedEdge.clone(Object, Object)" access="pub" jdoc="">
				<param name="source"/>
				<param name="sink"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.newgraph.codec">
		<class name="/:sandmark.util.newgraph.codec.CatalanNumbers" intfc="n" abs="n" inn="n" sloc="20" jdoc="Utility class for generating Catalan numbers. The Catalan number C_n can be defined as the number of totally balanced binary sequences of length 2n. @author Zach Heidepriem @see sandmark.util.newgraph.codec.TotallyBalancedBinarySequence @see sandmark.util.newgraph.codec.PlantedPlaneCubicTree">
			<mth name="/:sandmark.util.newgraph.codec.CatalanNumbers.findMinimumNumber(java.math.BigInteger)" access="pub" jdoc="@return the minimum n s.t. C_n &amp;lt;= bigInt">
				<param name="bigInt"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CatalanNumbers.getCatalanNumber(long)" access="pub" jdoc="@return C_n = (1 (n+1)) (2n \choose n) @throws IllegalArgumentException if n &amp;lt; 1">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CatalanNumbers.main(String[])" access="pub" jdoc="For testing">
				<comm cntt="java.math.BigInteger maxVal = new java.math.BigInteger (&amp;quot;9999999999999999999999999999999999&amp;quot;); for(java.math.BigInteger i = java.math.BigInteger.ONE; i.compareTo(maxVal) &amp;lt; 0; i = i.multiply(new java.math.BigInteger(&amp;quot;2&amp;quot;))) System.out.println(i + &amp;quot;:&amp;quot; + findMinimumNumber(i));"/>
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.TypedEdgeCodec" intfc="y" abs="n" inn="n" sloc="2" jdoc="">
		</class>
		<class name="/:sandmark.util.newgraph.codec.GraphCodec" intfc="y" abs="n" inn="n" sloc="13" jdoc="">
			<mth name="/:sandmark.util.newgraph.codec.GraphCodec.encode(java.math.BigInteger, sandmark.util.newgraph.NodeFactory)" access="pub" jdoc="">
				<param name="value"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.GraphCodec.decode(sandmark.util.newgraph.Graph)" access="pub" jdoc="">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.GraphCodec.encodeMutable(java.math.BigInteger, sandmark.util.newgraph.NodeFactory)" access="pub" jdoc="">
				<param name="value"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.GraphCodec.decode(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.GraphCodec.encode(java.math.BigInteger)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.GraphCodec.encodeMutable(java.math.BigInteger)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.GraphCodec.maxOutDegree()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph" intfc="n" abs="n" inn="n" sloc="277" jdoc="">
			<field name="preambleCount" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.maxOutDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.lastPreambleNodeCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.encode(java.math.BigInteger, sandmark.util.newgraph.NodeFactory)" access="pub" jdoc="">
				<param name="val"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.decode(sandmark.util.newgraph.Graph)" access="pub" jdoc="">
				<comm cntt="check outdegree"/>
				<comm cntt="find root"/>
				<comm cntt="check that the graph is reducible"/>
				<comm cntt="look for hamiltonian path in acyclic component"/>
				<comm cntt="find permutation"/>
				<comm cntt="System.err.println(p);"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.numPerms(int)" access="priv" jdoc="Returns the number of permutations on n elements of order 1 or 2. @param n the number of elements to permute @return the number of possible permutations of order 1 or 2">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.numPerms(int, int)" access="priv" jdoc="Returns the number of permutations on n elements of order 1 or 2 consisting of exactly k disjoint 2-cycles. @param n the number of elements to permute @param k the number of disjoint 2-cycles in the permutations @return the number of possible permutations of order 1 or 2">
				<param name="n"/>
				<param name="k"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.getPermutation(java.math.BigInteger, int, int)" access="priv" jdoc="">
				<param name="value"/>
				<param name="n"/>
				<param name="k"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.getCycles(java.math.BigInteger, int)" access="priv" jdoc="">
				<param name="value"/>
				<param name="numCycles"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.decodeCycles(int[])" access="priv" jdoc="">
				<param name="cycles"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.decodePermutation(java.util.Map)" access="priv" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.encode(java.math.BigInteger, int)" access="priv" jdoc="">
				<param name="value"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.encode(java.math.BigInteger, int, int)" access="priv" jdoc="">
				<param name="value"/>
				<param name="n"/>
				<param name="k"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph.main(String[])" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		<class name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph$BackEdge" intfc="n" abs="n" inn="y" sloc="15" jdoc="">
			<field name="prev" access="pub" jdoc=""/>
			<field name="curr" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph$BackEdge.BackEdge(int, int)" access="pub" jdoc="">
				<param name="_prev"/>
				<param name="_curr"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph$BackEdge.compareTo(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph$BackEdge.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph$Decoder" intfc="n" abs="n" inn="y" sloc="159" jdoc="">
			<field name="list" access="priv" jdoc=""/>
			<field name="preds" access="priv" jdoc=""/>
			<field name="succs" access="priv" jdoc=""/>
			<field name="available" access="priv" jdoc=""/>
			<field name="cycleStart" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph$Decoder.getPermutation()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph$Decoder.Decoder(sandmark.util.newgraph.Graph, java.lang.Object[], java.util.HashMap)" access="pub" jdoc="">
				<comm cntt="System.err.println(&amp;quot;cycleStart = &amp;quot; + cycleStart);"/>
				<comm cntt="System.err.println(&amp;quot;dangling = &amp;quot; + dangling);"/>
				<comm cntt="System.err.println(&amp;quot;waiting = &amp;quot; + waiting);"/>
				<param name="g"/>
				<param name="hamPathOrder"/>
				<param name="hamPathInverse"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph$Decoder.addSuccessor(int, int, int[], int[], int[], java.util.SortedSet)" access="priv" jdoc="">
				<comm cntt="System.err.println(&amp;quot;inserting &amp;quot; + to + &amp;quot; in &amp;quot; + (i+1));"/>
				<comm cntt="System.err.println(&amp;quot;inserting &amp;quot; + from + &amp;quot; in &amp;quot; + (i-1));"/>
				<param name="from"/>
				<param name="to"/>
				<param name="list"/>
				<param name="preds"/>
				<param name="succs"/>
				<param name="available"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.ReduciblePermutationGraph$Decoder.insert(int, int, int[], int[], int[], java.util.SortedSet)" access="priv" jdoc="">
				<param name="index"/>
				<param name="value"/>
				<param name="list"/>
				<param name="preds"/>
				<param name="succs"/>
				<param name="available"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper" intfc="n" abs="n" inn="n" sloc="311" jdoc="">
			<field name="mCodec" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.CycleAndPathWrapper()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.CycleAndPathWrapper(GraphCodec)" access="pub" jdoc="">
				<param name="wrappedCodec"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.setWrappedCodec(GraphCodec)" access="pub" jdoc="">
				<param name="wrappedCodec"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.maxOutDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.encode(java.math.BigInteger, sandmark.util.newgraph.NodeFactory)" access="pub" jdoc="">
				<comm cntt="sandmark.util.newgraph.Graphs.dotInFile(g,value + &amp;quot;.orig.dot&amp;quot;);"/>
				<param name="value"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.decode(sandmark.util.newgraph.Graph)" access="pub" jdoc="">
				<comm cntt="Repeatedly replace the shortest cycle with a single node."/>
				<comm cntt="Delete every edge involving 2 cycle nodes, and exchange the"/>
				<comm cntt="cycle node for the replacement node in every edge where one"/>
				<comm cntt="node is in the cycle"/>
				<comm cntt="Replace every edge from a replacement node to a non-replacement"/>
				<comm cntt="node with an edge from the replacement node to the first"/>
				<comm cntt="replacement node reachable from the non-replacement node."/>
				<comm cntt="Remove all non-replacement nodes"/>
				<comm cntt="sandmark.util.newgraph.Graphs.dotInFile(g,&amp;quot;unwrapped.dot&amp;quot;);"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.findShortCycles(sandmark.util.newgraph.Graph, java.util.Set)" access="priv" jdoc="">
				<comm cntt="We want to repeatedly: find the node involved in the shortest cycle, and handle it by: finding the nodes that form the cycle, and accepting the cycle if no nodes in the cycle are also part of another cycle found in a previous iteration."/>
				<comm cntt="Since shortestCycleNode is in a cycle of length cycleLength, there must be a node n with a path from shortestCycleNode to n with length cycleLength - 1 and a path from n to sCN with length 1. And we find all the intermediate nodes in the same fashion. We&amp;apos;re not interested in paths that contain nodes that are already in smaller cycles, so if this path reuses a node, forget about it."/>
				<param name="g"/>
				<param name="replaced"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.INFINITY(int)" access="priv" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.doFloyd(sandmark.util.newgraph.Graph, Object)" access="priv" jdoc="">
				<param name="g"/>
				<param name="nodes"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.createPath(sandmark.util.newgraph.NodeFactory, int, sandmark.util.newgraph.Edge)" access="priv" jdoc="">
				<param name="factory"/>
				<param name="nodeCount"/>
				<param name="template"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.createCycle(sandmark.util.newgraph.NodeFactory, int)" access="priv" jdoc="">
				<param name="factory"/>
				<param name="length"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		<class name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper$CycleState" intfc="n" abs="n" inn="y" sloc="17" jdoc="">
			<field name="g" access="pub" jdoc=""/>
			<field name="nextSinkNode" access="pub" jdoc=""/>
			<field name="nextSourceNode" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper$CycleState.CycleState(sandmark.util.newgraph.Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper$CycleState.setNextSinkNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndPathWrapper$CycleState.setNextSourceNode()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.codec.DecodeFailure" intfc="n" abs="n" inn="n" sloc="8" jdoc="">
			<mth name="/:sandmark.util.newgraph.codec.DecodeFailure.DecodeFailure()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.DecodeFailure.DecodeFailure(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec" intfc="n" abs="y" inn="n" sloc="182" jdoc="">
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.decode(int, int)" access="prot" jdoc="">
				<param name="digits"/>
				<param name="cycleLength"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.digits(java.math.BigInteger, int)" access="prot" jdoc="">
				<param name="value"/>
				<param name="cycleLength"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.cycleLength(java.math.BigInteger)" access="prot" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.maxOutDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.encode(java.math.BigInteger, sandmark.util.newgraph.NodeFactory)" access="pub" jdoc="">
				<param name="value"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.decode(sandmark.util.newgraph.Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.getSuccByType(sandmark.util.newgraph.Graph, Object, int)" access="priv" jdoc="">
				<param name="g"/>
				<param name="node"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.checkEdgeTypes(sandmark.util.newgraph.Graph)" access="priv" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.createRootedCycleGraph(int, sandmark.util.newgraph.NodeFactory)" access="priv" jdoc="">
				<param name="size"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.getCycleInOrder(sandmark.util.newgraph.Graph, Object, int)" access="priv" jdoc="">
				<param name="cycleGraph"/>
				<param name="root"/>
				<param name="cycleLength"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.count(java.util.Iterator)" access="priv" jdoc="">
				<param name="it"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.checkEdges(sandmark.util.newgraph.Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.CycleAndDigitsCodec.checkCycle(sandmark.util.newgraph.Graph, int)" access="pub" jdoc="">
				<param name="g"/>
				<param name="cycleType"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.PermutationGraph" intfc="n" abs="n" inn="n" sloc="58" jdoc="">
			<comm cntt="encode perIndex into the corresponding permutation"/>
			<comm cntt="PRE2: 0 &amp;lt;= perIndex &amp;lt; factorial(perLength)"/>
			<comm cntt="POST1: perIndex = 0"/>
			<mth name="/:sandmark.util.newgraph.codec.PermutationGraph.cycleLength(java.math.BigInteger)" access="prot" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PermutationGraph.digits(java.math.BigInteger, int)" access="prot" jdoc="">
				<comm cntt="we&amp;apos;re reducing perIndex to 0"/>
				<param name="value"/>
				<param name="cycleLength"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PermutationGraph.decode(int[], int)" access="prot" jdoc="">
				<param name="digits"/>
				<param name="cycleLength"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PermutationGraph.swap(int, int, int)" access="priv" jdoc="">
				<param name="perm"/>
				<param name="i"/>
				<param name="j"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PermutationGraph.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.RadixGraph" intfc="n" abs="n" inn="n" sloc="40" jdoc="">
			<mth name="/:sandmark.util.newgraph.codec.RadixGraph.decode(int, int)" access="prot" jdoc="">
				<param name="digits"/>
				<param name="cycleLength"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.RadixGraph.digits(java.math.BigInteger, int)" access="prot" jdoc="">
				<param name="value"/>
				<param name="radix"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.RadixGraph.cycleLength(java.math.BigInteger)" access="prot" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.RadixGraph.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.DefaultNodeFactory" intfc="n" abs="n" inn="n" sloc="6" jdoc="">
			<field name="num" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.DefaultNodeFactory.createNode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.AbstractCodec" intfc="n" abs="y" inn="n" sloc="40" jdoc="">
			<mth name="/:sandmark.util.newgraph.codec.AbstractCodec.encodeMutable(java.math.BigInteger, sandmark.util.newgraph.NodeFactory)" access="pub" jdoc="">
				<param name="value"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.AbstractCodec.decode(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.AbstractCodec.encode(java.math.BigInteger)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.AbstractCodec.encodeMutable(java.math.BigInteger)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.AbstractCodec.testOne(java.math.BigInteger, boolean)" access="priv" jdoc="">
				<param name="num"/>
				<param name="dumpDot"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.AbstractCodec.test(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence" intfc="n" abs="n" inn="n" sloc="105" jdoc="This class represents a totally balanced binary sequence. A sequence a = [a_1, a_2, ...., a_2n is a TBBS if:&amp;lt;br&amp;gt; 1) a contains n 0&amp;apos;s and n 1&amp;apos;s&amp;lt;br&amp;gt; 2) for any i, 1 &amp;lt;= i &amp;lt;= 2n, it holds that:&amp;lt;br&amp;gt; |{j: 1 &amp;lt;= j &amp;lt;= i, a_i = 0}| &amp;gt;= |{j: 1 &amp;lt;= j &amp;lt;= i, a_i = 1}|. @author Zach Heidepriem @see sandmark.util.newgraph.codec.CatalanNumbers @see sandmark.util.newgraph.codec.PlantedPlaneCubicTree">
			<comm cntt="Builds this sequence. (from Kreher, Stinson &amp;quot;Combinatorial Algorithms&amp;quot;, 1999)"/>
			<comm cntt="Computes this rank. (from Kreher, Stinson &amp;quot;Combinatorial Algorithms&amp;quot;, 1999)"/>
			<comm cntt="taken from the same text..."/>
			<comm cntt="for testing"/>
			<field name="mSequence" access="priv" jdoc=""/>
			<field name="mRank" access="priv" jdoc=""/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.TotallyBalancedBinarySequence(java.math.BigInteger)" access="pub" jdoc="">
				<param name="bigInt"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.TotallyBalancedBinarySequence(boolean[])" access="pub" jdoc="Take a sequence of booleans and calculate the corresponding bigInt">
				<param name="sequence"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.getRank()" access="pub" jdoc="@return the rank of this sequence in its Catalan family">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.getCatalanNumber()" access="pub" jdoc="@return the Catalan family this TBBS belongs to.">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.get(int)" access="pub" jdoc="@return true iff the number at position i in this TBBS is a 1 @throws IllegalArgumentException if i &amp;gt; this.size()-1 or i &amp;lt; 0;">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.getSequence()" access="pub" jdoc="@return the Catalan sequence">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.size()" access="pub" jdoc="@return the size of this sequence">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.catalanUnrank(int, java.math.BigInteger)" access="priv" jdoc="">
				<param name="n"/>
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.catalanRank(int, boolean[])" access="priv" jdoc="">
				<param name="n"/>
				<param name="sequence"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.M(int, int, int)" access="priv" jdoc="">
				<comm cntt="2n-x"/>
				<comm cntt="n - (x+y) 2"/>
				<comm cntt="n - 1 - (x+y) 2"/>
				<param name="n"/>
				<param name="x"/>
				<param name="y"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.toString()" access="pub" jdoc="Displays the rank in parens followed by the sequence">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.checkBalanced()" access="pub" jdoc="For testing. The sequence should always be balanced, i.e. this method should always return true.">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.TotallyBalancedBinarySequence.main(String[])" access="pub" jdoc="">
				<comm cntt="PASSES"/>
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree" intfc="n" abs="n" inn="n" sloc="225" jdoc="This class provides methods for encoding and decoding BigIntegers from PPCT&amp;apos;s. The BigInteger is first encoded into a totally balanced binary sequence, which is used to construct a PPT. The PPT is then converted into a PPCT. The process is reversed for decoding. @author Zach Heidepriem">
			<comm cntt="As described in http: citeseer.nj.nec.com 598821.html Theorem 2 Remark 2"/>
			<comm cntt="As described in http: citeseer.nj.nec.com 598821.html Theorem 2 Remark 2, but reversed"/>
			<comm cntt="Build a TBBS starting at node, appending result to sequence"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.maxOutDegree()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.encode(java.math.BigInteger, sandmark.util.newgraph.NodeFactory)" access="pub" jdoc="">
				<comm cntt="First get a TBBS from the BigInt"/>
				<comm cntt="Now build a PPT (n-ary tree) from the BigInt"/>
				<comm cntt="false means go down..."/>
				<comm cntt="true means go up"/>
				<comm cntt="Convert the n-ary tree to a binary tree."/>
				<comm cntt="Drop the root as described in the reference"/>
				<param name="val"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.nToBTree(NTreeNode)" access="priv" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.bToNTree(BTreeNode)" access="priv" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.addLeaves(BTreeNode, sandmark.util.newgraph.NodeFactory)" access="priv" jdoc="">
				<param name="root"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.buildGraph(sandmark.util.newgraph.Graph, BTreeNode)" access="priv" jdoc="">
				<param name="g"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.leavesInOrder(java.util.List, BTreeNode)" access="priv" jdoc="">
				<param name="list"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.decode(sandmark.util.newgraph.Graph)" access="pub" jdoc="">
				<comm cntt="Re-add the root of the tree we remove during encoding, as described"/>
				<comm cntt="in the reference"/>
				<comm cntt="Build a TBBS object from the sequence (calculate rank)"/>
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.getArray(java.util.List)" access="priv" jdoc="">
				<param name="list"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.buildBTree(sandmark.util.newgraph.Graph, Object, java.util.List)" access="priv" jdoc="">
				<param name="g"/>
				<param name="root"/>
				<param name="leaves"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.removeLeaves(BTreeNode)" access="priv" jdoc="">
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.checkNode(BTreeNode)" access="priv" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.findRootAndLeaves(sandmark.util.newgraph.Graph, java.util.List)" access="priv" jdoc="">
				<param name="g"/>
				<param name="leavesInOrder"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.buildSequence(NTreeNode, java.util.List)" access="priv" jdoc="">
				<param name="root"/>
				<param name="sequence"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		<class name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree$BTreeNode" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<comm cntt="Used for encoding"/>
			<comm cntt="Used for decoding"/>
			<field name="right" access="pub" jdoc=""/>
			<field name="left" access="pub" jdoc=""/>
			<field name="node" access="pub" jdoc=""/>
			<field name="index" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree$BTreeNode.BTreeNode(Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree$BTreeNode.BTreeNode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree$NTreeNode" intfc="n" abs="n" inn="y" sloc="5" jdoc="">
			<field name="kids" access="pub" jdoc=""/>
			<field name="node" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.newgraph.codec.PlantedPlaneCubicTree$NTreeNode.NTreeNode(Object)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.newgraph.codec.WrapperCodec" intfc="y" abs="n" inn="n" sloc="3" jdoc="">
			<mth name="/:sandmark.util.newgraph.codec.WrapperCodec.setWrappedCodec(GraphCodec)" access="pub" jdoc="">
				<param name="codec"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.opaquepredicatelib">
		<class name="/:sandmark.util.opaquepredicatelib.StringOpPredicateGenerator" intfc="n" abs="n" inn="n" sloc="119" jdoc="RuntimeStrOPLib creates run time non-deterministic predicates at the requested byte code position of a node within the CFG of a method. @author Ashok Venkatraj (ashok@cs.arizona.edu)">
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="sInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.StringOpPredicateGenerator.insertOpaque(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int, org.apache.bcel.generic.BranchInstruction)" access="priv" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="varnum"/>
				<param name="comparator"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.StringOpPredicateGenerator.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.StringOpPredicateGenerator.findGoodLocal(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="method"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.StringOpPredicateGenerator.canInsertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.StringOpPredicateGenerator.getInfo()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.IntComparePredicateGenerator" intfc="n" abs="n" inn="n" sloc="91" jdoc="RuntimeIntOPLib creates run time non-deterministic predicates at the requested byte code position of a node within the CFG of a method. @author Ashok Purushotham Ramasamy Venkatraj (ashok@cs.arizona.edu)">
			<field name="compareClasses" access="pub" jdoc=""/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="sInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.IntComparePredicateGenerator.insertOpaque(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int, org.apache.bcel.generic.BranchInstruction)" access="priv" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="varnum"/>
				<param name="comparator"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.IntComparePredicateGenerator.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.IntComparePredicateGenerator.findGoodLocal(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="method"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.IntComparePredicateGenerator.canInsertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.IntComparePredicateGenerator.getInfo()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.ObjectComparePredicateGenerator" intfc="n" abs="n" inn="n" sloc="130" jdoc="RuntimeIsNullOPLib creates run time non-deterministic predicates at the requested byte code position of a node within the CFG of a method. @author Ashok Venkatraj (ashok@cs.arizona.edu)">
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="compareClasses" access="priv" jdoc=""/>
			<field name="sInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.ObjectComparePredicateGenerator.insertOpaque(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int, org.apache.bcel.generic.BranchInstruction)" access="priv" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="varnum"/>
				<param name="comparator"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ObjectComparePredicateGenerator.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ObjectComparePredicateGenerator.canInsertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ObjectComparePredicateGenerator.getInfo()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.PredicateFactory" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<const name="predicateInfoMethodName" access="priv" jdoc=""/>
			<field name="mPredicateGeneratorClass" access="priv" jdoc=""/>
			<field name="cons" access="priv" jdoc=""/>
			<field name="mInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.PredicateFactory.PredicateFactory(Class)" access="pub" jdoc="">
				<param name="predicateGenerator"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.PredicateFactory.createInstance()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.PredicateFactory.getPredicateInfo()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.AlgebraicPredicateGenerator" intfc="n" abs="n" inn="n" sloc="108" jdoc="">
			<comm cntt="keep in sync with above exprs"/>
			<field name="trueExprs" access="priv" jdoc=""/>
			<field name="falseExprs" access="priv" jdoc=""/>
			<field name="unknownExprs" access="priv" jdoc=""/>
			<const name="MAX_VARS" access="priv" jdoc=""/>
			<field name="sInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.AlgebraicPredicateGenerator.getInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.AlgebraicPredicateGenerator.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.AlgebraicPredicateGenerator.canInsertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.AlgebraicPredicateGenerator.findLiveInts(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="method"/>
				<param name="ih"/>
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.OpaqueManager" intfc="n" abs="n" inn="n" sloc="63" jdoc="The OpaqueManager class encapsulates the various opaque predicate libraries. This forms an interface between the user and the detailed low level implementation of the various opaque predicates such as &amp;apos;algebraic&amp;apos; predicates, &amp;apos;heap alias analysis&amp;apos; predicates, &amp;apos;thread contention&amp;apos; predicates, etc. Each of these predicates are implemented in there own different classes extending from a base class. @author Ashok Purushotham Ramasamy Venkatraj (ashok@cs.arizona.edu) Tapas R. Sahoo(tapas@cs.arizona.edu)">
			<field name="DEBUG" access="priv" jdoc=""/>
			<const name="PV_TRUE" access="pub" jdoc=""/>
			<const name="PV_FALSE" access="pub" jdoc=""/>
			<const name="PV_UNKNOWN" access="pub" jdoc=""/>
			<const name="PT_ALGEBRAIC" access="pub" jdoc=""/>
			<const name="PT_THREAD" access="pub" jdoc=""/>
			<const name="PT_INT_OP" access="pub" jdoc=""/>
			<const name="PT_OBJECT_OP" access="pub" jdoc=""/>
			<const name="PT_STRING_OP" access="pub" jdoc=""/>
			<const name="PT_DATA_STRUCTURE_OP" access="pub" jdoc=""/>
			<field name="mPredicates" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaqueManager.OpaqueManager()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaqueManager.getPredicates()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaqueManager.loadPredicates()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaqueManager.getPredicatesByType(int)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaqueManager.getPredicatesByType(int, PredicateFactory[])" access="pub" jdoc="">
				<param name="type"/>
				<param name="predicates"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaqueManager.getPredicatesByValue(int)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaqueManager.getPredicatesByValue(int, PredicateFactory[])" access="pub" jdoc="">
				<param name="value"/>
				<param name="predicates"/>
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.smNode" intfc="n" abs="n" inn="n" sloc="216" jdoc="">
			<field name="prev" access="pub" jdoc=""/>
			<field name="next" access="pub" jdoc=""/>
			<field name="g" access="pub" jdoc=""/>
			<field name="h" access="pub" jdoc=""/>
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="value" access="pub" jdoc=""/>
			<field name="cnt" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.smNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.Move(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.Insert(int, int, smNode)" access="pub" jdoc="">
				<comm cntt="p.prev=p;"/>
				<comm cntt="p.next=p;"/>
				<param name="i"/>
				<param name="j"/>
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.reachableNodes()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.reachable(java.util.TreeSet)" access="pub" jdoc="">
				<comm cntt="java.util.Stack s= new java.util.Stack(); s.push((Object)this); s.push while(!s.empty() &amp;&amp; !reached.contains((Object)this) ) { }"/>
				<comm cntt="if(!reached.contains((Node)this ))"/>
				<comm cntt="{"/>
				<comm cntt="if(this.prev!=this)"/>
				<comm cntt="else if(this.next !=this)"/>
				<comm cntt="}"/>
				<param name="reached"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.dodfs(smNode, java.util.HashSet)" access="pub" jdoc="">
				<param name="p"/>
				<param name="hs"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.createCut(smNode, int, java.util.HashSet)" access="pub" jdoc="">
				<comm cntt="if(hs.size()==wheretocut) { if( hs.contains(p.prev)==true &amp;&amp; p.prev !=p) { if(DEBUG) System.out.println(&amp;quot;Found Cut and prev pointer points to something already in HashSet&amp;quot;); p.prev=p; return; } else if (hs.contains(p.next)==true &amp;&amp; p.prev !=p) { if(DEBUG) System.out.println(&amp;quot;Found Cut and next pointer points to something already in HashSet&amp;quot;); p.prev=p; return; } }"/>
				<param name="p"/>
				<param name="wheretocut"/>
				<param name="hs"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.reachableNodes(java.util.ArrayList)" access="pub" jdoc="">
				<param name="al"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.Split(int, smNode)" access="pub" jdoc="">
				<comm cntt="TreeSet a = p.reachableNodes(); TreeSet b= q.reachableNodes(); if( a.equals(b) ==false) { a.removeAll(b); TreeSet diff= new TreeSet(a); a=p.reachableNodes(); a.retainAll(b); p.splitGraph(diff,b); return q; } else"/>
				<param name="index"/>
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.splitGraph(java.util.TreeSet, java.util.TreeSet)" access="pub" jdoc="">
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.addNode(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.selectNode4b(int)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.selectNode(int)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.Merge(smNode, smNode)" access="pub" jdoc="">
				<param name="p"/>
				<param name="q"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.smNode.Link(int, int, smNode)" access="pub" jdoc="">
				<param name="i"/>
				<param name="j"/>
				<param name="p"/>
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.OpaquePredicateGenerator" intfc="n" abs="y" inn="n" sloc="84" jdoc="Abstract superclass of all opaque predicate generator classes. In general, an opaque predicate will ensure that a 1 or 0 is on top of the stack upon reaching a specified InstructionHandle.">
			<mth name="/:sandmark.util.opaquepredicatelib.OpaquePredicateGenerator.canInsertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaquePredicateGenerator.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="Inserts an opaque predicate into the given method, so that a 1 or 0 will be on top of the stack just before the given InstructionHandle.">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaquePredicateGenerator.insertInterproceduralPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="This method attempts to insert an inter-procedural opaque predicate that will put a 1 or 0 on top of the stack just before the given InstructionHandle of the given method. It computes the ApplicationCFG for the method&amp;apos;s application to find interprocedural dominator blocks, into which code can be added that will compute the opaque predicate. NOTE: the default implementation of this method is to throw an UnsupportedOperationException. Any new OP class will have to explicitly override this method to add interprocedural functionality.">
				<comm cntt="this is the default, specific OPs will have to override this"/>
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaquePredicateGenerator.findInterproceduralDominators(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle)" access="prot" jdoc="Returns blocks in order of dominance (i.e. block[0] will dominate all others). (this method filters out the sources and sinks)">
				<param name="method"/>
				<param name="insertBefore"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaquePredicateGenerator.findInterproceduralDominators(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="prot" jdoc="Same as above, but spreads the blocks out into &amp;apos;howmany&amp;apos; spaces.">
				<param name="method"/>
				<param name="insertBefore"/>
				<param name="howmany"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.OpaquePredicateGenerator.isInLoop(Object, sandmark.analysis.callgraph.ApplicationCFG)" access="priv" jdoc="Determines if the given object in the given graph is in a directed loop.">
				<param name="source"/>
				<param name="appcfg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.DataStructurePredicateGenerator" intfc="n" abs="y" inn="n" sloc="28" jdoc="DynamicStructure OpaquePredicates @author Ashok P. Ramasamy Venkatraj (ashok@cs.arizona.edu) DynamicStructure OpaquePredicates constructs a set of dynamic structures ,then maintain global pointers to these structures. Now they define opaquepredicates by performing operations on the dynamic structures while maintaining some invariants">
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="SMNODE_CURRENT_PATH" access="priv" jdoc=""/>
			<const name="SMNODE_CLASS_NAME" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.DataStructurePredicateGenerator.addSMNode(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.DataStructurePredicateGenerator.canInsertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.DSPGF1" intfc="n" abs="n" inn="n" sloc="266" jdoc="">
			<field name="sInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGF1.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="This method takes the methodgen as input and inserts an Opaquely false predicate before BasicBlock ,bb_ins_before. This particular module provides a bytecode embedding of the following code listing Node n= new smNode(); smNode a= n.Insert(5,1,null); smNode b= n.Insert(7,8,null); if(a.Move(1)== b.Move(2)) System.out.println(&amp;quot; Wrong :Isn&amp;apos;t this supposed to be false ?&amp;quot;); else System.out.println(&amp;quot;Right&amp;quot;);">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGF1.insertInterproceduralPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<comm cntt="block 0"/>
				<comm cntt="block 1"/>
				<comm cntt="block 2"/>
				<comm cntt="block 3"/>
				<comm cntt="block 4"/>
				<comm cntt="last block"/>
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGF1.getInfo()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.DSPGF2" intfc="n" abs="n" inn="n" sloc="395" jdoc="">
			<field name="sInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGF2.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="This method takes the methodgen as input and inserts an Opaquely false predicate before BasicBlock ,bb_ins_before. This particular module provides a bytecode embedding of the following code listing smNode n= new smNode(); smNode a= n.Insert(5,1,null); smNode b= n.Insert(7,8,null); smNode.g=a.Move(2); smNode.h=b.Move(3); smNode.h=n.Insert(2,1,smNode.h); if(smNode.g==smNode.h) System.out.println(&amp;quot; Wrong :Isn&amp;apos;t this supposed to be false ?&amp;quot;); else System.out.println(&amp;quot;Right&amp;quot;);">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGF2.insertInterproceduralPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<comm cntt="block 0"/>
				<comm cntt="block 1"/>
				<comm cntt="block 2"/>
				<comm cntt="block 3"/>
				<comm cntt="block 4"/>
				<comm cntt="block 5"/>
				<comm cntt="last block"/>
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGF2.getInfo()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.DSPGT1" intfc="n" abs="n" inn="n" sloc="308" jdoc="">
			<field name="sInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGT1.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="This method takes the methodgen as input and inserts an Opaquely true predicate before BasicBlock ,bb_ins_before. This particular module provides a bytecode embedding of the following code listing smNode n= new smNode(); smNode a= n.Insert(5,1,null); smNode b= n.Insert(7,8,null); n.Merge(a,b); if(a.Move(1)==b.Move(2)) op true System.out.println(&amp;quot; the Opaque predicate is correct.. &amp;quot;);">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGT1.insertInterproceduralPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<comm cntt="block 0"/>
				<comm cntt="block 1"/>
				<comm cntt="block 2"/>
				<comm cntt="block 3"/>
				<comm cntt="block 4"/>
				<comm cntt="block 5"/>
				<comm cntt="last block"/>
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGT1.getInfo()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.DSPGT2" intfc="n" abs="n" inn="n" sloc="268" jdoc="">
			<field name="sInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGT2.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="This method takes the methodgen as input and inserts an Opaquely true predicate before BasicBlock ,bb_ins_before. This particular module provides a bytecode embedding of the following code listing smNode n= new smNode(); smNode a= n.Insert(5,1,null); smNode b= n.Insert(7,8,null); n.Merge(a,b); if(smNode.h==b.Move(3)) System.out.println(&amp;quot; Opaquely true predicate generated &amp;quot;);">
				<comm cntt="Here&amp;apos;s what it used to do:"/>
				<comm cntt="n = new smNode();"/>
				<comm cntt="a = n.insert(1,5,null);"/>
				<comm cntt="b = n.insert(2,3,null);"/>
				<comm cntt="smNode.g = a.move(2);"/>
				<comm cntt="smNode.h = b.move(3);"/>
				<comm cntt="smNode.h = n.insert(2,1,smNode.h)"/>
				<comm cntt="if(smNode.h != b.move(3)) goto ih;"/>
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGT2.insertInterproceduralPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<comm cntt="block 0"/>
				<comm cntt="block 1"/>
				<comm cntt="block 2"/>
				<comm cntt="block 3"/>
				<comm cntt="last block"/>
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.DSPGT2.getInfo()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.PredicateInfo" intfc="n" abs="n" inn="n" sloc="8" jdoc="">
			<const name="mSupportedValues" access="priv" jdoc=""/>
			<const name="mPredType" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.PredicateInfo.PredicateInfo(int, int)" access="pub" jdoc="">
				<param name="predType"/>
				<param name="supportedValues"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.PredicateInfo.getSupportedValues()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.PredicateInfo.getType()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.ThreadPredicateGenerator" intfc="n" abs="n" inn="n" sloc="283" jdoc="ThreadLib creates run time deterministic nondeterministic predicates at the requested byte code position of a node within the CFG of a method. @author {tapas@cs.arizona.edu}">
			<comm cntt="ASH 2004 01 07: I&amp;apos;m pretty sure this is a non-deterministic predicate. Each thread does this: static field f = f 5; sleep randomly; f -= 1; There&amp;apos;s no synchronization. The actual predicate tests whether f % 2 == 0. Clearly, this changes from time to time."/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="NUMTHREADS" access="priv" jdoc=""/>
			<field name="sInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.ThreadPredicateGenerator.createThreadClass(sandmark.program.Application)" access="prot" jdoc="This method creates a &amp;apos;threadClassName&amp;apos; class extending from the &amp;apos;Thread&amp;apos; class; The run() method implements the actual operations ie. manipulating the static localvar value; We can create 2 instances of this &amp;apos;threadClassName&amp;apos; class and &amp;apos;run&amp;apos; them in parallel. The resultant localvar value will be non-deterministic.">
				<comm cntt="Make the &amp;lt;init&amp;gt; method"/>
				<comm cntt="create the &amp;apos;run&amp;apos; method to implement the thread execution"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ThreadPredicateGenerator.insertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="entry API for this predicate lib; returns 1 on success, 0 on failure; The idea is to create a static field in the current class. Then we create a Thread class and two instances of threads that access this static field and alter its value dynamically and return its value normalized to 0 or 1. -- opaquely non-deterministic predicate">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ThreadPredicateGenerator.insertInterproceduralPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ThreadPredicateGenerator.canInsertPredicate(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ih"/>
				<param name="valueType"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ThreadPredicateGenerator.updateTargeters(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="oldIH"/>
				<param name="newIH"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ThreadPredicateGenerator.getInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ThreadPredicateGenerator.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.util.opaquepredicatelib.ExprTree" intfc="n" abs="n" inn="n" sloc="510" jdoc="This class is used to parse a string representing a boolean expression that compares two integer expressions, and turn it into a set of instruction lists that will perform that test (for use as an algebraic opaque predicate). The grammar for the expressions is as follows: &amp;lt;bool_expr&amp;gt; := &amp;lt;int_expr&amp;gt; &amp;lt;cmp_op&amp;gt; &amp;lt;int_expr&amp;gt; &amp;lt;int_expr&amp;gt; := &amp;lt;int_term&amp;gt; | &amp;lt;int_expr&amp;gt; &amp;lt;int_op1&amp;gt; &amp;lt;int_term&amp;gt; &amp;lt;int_term&amp;gt; := &amp;lt;int_var&amp;gt; | &amp;lt;int_term&amp;gt; &amp;lt;int_op2&amp;gt; &amp;lt;int_var&amp;gt; &amp;lt;int_var&amp;gt; := &amp;lt;literal_int&amp;gt; | &amp;lt;variable&amp;gt; | &amp;apos;(&amp;apos; &amp;lt;int_expr&amp;gt; &amp;apos;)&amp;apos; &amp;lt;int_op1&amp;gt; := &amp;apos;+&amp;apos; | &amp;apos;-&amp;apos; &amp;lt;int_op2&amp;gt; := &amp;apos; &amp;apos; | &amp;apos; &amp;apos; | &amp;apos;%&amp;apos; &amp;lt;cmp_op&amp;gt; := &amp;apos;==&amp;apos; | &amp;apos;&amp;gt;&amp;apos; | &amp;apos;&amp;lt;&amp;apos; | &amp;apos;&amp;lt;=&amp;apos; | &amp;apos;&amp;gt;=&amp;apos; | &amp;apos;!=&amp;apos; &amp;lt;variable&amp;gt; := &amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, ..., &amp;apos;z&amp;apos;">
			<comm cntt=""/>
			<comm cntt="varnumber is NOT local var index, it denotes that this"/>
			<comm cntt="is the Nth variable I&amp;apos;ve encountered...so like"/>
			<comm cntt="7 y z-1 != x x"/>
			<comm cntt="could be though of as"/>
			<comm cntt="7 [0] [1]-1 != [2] [2]"/>
			<comm cntt="...get it?"/>
			<comm cntt="returns the number of different VARIABLE nodes in this"/>
			<comm cntt="tree (different === different varName field)"/>
			<comm cntt="every element of vars must be either"/>
			<comm cntt="1. a sandmark.program.Field object denoting an"/>
			<comm cntt="INT field in the enclosing class"/>
			<comm cntt="2. an Integer object containing the index of an"/>
			<comm cntt="INT local var that will be initialized before the target IH"/>
			<comm cntt="also, vars must contain as many entries as this.numVars() (but there could be duplicates in the list)"/>
			<comm cntt="also, any field given must be loadable (so no instance fields too early in &amp;lt;init&amp;gt;)"/>
			<const name="BOOL_EXPR" access="priv" jdoc=""/>
			<const name="INT_BINOP" access="priv" jdoc=""/>
			<const name="LITERAL_INT" access="priv" jdoc=""/>
			<const name="VARIABLE" access="priv" jdoc=""/>
			<const name="EQ" access="priv" jdoc=""/>
			<const name="NE" access="priv" jdoc=""/>
			<const name="GT" access="priv" jdoc=""/>
			<const name="GE" access="priv" jdoc=""/>
			<const name="LT" access="priv" jdoc=""/>
			<const name="LE" access="priv" jdoc=""/>
			<const name="PLUS" access="priv" jdoc=""/>
			<const name="MINUS" access="priv" jdoc=""/>
			<const name="MULT" access="priv" jdoc=""/>
			<const name="DIV" access="priv" jdoc=""/>
			<const name="MOD" access="priv" jdoc=""/>
			<field name="type" access="priv" jdoc=""/>
			<field name="operator" access="priv" jdoc=""/>
			<field name="left" access="priv" jdoc=""/>
			<field name="right" access="priv" jdoc=""/>
			<field name="literal_value" access="priv" jdoc=""/>
			<field name="varnumber" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.ExprTree()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.parse(String)" access="pub" jdoc="">
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.parseBoolExpr(java.util.LinkedList, java.util.List)" access="priv" jdoc="">
				<param name="queue"/>
				<param name="varlist"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.parseIntExpr(java.util.LinkedList, java.util.List)" access="priv" jdoc="">
				<param name="queue"/>
				<param name="varlist"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.parseIntTerm(java.util.LinkedList, java.util.List)" access="priv" jdoc="">
				<param name="queue"/>
				<param name="varlist"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.parseIntVar(java.util.LinkedList, java.util.List)" access="priv" jdoc="">
				<param name="queue"/>
				<param name="varlist"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.skipWhite(java.util.LinkedList)" access="priv" jdoc="">
				<param name="queue"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.numVars()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.getAllVars()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.getInstructionLists(sandmark.program.Method, Object[])" access="pub" jdoc="">
				<comm cntt="makes 3 blocks"/>
				<comm cntt="makes 1--3 lists"/>
				<comm cntt="both got stored"/>
				<comm cntt="left was stored"/>
				<comm cntt="should always have length 1"/>
				<comm cntt="right got stored"/>
				<comm cntt="neither stored"/>
				<comm cntt="makes 1 list"/>
				<comm cntt="makes 1 list"/>
				<comm cntt="Integer"/>
				<comm cntt="sandmark.program.Field"/>
				<param name="method"/>
				<param name="vars"/>
			</mth>
			<mth name="/:sandmark.util.opaquepredicatelib.ExprTree.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.outliner">
		<class name="/:sandmark.util.outliner.OutlineUtil" intfc="n" abs="n" inn="n" sloc="2077" jdoc="">
			<comm cntt="ExceptionHandler shift information"/>
			<comm cntt="for target method shifts:"/>
			<comm cntt="for outline method shifts:"/>
			<field name="BUG" access="priv" jdoc=""/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="FIXBUG" access="priv" jdoc=""/>
			<const name="REMOVE_UPDATES" access="priv" jdoc=""/>
			<const name="NO_UPDATES" access="priv" jdoc=""/>
			<const name="ZERO_UPDATES" access="priv" jdoc=""/>
			<const name="TWO_UPDATES" access="priv" jdoc=""/>
			<const name="ALL_UPDATES" access="priv" jdoc=""/>
			<field name="app" access="priv" jdoc=""/>
			<field name="meth" access="priv" jdoc=""/>
			<field name="mcfg" access="priv" jdoc=""/>
			<field name="exOffset" access="priv" jdoc=""/>
			<field name="updateExTable" access="priv" jdoc=""/>
			<field name="updateExType" access="priv" jdoc=""/>
			<field name="sPC" access="priv" jdoc=""/>
			<field name="ePC" access="priv" jdoc=""/>
			<field name="hPC" access="priv" jdoc=""/>
			<field name="sOffset" access="pub" jdoc=""/>
			<field name="eOffset" access="pub" jdoc=""/>
			<field name="hOffset" access="pub" jdoc=""/>
			<field name="sOffsetIncr" access="pub" jdoc=""/>
			<field name="eOffsetIncr" access="pub" jdoc=""/>
			<field name="hOffsetIncr" access="pub" jdoc=""/>
			<field name="exctype" access="priv" jdoc=""/>
			<field name="exMark" access="priv" jdoc=""/>
			<const name="VOID_TYPE" access="priv" jdoc=""/>
			<const name="INTEGER_TYPE" access="priv" jdoc=""/>
			<const name="DOUBLE_TYPE" access="priv" jdoc=""/>
			<const name="FLOAT_TYPE" access="priv" jdoc=""/>
			<const name="LONG_TYPE" access="priv" jdoc=""/>
			<const name="CHARACTER_TYPE" access="priv" jdoc=""/>
			<const name="SHORT_TYPE" access="priv" jdoc=""/>
			<const name="BYTE_TYPE" access="priv" jdoc=""/>
			<const name="BOOLEAN_TYPE" access="priv" jdoc=""/>
			<field name="typeTable" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.outliner.OutlineUtil.OutlineUtil(sandmark.program.Application, sandmark.program.Method)" access="pub" jdoc="Constructor">
				<param name="baseApp"/>
				<param name="baseMeth"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.isValidMethod()" access="pub" jdoc="Checks if this target method can be outlined or not.">
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.createPushInstruction(int)" access="priv" jdoc="Makes an ICONST_n or BIPUSH n for a given int.">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.dominates(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="Returns true if ih1 dominates ih2, else returns false.">
				<comm cntt="Else, the handles are in the same block; so use 2nd approach"/>
				<param name="ih1"/>
				<param name="ih2"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.postdominates(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="Returns true if ih1 postdominates ih2, else returns false.">
				<comm cntt="Else, the handles are in the same block; so use 2nd approach"/>
				<param name="ih1"/>
				<param name="ih2"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.verifyOutliningPoints(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="This function checks whether the &amp;apos;fromIH&amp;apos; and &amp;apos;toIH&amp;apos; points satisfy the dom postdom condition. All blocks in between then should also satisfy this criteria so that we make sure there are no jumps into this chunk of code. The stack context at &amp;apos;fromIH&amp;apos; and &amp;apos;toIH&amp;apos; should be zero. Additional condition: should not split exception handling blocks.">
				<comm cntt="Get all the successors and include it in the linkedlist"/>
				<comm cntt="From the worklist, select verify that all BBlocks satisfy dom postdom conditon;"/>
				<comm cntt="if(tempBB==fromBB) continue;"/>
				<comm cntt="Also make sure that the stack context size is zero at &amp;apos;fromIH&amp;apos; and &amp;apos;toIH-&amp;gt;next&amp;apos;"/>
				<comm cntt="finally, check the exception handler condition"/>
				<param name="fromIH"/>
				<param name="toIH"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.getCatchEndOffset(org.apache.bcel.generic.CodeExceptionGen)" access="priv" jdoc="Returns the offset of the last instruction in the catch block &amp;apos;ceg&amp;apos;.">
				<param name="ceg"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.splitsExceptionBlock(int, int, int, int, int, int)" access="priv" jdoc="Checks whether &amp;apos;from&amp;apos; and &amp;apos;to&amp;apos; properly split the try-catch block.">
				<comm cntt="entire try-catch block lies below toIH"/>
				<comm cntt="entire try-catch block lies above fromIH"/>
				<comm cntt="part of catch block is outlined."/>
				<comm cntt="part of try block is outlined."/>
				<comm cntt="sOffset lies between fromIH and toIH"/>
				<comm cntt="entire try-catch block is outlined."/>
				<param name="sOffset"/>
				<param name="eOffset"/>
				<param name="hOffset"/>
				<param name="hEndOffset"/>
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.getSlotLiveRanges(java.util.ArrayList, int)" access="priv" jdoc="Returns the DUWeb objects associated with the slot index &amp;apos;slot&amp;apos;.">
				<comm cntt="defuse.DefWrappers sets"/>
				<comm cntt="(sandmark.analysis.defuse.DUWeb[])dulist.toArray();"/>
				<param name="nodelist"/>
				<param name="slot"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.liverangeInterferes(int, sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="Returns &amp;apos;true&amp;apos; if index &amp;apos;slot&amp;apos; has atleast one of its liverange intersecting the region from &amp;apos;fromBB&amp;apos; to &amp;apos;toBB&amp;apos;; Else, returns false.">
				<comm cntt="Get all the successors and include it in the linkedlist"/>
				<param name="slot"/>
				<param name="fromBB"/>
				<param name="toBB"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.getDefHandleFromWrapper(sandmark.analysis.defuse.DefWrapper)" access="priv" jdoc="Returns the instruction handle of the def. associated with this DefWrapper.">
				<param name="defwrap"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.getPliveVars(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, java.util.ArrayList)" access="pub" jdoc="Returns the LiveVar objects those have their liveranges passing into the outlined code range.">
				<comm cntt="init: invalid"/>
				<comm cntt="Now get all the def use handles from the duweb[] and check that atleast one def is before &amp;apos;fromIH&amp;apos; and all use in between &amp;apos;fromIH&amp;apos; and &amp;apos;toIH&amp;apos;"/>
				<comm cntt="above 2 set sizes are not necessarily the same; not strictly non-zero either."/>
				<comm cntt="if USE within the range"/>
				<comm cntt="if atleast one DEF above fromIH, then add"/>
				<comm cntt="if DEF-USE chain passes thru the entire range"/>
				<comm cntt="slotarray[], deflist[] and uselist[] contains the final slots satisfying &amp;apos;P&amp;apos; criteria"/>
				<param name="fromIH"/>
				<param name="toIH"/>
				<param name="nodelist"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.getQliveVars(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, java.util.ArrayList)" access="pub" jdoc="Returns the LiveVar objects those have their liveranges passing out of the outlined code range.">
				<comm cntt="init: invalid"/>
				<comm cntt="Now get all the def use handles from the duweb[] and check that atleast one def is in between &amp;apos;fromIH&amp;apos; and &amp;apos;toIH&amp;apos; and rest def use after &amp;apos;toIH&amp;apos;"/>
				<comm cntt="Above 2 set sizes are not necessarily the same; not strictly non-zero either."/>
				<comm cntt="no defIHs should lie above fromIH"/>
				<comm cntt="atleast one use below toIH"/>
				<comm cntt="slotarray[], deflist[] and uselist[] contains the final slots satisfying &amp;apos;Q&amp;apos; criteria"/>
				<param name="fromIH"/>
				<param name="toIH"/>
				<param name="nodelist"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.getVariableType(sandmark.program.Method, int)" access="priv" jdoc="Returns the variable type associated with this &amp;apos;slotid&amp;apos;.">
				<param name="meth"/>
				<param name="slotid"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.getRliveVars(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, java.util.ArrayList)" access="pub" jdoc="Returns the LiveVar objects those have their liveranges passing through the entire outlined code range.">
				<comm cntt="init: invalid"/>
				<comm cntt="Now get all the def use handles from the duweb[] and check that atleast one def use is before &amp;apos;fromIH&amp;apos; and one def use is after &amp;apos;toIH&amp;apos;"/>
				<comm cntt="above 2 set sizes are not necessarily the same; not strictly non-zero either."/>
				<comm cntt="slotarray[], deflist[] and uselist[] contains the final slots satisfying &amp;apos;R&amp;apos; criteria"/>
				<param name="fromIH"/>
				<param name="toIH"/>
				<param name="nodelist"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.passInRanges(org.apache.bcel.generic.InstructionHandle, LiveVar)" access="pub" jdoc="This function pushes the set of parameters that are to be passed from target method to outlined method, into the stack.">
				<comm cntt="invoke some error routine..."/>
				<comm cntt="Generate similar code in the loop for each incoming live range &amp;lt;type&amp;gt;load &amp;lt;slotnum&amp;gt;"/>
				<param name="fromIH"/>
				<param name="lv1"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.passThroughRanges(org.apache.bcel.generic.InstructionHandle, LiveVar)" access="pub" jdoc="This function promotes and packs the locals that have liveranges through outlined code range into an Object array and pushes this into the stack.">
				<comm cntt="invoke some error routine ..."/>
				<comm cntt="Generate similar code in the loop for each incoming liverange in lv3[] aload arrayref; dup; ( for the main array[]ref ) iconst &amp;lt;index&amp;gt;; &amp;lt;type&amp;gt; load &amp;lt;slot&amp;gt;; if(prim_type) new &amp;lt;Class type&amp;gt;; dup_x1; (or dup_x2) for double long swap; (or dup_x2 pop) for double long invokespecial &amp;lt;Object Class type&amp;gt; &amp;lt;primitive type&amp;gt; checkcast &amp;lt;OBJECT&amp;gt; aastore; At this point we have the object reference at the top of stack."/>
				<comm cntt="initialize array"/>
				<comm cntt="invoke is 3 word instruction"/>
				<param name="fromIH"/>
				<param name="lv3"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.createBranchInstruction(String)" access="priv" jdoc="Returns a branch instruction equivalent to the string representation.">
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.saveExceptionHandler(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.CodeExceptionGen, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="Keeps a mapping from the old exception handler offsets to the new offsets in the outlined code.">
				<param name="oldIH"/>
				<param name="ceg"/>
				<param name="newIH"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.isHandlerStart(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.CodeExceptionGen)" access="priv" jdoc="Returns true if &amp;apos;ih&amp;apos; is the start instruction handle of the handler block of exception &amp;apos;ceg&amp;apos;">
				<param name="ih"/>
				<param name="ceg"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.getSWordGrpLen(org.apache.bcel.generic.InstructionFactory)" access="priv" jdoc="Returns the length of a specific group of single word instructions.">
				<comm cntt="for invoke"/>
				<param name="ifactory"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.getDWordGrpLen(org.apache.bcel.generic.InstructionFactory)" access="priv" jdoc="Returns the length of a specific group of double word instructions.">
				<comm cntt="for invoke"/>
				<param name="ifactory"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.indexOffsetUpdate(int, int)" access="priv" jdoc="Updates the exception offsets based on &amp;apos;action&amp;apos;">
				<param name="currOffset"/>
				<param name="action"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.updateExceptionOffset(int, int)" access="priv" jdoc="Updates the exception offset based in the length of the instruction that is inserted or deleted.">
				<param name="currOffset"/>
				<param name="instrlen"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.createOutlineFunction(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, LiveVar, LiveVar, LiveVar)" access="pub" jdoc="Implements the entire BasicBlock to Seq.Instr routines, etc.">
				<comm cntt="get the exception table(if any)"/>
				<comm cntt="Recreate bytecode sequence from the CFG within the &amp;apos;fromIH&amp;apos; and &amp;apos;toIH&amp;apos; range"/>
				<comm cntt="First extract the second half of the split Block ; and create a new block"/>
				<comm cntt="maybe the next instruction is exceptionhandler PC; so CFG traversal will skip it"/>
				<comm cntt="insert code from &amp;apos;tempBB.getLastInstruction().getNext()&amp;apos; to &amp;apos;endCatchIH&amp;apos; in &amp;apos;ilist&amp;apos;"/>
				<comm cntt="Get the successors"/>
				<comm cntt="TBD: BUG: this will throw exception if last statement is RETURN"/>
				<comm cntt="Better to commit the instructionlist into the Outline method over here"/>
				<comm cntt="to be changed later;"/>
				<comm cntt="=lv3.length;"/>
				<comm cntt="TBD: copy the ExceptionTable ranges to the method Object. - done!"/>
				<comm cntt="outlinemeth.addExceptionHandler(sPC[w], ePC[w], hPC[w], exctype[w]);"/>
				<comm cntt="Current &amp;apos;ilist&amp;apos; contains just all the &amp;apos;raw&amp;apos; instructions; Match the index of the parameter(LV1) with that of these instructions. Also, extract LV3 values from objectref[] in the parameter and save in there corresponding primitives. All these instructions are inserted at the start of the method code."/>
				<comm cntt="&amp;apos;oldIndex&amp;apos; not required actually; for debugging"/>
				<comm cntt="if change is such that it shortens instr.length, adjust xOffsetIncr"/>
				<comm cntt="is this case possible ?"/>
				<comm cntt="For LV3, include code at beginning: Object[] -&amp;gt; Primitive Object , and at end of each primitive store, do: Primitive Object -&amp;gt; Object[] storage ..........................................................................."/>
				<comm cntt="For each store for LV3 Primitive Object, store in corresponding Object[] index dup; one copy left for the actual Primitive Object store if(prim_type) new &amp;lt;object_type&amp;gt;; dup_x1; (or dup_x2) for double long swap; ( or dup_x2 pop) for double long invokespecial &amp;lt;init&amp;gt;; aload &amp;lt;LV3index&amp;gt;; swap; iconst_&amp;lt;arrayindex&amp;gt; swap; aaload;"/>
				<comm cntt="At this point we have &amp;apos;arrindex&amp;apos; and its corresponding &amp;apos;object_slot&amp;apos;"/>
				<comm cntt="Include the code at start of &amp;apos;OUTLINEMETHOD&amp;apos; for Object[] -&amp;gt; Primitive Object storage aload arrayref; for(;;) dup; push &amp;lt;arrayindex&amp;gt;; aaload; checkcast &amp;lt;object_type&amp;gt;; if(prim_type) invokevirtual .&amp;lt;type&amp;gt;Value(); &amp;lt;type&amp;gt;store&amp;lt;prim_slot&amp;gt;; pop;"/>
				<comm cntt="For LV2, promote and pack the LV2 into Object[] and return; Do this only if(LV2.length&amp;gt;1) ....................................................."/>
				<comm cntt="No promoting-packing done ..."/>
				<comm cntt="Else, promote-pack ..."/>
				<comm cntt="arrref at top of stack now; dup; push index; if(reference_type) &amp;lt;object_type&amp;gt;load&amp;lt;slot&amp;gt;; AASTORE; else new &amp;lt;objtype&amp;gt;; dup; &amp;lt;prim_type&amp;gt;load&amp;lt;slot&amp;gt;; invokespecial &amp;lt;init&amp;gt;; AASTORE;"/>
				<comm cntt="No promotion required; Just add to array"/>
				<comm cntt="org.apache.bcel.generic.Type.OBJECT)"/>
				<comm cntt="Promote the primitive local first; then pack it into the array"/>
				<comm cntt="remove the &amp;apos;nopIH&amp;apos; instruction @ end of list"/>
				<comm cntt="outlinemeth.addExceptionHandler(newIH[28], newIH[31], newIH[33], exctype[w]);"/>
				<comm cntt="if(DEBUG)System.out.println(&amp;quot;w = &amp;quot;+w); if(DEBUG)System.out.println(&amp;quot;sPC = &amp;quot;+sPC[w]); if(DEBUG)System.out.println(&amp;quot;ePC = &amp;quot;+ePC[w]); if(DEBUG)System.out.println(&amp;quot;hPC = &amp;quot;+hPC[w]); if(DEBUG)System.out.println(&amp;quot;exctype = &amp;quot;+exctype[w]); outlinemeth.addExceptionHandler(sPC[w], ePC[w], hPC[w], exctype[w]);"/>
				<param name="fromIH"/>
				<param name="toIH"/>
				<param name="lv1"/>
				<param name="lv2"/>
				<param name="lv3"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.offsetToIH(int, org.apache.bcel.generic.InstructionList)" access="priv" jdoc="Returns the instruction handle that has position &amp;apos;offset&amp;apos; in &amp;apos;ilist&amp;apos;">
				<comm cntt="if(DEBUG)System.out.println(&amp;quot; len = &amp;quot;+len);"/>
				<param name="offset"/>
				<param name="ilist"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.unpackLocals(org.apache.bcel.generic.InstructionHandle, LiveVar, LiveVar, int, sandmark.program.Method)" access="pub" jdoc="This function unpacks all the information ie. returned from the outlined method; and also the information that passes through the outlined code.">
				<comm cntt="Unpack the returned LV2 registers"/>
				<comm cntt="&amp;lt;type&amp;gt;store &amp;lt;slot&amp;gt;"/>
				<comm cntt="Include the code after &amp;apos;toIH&amp;apos; for object -&amp;gt; primitive storage &amp;apos;object[] is in top of stack&amp;apos; dup push index aaload checkcast &amp;lt;object_type&amp;gt; invokevirtual &amp;lt;type&amp;gt;Value() .. (only for nonreferencetypes) &amp;lt;type&amp;gt;store"/>
				<comm cntt="pop out the reference object from the stack"/>
				<comm cntt="Unpack for LV3: Object[] -&amp;gt; Object-Primitive storage"/>
				<comm cntt="aload arrayref;(object reference not @ top of stack) for(;;) dup; push arrayindex; aaload; checkcast &amp;lt;object_type&amp;gt;; if(prim_type) invokevirtual &amp;lt;type&amp;gt;Value(); &amp;lt;type&amp;gt;store&amp;lt;prim_slot&amp;gt; pop;"/>
				<comm cntt="TBD: put additional condition for end of file"/>
				<param name="toIH"/>
				<param name="lv2"/>
				<param name="lv3"/>
				<param name="LV3index"/>
				<param name="outlinemeth"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.misc(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, sandmark.program.Method, LiveVar, LiveVar, LiveVar)" access="pub" jdoc="Performs various operations such as creating invokation for outlined method; updating the exception table ranges of the target method, etc.">
				<comm cntt="insert a &amp;apos;nop&amp;apos; instruction before &amp;apos;fromIH&amp;apos;"/>
				<comm cntt="insert the method invokation to &amp;apos;outmeth&amp;apos;"/>
				<comm cntt="delete the instruction range."/>
				<comm cntt="for &amp;apos;toIH&amp;apos;"/>
				<comm cntt="update the ExceptionTable ranges (if required)"/>
				<param name="fromIH"/>
				<param name="toIH"/>
				<param name="outmeth"/>
				<param name="lv1"/>
				<param name="lv2"/>
				<param name="lv3"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineUtil.identifyCrossPoint(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="DEPRECATED: Identify cross-points &amp;apos;m&amp;apos; and &amp;apos;n&amp;apos;. &amp;apos;m&amp;apos; and &amp;apos;n&amp;apos; should dominate post-dominate the bottom top of method; Also, make the cut optimal, such that live variables are minimum .">
				<comm cntt="Entire range is in a single block"/>
				<comm cntt="Choose a point where the stackcontext is zero"/>
				<comm cntt="Get all the successors and include it in the linkedlist"/>
				<comm cntt="From the worklist, select all BBlocks which satisfy dom postdom conditon; Then select the one among it which has least live variables scope. And then select a random zero ## STACK CONTEXT ## ih from that BBlock"/>
				<comm cntt="a very big number; just for initialization"/>
				<comm cntt="this will be a better cut, since less number of local variables to be passed as parameter to the new function"/>
				<comm cntt="Choose a point where the stackcontext is zero"/>
				<param name="from"/>
				<param name="to"/>
			</mth>
		</class>
		<class name="/:sandmark.util.outliner.Outliner" intfc="n" abs="n" inn="n" sloc="61" jdoc="">
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="BUG" access="priv" jdoc=""/>
			<field name="fromIH" access="priv" jdoc=""/>
			<field name="toIH" access="priv" jdoc=""/>
			<field name="baseMethod" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.outliner.Outliner.Outliner()" access="pub" jdoc="Outline the code in between &amp;apos;from&amp;apos; and &amp;apos;to&amp;apos; (inclusive)">
			</mth>
			<mth name="/:sandmark.util.outliner.Outliner.Outliner(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle, sandmark.program.Method)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
				<param name="targetMethod"/>
			</mth>
			<mth name="/:sandmark.util.outliner.Outliner.apply(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="This function verifies that the fromIH and toIH satisfy the dom postdom criteria."/>
				<comm cntt="Extract an iterator over DUWeb objects in the igraph"/>
				<comm cntt="Extract set of variables (along with their types) which have use in this range, and last def. before &amp;apos;fromIH&amp;apos;."/>
				<comm cntt="Extract set of variables (along with their types) which have def in this range, and atleast one use after &amp;apos;toIH&amp;apos; and no definition before this range."/>
				<comm cntt="Extract set of variables (along with their types) whose live range passes the entire range."/>
				<comm cntt="Pass the lv1 locals to the new function as intial @params. Pushes the arguments into the top of the stack, to be consumed by the invokation to the new function"/>
				<comm cntt="Promote and pass the lv3 locals in a Object array to pass it to the new function as its first @param. Unpack it in that function. this funtion returns the arrayref index and pushes the object into the top of the stack, to be consumed by the invokation to the new function"/>
				<comm cntt="Create the new function with the in-range instructions and necessary unpacking instructions(for lv1) and packing instructions (for lv2) to be returned. For lv3, not sure as of now. Check the routines in MethodMadness obfuscator ..."/>
				<comm cntt="Unpacks the locals: - returned by the new function at the position(LV2) and - passed as object array to the new function(LV3) at &amp;apos;lowerCutHandle&amp;apos; and insert appropriate instructions to get the value into primitive locals in their correct slots ..."/>
				<comm cntt="Miscelleneous modules: 1. Add method Invokation 2. Remove the code range which is outlined. 3. Update ExceptionTable of target method(if needed)."/>
				<comm cntt="to be done in maintest invokation"/>
				<param name="app"/>
			</mth>
		</class>
		<class name="/:sandmark.util.outliner.OutlineFrame" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="domMethod" access="pub" jdoc=""/>
			<field name="postdomMethod" access="pub" jdoc=""/>
			<field name="domInvoke" access="pub" jdoc=""/>
			<field name="postdomInvoke" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.outliner.OutlineFrame.OutlineFrame(sandmark.program.Method, sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="method1"/>
				<param name="method2"/>
				<param name="invokehandle1"/>
				<param name="invokehandle2"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineFrame.getdomBB(sandmark.analysis.controlflowgraph.MethodCFG)" access="pub" jdoc="">
				<param name="mcfg"/>
			</mth>
			<mth name="/:sandmark.util.outliner.OutlineFrame.getpostdomBB(sandmark.analysis.controlflowgraph.MethodCFG)" access="pub" jdoc="">
				<param name="mcfg"/>
			</mth>
		</class>
		<class name="/:sandmark.util.outliner.LiveVar" intfc="n" abs="n" inn="n" sloc="42" jdoc="">
			<comm cntt="returns the definition instruction handles"/>
			<comm cntt="returns the use instruction handles"/>
			<field name="slot" access="pub" jdoc=""/>
			<field name="localtype" access="pub" jdoc=""/>
			<field name="defList" access="pub" jdoc=""/>
			<field name="useList" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.outliner.LiveVar.LiveVar(int, org.apache.bcel.generic.Type)" access="pub" jdoc="">
				<param name="index"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.util.outliner.LiveVar.setDefList(java.util.ArrayList)" access="pub" jdoc="">
				<param name="list"/>
			</mth>
			<mth name="/:sandmark.util.outliner.LiveVar.getDefList()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.outliner.LiveVar.setUseList(java.util.ArrayList)" access="pub" jdoc="">
				<param name="list"/>
			</mth>
			<mth name="/:sandmark.util.outliner.LiveVar.getUseList()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.outliner.LiveVar.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.outliner.LiveVar.getSlot()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.outliner.LiveVar.isObjectType()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.primitivepromotion">
		<class name="/:sandmark.util.primitivepromotion.LocalPromoter" intfc="n" abs="n" inn="n" sloc="229" jdoc="This class provides routines for promoting primitive local variables in methods to their corresponding wrapper type. @author Srinivas Visvanathan">
			<comm cntt="name of wrapper type"/>
			<comm cntt="primitve type"/>
			<comm cntt="class name of primitve load store"/>
			<comm cntt="e.g. org.apache.bcel.generic.ISTORE"/>
			<comm cntt="name of method which is used to get the"/>
			<comm cntt="primitive value from a wrapper object"/>
			<comm cntt="Main routne that manages the primitive promotion for all types. All the previous public methods are wrappers for this method, to set stuff up for the approapriate type"/>
			<comm cntt="Adds code at the start of mg that wraps primitive locals of the type being promoted. Returns the handle to the first instruction of mg that follows this wrapper code"/>
			<comm cntt="Replaces &amp;quot;TLOAD x&amp;quot; with the sequence: ALOAD x INVOKEVIRTUAL T.tvalue()t This method returns the handle to the instruction following the original &amp;quot;TLOAD x&amp;quot;"/>
			<comm cntt="Replaces &amp;quot;TSTORE x&amp;quot; with the sequence: NEW java.lang.T DUP_X1 DUP_X2 (X1 for int float, X2 for long double) DUP_X1 DUP_X2 (X1 for int float, X2 for long double) POP INVOKESPECIAL T.&amp;lt;init&amp;gt;(t)V ASTORE x This method returns the handle to the instruction following the original &amp;quot;TSTORE x&amp;quot;"/>
			<comm cntt="Replaces &amp;quot;IINC x i&amp;quot; with the sequence ILOAD x ICONST i IADD ISTORE x The method returns the handle to the new &amp;quot;ILOAD x&amp;quot; instruction, so that when the main loop continues scanning, the ILOAD and ISTORE will be processed"/>
			<field name="tName" access="priv" jdoc=""/>
			<field name="pType" access="priv" jdoc=""/>
			<field name="loadName" access="priv" jdoc=""/>
			<field name="storeName" access="priv" jdoc=""/>
			<field name="tValue" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.primitivepromotion.LocalPromoter.iPromote(sandmark.program.Method)" access="pub" jdoc="Used to promote local variables of type int in a method to java.lang.Integer. It also affects local variables of type byte, char, short and boolean, since these are implemented using the int primitive at the bytecode level. @param mg Method whose locals have to be promoted">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.LocalPromoter.fPromote(sandmark.program.Method)" access="pub" jdoc="Used to promote local variables of type float in a method to java.lang.Float. @param mg Method whose locals have to be promoted">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.LocalPromoter.lPromote(sandmark.program.Method)" access="pub" jdoc="Used to promote local variables of type long in a method to java.lang.Long. @param mg Method whose locals have to be promoted">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.LocalPromoter.dPromote(sandmark.program.Method)" access="pub" jdoc="Used to promote local variables of type double in a method to java.lang.Double. @param mg Method whose locals have to be promoted">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.LocalPromoter.tPromote(sandmark.program.Method)" access="priv" jdoc="">
				<comm cntt="wrap the input params of the type being promoted"/>
				<comm cntt="scan thru the method&amp;apos;s instructions"/>
				<comm cntt="if its a load for the type being promoted"/>
				<comm cntt="if its a store for the type being promoted"/>
				<comm cntt="if its IINC and we&amp;apos;re promoting int"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.LocalPromoter.wrapMethodParams(sandmark.program.Method, org.apache.bcel.generic.InstructionFactory, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<comm cntt="collect indexes of params that have to be wrapped in the list indices"/>
				<comm cntt="if we&amp;apos;re promoting ints then remember this index"/>
				<comm cntt="if we&amp;apos;re promoting floats then remember this index"/>
				<comm cntt="if we&amp;apos;re promoting long then remember this index"/>
				<comm cntt="if we&amp;apos;re promoting doubles then remember this index"/>
				<comm cntt="array type, reference type etc."/>
				<comm cntt="generate instructions to wrap each of the local params of the type"/>
				<comm cntt="being promoted"/>
				<comm cntt="new java.lang.T"/>
				<comm cntt="dup"/>
				<comm cntt="tload idx"/>
				<comm cntt="invokespecial T(t)V"/>
				<comm cntt="astore idx"/>
				<comm cntt="return handle to first instruction in the original list"/>
				<param name="mg"/>
				<param name="iF"/>
				<param name="il"/>
				<param name="ih"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.LocalPromoter.fixLoad(org.apache.bcel.generic.InstructionFactory, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.LoadInstruction)" access="priv" jdoc="">
				<comm cntt="aload &amp;lt;idx&amp;gt; - load object ref of wrapper type tName"/>
				<comm cntt="redirect branches targetting the iload to now target the aload"/>
				<comm cntt="delete the tload instruction"/>
				<comm cntt="invokevirtual T.tValue()t"/>
				<param name="iF"/>
				<param name="il"/>
				<param name="ih"/>
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.LocalPromoter.fixStore(org.apache.bcel.generic.InstructionFactory, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.StoreInstruction)" access="priv" jdoc="">
				<comm cntt="new java.lang.T"/>
				<comm cntt="redirect branches targetting the tstore to now target the new"/>
				<comm cntt="delete the tstore instruction"/>
				<comm cntt="2 dup_x1 for int float, 2 dup_x2 for long double"/>
				<comm cntt="POP"/>
				<comm cntt="invokespecial T(t)V"/>
				<comm cntt="astore idx"/>
				<param name="iF"/>
				<param name="il"/>
				<param name="ih"/>
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.LocalPromoter.fixIINC(org.apache.bcel.generic.InstructionFactory, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.IINC, org.apache.bcel.generic.ConstantPoolGen)" access="priv" jdoc="">
				<comm cntt="iload idx"/>
				<comm cntt="remember handle to iload"/>
				<comm cntt="redirect branches targetting the iload to now target the aload"/>
				<comm cntt="delete the iinc instruction"/>
				<comm cntt="iconst incr"/>
				<comm cntt="iadd"/>
				<comm cntt="istore idx"/>
				<comm cntt="return handle to iload, next instruction to be processed"/>
				<comm cntt="will be handled in the main loop as an ILOAD"/>
				<param name="iF"/>
				<param name="il"/>
				<param name="ih"/>
				<param name="instr"/>
				<param name="cp"/>
			</mth>
		</class>
		<class name="/:sandmark.util.primitivepromotion.ParamPromoter" intfc="n" abs="n" inn="n" sloc="151" jdoc="Promotes the types of the parameters of a method. To use the class use the &amp;quot;apply&amp;quot; method defined by its super class (@see sandmark.util.MethodSignatureChanger) @author Srinivas Visvanathn">
			<comm cntt="index of first arg that&amp;apos;s promoted"/>
			<comm cntt="unpacks and unwraps args to what they orignally were"/>
			<field name="oldAT" access="pub" jdoc=""/>
			<field name="newAT" access="pub" jdoc=""/>
			<field name="oldIndices" access="pub" jdoc=""/>
			<field name="newIndices" access="pub" jdoc=""/>
			<field name="first" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.primitivepromotion.ParamPromoter.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.ParamPromoter.customInit(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="ensure there are enough args and some of them are of primitive type"/>
				<comm cntt="compute arg types for promoted method"/>
				<comm cntt="also remember the first arg that&amp;apos;s promoted"/>
				<comm cntt="ensure, method with promoted args doesn&amp;apos;t already exist"/>
				<comm cntt="compute local var indices for old and new params"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.ParamPromoter.fixMethodSignature(sandmark.program.Method)" access="prot" jdoc="">
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.ParamPromoter.fixMethodCode(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="param jj was promoted, unwrap unpack the param"/>
				<comm cntt="param jj wasn&amp;apos;t promoted, but it got packed, so unpack"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.ParamPromoter.fixInvoke(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionFactory, org.apache.bcel.generic.ConstantPoolGen, sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="remember the instruction that precedes the invoke"/>
				<comm cntt="scan backwards thru args upto the first promoted arg"/>
				<comm cntt="have to store this arg and load it back again"/>
				<comm cntt="if this arg is promoted then add code to wrap it before the store"/>
				<comm cntt="set tmph so that further instructions get added"/>
				<comm cntt="in between the previous store-load pair"/>
				<comm cntt="add code to wrap the first promoted arg"/>
				<comm cntt="make the invoke refer to the promoted method"/>
				<comm cntt="redirect branches to the start of the wrapup sequence"/>
				<param name="ih"/>
				<param name="il"/>
				<param name="iF"/>
				<param name="cpg"/>
				<param name="meth"/>
			</mth>
		</class>
		<class name="/:sandmark.util.primitivepromotion.ReturnPromoter" intfc="n" abs="n" inn="n" sloc="97" jdoc="Promotes the return type of a method. To use the class use the &amp;quot;apply&amp;quot; method defined by its super class (@see sandmark.util.MethodSignatureChanger) @author Srinivas Visvanathn">
			<comm cntt="primitive type"/>
			<comm cntt="wrapper type"/>
			<comm cntt="args of method"/>
			<field name="pType" access="priv" jdoc=""/>
			<field name="wType" access="priv" jdoc=""/>
			<field name="argTypes" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.primitivepromotion.ReturnPromoter.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.ReturnPromoter.customInit(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="ensure return type is a primitive type"/>
				<comm cntt="ensure a method with promoted return type doesn&amp;apos;t already exist"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.ReturnPromoter.fixMethodSignature(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="change return type"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.ReturnPromoter.fixMethodCode(sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="scan thru instructions looking for returns"/>
				<comm cntt="add code to wrap the primitive value into an object"/>
				<comm cntt="NEW java.lang.T"/>
				<comm cntt="2 DUP_X1 DUP_X2"/>
				<comm cntt="POP"/>
				<comm cntt="invokespecial T(t)V"/>
				<comm cntt="ARETURN"/>
				<param name="meth"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.ReturnPromoter.fixInvoke(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionFactory, org.apache.bcel.generic.ConstantPoolGen, sandmark.program.Method)" access="prot" jdoc="">
				<comm cntt="make invoke refer to the promoted method"/>
				<comm cntt="unwrap the primitive value, after the invoke"/>
				<param name="ih"/>
				<param name="il"/>
				<param name="iF"/>
				<param name="cpg"/>
				<param name="meth"/>
			</mth>
		</class>
		<class name="/:sandmark.util.primitivepromotion.PromoterException" intfc="n" abs="n" inn="n" sloc="7" jdoc="Exceptions thrown by primitive promotion routines @author Srinivas Visvanathan">
			<mth name="/:sandmark.util.primitivepromotion.PromoterException.PromoterException(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:sandmark.util.primitivepromotion.PromoterUtil" intfc="n" abs="n" inn="n" sloc="48" jdoc="Useful routines for the promoter classes @author Srinivas Visvanathan">
			<mth name="/:sandmark.util.primitivepromotion.PromoterUtil.getWrapperType(org.apache.bcel.generic.Type)" access="pub" jdoc="Returns the wrapper type for a given primitive type. Returns null if primitiveType is not a primitive type.">
				<param name="primitiveType"/>
			</mth>
			<mth name="/:sandmark.util.primitivepromotion.PromoterUtil.getValueMethodName(org.apache.bcel.generic.Type)" access="pub" jdoc="Returns the name of the method that can be used to get the primitive value from its wrapper type. Returns null if primitiveType is not a primitive type">
				<param name="primitiveType"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.splitint">
		<class name="/:sandmark.util.splitint.PartialSumSplitter" intfc="n" abs="n" inn="n" sloc="78" jdoc="">
			<mth name="/:sandmark.util.splitint.PartialSumSplitter.PartialSumSplitter(java.util.Random)" access="pub" jdoc="">
				<comm cntt="We don&amp;apos;t use randomness."/>
				<param name="rnd"/>
			</mth>
			<mth name="/:sandmark.util.splitint.PartialSumSplitter.PartialSumSplitter()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.PartialSumSplitter.split(java.math.BigInteger, int)" access="pub" jdoc="">
				<param name="value"/>
				<param name="nparts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.PartialSumSplitter.combine(java.math.BigInteger[])" access="pub" jdoc="">
				<param name="parts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.PartialSumSplitter.orderMatters()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.PartialSumSplitter.mask(int)" access="priv" jdoc="">
				<param name="bits"/>
			</mth>
			<mth name="/:sandmark.util.splitint.PartialSumSplitter.main(String[])" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.splitint.CombinationSplitter" intfc="n" abs="n" inn="n" sloc="104" jdoc="">
			<field name="maxValue" access="priv" jdoc=""/>
			<field name="bigMaxValue" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.splitint.CombinationSplitter.CombinationSplitter(int)" access="pub" jdoc="">
				<param name="maxValue"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CombinationSplitter.split(java.math.BigInteger)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CombinationSplitter.combine(java.math.BigInteger[])" access="pub" jdoc="">
				<param name="bigParts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CombinationSplitter.orderMatters()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.CombinationSplitter.main(String[])" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.splitint.FastCRTSplitter" intfc="n" abs="n" inn="n" sloc="71" jdoc="">
			<mth name="/:sandmark.util.splitint.FastCRTSplitter.FastCRTSplitter(int, int, int, javax.crypto.SecretKey)" access="pub" jdoc="">
				<param name="bits"/>
				<param name="minModuli"/>
				<param name="maxparts"/>
				<param name="w"/>
			</mth>
			<mth name="/:sandmark.util.splitint.FastCRTSplitter.FastCRTSplitter(int, int, javax.crypto.SecretKey)" access="pub" jdoc="">
				<param name="bits"/>
				<param name="maxparts"/>
				<param name="w"/>
			</mth>
			<mth name="/:sandmark.util.splitint.FastCRTSplitter.filter(Congruence)" access="prot" jdoc="">
				<param name="cs"/>
			</mth>
			<mth name="/:sandmark.util.splitint.FastCRTSplitter.main(String[])" access="pub" jdoc="">
				<comm cntt="for (int i = 0; i &amp;lt; a.length; i++)"/>
				<comm cntt="System.out.println(a[i]);"/>
				<comm cntt="System.out.println(&amp;quot;------------------------------------------&amp;quot;);"/>
				<comm cntt="System.out.println(s.combine(a));"/>
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.splitint.IntSplitter" intfc="y" abs="n" inn="n" sloc="5" jdoc="">
			<mth name="/:sandmark.util.splitint.IntSplitter.split(java.math.BigInteger)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.splitint.IntSplitter.combine(java.math.BigInteger)" access="pub" jdoc="">
				<param name="parts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.IntSplitter.orderMatters()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.util.splitint.SlowCRTSplitter" intfc="n" abs="n" inn="n" sloc="140" jdoc="">
			<mth name="/:sandmark.util.splitint.SlowCRTSplitter.SlowCRTSplitter(int, int, int, javax.crypto.SecretKey)" access="pub" jdoc="">
				<param name="bits"/>
				<param name="minModuli"/>
				<param name="maxparts"/>
				<param name="w"/>
			</mth>
			<mth name="/:sandmark.util.splitint.SlowCRTSplitter.SlowCRTSplitter(int, int, javax.crypto.SecretKey)" access="pub" jdoc="">
				<param name="bits"/>
				<param name="maxparts"/>
				<param name="w"/>
			</mth>
			<mth name="/:sandmark.util.splitint.SlowCRTSplitter.filter(Congruence)" access="prot" jdoc="">
				<comm cntt="System.out.println(&amp;quot;maxcount = &amp;quot; + maxcount);"/>
				<comm cntt="System.out.println(&amp;quot;secondcount = &amp;quot; + secondcount);"/>
				<comm cntt="shouldn&amp;apos;t happen... ??"/>
				<param name="cs"/>
			</mth>
			<mth name="/:sandmark.util.splitint.SlowCRTSplitter.nextNode(java.util.Iterator, java.util.Set)" access="priv" jdoc="">
				<param name="i"/>
				<param name="u"/>
			</mth>
			<mth name="/:sandmark.util.splitint.SlowCRTSplitter.main(String[])" access="pub" jdoc="">
				<comm cntt="for (int i = 0; i &amp;lt; a.length; i++)"/>
				<comm cntt="System.out.println(a[i]);"/>
				<comm cntt="System.out.println(&amp;quot;------------------------------------------&amp;quot;);"/>
				<comm cntt="System.out.println(s.combine(a));"/>
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.splitint.ResidueSplitter" intfc="n" abs="y" inn="n" sloc="7" jdoc="">
			<mth name="/:sandmark.util.splitint.ResidueSplitter.combineRes(java.math.BigInteger)" access="pub" jdoc="">
				<param name="parts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.ResidueSplitter.combine(java.math.BigInteger)" access="pub" jdoc="">
				<param name="parts"/>
			</mth>
		</class>
		<class name="/:sandmark.util.splitint.ScaledSplitter" intfc="n" abs="n" inn="n" sloc="93" jdoc="">
			<field name="EXPONENT_DIGITS" access="pub" jdoc=""/>
			<field name="LENGTH_DIGITS" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.splitint.ScaledSplitter.orderMatters()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.ScaledSplitter.split(java.math.BigInteger, int)" access="pub" jdoc="">
				<param name="value"/>
				<param name="nparts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.ScaledSplitter.combine(java.math.BigInteger[])" access="pub" jdoc="">
				<param name="parts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.ScaledSplitter.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.splitint.CRTSplitter" intfc="n" abs="y" inn="n" sloc="264" jdoc="">
			<field name="p" access="priv" jdoc=""/>
			<field name="c" access="priv" jdoc=""/>
			<field name="w" access="priv" jdoc=""/>
			<field name="splittingGraph" access="priv" jdoc=""/>
			<field name="MAX_LONG" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.splitint.CRTSplitter.orderMatters()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.CRTSplitter(int, int, int, javax.crypto.SecretKey)" access="pub" jdoc="">
				<param name="bits"/>
				<param name="minModuli"/>
				<param name="maxparts"/>
				<param name="w"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.CRTSplitter(int, int, javax.crypto.SecretKey)" access="pub" jdoc="">
				<param name="bits"/>
				<param name="maxparts"/>
				<param name="w"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.getAlgorithm()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.convert(long)" access="priv" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.convert(byte)" access="priv" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.split(java.math.BigInteger)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.numModuli()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.modulo(int)" access="prot" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.filter(Congruence)" access="prot" jdoc="">
				<param name="cs"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.combineRes(java.math.BigInteger)" access="pub" jdoc="">
				<param name="parts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.chinese(java.math.BigInteger, java.math.BigInteger, java.math.BigInteger, java.math.BigInteger)" access="priv" jdoc="">
				<param name="a"/>
				<param name="m"/>
				<param name="b"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.euclid(java.math.BigInteger, java.math.BigInteger)" access="priv" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.gcd(long, long)" access="priv" jdoc="">
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter.findmods(int)" access="priv" jdoc="">
				<param name="bits"/>
			</mth>
		<class name="/:sandmark.util.splitint.CRTSplitter$Congruence" intfc="n" abs="n" inn="y" sloc="26" jdoc="">
			<field name="residue" access="pub" jdoc=""/>
			<field name="prime1" access="pub" jdoc=""/>
			<field name="prime2" access="pub" jdoc=""/>
			<mth name="/:sandmark.util.splitint.CRTSplitter$Congruence.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter$Congruence.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.CRTSplitter$Congruence.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.util.splitint.AdditiveSplitter" intfc="n" abs="n" inn="n" sloc="54" jdoc="">
			<field name="mRnd" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.splitint.AdditiveSplitter.AdditiveSplitter(java.util.Random)" access="pub" jdoc="">
				<param name="rnd"/>
			</mth>
			<mth name="/:sandmark.util.splitint.AdditiveSplitter.orderMatters()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.AdditiveSplitter.split(java.math.BigInteger, int)" access="pub" jdoc="">
				<param name="value"/>
				<param name="nparts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.AdditiveSplitter.combine(java.math.BigInteger[])" access="pub" jdoc="">
				<param name="parts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.AdditiveSplitter.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.util.splitint.ValueSplitter" intfc="n" abs="y" inn="n" sloc="70" jdoc="">
			<mth name="/:sandmark.util.splitint.ValueSplitter.split(java.math.BigInteger, int)" access="pub" jdoc="">
				<param name="value"/>
				<param name="nparts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.ValueSplitter.combine(java.math.BigInteger[])" access="pub" jdoc="">
				<param name="parts"/>
			</mth>
			<mth name="/:sandmark.util.splitint.ValueSplitter.orderMatters()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.splitint.ValueSplitter.getRandomIntsWithSum(int, int)" access="pub" jdoc="">
				<param name="sum"/>
				<param name="count"/>
			</mth>
			<mth name="/:sandmark.util.splitint.ValueSplitter.getRandomIntsWithSum(int, int, java.util.Random)" access="pub" jdoc="">
				<param name="sum"/>
				<param name="count"/>
				<param name="rnd"/>
			</mth>
			<mth name="/:sandmark.util.splitint.ValueSplitter.getSubstringsWithLengths(String, int[])" access="pub" jdoc="">
				<param name="str"/>
				<param name="lengths"/>
			</mth>
			<mth name="/:sandmark.util.splitint.ValueSplitter.getZeroString(int)" access="pub" jdoc="">
				<param name="nzeros"/>
			</mth>
			<mth name="/:sandmark.util.splitint.ValueSplitter.testSplitter(ValueSplitter, int, boolean)" access="pub" jdoc="">
				<comm cntt="new java.util.Random();"/>
				<param name="vs"/>
				<param name="reps"/>
				<param name="debug"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.util.stealth">
		<class name="/:sandmark.util.stealth.Cluster" intfc="n" abs="n" inn="n" sloc="378" jdoc="">
			<comm cntt="Evaluates the methodlevel complexity for all methods in &amp;apos;myApp&amp;apos; for the metric m and returns a vector of complexities"/>
			<comm cntt="normal quadratic sort; can implement quicksort or likewise to make it faster"/>
			<comm cntt="Builds cluster in a bottom-up approach starting with single element clusters; uses WARD&amp;apos;s clustering technique"/>
			<comm cntt="Returns the clusters built; dimenstion -&amp;gt;[k][2] float[][0] contains the cluster centroid float[][1] contains the cluster size"/>
			<comm cntt="Sets the number of clusters to be generated"/>
			<comm cntt="Returns the number of clusters"/>
			<comm cntt="TESTRUN Usage:- eg. Cluster &amp;lt;bench.jar&amp;gt; &amp;lt;A.jar&amp;gt; &amp;lt;A_wm.jar&amp;gt; &amp;lt;mark_file&amp;gt; arg[0] -&amp;gt; benchmark jar file(eg. specJVM: bench.jar) arg[1] -&amp;gt; original application jar file for which to evaluate the global stealth arg[2] -&amp;gt; watermarked application jar file for which to evaluate the global stealth arg[3] -&amp;gt; fileName of the markedMethods obtained from your watermarker to evaluate local stealth"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="myApp" access="priv" jdoc=""/>
			<field name="DEFAULT_BENCHCLUSTER_SIZE" access="priv" jdoc=""/>
			<field name="DEFAULT_APPCLUSTER_SIZE" access="priv" jdoc=""/>
			<field name="methodMeasure" access="priv" jdoc=""/>
			<field name="numberOfClusters" access="priv" jdoc=""/>
			<field name="finalCluster" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.stealth.Cluster.Cluster(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.util.stealth.Cluster.evaluateMethods(String)" access="pub" jdoc="">
				<comm cntt="m.evaluateMetric();"/>
				<comm cntt="m.evaluateMetric();"/>
				<comm cntt="m.evaluateMetric();"/>
				<param name="metricName"/>
			</mth>
			<mth name="/:sandmark.util.stealth.Cluster.bubblesort(float, int)" access="pub" jdoc="">
				<param name="data"/>
				<param name="num"/>
			</mth>
			<mth name="/:sandmark.util.stealth.Cluster.buildcluster(java.util.Vector)" access="pub" jdoc="">
				<comm cntt="just for optimizing"/>
				<comm cntt="a = reference; b = left cluster; c = right cluster b &amp;lt;---&amp;gt; a &amp;lt;---&amp;gt; c a is always correctly positioned; scan left to the first b with clusterSize!=-1 scan right to the first c with clusterSize!=-1"/>
				<comm cntt="setting the pointers for a,b,c"/>
				<comm cntt="merge cluster {a,b} --&amp;gt; {b}"/>
				<comm cntt="merge cluster {a,c} --&amp;gt; {a}"/>
				<comm cntt="end of one scan ... for"/>
				<comm cntt="read the clusters into int array and return"/>
				<param name="data"/>
			</mth>
			<mth name="/:sandmark.util.stealth.Cluster.getClusters()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.stealth.Cluster.setNumberOfClusters(int)" access="pub" jdoc="">
				<param name="numClusters"/>
			</mth>
			<mth name="/:sandmark.util.stealth.Cluster.getNumberOfClusters()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.util.stealth.Cluster.main(String[])" access="pub" jdoc="">
				<comm cntt="Evaluate the local stealth for the orig_application"/>
				<comm cntt="Evaluate the local stealth for the wm_application"/>
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.util.stealth.Stealth" intfc="n" abs="n" inn="n" sloc="82" jdoc="">
			<comm cntt="Constructor"/>
			<comm cntt="Returns the currently implemented method level complexity metrices"/>
			<comm cntt="This function evaluates the normalcy for the method &amp;apos;m&amp;apos; with respect to the benchmark methods already defined and the already evaluated cluster &amp;apos;clusterObj&amp;apos;"/>
			<comm cntt="This function evaluates the global stealth of an application by comparing it with the benchmark method clusters"/>
			<comm cntt="This functions evaluates the average normalcy of the watermarked methods when compared to the average normalcy of the other methods in the target application"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="myApp" access="priv" jdoc=""/>
			<mth name="/:sandmark.util.stealth.Stealth.Stealth(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.util.stealth.Stealth.getMetricObjects(sandmark.program.Method)" access="priv" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.util.stealth.Stealth.evaluateNormalcy(sandmark.util.stealth.Cluster, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="Compute the complexity of this methid &amp;apos;m&amp;apos;"/>
				<comm cntt="hm.evaluateMetric();"/>
				<comm cntt="metr.evaluateMetric();"/>
				<comm cntt="Check in which cluster does it fit in"/>
				<param name="clusterObj"/>
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.util.stealth.Stealth.evaluateGlobalStealth(sandmark.util.stealth.Cluster, sandmark.program.Application)" access="pub" jdoc="">
				<param name="clusterObj"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.util.stealth.Stealth.evaluateLocalStealth(sandmark.util.stealth.Cluster, java.util.Vector)" access="pub" jdoc="">
				<param name="clusterObj"/>
				<param name="wmMethodObjects"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.view">
		<class name="/:sandmark.view.View" intfc="n" abs="n" inn="n" sloc="28" jdoc="@author Christian Collberg @version 1.0">
			<comm cntt="Describe what viewing is."/>
			<field name="sConfigProps" access="priv" jdoc="Get the GENERAL properties of View"/>
			<mth name="/:sandmark.view.View.getProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.view.View.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the About page for View @return html code for the about page">
			</mth>
			<mth name="/:sandmark.view.View.getHelpURL()" access="pub" jdoc="Get the URL of the Help page for View @return URL for the help page">
			</mth>
			<mth name="/:sandmark.view.View.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.visualize">
		<class name="/:sandmark.visualize.Visualize" intfc="n" abs="n" inn="n" sloc="37" jdoc="Visualize.java -- @author Jasvir Nagra &amp;lt;jas@cs.auckland.ac.nz&amp;gt; Created On : Sat May 10 14:26:36 2003 Last Modified : &amp;lt;03 05 10 17:32:46 jas&amp;gt; Description : Visualize things Keywords : visualization agave sandmark PURPOSE | Sandmark project |">
			<comm cntt="Describe what visualizing is."/>
			<field name="sConfigProps" access="priv" jdoc="Get the GENERAL properties of Visualize"/>
			<mth name="/:sandmark.visualize.Visualize.visualizePaneSelected(sandmark.gui.SandMarkFrame)" access="pub" jdoc="This method is executed in response to the user selecting the visualize tab. @param f">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.visualize.Visualize.visualizePaneDeselected(sandmark.gui.SandMarkFrame)" access="pub" jdoc="This method is executed in response to the user deselecting the visualize tab. @param f">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.visualize.Visualize.visualizeButtonPressed(sandmark.gui.SandMarkFrame)" access="pub" jdoc="This method is executed in response to the user clicking on the visualize button in the visualize tab. We check that the right arguments have been filled in. If so, we run the actual visualizer. @param f">
				<comm cntt="= f.getVisualizeData();"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.visualize.Visualize.getProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.visualize.Visualize.getAboutHTML()" access="pub" jdoc="Get the HTML codes of the About page for Visualize @return html code for the about page">
			</mth>
			<mth name="/:sandmark.visualize.Visualize.getHelpURL()" access="pub" jdoc="Get the URL of the Help page for Visualize @return URL for the help page">
			</mth>
			<mth name="/:sandmark.visualize.Visualize.getOverview()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.visualize.heap">
		<class name="/:sandmark.visualize.heap.SQL" intfc="n" abs="n" inn="n" sloc="63" jdoc="SQL.java -- @author Jasvir Nagra &amp;lt;jas@cs.auckland.ac.nz&amp;gt; Created On : Thu May 22 21:44:29 2003 Last Modified : &amp;lt;03 05 22 22:42:10 jas&amp;gt; Description : Generate SQL from sandmark.util.newgraph.Graph Keywords : sql sandmark PURPOSE | Sandmark project |">
			<mth name="/:sandmark.visualize.heap.SQL.toSql(sandmark.util.newgraph.Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.visualize.heap.SQL.sqlInFile(sandmark.util.newgraph.Graph, String)" access="pub" jdoc="">
				<param name="g"/>
				<param name="filename"/>
			</mth>
			<mth name="/:sandmark.visualize.heap.SQL.toSql(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.visualize.heap.SQL.sqlInFile(sandmark.util.newgraph.MutableGraph, String)" access="pub" jdoc="">
				<param name="g"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.visualize.heap.SQL.toString(sandmark.util.newgraph.Graph)" access="pub" jdoc="">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.visualize.heap.SQL.toString(sandmark.util.newgraph.Node)" access="pub" jdoc="">
				<comm cntt="+ (node instanceof sandmark.util.exec.HeapNode"/>
				<comm cntt="? ((sandmark.util.exec.HeapNode)node).timestamp()"/>
				<comm cntt=": 0)"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.visualize.heap.SQL.toString(sandmark.util.newgraph.Edge)" access="pub" jdoc="">
				<param name="edge"/>
			</mth>
			<mth name="/:sandmark.visualize.heap.SQL.createNodesTable()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.visualize.heap.SQL.createEdgesTable()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.visualize.heap.HeapVisualizer" intfc="n" abs="n" inn="n" sloc="25" jdoc="Heap.java -- @author Jasvir Nagra &amp;lt;jas@cs.auckland.ac.nz&amp;gt; Created On : Tue Apr 29 11:40:10 2003 Last Modified : &amp;lt;03 05 27 15:35:08 jas&amp;gt; Description : Allows visualization of the heap Keywords : heap visualization agave sandmark PURPOSE | Sandmark project |">
			<comm cntt="This is in flux - you probably shouldn&amp;apos;t be using this. -- jas"/>
			<field name="buffer" access="pub" jdoc=""/>
			<mth name="/:sandmark.visualize.heap.HeapVisualizer.HeapVisualizer(sandmark.watermark.DynamicRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.visualize.heap.HeapVisualizer.getHeap()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.visualize.heap.HeapVisualizer.main(String)" access="pub" jdoc="">
				<comm cntt="Thread.sleep ( 5000 );"/>
				<comm cntt="recognizer.STOP();"/>
				<param name="args"/>
			</mth>
		<class name="/:sandmark.visualize.heap.HeapVisualizer$InitBreakpoint" intfc="n" abs="n" inn="y" sloc="16" jdoc="">
			<field name="root" access="pub" jdoc=""/>
			<field name="i" access="pub" jdoc=""/>
			<mth name="/:sandmark.visualize.heap.HeapVisualizer$InitBreakpoint.InitBreakpoint()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.visualize.heap.HeapVisualizer$InitBreakpoint.Action(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark">
		<class name="/:sandmark.watermark.DynamicEmbedParameters" intfc="n" abs="n" inn="n" sloc="5" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="app" access="pub" jdoc=""/>
			<field name="watermark" access="pub" jdoc=""/>
			<field name="traceFile" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.watermark.StaticRecognizeParameters" intfc="n" abs="n" inn="n" sloc="4" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="key" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.watermark.WatermarkingException" intfc="n" abs="n" inn="n" sloc="8" jdoc="">
			<mth name="/:sandmark.watermark.WatermarkingException.WatermarkingException()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.WatermarkingException.WatermarkingException(String)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.DynamicWatermarker" intfc="n" abs="y" inn="n" sloc="133" jdoc="A DynamicWatermarker object encapsulates code for running a particular dynamic watermark algorithm.">
			<comm cntt="Embed a watermark value into the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Watermark: The watermark value to be embedded. &amp;lt;LI&amp;gt; Trace File: The name of the file containing trace data. &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt;LI&amp;gt; Output File: The name of the jar file to be constructed. &amp;lt;LI&amp;gt; DWM_CT_Encode_ClassName: The name of the Java file that builds the watermark. &amp;lt; UL&amp;gt;"/>
			<comm cntt="Get the GENERAL properties of DynamicWatermark"/>
			<comm cntt="Get the HTML codes of the About page for Dynamic Watermarking"/>
			<comm cntt="Describe what dynaimc watermarking is."/>
			<comm cntt="Get the URL of the Help page for Dynamic Watermarking"/>
			<field name="sConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.DynamicWatermarker.startTracing(DynamicTraceParameters)" access="pub" jdoc="Start a tracing run of the program. Return an iterator object that will generate the trace points encountered by the program.">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.endTracing()" access="pub" jdoc="This routine should be called when the tracing run has completed. tracePoints is a vector of generated trace points generated by the iterator returned by startTracing.">
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.stopTracing()" access="pub" jdoc="Force the end to a tracing run of the program.">
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.embed(DynamicEmbedParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.startRecognition(DynamicRecognizeParameters)" access="pub" jdoc="Start a recognition run of the program.">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.watermarks()" access="pub" jdoc="Return an iterator object that will generate the watermarks found in the program.">
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.stopRecognition()" access="pub" jdoc="Force the end to a tracing run of the program.">
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.waitForProgramExit()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.getProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.getEmbedParams(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.getRecognizeParams(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.getTraceParams(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.constructArgv(java.io.File, String, String, String)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;constructArgv:&amp;quot;);"/>
				<comm cntt="for(int i=0; i&amp;lt;argv.length; i++)"/>
				<comm cntt="System.out.println(argv[i]);"/>
				<param name="jar"/>
				<param name="extraCP"/>
				<param name="mainClass"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.getAboutHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.getOverview()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.DynamicWatermarker.getHelpURL()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.StaticWatermarker" intfc="n" abs="y" inn="n" sloc="63" jdoc="A StaticWatermarker object encapsulates code for running a particular static watermark algorithm.">
			<comm cntt="Return an iterator which generates the watermarks found in the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be examined. &amp;lt;LI&amp;gt; Key: The secret key. &amp;lt; UL&amp;gt;"/>
			<comm cntt="Get the GENERAL properties of StaticWatermark"/>
			<comm cntt="Get the HTML codes of the About page for Static Watermarking"/>
			<comm cntt="Describe what static watermarking is."/>
			<comm cntt="Get the URL of the Help page for Static Watermarking"/>
			<field name="sConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.StaticWatermarker.embed(StaticEmbedParameters)" access="pub" jdoc="Embed a watermark value into the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Watermark: The watermark value to be embedded. &amp;lt;LI&amp;gt; Key: The secret key. &amp;lt; UL&amp;gt;">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.StaticWatermarker.recognize(StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.StaticWatermarker.getProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.StaticWatermarker.getEmbedParams(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.StaticWatermarker.getRecognizeParams(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.StaticWatermarker.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.StaticWatermarker.getAboutHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.StaticWatermarker.getOverview()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.StaticWatermarker.getHelpURL()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.StaticRecognize" intfc="n" abs="n" inn="n" sloc="12" jdoc="">
			<mth name="/:sandmark.watermark.StaticRecognize.runRecognition(sandmark.Algorithm, StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="alg"/>
				<param name="params"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.GeneralWatermarker" intfc="n" abs="y" inn="n" sloc="24" jdoc="A GeneralWatermarker object encapsulates code for running a particular watermark algorithm. Watermarks are grouped into two abstract subclasses: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; StaticWatermarker &amp;lt;LI&amp;gt; DynamicWatermarker &amp;lt; UL&amp;gt; &amp;lt;P&amp;gt; A watermarker has a label that is used to refer to it in the GUI.">
			<field name="sConfigProps" access="priv" jdoc="Get the GENERAL properties of watermark"/>
			<mth name="/:sandmark.watermark.GeneralWatermarker.getProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.GeneralWatermarker.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.GeneralWatermarker.getAboutHTML()" access="pub" jdoc="Specifies the description given in the About page for Watermarking. @return an HTML formatted description of the algorithm.">
			</mth>
			<mth name="/:sandmark.watermark.GeneralWatermarker.getHelpURL()" access="pub" jdoc="Specifies the URL of the Help page for Watermarking. @return the Help page URL">
			</mth>
		</class>
		<class name="/:sandmark.watermark.DynamicRecognizeParameters" intfc="n" abs="n" inn="n" sloc="5" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="app" access="pub" jdoc=""/>
			<field name="appFile" access="pub" jdoc=""/>
			<field name="programCmdLine" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.watermark.DynamicTraceParameters" intfc="n" abs="n" inn="n" sloc="6" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="app" access="pub" jdoc=""/>
			<field name="appFile" access="pub" jdoc=""/>
			<field name="programCmdLine" access="pub" jdoc=""/>
			<field name="traceFile" access="pub" jdoc=""/>
		</class>
		<class name="/:sandmark.watermark.StaticEmbed" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/:sandmark.watermark.StaticEmbed.runEmbed(sandmark.Algorithm, StaticEmbedParameters)" access="pub" jdoc="">
				<param name="alg"/>
				<param name="params"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.StaticEmbedParameters" intfc="n" abs="n" inn="n" sloc="5" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<field name="key" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
			<field name="watermark" access="pub" jdoc=""/>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.addmethfield">
		<class name="/:sandmark.watermark.addmethfield.AddMethField" intfc="n" abs="n" inn="n" sloc="178" jdoc="Authors: Ginger Myles and Miriam Miklofsky Purpose: Implements algorithm 3.2 for CSc 620 Project 1">
			<comm cntt="Get the HTML codes of the About page."/>
			<comm cntt="Get the URL of the Help page"/>
			<comm cntt="Embedding"/>
			<comm cntt="end embed()"/>
			<comm cntt="Recognition"/>
			<comm cntt="Return an iterator which generates the watermarks found in the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt; UL&amp;gt;"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.getShortName()" access="pub" jdoc="Returns this watermarker&amp;apos;s short name.">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.getLongName()" access="pub" jdoc="Returns this watermarker&amp;apos;s long name.">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="Embed a watermark value into the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Watermark: The watermark value to be embedded. &amp;lt; UL&amp;gt;"/>
				<comm cntt="find a valid class to watermark"/>
				<comm cntt="break the watermark into two parts"/>
				<comm cntt="create a new field"/>
				<comm cntt="get a pseudorandom number to indicate which method will make a call"/>
				<comm cntt="to the watermarked method."/>
				<comm cntt="we are going to seed the random number generator with the key"/>
				<comm cntt="new java.util.Random(seed);"/>
				<comm cntt="get the name of method where the watermarked method will be"/>
				<comm cntt="inserted. We are using this name to tack on the second part"/>
				<comm cntt="of the watermark."/>
				<comm cntt="create a new method"/>
				<comm cntt="append new instructions to the temporary list so they can be added"/>
				<comm cntt="to the chosen method"/>
				<comm cntt="update the class gen so the changes to the method take hold"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.findValidClass(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.isClassValid(sandmark.program.Class)" access="priv" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.isValidMethod(sandmark.program.Method)" access="priv" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.findMethodToWM(sandmark.program.Class)" access="priv" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.makeNewMethod(String, sandmark.program.Field, sandmark.program.Class)" access="priv" jdoc="">
				<comm cntt="create the instruction list"/>
				<comm cntt="This new method takes the values of the two parameters, adds them"/>
				<comm cntt="together and places the result in the watermarked field."/>
				<param name="newMethodName"/>
				<param name="wmField"/>
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		<class name="/:sandmark.watermark.addmethfield.AddMethField$Recognizer" intfc="n" abs="n" inn="y" sloc="51" jdoc="">
			<comm cntt="An iterator which generates the watermarks found in the program."/>
			<field name="result" access="pub" jdoc=""/>
			<field name="current" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField$Recognizer.Recognizer(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField$Recognizer.generate(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField$Recognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField$Recognizer.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.addmethfield.AddMethField$Recognizer.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.arboit">
		<class name="/:sandmark.watermark.arboit.UtilFunctions" intfc="n" abs="n" inn="n" sloc="612" jdoc="This class maintains a bunch of static methods for use in ArboitAlg and DynamicAA.">
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="EVAL" access="pub" jdoc=""/>
			<field name="USE_CONSTS" access="pub" jdoc=""/>
			<field name="USE_RANK" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.preprocess(sandmark.program.Application)" access="pub" jdoc="This method determines which methods in the application are possible candidates for having an opaque predicate added.">
				<comm cntt="scan instruction list for ifstatements"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<comm cntt="end for"/>
				<comm cntt="end if"/>
				<comm cntt="end while"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.setSeed(String)" access="priv" jdoc="">
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.isAppValid(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.wmBigIntValue(String)" access="pub" jdoc="">
				<param name="wm"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.splitWM(String, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="this is a random maximum value that seems to work"/>
				<comm cntt="this is the number of opaque predicates"/>
				<comm cntt="sandmark.util.splitint.PartialSumSplitter mySplitter ="/>
				<comm cntt="new sandmark.util.splitint.PartialSumSplitter(getGenerator(props));"/>
				<comm cntt="System.out.println(&amp;quot;parts: &amp;quot; + props.getProperty(&amp;quot;MIN_WM_PARTS&amp;quot;)); java.math.BigInteger[] wmValues = mySplitter.split(wmBigIntValue(props), (new Integer(props.getProperty(&amp;quot;MIN_WM_PARTS&amp;quot;))).intValue()); if(DEBUG)System.out.println(&amp;quot;length: &amp;quot; + wmValues.length); for(int i=0; i &amp;lt; wmValues.length; i++){ if(EVAL)System.out.println(wmValues[i].intValue()); if(wmValues[i].intValue() &amp;gt; 32767){ if(DEBUG)System.out.println(wmValues[i].intValue()); throw new sandmark.watermark.WatermarkingException(&amp;quot;need more &amp;quot; + &amp;quot;parts inorder to watermark&amp;quot;); } }"/>
				<param name="watermark"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.findSliceStart(sandmark.program.Method, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ifIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.findIfHandle(sandmark.program.Method, int)" access="pub" jdoc="">
				<param name="method"/>
				<param name="ifIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.updateIndexList(java.util.ArrayList, Bundle, int)" access="pub" jdoc="@return false means we are done, true means we are not done.">
				<comm cntt="fix the remaining indices"/>
				<param name="candidateList"/>
				<param name="b"/>
				<param name="ifIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.fixList(java.util.ArrayList, sandmark.program.Method, int)" access="pub" jdoc="">
				<comm cntt="end for"/>
				<param name="indexList"/>
				<param name="m"/>
				<param name="oldIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.identifyUsableVars(sandmark.analysis.slicingtools.ForwardMethodSlice, sandmark.program.Method, int)" access="pub" jdoc="">
				<comm cntt="search the possibleVars to see if any are of type int"/>
				<comm cntt="for right now this is all that can be handled"/>
				<comm cntt="check if in scope"/>
				<param name="fs"/>
				<param name="m"/>
				<param name="ifIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.getWatermarkType(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.fixTarget(org.apache.bcel.generic.InstructionList, sandmark.program.Method, int)" access="pub" jdoc="">
				<param name="il"/>
				<param name="m"/>
				<param name="ifIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.getIfTarget(sandmark.program.Method, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="ifIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.getSlicingCrit(sandmark.program.Method, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<comm cntt="if(DEBUG){ System.out.println(&amp;quot;cfg&amp;quot;); sandmark.analysis.controlflowgraph.MethodCFG cfg = m.getCFG(); cfg.printCFG(); }"/>
				<comm cntt="once et is found get the uses of that tree"/>
				<param name="m"/>
				<param name="ifHandle"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.combineValues(java.util.ArrayList, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="sandmark.util.Random splitGenerator){"/>
				<comm cntt="this is a random maximum value"/>
				<comm cntt="this is the number of opaque predicates"/>
				<comm cntt="sandmark.util.splitint.PartialSumSplitter mySplitter ="/>
				<comm cntt="new sandmark.util.splitint.PartialSumSplitter(splitGenerator);"/>
				<comm cntt="loop through foundValues putting them in an array. I am doing it this"/>
				<comm cntt="way because to the toArray method does not seem to work."/>
				<param name="foundValues"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.processAnnotations(sandmark.watermark.arboit.trace.TracePoint, sandmark.program.Application)" access="priv" jdoc="">
				<comm cntt="int ifIndex = (int)index + 3;"/>
				<param name="annotationPoints"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.removeAnnotations(sandmark.program.Application)" access="pub" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.watermark(sandmark.program.Application, sandmark.watermark.DynamicEmbedParameters, sandmark.util.ConfigProperties, sandmark.watermark.arboit.trace.TracePoint)" access="pub" jdoc="">
				<param name="app"/>
				<param name="params"/>
				<param name="props"/>
				<param name="annotationPoints"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.watermark(sandmark.program.Application, String, String, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="app"/>
				<param name="watermark"/>
				<param name="key"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.getBundle(java.util.ArrayList, sandmark.util.Random)" access="priv" jdoc="">
				<param name="candidateList"/>
				<param name="gen"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.getIf(Bundle, sandmark.util.Random)" access="priv" jdoc="">
				<param name="b"/>
				<param name="gen"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.getUsableVars(sandmark.program.Method, int)" access="priv" jdoc="">
				<comm cntt="null;"/>
				<comm cntt="chose a slicing criterion"/>
				<comm cntt="compute slice"/>
				<comm cntt="identify variables for opaque predicate"/>
				<param name="m"/>
				<param name="ifIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.loop(java.util.ArrayList, String, java.math.BigInteger[], sandmark.util.ConfigProperties)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;indexlist: &amp;quot; + b.getIndexList().size());"/>
				<param name="candidateList"/>
				<param name="key"/>
				<param name="wmValues"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.recover(sandmark.program.Application, sandmark.util.ConfigProperties, sandmark.watermark.arboit.trace.TracePoint)" access="pub" jdoc="">
				<comm cntt="int value = getMethodValue(ivinst, m, props); if(value != 0){ Integer ivalue = new Integer(value); String svalue = ivalue.toString(); java.math.BigInteger bi = new java.math.BigInteger(svalue); foundValues.add(bi); }"/>
				<comm cntt="bb.getInstList();"/>
				<comm cntt="return UtilFunctions.combineValues(foundValues, getGenerator(props));"/>
				<param name="app"/>
				<param name="props"/>
				<param name="annotationPoints"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.recover(sandmark.program.Application, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="return UtilFunctions.combineValues(foundValues, getGenerator(props));"/>
				<param name="app"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.recoverOpaqueInst(sandmark.program.Method, sandmark.util.ConfigProperties)" access="priv" jdoc="">
				<param name="m"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.getMethodValue(org.apache.bcel.generic.InvokeInstruction, sandmark.program.Method, sandmark.util.ConfigProperties)" access="priv" jdoc="">
				<comm cntt="int value = 0;"/>
				<comm cntt="System.out.println(&amp;quot;possible&amp;quot;);"/>
				<comm cntt="org.apache.bcel.generic.InstructionList methodil = possMeth.getInstructionList(); org.apache.bcel.generic.InstructionHandle[] ihs = methodil.getInstructionHandles(); java.util.ArrayList ihList = new java.util.ArrayList(); for(int j=0; j &amp;lt; ihs.length; j++) ihList.add(ihs[j]);"/>
				<comm cntt="what happens if we set exceptions matter to true for recognition?"/>
				<comm cntt="we don&amp;apos;t find any of the watermark"/>
				<comm cntt="sandmark.util.newexprtree.MethodExprTree met = new sandmark.util.newexprtree.MethodExprTree(m, m.getCPG(), false); java.util.ArrayList exprTreeBlocks = met.getExprTreeBlocks(); for(int i=0; i &amp;lt; exprTreeBlocks.size(); i++){ sandmark.util.newexprtree.ExprTreeBlock etb = (sandmark.util.newexprtree.ExprTreeBlock)exprTreeBlocks.get(i); java.util.ArrayList ets = etb.getExprTrees(); for(int j=0; j &amp;lt; ets.size(); j++){ sandmark.util.newexprtree.ExprTree et = (sandmark.util.newexprtree.ExprTree)ets.get(j); java.util.ArrayList blockInsts = et.getInstructionList(); System.out.println(blockInsts.toString()); org.apache.bcel.generic.InstructionHandle lastIH = (org.apache.bcel.generic.InstructionHandle)blockInsts.get(blockInsts.size()-1); org.apache.bcel.generic.Instruction lastInst = lastIH.getInstruction(); if(lastInst instanceof org.apache.bcel.generic.IfInstruction){"/>
				<comm cntt="}"/>
				<comm cntt="value = myOPs.isOpaque(ihList, getWatermarkType(props));"/>
				<param name="ivinst"/>
				<param name="m"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.UtilFunctions.recoverOpaqueMethod(sandmark.program.Method, sandmark.util.ConfigProperties)" access="priv" jdoc="">
				<comm cntt="String methodName = ivinst.getMethodName(m.getCPG()); String methodSig = ivinst.getSignature(m.getCPG()); sandmark.program.Method possMeth = (m.getEnclosingClass()).getMethod( methodName, methodSig); AlgOP myOPs = new AlgOP(); if(myOPs.isPossible(methodSig)){ org.apache.bcel.generic.InstructionList methodil = possMeth.getInstructionList(); org.apache.bcel.generic.InstructionHandle[] ihs = methodil.getInstructionHandles(); java.util.ArrayList ihList = new java.util.ArrayList(); for(int j=0; j &amp;lt; ihs.length; j++) ihList.add(ihs[j]); int value = myOPs.isOpaque(ihList, getWatermarkType(props));"/>
				<comm cntt="int value = getMethodValue(ivinst, m, props); if(value != 0){ Integer ivalue = new Integer(value); String svalue = ivalue.toString(); java.math.BigInteger bi = new java.math.BigInteger(svalue); foundValues.add(bi); }"/>
				<comm cntt="}"/>
				<param name="m"/>
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.arboit.AlgOP" intfc="n" abs="n" inn="n" sloc="1844" jdoc="">
			<comm cntt="used for determining whether we are using the rank of the OP or the"/>
			<comm cntt="constants contained in the constructed code"/>
			<comm cntt="There are currently 10 opaque predicates in this class"/>
			<comm cntt="this one requires two local variables"/>
			<comm cntt="This method implements 7(y y) - 1 != (x x)"/>
			<comm cntt="This method implements ((x x) 2) % 2 == 0"/>
			<comm cntt="This method implements x(x+1) % 2 == 0"/>
			<comm cntt="This method implements (x x) &amp;gt;= 0"/>
			<comm cntt="This method implements x(x+1)(x+2) % 3 == 0"/>
			<comm cntt="This method implements ((x x) + 1) % 7 != 0"/>
			<comm cntt="This method implements ((x x) + x + 7) % 81 != 0"/>
			<comm cntt="This method implements (4(x x) + 4) % 19 != 0"/>
			<comm cntt="This method implements ((x x)(x+1)(x+1)) % 4 == 0"/>
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="EVAL" access="pub" jdoc=""/>
			<field name="EVEN_OP" access="prot" jdoc=""/>
			<field name="ODD_OP" access="prot" jdoc=""/>
			<field name="USE_CONSTS" access="prot" jdoc=""/>
			<field name="USE_RANK" access="prot" jdoc=""/>
			<const name="OP_1" access="pub" jdoc=""/>
			<const name="OP_2" access="pub" jdoc=""/>
			<const name="OP_3" access="pub" jdoc=""/>
			<const name="OP_4" access="pub" jdoc=""/>
			<const name="OP_5" access="pub" jdoc=""/>
			<const name="OP_6" access="pub" jdoc=""/>
			<const name="OP_7" access="pub" jdoc=""/>
			<const name="OP_8" access="pub" jdoc=""/>
			<const name="OP_9" access="pub" jdoc=""/>
			<field name="OP_1_CONSTS" access="prot" jdoc=""/>
			<field name="OP_2_CONSTS" access="prot" jdoc=""/>
			<field name="OP_3_CONSTS" access="prot" jdoc=""/>
			<field name="OP_4_CONSTS" access="prot" jdoc=""/>
			<field name="OP_5_CONSTS" access="prot" jdoc=""/>
			<field name="OP_6_CONSTS" access="prot" jdoc=""/>
			<field name="OP_7_CONSTS" access="prot" jdoc=""/>
			<field name="OP_8_CONSTS" access="prot" jdoc=""/>
			<field name="OP_9_CONSTS" access="prot" jdoc=""/>
			<field name="NUM_OPS" access="prot" jdoc=""/>
			<field name="EVEN_OPS" access="prot" jdoc=""/>
			<field name="ODD_OPS" access="prot" jdoc=""/>
			<field name="op_generator" access="pub" jdoc=""/>
			<field name="nameGenerator" access="pub" jdoc=""/>
			<field name="op_used" access="pub" jdoc=""/>
			<field name="method_refs" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.arboit.AlgOP.AlgOP(boolean)" access="pub" jdoc="">
				<param name="recognition"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.numParamNeeded()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.lastOPUsed()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.insertOpaquePredicate(sandmark.program.Method, java.util.ArrayList, int, int, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="String consts_or_rank = props.getProperty(&amp;quot;ENCODE_AS_CONSTS&amp;quot;);"/>
				<param name="m"/>
				<param name="usableVars"/>
				<param name="ifIndex"/>
				<param name="wm"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.makeOpaqueMethod(sandmark.util.ConfigProperties, int, sandmark.program.Class, java.util.ArrayList)" access="priv" jdoc="">
				<param name="props"/>
				<param name="wm"/>
				<param name="cls"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.makeTheMethod(sandmark.program.Class, org.apache.bcel.generic.InstructionList, java.util.ArrayList)" access="priv" jdoc="">
				<param name="cls"/>
				<param name="methodIL"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.makeInsertList(java.util.ArrayList, int, int, sandmark.program.Method)" access="priv" jdoc="">
				<param name="params"/>
				<param name="ifIndex"/>
				<param name="methodRef"/>
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.makeMethodCallInst(java.util.ArrayList, int, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="params"/>
				<param name="methodRef"/>
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.getParams(java.util.ArrayList)" access="priv" jdoc="">
				<comm cntt="if(numParamNeeded() == 2){"/>
				<comm cntt="numParamNeeded())"/>
				<comm cntt="}"/>
				<param name="usableVars"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.makeInsertList(sandmark.util.ConfigProperties, int, java.util.ArrayList, int, sandmark.program.Method)" access="priv" jdoc="">
				<param name="props"/>
				<param name="wm"/>
				<param name="params"/>
				<param name="ifIndex"/>
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOpaqueInsts(int, java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="chose a random op value from the even array"/>
				<comm cntt="chose a random op value from the odd array"/>
				<param name="wmValue"/>
				<param name="usableVars"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOpaqueMethodIL(int, int)" access="pub" jdoc="">
				<comm cntt="chose a random op value from the even array"/>
				<comm cntt="chose a random op value from the odd array"/>
				<comm cntt="org.apache.bcel.generic.InstructionHandle extraTargetHandle = il.getEnd();"/>
				<param name="wmValue"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createIL(int[], int, int, int)" access="priv" jdoc="">
				<param name="varNums"/>
				<param name="chosen_op"/>
				<param name="wmValue"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createSpecIL(int[], int, int, int)" access="priv" jdoc="">
				<param name="varNums"/>
				<param name="chosen_op"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOP1(int, int, int, int)" access="priv" jdoc="">
				<param name="var1"/>
				<param name="var2"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOP2(int, int, int)" access="priv" jdoc="">
				<param name="var1"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOP3(int, int, int)" access="priv" jdoc="">
				<param name="var1"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOP4(int, int, int)" access="priv" jdoc="">
				<param name="var1"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOP5(int, int, int)" access="priv" jdoc="">
				<param name="var1"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOP6(int, int, int)" access="priv" jdoc="">
				<param name="var1"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOP7(int, int, int)" access="priv" jdoc="">
				<param name="var1"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOP8(int, int, int)" access="priv" jdoc="">
				<param name="var1"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.createOP9(int, int, int)" access="priv" jdoc="">
				<param name="var1"/>
				<param name="coefficient"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.consts_used(int)" access="priv" jdoc="">
				<comm cntt="case OP_10:"/>
				<comm cntt="return OP_10_CONSTS;"/>
				<param name="chosen_op"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.isOpaque(java.util.ArrayList, int)" access="pub" jdoc="">
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.check1(java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="we are using rank"/>
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.check2(java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="use rank"/>
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.check3(java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="use rank"/>
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.check4(java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="use rank"/>
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.check5(java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="use rank"/>
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.check6(java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="use rank"/>
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.check7(java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="use rank"/>
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.check8(java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="use rank"/>
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.check9(java.util.ArrayList, int)" access="priv" jdoc="">
				<comm cntt="use rank"/>
				<param name="instructions"/>
				<param name="wm_type"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.AlgOP.isPossible(String)" access="pub" jdoc="">
				<comm cntt="if(sig.equals(&amp;quot;(II)Z&amp;quot;))"/>
				<comm cntt="return true;"/>
				<param name="sig"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.arboit.ArboitAlg" intfc="n" abs="n" inn="n" sloc="101" jdoc="This algorithm embeds a watermark by inserting opaque predicates in selected branch statements. The algorithm is based on Genevieve Arboit&amp;apos;s Algorithms 1 and 2 from &amp;quot;A Method for Watermarking Java Programs via Opaque Predicates.&amp;quot;">
			<comm cntt="Get the HTML codes of the About page."/>
			<comm cntt="Get the URL of the Help page"/>
			<comm cntt="Embedding"/>
			<comm cntt="Recognition"/>
			<comm cntt="end class Recognizer"/>
			<comm cntt="Return an iterator which generates the watermarks found in the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; WM_Recognize_JarInput: The name of the file to be watermarked. &amp;lt; UL&amp;gt;"/>
			<field name="EVAL" access="priv" jdoc=""/>
			<field name="USE_CONSTS" access="pub" jdoc=""/>
			<field name="USE_RANK" access="pub" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.ArboitAlg()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getShortName()" access="pub" jdoc="Returns this watermarker&amp;apos;s short name.">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getLongName()" access="pub" jdoc="Returns this watermarker&amp;apos;s long name.">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getConfigProperties()" access="pub" jdoc="">
				<comm cntt="{&amp;quot;MIN_WM_PARTS&amp;quot;,"/>
				<comm cntt="&amp;quot;5&amp;quot;,"/>
				<comm cntt="&amp;quot;An integer describing the number of parts the watermark should &amp;quot; +"/>
				<comm cntt="&amp;quot;be broken up into. There must be atleast 2&amp;quot;,"/>
				<comm cntt="&amp;quot;5&amp;quot;, &amp;quot;S&amp;quot;, &amp;quot;SE&amp;quot;,"/>
				<comm cntt="},"/>
				<comm cntt="{&amp;quot;ENCODE_AS_CONSTS&amp;quot;,"/>
				<comm cntt="{&amp;quot;USE_OPAQUE_METHODS&amp;quot;,"/>
				<comm cntt="{&amp;quot;REUSE_METHODS&amp;quot;,"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="check if this app is valid to watermark"/>
				<comm cntt="sandmark.util.ConfigProperties mycp = null; if(mConfigProps == null){ System.out.println(&amp;quot;in here&amp;quot;); mycp = getConfigProperties(); props.setProperty(&amp;quot;MIN_WM_PARTS&amp;quot;, mycp.getProperty(&amp;quot;MIN_WM_PARTS&amp;quot;)); props.setProperty(&amp;quot;Encode as constants&amp;quot;, mycp.getProperty(&amp;quot;Encode as constants&amp;quot;)); props.setProperty(&amp;quot;Use opaque methods&amp;quot;, mycp.getProperty(&amp;quot;Use opaque methods&amp;quot;)); props.setProperty(&amp;quot;Reuse methods&amp;quot;, mycp.getProperty(&amp;quot;Reuse methods&amp;quot;));"/>
				<comm cntt="java.util.Enumeration e = mycp.keys(); while(e.hasMoreElements()){ String nextKey = (String)e.nextElement(); props.setProperty(nextKey, (String)mycp.getProperty(nextKey)); }"/>
				<comm cntt="} boolean success = UtilFunctions.watermark(app, props);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		<class name="/:sandmark.watermark.arboit.ArboitAlg$Recognizer" intfc="n" abs="n" inn="y" sloc="24" jdoc="">
			<comm cntt="An iterator which generates the watermarks found in the program."/>
			<comm cntt="end generate()"/>
			<field name="result" access="pub" jdoc=""/>
			<field name="consts_or_rank" access="pub" jdoc=""/>
			<field name="current" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg$Recognizer.Recognizer(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg$Recognizer.generate(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg$Recognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg$Recognizer.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.ArboitAlg$Recognizer.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.arboit.Bundle" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<field name="name" access="priv" jdoc=""/>
			<field name="method" access="priv" jdoc=""/>
			<field name="indexList" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.arboit.Bundle.Bundle(String, sandmark.program.Method, java.util.ArrayList)" access="pub" jdoc="">
				<param name="name"/>
				<param name="method"/>
				<param name="indexList"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.Bundle.getMethod()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.Bundle.getClassName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.Bundle.getIndexList()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.Bundle.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.Bundle.equals(Object)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.arboit.DynamicAA" intfc="n" abs="n" inn="n" sloc="229" jdoc="">
			<comm cntt="Get the properties of the DynamicAA algorithm."/>
			<comm cntt="Get the HTML codes of the About page for DynamicAA"/>
			<comm cntt="Get the URL of the Help page for DynamicAA"/>
			<comm cntt="public void waitForProgramExit(){} private void annotate(java.util.Properties props) { try{ if(props.getProperty(&amp;quot;DWM_AA_AnnotatedJar&amp;quot;).equals(&amp;quot;&amp;quot;)){ String annotatedJarName = sandmark.Console.constructOutputFileName( props.getProperty(&amp;quot;Input File&amp;quot;), &amp;quot;anno&amp;quot;); System.out.println(&amp;quot;annotated Jar Name: &amp;quot; + annotatedJarName); props.setProperty(&amp;quot;DWM_AA_AnnotatedJar&amp;quot;, annotatedJarName); } sandmark.watermark.arboit.trace.Annotate anno = new sandmark.watermark.arboit.trace.Annotate(props); anno.annotate(); anno.save(); String newClassPath = sandmark.Console.getSystemClassPath() + java.io.File.pathSeparatorChar + props.getProperty(&amp;quot;Class Path&amp;quot;) + java.io.File.pathSeparatorChar + props.getProperty(&amp;quot;DWM_AA_AnnotatedJar&amp;quot;); props.setProperty(&amp;quot;Computed Class Path&amp;quot;, newClassPath); } catch (Exception e) { e.printStackTrace(); sandmark.util.Log.message(0, &amp;quot;Annotation failed&amp;quot;, e); }"/>
			<comm cntt="Embedding"/>
			<comm cntt="Recognition"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="EVAL" access="priv" jdoc=""/>
			<field name="mRecognizeParams" access="priv" jdoc=""/>
			<field name="mTraceParams" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<field name="tracer" access="pub" jdoc=""/>
			<field name="tracer2" access="pub" jdoc=""/>
			<field name="result" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.getShortName()" access="pub" jdoc="Returns this watermarker&amp;apos;s short name.">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.getLongName()" access="pub" jdoc="Returns this watermarker&amp;apos;s long name.">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.getConfigProperties()" access="pub" jdoc="">
				<comm cntt="{&amp;quot;MIN_WM_PARTS&amp;quot;,"/>
				<comm cntt="&amp;quot;5&amp;quot;,"/>
				<comm cntt="&amp;quot;An integer describing the number of parts the watermark should &amp;quot; +"/>
				<comm cntt="&amp;quot;be broken up into.&amp;quot;,"/>
				<comm cntt="null, &amp;quot;I&amp;quot;, &amp;quot;DE&amp;quot;,"/>
				<comm cntt="},"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.annotate(sandmark.program.Application, java.io.File, sandmark.util.ConfigProperties)" access="priv" jdoc="">
				<param name="app"/>
				<param name="appFile"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.startTracing(sandmark.watermark.DynamicTraceParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.endTracing()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.stopTracing()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.embed(sandmark.watermark.DynamicEmbedParameters)" access="pub" jdoc="">
				<comm cntt="embed"/>
				<comm cntt="remove annotation points"/>
				<comm cntt="UtilFunctions.removeAnnotations(app);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.startRecognition(sandmark.watermark.DynamicRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.recover(sandmark.program.Application, java.io.File, sandmark.util.ConfigProperties)" access="priv" jdoc="">
				<comm cntt="recover"/>
				<param name="app"/>
				<param name="traceFile"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.watermarks()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.stopRecognition()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.DynamicAA.waitForProgramExit()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.arboit.trace">
		<class name="/:sandmark.watermark.arboit.trace.TracePoint" intfc="n" abs="n" inn="n" sloc="42" jdoc="This class represents the location of an annotation point in the code. &amp;lt;P&amp;gt; All fields are public, but should be treated as read-only.">
			<field name="location" access="pub" jdoc="The source location of a Annotate.mark(Arg) call."/>
			<mth name="/:sandmark.watermark.arboit.trace.TracePoint.TracePoint(sandmark.util.ByteCodeLocation)" access="pub" jdoc="">
				<param name="location"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.TracePoint.equals(Object)" access="pub" jdoc="Compare for equality. @param b object to compare to">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.TracePoint.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.TracePoint.toString()" access="pub" jdoc="Format the data in an easy to parse form.">
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.TracePoint.toString(TracePoint[])" access="pub" jdoc="Format the data for easy reading.">
				<param name="pts"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.TracePoint.write(java.io.File, TracePoint[])" access="pub" jdoc="">
				<param name="traceFile"/>
				<param name="tracePoints"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.TracePoint.read(java.io.File)" access="pub" jdoc="">
				<param name="traceFile"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.arboit.trace.Annotate" intfc="n" abs="n" inn="n" sloc="51" jdoc="">
			<field name="app" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<const name="ANNOTATEDCODESIZE" access="pub" jdoc="The code we are adding to each usable if statement in a method. &amp;lt;PRE&amp;gt; INVOKESTATIC sandmark.watermark.arboit.trace.Annotator.sm$mark() &amp;lt; PRE&amp;gt;"/>
			<mth name="/:sandmark.watermark.arboit.trace.Annotate.Annotate(sandmark.program.Application, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="app"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Annotate.annotate()" access="pub" jdoc="">
				<comm cntt="add a reference to &amp;quot;sandmark.watermark.arboit.trace.Annotator&amp;quot;"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Annotate.save(java.io.File)" access="pub" jdoc="Save the edited classfiles under a new name.">
				<param name="appFile"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Annotate.annotateClass(sandmark.program.Class, int)" access="pub" jdoc="">
				<param name="cls"/>
				<param name="annoMethodRef"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Annotate.annotateMethod(sandmark.program.Method, int)" access="pub" jdoc="">
				<comm cntt="scan the instructions looking for if statements"/>
				<comm cntt="when one is found insert a mark before it."/>
				<comm cntt="insert the mark instructions before this instruction"/>
				<param name="m"/>
				<param name="annoMethodRef"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.arboit.trace.Tracer" intfc="n" abs="n" inn="n" sloc="34" jdoc="">
			<comm cntt="end inner class Breakpoint"/>
			<field name="annotatorClass" access="priv" jdoc=""/>
			<field name="list" access="priv" jdoc=""/>
			<field name="nextObjext" access="priv" jdoc=""/>
			<field name="done" access="priv" jdoc=""/>
			<field name="callStackList" access="priv" jdoc=""/>
			<field name="mExited" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.arboit.trace.Tracer.Tracer(String, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="cmdLine"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Tracer.getTracePoints()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Tracer.STOP()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Tracer.onProgramExit(com.sun.jdi.VirtualMachine)" access="prot" jdoc="">
				<param name="vm"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Tracer.exited()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.watermark.arboit.trace.Tracer$Breakpoint" intfc="n" abs="n" inn="y" sloc="19" jdoc="">
			<mth name="/:sandmark.watermark.arboit.trace.Tracer$Breakpoint.Breakpoint(String, String)" access="pub" jdoc="">
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Tracer$Breakpoint.Action(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;location: &amp;quot; + location);"/>
				<comm cntt="sandmark.util.StackFrame[] stack = data.getCallStack();"/>
				<comm cntt="sandmark.util.StackFrame[] stack1 ="/>
				<comm cntt="sandmark.util.exec.MethodCallData.deleteIncompleteStackFrames(stack);"/>
				<comm cntt="for(int i=0; i &amp;lt; stack.length; i++){"/>
				<comm cntt="System.out.println(&amp;quot;in loop&amp;quot;);"/>
				<comm cntt="}"/>
				<param name="data"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.arboit.trace.Annotator" intfc="n" abs="n" inn="n" sloc="6" jdoc="">
			<mth name="/:sandmark.watermark.arboit.trace.Annotator.MARK()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.arboit.trace.Annotator.sm$mark()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.assignlv">
		<class name="/:sandmark.watermark.assignlv.ToBinary" intfc="n" abs="n" inn="n" sloc="88" jdoc="">
			<field name="bMark" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.assignlv.ToBinary.ToBinary(String, boolean)" access="pub" jdoc="">
				<param name="wm"/>
				<param name="addLength"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.ToBinary.getBinary()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.ToBinary.convertLength(String)" access="priv" jdoc="precondition: length must be a power of 2.">
				<comm cntt="System.out.println(&amp;quot;length comming into convertLength: &amp;quot; + length);"/>
				<comm cntt="System.out.println(&amp;quot;divisor: &amp;quot; + divisor);"/>
				<comm cntt="System.out.println(&amp;quot;power: &amp;quot; + power);"/>
				<comm cntt="System.out.println(&amp;quot;start of string: &amp;quot; + startOfString);"/>
				<comm cntt="System.out.println(&amp;quot;end of string: &amp;quot; + endOfString);"/>
				<param name="length"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.ToBinary.convert(String)" access="priv" jdoc="">
				<comm cntt="we have to go through each character and change it to it binary"/>
				<param name="wmString"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.assignlv.MethodCompare" intfc="n" abs="n" inn="n" sloc="60" jdoc="">
			<comm cntt="public boolean equals(Object o){ ClassNameMethodBundle c1 = ClassNameMethodBundle.this; ClassNameMethodBundle c2 = (ClassNameMethodBundle)o; sandmark.program.Method m1 = c1.getMethod(); sandmark.program.Method m2 = c2.getMethod(); String sig1 = m1.getSignature(); String sig2 = m2.getSignature(); org.apache.bcel.classfile.Code m1code = m1.getCode(); int m1Length = m1code.getLength(); org.apache.bcel.classfile.Code m2code = m2.getCode(); int m2Length = m2code.getLength(); org.apache.bcel.generic.InstructionList il1 = m1.getInstructionList(); org.apache.bcel.generic.InstructionList il2 = m2.getInstructionList(); org.apache.bcel.generic.InstructionHandle ih1 = il1.getStart(); org.apache.bcel.generic.InstructionHandle ih2 = il2.getStart(); String sih1 = ih1.toString(); String sih2 = ih2.toString(); int hash1 = sih1.hashCode(); int hash2 = sih2.hashCode(); String c1 = m1.getClassName(); String c2 = m2.getClassName(); if((sig1.compareTo(sig2) == 0) &amp;&amp; (m1Length == m2Length) &amp;&amp; (hash1 == hash2) &amp;&amp; (c1.compareTo(c2) == 0)) return true; else return false; }"/>
			<comm cntt="public boolean equals(Object o){ org.apache.bcel.classfile.Method m = (org.apache.bcel.classfile.Method) o; org.apache.bcel.classfile.Code m1code = org.apache.bcel.classfile.Method.this.getCode(); int m1Length = m1code.getLength(); org.apache.bcel.classfile.Code mcode = m.getCode(); int mLength = mcode.getLength(); if(m1Length == mLength){ return true; }else{ return false; } }"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.assignlv.MethodCompare.MethodCompare()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.MethodCompare.compare(Object, Object)" access="pub" jdoc="">
				<comm cntt="org.apache.bcel.classfile.Code m1code = m1.getCode();"/>
				<comm cntt="org.apache.bcel.classfile.Code m2code = m2.getCode();"/>
				<comm cntt="System.out.println(&amp;quot;method lengths are the same&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;m1: &amp;quot; + m1Name);"/>
				<comm cntt="System.out.println(&amp;quot;m2: &amp;quot; + m2Name);"/>
				<comm cntt="System.out.println(&amp;quot;retVal1: &amp;quot; + retVal);"/>
				<comm cntt="System.out.println(&amp;quot;all the way in here&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;retVal: &amp;quot; + retVal);"/>
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.assignlv.AssignLV" intfc="n" abs="n" inn="n" sloc="207" jdoc="This algorithm .....">
			<comm cntt="Get the HTML codes of the About page."/>
			<comm cntt="Get the URL of the Help page"/>
			<comm cntt="Embedding"/>
			<comm cntt="Recognition"/>
			<comm cntt="Return an iterator which generates the watermarks found in the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt; UL&amp;gt;"/>
			<field name="bitsEmbedded" access="priv" jdoc=""/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.getShortName()" access="pub" jdoc="Returns this watermarker&amp;apos;s short name.">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.getLongName()" access="pub" jdoc="Returns this watermarker&amp;apos;s long name.">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="Embed a watermark value into the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Watermark: The watermark value to be embedded. &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt;LI&amp;gt; Output File: The name of the jar file to be constructed. &amp;lt; UL&amp;gt;"/>
				<comm cntt="Convert the watermark to a binary and add the length at the begining"/>
				<comm cntt="convert the watermark to a binary without adding the length at the begining"/>
				<comm cntt="iterate over the classes putting the class name and method into an arrayList."/>
				<comm cntt="sort the list of methods based upon their signature and method length"/>
				<comm cntt="seed a pseudorandom number generator with the key"/>
				<comm cntt="randomly choose methods embedding the watermark"/>
				<comm cntt="sandmark.program.Method[] methods = origClass.getMethods();"/>
				<comm cntt="generate the interference graph information"/>
				<comm cntt="do the register allocation"/>
				<comm cntt="get the interference graph with the new register allocation"/>
				<comm cntt="System.out.println(igNodes);"/>
				<comm cntt="add edges to the interference graph based upon the watermark"/>
				<comm cntt="do the register allocation on the new interference graph"/>
				<comm cntt="sandmark.analysis.controlflowgraph.RegisterAllocator.DEBUG = true;"/>
				<comm cntt="sandmark.analysis.controlflowgraph.RegisterAllocator.DEBUG = false;"/>
				<comm cntt="igNodes = ig.getVars();"/>
				<comm cntt="java.util.Collections.sort(igNodes);"/>
				<comm cntt="check if we embedded the whole watermark"/>
				<comm cntt="sandmark.util.Log.message(0, &amp;quot;Embedding failed: unable to embed the entire watermark.&amp;quot;);"/>
				<comm cntt="else{"/>
				<comm cntt="sandmark.util.Log.message(0, &amp;quot;Watermarking using &amp;quot; + this.getShortName() +"/>
				<comm cntt="&amp;quot;is done&amp;quot;);"/>
				<comm cntt="}"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.IGModifier(sandmark.analysis.interference.InterferenceGraph, java.util.ArrayList, String, String, String)" access="priv" jdoc="">
				<comm cntt="sort the nodes"/>
				<comm cntt="System.out.println(&amp;quot;orig: &amp;quot; + igNodes);"/>
				<comm cntt="if(DEBUG)"/>
				<comm cntt="for each node find the two closest nodes that are not connected"/>
				<comm cntt="add an interference based upon the next bit in the watermark"/>
				<comm cntt="check if it interferes with any nodes already in the tripleList"/>
				<comm cntt="boolean interfere = false;"/>
				<comm cntt="check if it interferes with any nodes already in the tripleList"/>
				<comm cntt="end while"/>
				<comm cntt="check if it interferes with any nodes already in the tripleList"/>
				<comm cntt="end while"/>
				<comm cntt="System.out.println(&amp;quot;found a triple: &amp;quot; + v + &amp;quot;\n&amp;quot; + v1 + &amp;quot;\n&amp;quot; + v2);"/>
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<param name="ig"/>
				<param name="igNodes"/>
				<param name="workingWM"/>
				<param name="justWM"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		<class name="/:sandmark.watermark.assignlv.AssignLV$Recognizer" intfc="n" abs="n" inn="y" sloc="171" jdoc="">
			<comm cntt="An iterator which generates the watermarks found in the program."/>
			<comm cntt="end generate()"/>
			<field name="result" access="pub" jdoc=""/>
			<field name="current" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.assignlv.AssignLV$Recognizer.Recognizer(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV$Recognizer.generate(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<comm cntt="iterate over the classes putting the class name and method into an"/>
				<comm cntt="arrayList."/>
				<comm cntt="sort the list of methods based upon their signature and method length"/>
				<comm cntt="seed a pseudorandom number generator with the key"/>
				<comm cntt="new java.util.Random(seed);"/>
				<comm cntt="iterate over the methods in bundleArray in the same order as they"/>
				<comm cntt="where embedded"/>
				<comm cntt="generate the interference information"/>
				<comm cntt="get interference graph nodes"/>
				<comm cntt="do the register allocation to obtain the original allocation"/>
				<comm cntt="method.mark();"/>
				<comm cntt="get new interference graph nodes"/>
				<comm cntt="sort the list"/>
				<comm cntt="System.out.println(origColoring);"/>
				<comm cntt="compare the coloring to obtain the watermark"/>
				<comm cntt="end iteration over methods"/>
				<comm cntt="If binary watermark does not have length at least 16 search for"/>
				<comm cntt="the field that contains the remaining portion of the watermark"/>
				<comm cntt="System.out.println(&amp;quot; The complete binary watermark obtained from the methods&amp;quot; + workingWM);"/>
				<comm cntt="changed all 16&amp;apos;s to 8&amp;apos;s"/>
				<comm cntt="take the first 8 to determine how long the watermark should be"/>
				<comm cntt="if the binary watermark is not that length search for the field"/>
				<comm cntt="that contains the remaining protion of the watermark"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV$Recognizer.compare(sandmark.analysis.interference.InterferenceGraph, java.util.ArrayList, java.util.Hashtable, String)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;orig: &amp;quot; + origColoring);"/>
				<comm cntt="check if it interferes with any nodes already in the tripleList"/>
				<comm cntt="check if it interferes with any nodes already in the tripleList"/>
				<comm cntt="end while"/>
				<comm cntt="check if it interferes with any nodes already in the tripleList"/>
				<comm cntt="end while"/>
				<comm cntt="System.out.println(&amp;quot;found a triple: &amp;quot; + v + &amp;quot;\n&amp;quot; + v1 + &amp;quot;\n&amp;quot; + v2);"/>
				<comm cntt="System.out.println(&amp;quot;with corresponding nodes &amp;quot; + w + &amp;quot; &amp;quot; + w1 + &amp;quot; &amp;quot; + w2);"/>
				<comm cntt="end if"/>
				<comm cntt="end if"/>
				<comm cntt="end for"/>
				<param name="ig"/>
				<param name="origColoring"/>
				<param name="markedIndices"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV$Recognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV$Recognizer.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.AssignLV$Recognizer.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.assignlv.FromBinary" intfc="n" abs="n" inn="n" sloc="68" jdoc="">
			<field name="mark" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.assignlv.FromBinary.FromBinary(String, boolean)" access="pub" jdoc="">
				<param name="binary"/>
				<param name="isLength"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.FromBinary.getString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.FromBinary.convertLength(String)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;power: &amp;quot; + power);"/>
				<comm cntt="System.out.println(&amp;quot;length: &amp;quot; + length);"/>
				<comm cntt="System.out.println(&amp;quot;iLength: &amp;quot; + iLength);"/>
				<param name="binary"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.FromBinary.convert(String)" access="priv" jdoc="">
				<comm cntt="each set of 8 bits is one character"/>
				<comm cntt="so we have to convert each 8 bit set into a character"/>
				<comm cntt="System.out.println(&amp;quot;binary length: &amp;quot; + binary.length());"/>
				<param name="binary"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.assignlv.ToArray" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/:sandmark.watermark.assignlv.ToArray.ToArray()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.ToArray.myToArray(java.util.ArrayList)" access="pub" jdoc="">
				<param name="list"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.assignlv.ClassNameMethodBundle" intfc="n" abs="n" inn="n" sloc="25" jdoc="">
			<field name="name" access="priv" jdoc=""/>
			<field name="method" access="priv" jdoc=""/>
			<field name="methodArraySlot" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.assignlv.ClassNameMethodBundle.ClassNameMethodBundle(String, sandmark.program.Method, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="method"/>
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.watermark.assignlv.ClassNameMethodBundle.getMethod()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.ClassNameMethodBundle.getClassName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.ClassNameMethodBundle.getSlot()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.assignlv.ClassNameMethodBundle.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.bogusexp">
		<class name="/:sandmark.watermark.bogusexp.BogusExpression" intfc="n" abs="n" inn="n" sloc="169" jdoc="">
			<comm cntt="Returns this watermarker&amp;apos;s short name."/>
			<comm cntt="Returns this watermarker&amp;apos;s long name."/>
			<comm cntt="Get the HTML codes of the About page."/>
			<comm cntt="Get the URL of the Help page"/>
			<comm cntt="Specifies the author of this algorithm."/>
			<comm cntt="Specifies the author&amp;apos;s email address."/>
			<comm cntt="Specifies what this algorithm does."/>
			<comm cntt="Embedding"/>
			<comm cntt="Recognition"/>
			<comm cntt="Return an iterator which generates the watermarks found in the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt; UL&amp;gt;"/>
			<field name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getPostrequisities()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getPostsuggestions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getPreprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getPrerequisities()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getPresuggestions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="Embed a watermark value into the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Watermark: The watermark value to be embedded. &amp;lt; UL&amp;gt;"/>
				<comm cntt="new java.util.Random();"/>
				<comm cntt="Incase of illegal interfaces"/>
				<comm cntt="(default: insert it in first method)"/>
				<comm cntt="take a random method for the class and add the watermarking expression in it..."/>
				<comm cntt="new java.util.Random();"/>
				<comm cntt="choose a random place (between 1 and &amp;apos;numInstr&amp;apos;) to insert the instruction..."/>
				<comm cntt="new java.util.Random();"/>
				<comm cntt="(default: insert it at start of method code)"/>
				<comm cntt="add local variable &amp; assign watermarking expression..."/>
				<comm cntt="mObj.setMaxStack();"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		<class name="/:sandmark.watermark.bogusexp.BogusExpression$Recognizer" intfc="n" abs="n" inn="y" sloc="100" jdoc="">
			<comm cntt="An iterator which generates the watermarks found in the program."/>
			<field name="result" access="pub" jdoc=""/>
			<field name="current" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression$Recognizer.Recognizer(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression$Recognizer.generate(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<comm cntt="code to extract the watermark follows"/>
				<comm cntt="NOTE:&amp;apos;cp&amp;apos; removed: change parsing"/>
				<comm cntt="NOTE:&amp;apos;cp&amp;apos; removed"/>
				<comm cntt="NOTE:&amp;apos;cp&amp;apos; removed"/>
				<comm cntt="NOTE:&amp;apos;cp&amp;apos; removed"/>
				<comm cntt="if localIndex matches"/>
				<comm cntt="if instr ISTORE"/>
				<comm cntt="&amp;apos;for&amp;apos; check each instr"/>
				<comm cntt="if &amp;apos;sm$&amp;apos;"/>
				<comm cntt="iterate locals"/>
				<comm cntt="iterate methods"/>
				<comm cntt="iterate classes"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression$Recognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression$Recognizer.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusexp.BogusExpression$Recognizer.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.bogusinitializer">
		<class name="/:sandmark.watermark.bogusinitializer.BogusInitializer" intfc="n" abs="n" inn="n" sloc="109" jdoc="Algorithm Implemented by : Ashok Venkatraj &amp; RathnaPrabhu emails : ashok@cs.arizona.edu prabhu@cs.arizona.edu This algorithm adds a constant &amp;quot;sm$len=x&amp;quot; where x is the number of bogus initialisers to be embedded in the constant pool of a random class. sm$len is the identifer we&amp;apos;re looking for during recognition and based on the value , we will looking for that many bogus initialisers embedded Important : THE INPUT JAR FILE SHOULD NOT CONTAIN ANY INTERFACES OTHERWISE, getInstructionList will return null">
			<comm cntt="Get the HTML codes of the About page for BogusInitializer"/>
			<comm cntt="Get the URL of the Help page for BogusInitializer"/>
			<comm cntt="Embedding"/>
			<comm cntt="Recognition"/>
			<comm cntt="Return an iterator which generates the watermarks found in the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt; UL&amp;gt;"/>
			<field name="bogus_ids_no" access="pub" jdoc=""/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.BogusInitializer()" access="pub" jdoc="Constructs a watermarker.">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.getShortName()" access="pub" jdoc="Returns this watermarker&amp;apos;s short name.">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.getLongName()" access="pub" jdoc="Returns this watermarker&amp;apos;s long name.">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="Embed a watermark value into the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Watermark: The watermark value to be embedded. &amp;lt; UL&amp;gt;"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		<class name="/:sandmark.watermark.bogusinitializer.BogusInitializer$Recognizer" intfc="n" abs="n" inn="y" sloc="67" jdoc="">
			<comm cntt="Obtain the value of sm$len . Based on the value of sm$len , we use a loop to find out the values of BIPUSH . Inherent advantage is that, we aren&amp;apos;t relying on the names of added bogus variables, some compilers may strip out such information (ie) if watermark was 1056 ,then the code added during embedding would give us the following : 0: bipush 56 2: istore %4 4: bipush 10 6: istore_3 ..... The method&amp;apos;s code ..... We strip out the values in BIPUSH statements and reconstruct back the original watermark ."/>
			<field name="result" access="pub" jdoc=""/>
			<field name="current" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer$Recognizer.Recognizer(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer$Recognizer.generate(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer$Recognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer$Recognizer.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusinitializer.BogusInitializer$Recognizer.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.bogusswitch">
		<class name="/:sandmark.watermark.bogusswitch.Bogus_Switch" intfc="n" abs="n" inn="n" sloc="94" jdoc="">
			<comm cntt="Get the HTML codes of the About page."/>
			<comm cntt="Get the URL of the Help page"/>
			<comm cntt="Embedding"/>
			<comm cntt="Recognition"/>
			<comm cntt="Return an iterator which generates the watermarks found in the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt; UL&amp;gt;"/>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getShortName()" access="pub" jdoc="Returns this watermarker&amp;apos;s short name.">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getLongName()" access="pub" jdoc="Returns this watermarker&amp;apos;s long name.">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		<class name="/:sandmark.watermark.bogusswitch.Bogus_Switch$Recognizer" intfc="n" abs="n" inn="y" sloc="48" jdoc="">
			<comm cntt="An iterator which generates the watermarks found in the program."/>
			<field name="result" access="pub" jdoc=""/>
			<field name="curndx" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch$Recognizer.Recognizer(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch$Recognizer.generate(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch$Recognizer.tryGetWM(org.apache.bcel.generic.Instruction)" access="priv" jdoc="">
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch$Recognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch$Recognizer.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.bogusswitch.Bogus_Switch$Recognizer.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.constantstring">
		<class name="/:sandmark.watermark.constantstring.ConstantString" intfc="n" abs="n" inn="n" sloc="74" jdoc="This algorithm adds a constant &amp;quot;sm$watermark=WATERMARK&amp;quot; to the constant pool of a random class. &amp;quot;WATERMARK&amp;quot; is the actual watermark value, sm$watermark is the identifer we&amp;apos;re looking for during recognition.">
			<comm cntt="Get the properties of ConstantString algorithm"/>
			<comm cntt="Get the HTML codes of the About page for ConstantString"/>
			<comm cntt="Get the URL of the Help page for ConstantString"/>
			<comm cntt="Embedding"/>
			<comm cntt="Recognition"/>
			<comm cntt="Return an iterator which generates the watermarks found in the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt; UL&amp;gt;"/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.ConstantString()" access="pub" jdoc="Constructs a watermarker.">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getShortName()" access="pub" jdoc="Returns this watermarker&amp;apos;s short name.">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getLongName()" access="pub" jdoc="Returns this watermarker&amp;apos;s long name.">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="Embed a watermark value into the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Watermark: The watermark value to be embedded. &amp;lt; UL&amp;gt;"/>
				<comm cntt="throw new java.lang.UnsupportedOperationException(&amp;quot;unimplemented&amp;quot;);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		<class name="/:sandmark.watermark.constantstring.ConstantString$Recognizer" intfc="n" abs="n" inn="y" sloc="36" jdoc="">
			<comm cntt="An iterator which generates the watermarks found in the program. We simply walk through every class looking for a constant of the form &amp;quot;sm$watermark=WATERMARK&amp;quot; We store the WATERMARK bit in a Vector result. The iterator will then generate the elements from this vector one at a time. (This is, obviously, the wrong thing to do, but writing an iterator that actually generates one element at a time in Java is painful.)"/>
			<field name="result" access="pub" jdoc=""/>
			<field name="current" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.constantstring.ConstantString$Recognizer.Recognizer(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString$Recognizer.generate(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString$Recognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString$Recognizer.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.constantstring.ConstantString$Recognizer.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.constantstring.Program" intfc="n" abs="n" inn="n" sloc="3" jdoc="">
			<field name="wm" access="priv" jdoc=""/>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.ct">
		<class name="/:sandmark.watermark.ct.FindWindows" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<mth name="/:sandmark.watermark.ct.FindWindows.main(String)" access="pub" jdoc="">
				<comm cntt="methodInstructions.add(new Integer(method.getInstructionList().getLength()));"/>
				<comm cntt="methodSizes.add(new Integer(method.getInstructionList().getByteCode().length));"/>
				<comm cntt="System.out.print(&amp;quot;Method Sizes: &amp;quot;); for(int i = 0 ; i &amp;lt; methodSizes.size() ; i++) System.out.print(methodSizes.get(i) + &amp;quot; &amp;quot;); System.out.println(); System.out.print(&amp;quot;Method Lengths: &amp;quot;); for(int i = 0 ; i &amp;lt; methodInstructions.size() ; i++) System.out.print(methodInstructions.get(i) + &amp;quot; &amp;quot;); System.out.println();"/>
				<param name="argv"/>
			</mth>
		<class name="/:sandmark.watermark.ct.FindWindows$Window" intfc="n" abs="n" inn="y" sloc="20" jdoc="">
			<field name="prev" access="pub" jdoc=""/>
			<field name="opcode" access="pub" jdoc=""/>
			<field name="mHash" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.FindWindows$Window.Window(Window, int)" access="pub" jdoc="">
				<param name="p"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.FindWindows$Window.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.FindWindows$Window.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.FindWindows$Window.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.FindWindows$WindowState" intfc="n" abs="n" inn="y" sloc="88" jdoc="">
			<field name="mWindows" access="pub" jdoc=""/>
			<field name="mFilter" access="pub" jdoc=""/>
			<field name="mCurrentWindows" access="pub" jdoc=""/>
			<field name="mWindowCount" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.FindWindows$WindowState.WindowState(int, String)" access="pub" jdoc="">
				<param name="n"/>
				<param name="filterFile"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.FindWindows$WindowState.clear()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.FindWindows$WindowState.collect(org.apache.bcel.generic.InstructionHandle, boolean)" access="pub" jdoc="">
				<param name="ih"/>
				<param name="emptyStack"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.FindWindows$WindowState.dump()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.FindWindows$WindowState.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.FindWindows$WindowState.parseFilter(String)" access="priv" jdoc="">
				<param name="file"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.ct.CT" intfc="n" abs="n" inn="n" sloc="327" jdoc="A StaticWatermarker object encapsulates code for running a particular static watermark algorithm.">
			<comm cntt="Get the properties of CT algorithm"/>
			<comm cntt="Get the HTML codes of the About page for CT"/>
			<comm cntt="Get the URL of the Help page for CT"/>
			<comm cntt="Tracing"/>
			<comm cntt="Embedding"/>
			<comm cntt="Recognition"/>
			<field name="mTraceParams" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<field name="tracer" access="pub" jdoc=""/>
			<field name="recognizer" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.CT.getShortName()" access="pub" jdoc="Returns this watermarker&amp;apos;s short name.">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.getLongName()" access="pub" jdoc="Returns this watermarker&amp;apos;s long name.">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.preprocess(sandmark.watermark.DynamicTraceParameters, sandmark.util.ConfigProperties)" access="priv" jdoc="">
				<comm cntt="Before running the trace we process the input jar file in order to get accurate stack frame information during the actual trace. Return a new properties set where the class path includes this new jar file."/>
				<param name="params"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.startTracing(sandmark.watermark.DynamicTraceParameters)" access="pub" jdoc="Start a tracing run of the program. Return an iterator object that will generate the trace points encountered by the program.">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.endTracing()" access="pub" jdoc="This routine is called when the tracing run has completed. tracePoints is an array of trace points generated by sandmark.watermark.ct.trace.Tracer. In our case, these are of type sandmark.watermark.ct.trace.TracePoint">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.stopTracing()" access="pub" jdoc="Force an end to a tracing run of the program.">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.embed(sandmark.watermark.DynamicEmbedParameters)" access="pub" jdoc="Embed a watermark value into the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Watermark: The watermark value to be embedded. &amp;lt;LI&amp;gt; Trace File: The name of the file containing trace data. &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt;LI&amp;gt; Output File: The name of the jar file to be constructed. &amp;lt;LI&amp;gt; DWM_ct_Encode_ClassName: The name of the Java file that builds the watermark. &amp;lt; UL&amp;gt;">
				<comm cntt="props.setProperty(&amp;quot;Storage Location&amp;quot;, &amp;quot;formal&amp;quot;);"/>
				<comm cntt="embedder.saveSource(sourceFileName);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.startRecognition(sandmark.watermark.DynamicRecognizeParameters)" access="pub" jdoc="Start a recognition run of the program.">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.watermarks()" access="pub" jdoc="Return an iterator object that will generate the watermarks found in the program.">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.stopRecognition()" access="pub" jdoc="Force the end to a tracing run of the program.">
			</mth>
			<mth name="/:sandmark.watermark.ct.CT.waitForProgramExit()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.Evaluate" intfc="n" abs="n" inn="n" sloc="82" jdoc="This class contains code to evaluate the CT algorithm.">
			<mth name="/:sandmark.watermark.ct.Evaluate.edgeCount(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.Evaluate.doit(int, java.math.BigInteger, String, boolean)" access="pub" jdoc="">
				<comm cntt="ilist.setPositions();"/>
				<comm cntt="if(components == 1)"/>
				<comm cntt="System.out.println(ilist);"/>
				<param name="components"/>
				<param name="watermark"/>
				<param name="encoding"/>
				<param name="useCycleGraph"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.Evaluate.testOneCodec(String, boolean)" access="pub" jdoc="">
				<param name="codec"/>
				<param name="useCycleGraph"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.Evaluate.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.ct.embed">
		<class name="/:sandmark.watermark.ct.embed.PrepareTrace" intfc="n" abs="n" inn="n" sloc="161" jdoc="">
			<comm cntt="----------------------------------------------------------------"/>
			<comm cntt="-------------------------------------------------------------"/>
			<mth name="/:sandmark.watermark.ct.embed.PrepareTrace.distribute(sandmark.util.MethodID[], int)" access="pub" jdoc="Distributes a set of code fragments among insertion points. Produces a list of lists, with one sublist for each insertion point. @param flist code fragment list @param n number of insertion points This method needs to be more random. It seems like the first trace point is always picked, for example.">
				<comm cntt="System.out.println(&amp;quot;NFRAGS=&amp;quot; + nfrags);"/>
				<param name="flist"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.PrepareTrace.uniquify(sandmark.watermark.ct.trace.TracePoint[])" access="pub" jdoc="The LOCATION VALUE flags are determined by looking at all the traces that come from the same location. If there&amp;apos;s just one trace at a location, it&amp;apos;s LOCATION based. If there&amp;apos;s more than one, it&amp;apos;s VALUE based. But if there are any duplicate values at a location, the location is discarded and not used as a trace point. Any location that has multiple identical values should be discarded. All values at a location should be unique or else that location should be discarded. &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; Insert all trace points into a table indexed by sandmark.util.ByteCodeLocation. Each entry is a list of the trace points generated at that location. &amp;apos;table&amp;apos; is a Hashtable that maps the source location of a trace event (sandmark.util.ByteCodeLocation) to a list of the trace events that happened at that location (sandmark.watermark.ct.trace.TracePoint). &amp;lt;LI&amp;gt; Walk &amp;apos;table&amp;apos; and determine for each source location whether &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; there are multiple identical trace values at this location (in which case it should be discarded), or &amp;lt;LI&amp;gt; there is exactly one trace point at this location (in which case it&amp;apos;s a LOCATION trace point), or &amp;lt;LI&amp;gt; there are multiple unique values at this source location (in which case it&amp;apos;s a VALUE trace point). &amp;lt; OL&amp;gt; &amp;lt;LI&amp;gt; Return an array of those tracepoints which have been determined to be unique. &amp;lt; OL&amp;gt; @param traceData the code points that were touched during tracing.">
				<param name="traceData"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.PrepareTrace.allocate(sandmark.watermark.ct.trace.TracePoint[], sandmark.util.MethodID[])" access="pub" jdoc="Allocate the code fragments among the trace points. Returns an array of EmbedData objects, each of which maps a TracePoint object to a list of method names. These methods should be inserted at the point in the code that TracePoint references. @param traceData annotation points hit during tracing @param methods array of methods to insert">
				<comm cntt="for(int i=0;i&amp;lt;traceData.length;i++) System.out.println(&amp;quot;trace points &amp;quot;+i+&amp;quot;=&amp;quot;+traceData[i]); System.out.println(&amp;quot;trace pointsssssssssssssssssssssssssssss &amp;quot;);"/>
				<comm cntt="System.out.println(sandmark.watermark.ct.trace.TracePoint.toString(traceData));"/>
				<comm cntt="for(int i=0;i&amp;lt;methods.length;i++)"/>
				<comm cntt="System.out.println(&amp;quot;Method points=&amp;quot;+i+&amp;quot; &amp;quot;+methods[i]);"/>
				<comm cntt="sandmark.util.MethodID[][] d = mydistribute(methods, traceLocations.length);"/>
				<comm cntt="System.out.println(&amp;quot;Embedding......&amp;quot;);"/>
				<comm cntt="for(int i=0;i&amp;lt;validPoints;i++)"/>
				<comm cntt="{"/>
				<comm cntt="System.out.println(&amp;quot;i=&amp;quot;+i+&amp;quot;=&amp;quot;+e[i]);"/>
				<comm cntt="}"/>
				<param name="traceData"/>
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.PrepareTrace.test(String, sandmark.watermark.ct.trace.TracePoint[], sandmark.util.MethodID[])" access="pub" jdoc="Run a test of this class.">
				<param name="header"/>
				<param name="tracePoints"/>
				<param name="creators"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.PrepareTrace.TP(String, String, String, int, int)" access="pub" jdoc="Construct a trace point. @param value the value at the trace point @param callerName the name of the caller @param callerLocation the name of the caller location @param bytecodeLoc the botecode location @param lineNumber the line number">
				<param name="value"/>
				<param name="callerName"/>
				<param name="callerLocation"/>
				<param name="bytecodeLoc"/>
				<param name="lineNumber"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.PrepareTrace.main(String[])" access="pub" jdoc="Test this class.">
				<param name="args"/>
			</mth>
		<class name="/:sandmark.watermark.ct.embed.PrepareTrace$TraceLocation" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="tracePoint" access="pub" jdoc=""/>
			<field name="kind" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.PrepareTrace$TraceLocation.TraceLocation(sandmark.watermark.ct.trace.TracePoint, int)" access="pub" jdoc="">
				<param name="tracePoint"/>
				<param name="kind"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.ct.embed.Inliner" intfc="n" abs="n" inn="n" sloc="68" jdoc="">
			<comm cntt="Inline all the method invocation in the method mg that are calls to methods in class watermarkClassName"/>
			<comm cntt="Inline a given invoke call"/>
			<const name="Debug" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.Inliner.doInline(sandmark.program.Application, sandmark.util.ConfigProperties)" access="pub" jdoc="@param app the program to be watermarked @param props global property list">
				<param name="app"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Inliner.inlineMethods(sandmark.program.Class, sandmark.program.Method, String)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Evaluating inline&amp;quot;+call);"/>
				<param name="ec"/>
				<param name="mg"/>
				<param name="watermarkClassName"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Inliner.inlineMethod(sandmark.program.Class, sandmark.program.Method, org.apache.bcel.generic.InstructionHandle, String)" access="pub" jdoc="">
				<param name="ec"/>
				<param name="mg"/>
				<param name="call"/>
				<param name="watermarkClassName"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.InsertStorageCreators" intfc="n" abs="n" inn="n" sloc="95" jdoc="We need some kind of structure to store handles to watermark graph components. We can use arrays, vectors, hashtables, etc. At some point these structures need to be created. This class is in charge of inserting code for creating these storage structures.">
			<comm cntt="-----------------------------------------------------------"/>
			<comm cntt="Constructor and Main Routine"/>
			<comm cntt="-----------------------------------------------------------"/>
			<field name="props" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
			<field name="watermarkClassName" access="pub" jdoc=""/>
			<field name="storageCreators" access="pub" jdoc=""/>
			<field name="rootNode" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.InsertStorageCreators.InsertStorageCreators(sandmark.program.Application, sandmark.util.ConfigProperties, String[][], sandmark.watermark.ct.trace.callforest.Node)" access="pub" jdoc="We need some kind of structure to store handles to watermark graph components. We can use arrays, vectors, hashtables, etc. At some point these structures need to be created. This class is in charge of inserting code for creating these storage structures.">
				<param name="app"/>
				<param name="props"/>
				<param name="storageCreators"/>
				<param name="domNode"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertStorageCreators.getCallForestRoot()" access="pub" jdoc="Return the location in the code where we should insert the calls to Watermark.CreateStorage_X(). Rather than inserting the calls at the exact bytecode location we go to location 0, the beginning of the method. This avoids the unpleasant situation &amp;lt;PRE&amp;gt; main() { P(10); } &amp;lt; PRE&amp;gt; where we might insert the calls between &amp;apos;push 10&amp;apos; and &amp;apos;call P&amp;apos;.">
				<comm cntt="System.out.println(&amp;quot;rootNode======&amp;quot;+rootNode);"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertStorageCreators.insert()" access="pub" jdoc="Insert calls to Watermark.CreateStorage_X(). The method &amp;lt;PRE&amp;gt; void main() { P(); } &amp;lt; PRE&amp;gt; should turn into &amp;lt;PRE&amp;gt; void main() { java.util.Hashtable sm$hash = Watermark.CreateStorage_sm$hash(); java.util.Vector sm$vector = Watermark.CreateStorage_sm$vector(); P(); } &amp;lt; PRE&amp;gt; If we&amp;apos;re passing storage containers in formal parameters, this will eventually turn into &amp;lt;PRE&amp;gt; void main() { java.util.Hashtable sm$hash = Watermark.CreateStorage_sm$hash(); java.util.Vector sm$vector = Watermark.CreateStorage_sm$vector(); P(sm$hash,sm$vector); } storageCreators[][] is an array of quadruples: {methodName, returnType, localName, GLOBAL FORMAL} for example {&amp;quot;CreateStorage_sm$hash&amp;quot;, &amp;quot;java.util.Hashtable&amp;quot;, &amp;quot;sm$hash&amp;quot;, &amp;quot;FORMAL&amp;quot;} &amp;lt; PRE&amp;gt; Rather than inserting the calls at the exact bytecode location we go to location 0, the beginning of the method. This avoids the unpleasant situation &amp;lt;PRE&amp;gt; main() { P(10); } &amp;lt; PRE&amp;gt; where we might insert the calls between &amp;apos;push 10&amp;apos; and &amp;apos;call P&amp;apos;. This is the main entry point to this class.">
				<comm cntt="System.out.println(&amp;quot;createStorage:1:rootLocation=&amp;quot; + rootLocation);"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertStorageCreators.createStorageCreatorCall(String, String, String, org.apache.bcel.generic.ConstantPoolGen, org.apache.bcel.generic.MethodGen)" access="pub" jdoc="Return a list of instructions that invoke the method &amp;apos;methodName&amp;apos;, whose signature is &amp;quot;()returnType&amp;quot;. Store the resulting storage container in local variable &amp;apos;localName&amp;apos;. @param methodName name of method to be called @param returnType return type of method to be called @param localName name of local to store into @param cp constant pool @param mg method to be edited">
				<comm cntt="System.out.println(&amp;quot;insertStorageCreatorCall:sig=&amp;quot; + sig);"/>
				<comm cntt="mg.setMaxLocals(mg.getMaxLocals()+1);"/>
				<param name="methodName"/>
				<param name="returnType"/>
				<param name="localName"/>
				<param name="cp"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertStorageCreators.createStorageCreatorCall(String, String, String, org.apache.bcel.generic.ConstantPoolGen, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;insertStorageCreatorCall:sig=&amp;quot; + sig);"/>
				<comm cntt="System.out.println(&amp;quot;insertStorageCreatorCall:1:getMaxLocals=&amp;quot; + mg.getMaxLocals());"/>
				<comm cntt="System.out.println(&amp;quot;insertStorageCreatorCall:2:localIndex=&amp;quot; + localIndex);"/>
				<comm cntt="System.out.println(&amp;quot;insertStorageCreatorCall:3:getMaxLocals=&amp;quot; + mg.getMaxLocals());"/>
				<comm cntt="mg.setMaxLocals(mg.getMaxLocals()+1);"/>
				<param name="methodName"/>
				<param name="returnType"/>
				<param name="localName"/>
				<param name="cp"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.Distribute" intfc="n" abs="n" inn="n" sloc="212" jdoc="This class is used to distribute a set of code fragments among insertion points. Allocate the code fragments among the trace points. Returns an array of EmbedData objects, each of which maps a TracePoint object to a list of method names. These methods should be inserted at the point in the code that TracePoint references.">
			<comm cntt="contains initial trace data"/>
			<comm cntt="trace data after call to uniquify"/>
			<comm cntt="The node where the calls to storage creator"/>
			<comm cntt="should be embedded"/>
			<comm cntt="Returns the new trace data after call to uniquify"/>
			<comm cntt="Gets the callforest"/>
			<comm cntt="Returns the node where the calls to storage creator should be embedded"/>
			<comm cntt="List of methods for which we have to modify the parameter list. This methods appear in the path from the DomNode to the node where the CreateGraph() method was called."/>
			<comm cntt="----------------------------------------------------------------"/>
			<comm cntt="----------------------------------------------------------------"/>
			<comm cntt="static sandmark.util.StackFrame mkFrame( String name, String sig, String className, long lineNumber, long codeIndex, long threadID, long frameID) { return new sandmark.util.StackFrame( new sandmark.util.ByteCodeLocation( new sandmark.util.MethodID(name, sig, className), lineNumber, codeIndex ), threadID, frameID ); }"/>
			<const name="Debug" access="priv" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="traceData" access="pub" jdoc=""/>
			<field name="newTraceData" access="pub" jdoc=""/>
			<field name="traceLocations" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
			<field name="callForest" access="pub" jdoc=""/>
			<field name="nstatistics" access="pub" jdoc=""/>
			<field name="classHierarchy" access="pub" jdoc=""/>
			<field name="allMeths" access="pub" jdoc=""/>
			<field name="embedData" access="pub" jdoc=""/>
			<field name="DomNode" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.Distribute.Distribute(sandmark.util.ConfigProperties, sandmark.watermark.ct.trace.TracePoint[], sandmark.program.Application, sandmark.util.MethodID[])" access="pub" jdoc="@param props global property list @param traceData a vector of annotation points that were hit during tracing @param inApp the application to be watermarked. @param creators array of methods to insert">
				<comm cntt="call the uniquify method"/>
				<comm cntt="callForest= new sandmark.watermark.ct.trace.callforest.Forest(newTraceData, classHierarchy, nstatistics, props);"/>
				<param name="props"/>
				<param name="traceData"/>
				<param name="inApp"/>
				<param name="creators"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Distribute.findEmbedding()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Distribute.getNewTraceData()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Distribute.getCallForest()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Distribute.getStorageNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Distribute.allMethods()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Distribute.uniquify(sandmark.watermark.ct.trace.TracePoint[])" access="pub" jdoc="The LOCATION VALUE flags are determined by looking at all the traces that come from the same location. If there&amp;apos;s just one trace at a location, it&amp;apos;s LOCATION based. If there&amp;apos;s more than one, it&amp;apos;s VALUE based. But if there are any duplicate values at a location, the location is discarded and not used as a trace point. Any location that has multiple identical values should be discarded. All values at a location should be unique or else that location should be discarded. &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; Insert all trace points into a table indexed by sandmark.util.ByteCodeLocation. Each entry is a list of the trace points generated at that location. &amp;apos;table&amp;apos; is a Hashtable that maps the source location of a trace event (sandmark.util.ByteCodeLocation) to a list of the trace events that happened at that location (sandmark.watermark.ct.trace.TracePoint). &amp;lt;LI&amp;gt; Walk &amp;apos;table&amp;apos; and determine for each source location whether &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; there are multiple identical trace values at this location (in which case it should be discarded), or &amp;lt;LI&amp;gt; there is exactly one trace point at this location (in which case it&amp;apos;s a LOCATION trace point), or &amp;lt;LI&amp;gt; there are multiple unique values at this source location (in which case it&amp;apos;s a VALUE trace point). &amp;lt; OL&amp;gt; &amp;lt;LI&amp;gt; Return an array of those tracepoints which have been determined to be unique. &amp;lt; OL&amp;gt; @param traceData the code points that were touched during tracing.">
				<param name="traceData"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Distribute.allocate(sandmark.util.MethodID[])" access="pub" jdoc="Allocate the code fragments among the trace points. Returns an array of EmbedData objects, each of which maps a TracePoint object to a list of method names. These methods should be inserted at the point in the code that TracePoint references. @param methods array of methods to insert">
				<comm cntt="sandmark.util.MethodID[][] d = distribute(methods, traceLocations.length);"/>
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Distribute.getDistribution(sandmark.util.MethodID[])" access="pub" jdoc="Distributes a set of code fragments among insertion points. Produces a list of lists, with one sublist for each insertion point. @param flist code fragment list">
				<comm cntt="The commented code adds a newStackFrame namely sm$mark on top of existing frames for each tracepoint"/>
				<comm cntt="This is required if sm$mark frame is not already there"/>
				<comm cntt="for(int i=0; i&amp;lt;newTraceData.length; i++){ threadid=newTraceData[i].stack[0].threadID; frameid=newTraceData[i].stack[0].frameID+1; sandmark.util.StackFrame st[]=new sandmark.util.StackFrame[newTraceData[i].stack.length+1]; st[0]=Distribute.mkFrame(&amp;quot;sm$mark&amp;quot;,&amp;quot;()V&amp;quot;,&amp;quot;sandmark.watermark.ct.trace.Annotator&amp;quot;,45,4,threadid,frameid); for(int j=0;j&amp;lt;newTraceData[i].stack.length;j++) { st[j+1]=newTraceData[i].stack[j]; } tp[i]=new sandmark.watermark.ct.trace.TracePoint(newTraceData[i].value,newTraceData[i].location,st); } ClassHierarchy ch=new ClassHierarchy(classHierarchy); newCallForest= new sandmark.watermark.ct.trace.callforest.Forest(tp, ch, nstatistics, props);"/>
				<comm cntt="This is used to get the list of insertion points"/>
				<param name="methods"/>
			</mth>
		<class name="/:sandmark.watermark.ct.embed.Distribute$TraceLocation" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="tracePoint" access="pub" jdoc=""/>
			<field name="kind" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.Distribute$TraceLocation.TraceLocation(sandmark.watermark.ct.trace.TracePoint, int)" access="pub" jdoc="">
				<param name="tracePoint"/>
				<param name="kind"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.Distribute$ClassHierarchy" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<field name="origClassHierarchy" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.Distribute$ClassHierarchy.ClassHierarchy(sandmark.analysis.classhierarchy.ClassHierarchy)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Distribute$ClassHierarchy.methodRenameOK(sandmark.util.MethodID, sandmark.util.MethodID)" access="pub" jdoc="">
				<param name="origMethod"/>
				<param name="newMethod"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.ct.embed.AddParameters" intfc="n" abs="n" inn="n" sloc="314" jdoc="Adds extra formal arguments to selected method signatures and calls.">
			<comm cntt="-----------------------------------------------------------"/>
			<comm cntt="Constructor and Main Routine"/>
			<comm cntt="-----------------------------------------------------------"/>
			<comm cntt="@param app the program to be watermarked. @param storageCreators[][] an array of quadruples: {methodName, returnType, localName, GLOBAL FORMAL} for example: {&amp;quot;CreateStorage_sm$hash&amp;quot;, &amp;quot;java.util.Hashtable&amp;quot;, &amp;quot;sm$hash&amp;quot;, &amp;quot;FORMAL&amp;quot;} @param methods the list of methods to which we will add the new arguments in &amp;apos;storageCreators&amp;apos;."/>
			<comm cntt="For every storage class add &amp;apos;push sm$class&amp;apos; before the call instruction. Since the formals have already been added we can look it up in the localvariable table. @param ec a class that is being edited @param mg a method being modified @param il the instruction list of the method @param ih the instruction handle of the call instruction to be edited @param call the call instruction to be edited."/>
			<comm cntt="Modify the call instruction by adding &amp;apos;type&amp;apos; to the signature of the method to call. @param ec a class that is being edited @param call the call instruction to be edited. @param type the type of the formal to be added."/>
			<const name="Debug" access="priv" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
			<field name="storageCreators" access="pub" jdoc=""/>
			<field name="methods" access="pub" jdoc=""/>
			<field name="methodSet" access="pub" jdoc=""/>
			<field name="watermarkClassName" access="pub" jdoc=""/>
			<field name="domMethodNode" access="pub" jdoc=""/>
			<field name="changeSet" access="pub" jdoc="Compute the set of methods that will need to change."/>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.AddParameters(sandmark.program.Application, sandmark.util.ConfigProperties, String[][], sandmark.util.MethodID[], sandmark.watermark.ct.trace.callforest.Node)" access="pub" jdoc="">
				<param name="app"/>
				<param name="props"/>
				<param name="storageCreators"/>
				<param name="methods"/>
				<param name="domNode"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.computeMethodsToChange()" access="pub" jdoc="">
				<comm cntt="newly added ?? If one of the methods is called from a node outside the last callforest graph"/>
				<comm cntt="end newly added"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.callShouldChange(sandmark.program.Class, org.apache.bcel.generic.InvokeInstruction)" access="pub" jdoc="Return true if the call instruction in the class ec will need to be modified. @param ec a class that is being edited @param call a call instruction">
				<comm cntt="return changeSet.contains(method);"/>
				<param name="ec"/>
				<param name="call"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.signatureShouldChange(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="Return true if the signature of the method mg in the class ec will need to be modified. @param ec a class that is being edited @param mg a method">
				<param name="ec"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.add()" access="pub" jdoc="This is the main entry point to this class. For every class do &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; add extra formal parameters to the methods in &amp;apos;methods&amp;apos;. &amp;lt;LI&amp;gt; add extra actual arguments to any calls to methods in methods. &amp;lt; OL&amp;gt;">
				<comm cntt="System.out.println(&amp;quot;M=&amp;quot;+mg.getName());"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.addStorageFormals(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="For every method in &amp;apos;methods&amp;apos;, add formal parameters, one per storage class. @param ec a class that is being edited @param mg a method being modified &amp;lt;P&amp;gt; For example, &amp;lt;PRE&amp;gt; P(int) { } could turn into P(int, java.util.Vector sm$vector, java.util.Hashtable sm$hash) { } &amp;lt; PRE&amp;gt;"/>
				<param name="ec"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.addStorageFormal(sandmark.program.Class, sandmark.program.Method, String, String)" access="pub" jdoc="Add formal &amp;apos;name&amp;apos; of type &amp;apos;type&amp;apos; to method eg in class ec. @param ec a class that is being edited @param mg a method being modified @param name name of the formal to add @param type type of the formal to add">
				<param name="ec"/>
				<param name="mg"/>
				<param name="name"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.moveLocal(sandmark.program.Method, int)" access="pub" jdoc="">
				<comm cntt="set all localvariableinstr with index as localIndex to maxindex+2"/>
				<param name="mg"/>
				<param name="localIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.addStorageActuals(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="For every method call in the program to one of the methods that &amp;apos;should change&amp;apos;, add actual parameters, one per storage class. @param ec a class that is being edited @param mg a method being modified &amp;lt;P&amp;gt; For example, &amp;lt;PRE&amp;gt; P(int, java.util.Vector sm$vector, java.util.Hashtable sm$hash) { Q(5); } &amp;lt; PRE&amp;gt; should turn into &amp;lt;PRE&amp;gt; P(int, java.util.Vector sm$vector, java.util.Hashtable sm$hash) { Q(5, sm$vector, sm$hash); } &amp;lt; PRE&amp;gt; At this point we should already have added the formals."/>
				<param name="ec"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.getLocalIndex(String, sandmark.program.Method)" access="pub" jdoc="">
				<param name="localName"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.findLocal(String, sandmark.program.Method)" access="pub" jdoc="">
				<param name="name"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.editCall(sandmark.program.Class, sandmark.program.Method, org.apache.bcel.generic.InstructionList, org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InvokeInstruction)" access="pub" jdoc="">
				<param name="ec"/>
				<param name="mg"/>
				<param name="il"/>
				<param name="ih"/>
				<param name="call"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.AddParameters.fixMethodSignature(sandmark.program.Class, org.apache.bcel.generic.InstructionHandle, String)" access="pub" jdoc="">
				<param name="ec"/>
				<param name="ih"/>
				<param name="type"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.EmbedData" intfc="n" abs="n" inn="n" sloc="22" jdoc="All fields are public, but should be treated as read-only.">
			<field name="tracePoint" access="pub" jdoc="The annotation trace point, representing a source location and the mark() value encountered at that location."/>
			<field name="methods" access="pub" jdoc="The methods in Watermark.java that should be inserted at this point."/>
			<const name="LOCATION" access="pub" jdoc="Whether this trace point is location or value based."/>
			<const name="VALUE" access="pub" jdoc=""/>
			<field name="kind" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.EmbedData.EmbedData(sandmark.watermark.ct.trace.TracePoint, sandmark.util.MethodID[], int)" access="pub" jdoc="Construct an new annotation trace point, representing a source location and the mark() value encountered at that location. @param tracePoint the source code location @param methods the methods to be inserted at this point @param kind whether this trace point is location or value based">
				<param name="tracePoint"/>
				<param name="methods"/>
				<param name="kind"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.EmbedData.toString()" access="pub" jdoc="Format the data in an easy to parse form.">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.Embedder" intfc="n" abs="n" inn="n" sloc="187" jdoc="The sandmark.watermark.ct.embed.Embedder class contains methods for adding watermarking code to Java bytecode.">
			<field name="params" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
			<field name="encoder" access="pub" jdoc=""/>
			<field name="callForest" access="pub" jdoc=""/>
			<field name="nstatistics" access="pub" jdoc=""/>
			<field name="dt" access="pub" jdoc=""/>
			<field name="rep" access="pub" jdoc=""/>
			<field name="graph" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.Embedder(sandmark.program.Application, sandmark.watermark.DynamicEmbedParameters, sandmark.util.ConfigProperties, sandmark.watermark.ct.trace.TracePoint[])" access="pub" jdoc="@param props global property list @param traceData a vector of annotation points that were hit during tracing &amp;lt;P&amp;gt; Reads properties: &amp;lt;BR&amp;gt; Input File: name of Jar file to input &amp;lt;BR&amp;gt; Output File: name of Jar file to output &amp;lt;BR&amp;gt; Encode_....: various options affecting the graph encoder &amp;lt;P&amp;gt; Sets properties: none &amp;lt;P&amp;gt; We add watermarking code to the program by: &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; opening the program as a class file collection, &amp;lt;LI&amp;gt; computing static information about the program, &amp;lt;LI&amp;gt; building the call forest from the tracing points found during tracing, &amp;lt;LI&amp;gt; construct the graph whose topology embeds the watermark, and &amp;lt;LI&amp;gt; convert the graph to java bytecode which constructs the graph. &amp;lt; OL&amp;gt;">
				<comm cntt="System.out.println(&amp;quot;Node Class: &amp;quot; + props.getProperty(&amp;quot;Node Class&amp;quot;));"/>
				<param name="app"/>
				<param name="params"/>
				<param name="props"/>
				<param name="traceData"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.saveByteCode()" access="pub" jdoc="Add calls to the graph-building routines to the program to be watermarked. &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; Get the bytecode that encodes the watermark, &amp;lt;LI&amp;gt; find the trace locations in the program where calls to the watermark-building code should be inserted, &amp;lt;LI&amp;gt; embed the calls at the appropriate locations, and &amp;lt;LI&amp;gt; save the resulting new, watermarked, program. &amp;lt; OL&amp;gt;">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.getEmbedding()" access="pub" jdoc="Compute the locations where calls to the watermarking routines should be inserted.">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.source()" access="pub" jdoc="Get the Java source for the watermark class.">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.saveSource(String)" access="pub" jdoc="Write the Java source for the watermark class. &amp;lt;P&amp;gt; @param sourceFileName The name of the file to be written.">
				<param name="sourceFileName"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.saveGraph(String)" access="pub" jdoc="Write a dot file for the watermark class. &amp;lt;P&amp;gt; @param dotFileName The name of the file to be written.">
				<param name="dotFileName"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.saveCallForest(String)" access="pub" jdoc="Write the dot files for the call forest graphs. &amp;lt;P&amp;gt; @param dotFileBaseName The base name (without the .dot extension) of the files to be written.">
				<param name="dotFileBaseName"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.addToGraphViewer()" access="pub" jdoc="Add all graphs to the graph viewer.">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.embedClass(sandmark.program.Class, sandmark.watermark.ct.embed.EmbedData[], sandmark.util.MethodID[])" access="pub" jdoc="Add the watermark class to the app, and embed calls to it based on the embedding information in &amp;apos;embedData&amp;apos;. There are several steps: &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; Replace the &amp;apos;mark()&amp;apos;-calls in the original program with calls to the watermark-building methods. Only some &amp;apos;mark()&amp;apos;-calls will be replaced, namely those indicated by &amp;apos;embedData&amp;apos;. &amp;lt;LI&amp;gt; In case we are passing graph handles in extra method arguments we need to create those formal arguments and add the extra actual arguments. &amp;lt;LI&amp;gt; We need to create storage (arrays, vectors, hashtables, etc) to store the handles to watermark graph components. &amp;lt;LI&amp;gt; We delete all remaining &amp;apos;mark()&amp;apos;-calls. &amp;lt;LI&amp;gt; Finally, we add the watermark class to class file collection. &amp;lt; OL&amp;gt; &amp;lt;p&amp;gt; @param app The application to be watermarked. @param watermarkClass The class that builds the watermark graph. @param embedData Where in the app calls to watermarkClass should be embedded. @param methods The methods to which formal parameters should be added to pass around storage containers.">
				<comm cntt="Pass the node where the calls to storageCreators should be embedded"/>
				<param name="watermarkClass"/>
				<param name="embedData"/>
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.constructGraph(String, sandmark.util.ConfigProperties)" access="pub" jdoc="Construct and return a graph embedding the value Watermark using encoding Graph Type. &amp;lt;p&amp;gt; @param props The property collection. &amp;lt;p&amp;gt; props contains at least: &amp;lt;BR&amp;gt; Watermark: The integer to be encoded. &amp;lt;BR&amp;gt; Graph Type: &amp;quot;radix&amp;quot;, &amp;quot;perm&amp;quot;, ..., or &amp;quot; &amp;quot;. With &amp;quot; &amp;quot; a random codec is selected. &amp;lt;BR&amp;gt; Subgraph Count: the number of graph components to construct">
				<comm cntt="System.out.println(&amp;quot;constructGraph &amp;quot; + e + &amp;quot; : &amp;quot; + e.getMessage());"/>
				<param name="watermarkString"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.Embedder.availableEdges(String, int)" access="pub" jdoc="">
				<param name="available"/>
				<param name="needed"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.ReplaceWMClass" intfc="n" abs="n" inn="n" sloc="253" jdoc="">
			<comm cntt="It replaces the class found in DWM_CT_Encode_ClassName(Watermark class) with the class found in Node Class (This class is set by findReplaceClass()) The steps involved are 1. Copy the Constant Pool table from old class to new class 2. Copy all the methods from old class to new class 3. Copy the storage allocator fields if any from old class to new class 4. Change the Constantpool of all class that reference the old class to refer to the new class 5. Deletes the old class"/>
			<comm cntt="It change the Constantpool entry of all class that reference the old watermark class to refer to the new watermark class"/>
			<comm cntt="It determines the class that closely resembles the Watermark Class. It then sets the &amp;quot;Node Class&amp;quot; &amp; &amp;quot;DWM_CT_Encode_AvailableEdges&amp;quot; properties based on the class selected and the fields in it."/>
			<const name="Debug" access="priv" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceWMClass.ReplaceWMClass(sandmark.program.Application, sandmark.util.ConfigProperties)" access="pub" jdoc="@param app the program to be watermarked @param props global property list">
				<param name="app"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceWMClass.doReplace()" access="pub" jdoc="">
				<comm cntt="move fields of type storage allocator if the storage type is global"/>
				<comm cntt="end"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceWMClass.replaceCallstoWatermarkMethods()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceWMClass.getAcceptableTypes(sandmark.program.Class)" access="priv" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceWMClass.constructorsOK(sandmark.program.Class)" access="priv" jdoc="">
				<param name="cls"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceWMClass.findReplaceClass()" access="pub" jdoc="">
				<comm cntt="Choose the class with most number of new calls pointing to it ."/>
				<comm cntt="Add new fields to the chosen class if numfields less than no of numcomponents"/>
				<comm cntt="create the bogus field"/>
				<comm cntt="create the fieldlist for DWM_CT_Encode_AvailableEdges"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceWMClass.calcNewCalls()" access="pub" jdoc="Creates a hashtable containing the number of new calls for each class in the collection. It is used to break the tie when many classes are eligible to be watermark class">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.InsertionPoints" intfc="n" abs="n" inn="n" sloc="241" jdoc="">
			<comm cntt="&amp;lt;p&amp;gt; @param numcomponents The maximum number of components required @param f The callForest"/>
			<comm cntt="returns a list of nodes where call to create_WatermarkGraph could be embedded"/>
			<comm cntt="It calculates the point where the call to create_StorageCreator should be embedded"/>
			<comm cntt="The methods to which formal parameters should be added to pass around storage containers."/>
			<comm cntt="calculates the node which dominates all other mark node in the graph and which appears the latest"/>
			<comm cntt="determine the points where the calls to create_WatermarkGraph could be embedded"/>
			<comm cntt="List of methods for which we have to modify the parameter list. This methods appear in the path from the DomNode to the node where the CreateGraph() method was called. Note: It looks only the nodes in the last callforest graph"/>
			<const name="Debug" access="priv" jdoc=""/>
			<field name="insertionPoints" access="pub" jdoc=""/>
			<field name="DominatorNode" access="pub" jdoc=""/>
			<field name="allMeth" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.InsertionPoints.InsertionPoints(int, sandmark.watermark.ct.trace.callforest.Forest)" access="pub" jdoc="">
				<param name="numcomponents"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertionPoints.getInsertionPoints()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertionPoints.getDomNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertionPoints.getAllMethods()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertionPoints.getStorageNode(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertionPoints.getNodeList(int, sandmark.watermark.ct.trace.callforest.Forest)" access="priv" jdoc="">
				<comm cntt="only consider the last graph in the call forest"/>
				<comm cntt="consider only those paths whose first node is reachable from DominatorNode"/>
				<comm cntt="Find the node with the largest weight. Add it to the list"/>
				<comm cntt="Call it the lastnode"/>
				<comm cntt="find path that ends at last node and has the largest weight."/>
				<comm cntt="Add its fist node to the list. Call it the firstnode"/>
				<comm cntt="Keep adding nodes so that they are spread across the entire path"/>
				<comm cntt="from the firstnode and the lastnode."/>
				<comm cntt="int totweight=getWeight(path,f);"/>
				<param name="numcomponents"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.InsertionPoints.allMethods(sandmark.watermark.ct.trace.callforest.Forest, java.util.ArrayList)" access="pub" jdoc="">
				<param name="f"/>
				<param name="inlist"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.DeleteMarkCalls" intfc="n" abs="n" inn="n" sloc="76" jdoc="">
			<comm cntt="-----------------------------------------------------------"/>
			<comm cntt="Constructor and Main Routine"/>
			<comm cntt="-----------------------------------------------------------"/>
			<field name="props" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
			<field name="watermarkClass" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.DeleteMarkCalls.DeleteMarkCalls(sandmark.program.Application, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="app"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.DeleteMarkCalls.delete()" access="pub" jdoc="Delete all the calls to sandmark.watermark.ct.trace.Annotator.sm$mark( ) in every class in the program. This is the main entry point to this class.">
				<comm cntt="System.out.println(&amp;quot;DeleteMarkCalls:deleteMarkCalls1:1&amp;quot;);"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.DeleteMarkCalls.deleteMarkCalls(sandmark.program.Class)" access="pub" jdoc="Delete all the calls to sandmark.watermark.ct.trace.Annotator.sm$mark( ) in every method in the given class. @param ec the class to be edited Return &amp;apos;true&amp;apos; if the class was changed.">
				<comm cntt="System.out.println(&amp;quot;DeleteMarkCalls:deleteMarkCalls2:1&amp;quot;);"/>
				<param name="ec"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.DeleteMarkCalls.deleteMarkCalls(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="Delete every call to sandmark.watermark.ct.trace.Annotator.sm$mark( ) in the given method. Return &amp;apos;true&amp;apos; if the method was changed. @param ec the class to be edited @param mg the method to be edited">
				<param name="ec"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.DeleteMarkCalls.deleteMarkCall(sandmark.program.Class, sandmark.program.Method, org.apache.bcel.generic.INVOKESTATIC, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="Check if the given instruction is a call to sandmark.watermark.ct.trace.Annotator.sm$mark( ) If it is, replace it with a &amp;quot;NOP&amp;quot;. This way we don&amp;apos;t have to worry about jumps to the removed instructions. The NOPs should be removed later. &amp;quot;sm$mark(String)&amp;quot; and &amp;quot;sm$mark(long)&amp;quot; are instead replaced by &amp;quot;POP&amp;quot;. Ideally, we&amp;apos;d like to delete them too, but that is hard. Consider, for example, &amp;quot;sm$mark(k+x 4)&amp;quot;. @param ec the class to be edited @param mg the method to be edited @param call the call instruction to be deleted @param ih the instruction handle of the call instruction Return &amp;apos;true&amp;apos; if the method was changed.">
				<comm cntt="System.out.println(&amp;quot;DeleteMarkCalls: removing call &amp;apos;&amp;quot; + methodName + &amp;quot;:&amp;quot; + methodSig);"/>
				<comm cntt="System.out.println(&amp;quot;DeleteMarkCalls: removing call &amp;apos;&amp;quot; + methodName + &amp;quot;:&amp;quot; + methodSig);"/>
				<comm cntt="System.out.println(&amp;quot;DeleteMarkCalls: removing call &amp;apos;&amp;quot; + methodName + &amp;quot;:&amp;quot; + methodSig);"/>
				<param name="ec"/>
				<param name="mg"/>
				<param name="call"/>
				<param name="ih"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.MarkLocation" intfc="n" abs="n" inn="n" sloc="78" jdoc="">
			<comm cntt="Create a local variable to hold the argument to the mark(x) call. Example: &amp;lt;PRE&amp;gt; void P() { int x = ...; ... mark(x+4); } &amp;lt; PRE&amp;gt; Suppose that mark(x) is to be replaced by calls to Create_graph1() Create_graph2() The resulting method would look something like this: &amp;lt;PRE&amp;gt; void P() { int x = ...; ... if ((x+4)==5) Create_graph1(); if ((x+4)==7) Create_graph2(); } &amp;lt; PRE&amp;gt; But the first time we use x+4 it will be popped off the stack, and can&amp;apos;t be reused. So, we have to do the following instead: &amp;lt;PRE&amp;gt; void P() { int x = ...; ... int sm$tmp1 = x+4; mark(sm$tmp1); if (sm$tmp1==5) Create_graph1(); if (sm$tmp1==7) Create_graph2(); } &amp;lt; PRE&amp;gt; We make sure not to affect the stack height or the mark call. &amp;apos;mark(sm$tmp1)&amp;apos; will be removed later."/>
			<comm cntt="Create a new MarkLocation object. If one already exists for this location, return it from the cache."/>
			<field name="ec" access="pub" jdoc=""/>
			<field name="mg" access="pub" jdoc=""/>
			<field name="ih" access="pub" jdoc=""/>
			<field name="il" access="pub" jdoc=""/>
			<field name="annoLocation" access="pub" jdoc=""/>
			<field name="kind" access="pub" jdoc=""/>
			<field name="embedType" access="pub" jdoc=""/>
			<field name="localIndex" access="pub" jdoc=""/>
			<const name="INT" access="pub" jdoc=""/>
			<const name="STRING" access="pub" jdoc=""/>
			<field name="markLocationCache" access="pub" jdoc=""/>
			<field name="locals" access="pub" jdoc=""/>
			<field name="varCount" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.MarkLocation.MarkLocation(sandmark.program.Application, sandmark.watermark.ct.embed.EmbedData)" access="pub" jdoc="">
				<param name="app"/>
				<param name="embedData"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.MarkLocation.createLocal()" access="pub" jdoc="">
				<comm cntt="mg.setMaxLocals(mg.getMaxLocals()+1); NEW AND UNTESTED!"/>
				<comm cntt="org.apache.bcel.generic.Instruction store = null; if (embedType == MarkLocation.STRING) store = new org.apache.bcel.generic.ASTORE(localIndex); else store = new org.apache.bcel.generic.LSTORE(localIndex); lg.setStart(il.insert(ih, store));"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.MarkLocation.create(sandmark.program.Application, sandmark.watermark.ct.embed.EmbedData)" access="pub" jdoc="">
				<param name="app"/>
				<param name="embedData"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.MarkLocation.init()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.InsertionPoint" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<field name="value" access="pub" jdoc=""/>
			<field name="callerCodeIndex" access="pub" jdoc=""/>
			<field name="callerSourceName" access="pub" jdoc=""/>
			<field name="callerName" access="pub" jdoc=""/>
			<field name="callerSig" access="pub" jdoc=""/>
			<field name="methods" access="pub" jdoc=""/>
			<field name="location" access="pub" jdoc=""/>
			<field name="markLocation" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.InsertionPoint.InsertionPoint(sandmark.program.Application, sandmark.watermark.ct.embed.EmbedData)" access="pub" jdoc="">
				<param name="app"/>
				<param name="embedData"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.embed.ReplaceMarkCalls" intfc="n" abs="n" inn="n" sloc="74" jdoc="Replaces Annot.mark() calls in the bytecode with method calls to watermark class">
			<comm cntt="-----------------------------------------------------------"/>
			<comm cntt="Constructor and Main Routine"/>
			<comm cntt="-----------------------------------------------------------"/>
			<comm cntt="Insert static method calls to the methods in watermarkClass. embedData contains information where the calls should be inserted. This is the main entry point to this class."/>
			<comm cntt="Insert static method calls to ip.methods at location ip.ih. The calls go to methods in the class watermarkClass. ip.ih has a call to a mark() method. @param ip the point in the code where to insert the call."/>
			<comm cntt="Insert static method call to methodRef at location ip.ih. localIndex is the index of the local variable which holds the argument of the &amp;apos;mark()&amp;apos; call. @param cp the constant pool @param instrs the instruction list @param methodRef constant pool index of the method to insert a call to @param ip the point in the code where to insert the call."/>
			<field name="props" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
			<field name="watermarkClassName" access="pub" jdoc=""/>
			<field name="embedData" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceMarkCalls.ReplaceMarkCalls(sandmark.program.Application, sandmark.util.ConfigProperties, sandmark.watermark.ct.embed.EmbedData[])" access="pub" jdoc="">
				<param name="app"/>
				<param name="props"/>
				<param name="embedData"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceMarkCalls.insert()" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;ReplaceMarkCalls:insertCalls1:1&amp;quot;);"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceMarkCalls.insertCalls(InsertionPoint)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;ReplaceMarkCalls:insertCalls2:1&amp;quot;);"/>
				<comm cntt="USED TO BE &amp;quot;()V&amp;quot;"/>
				<comm cntt="ip.markLocation.il.insert(ip.markLocation.ih, instrs); ip.markLocation.ih.setInstruction(new org.apache.bcel.generic.NOP());"/>
				<param name="ip"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.embed.ReplaceMarkCalls.insertCall(org.apache.bcel.generic.ConstantPoolGen, org.apache.bcel.generic.InstructionList, int, InsertionPoint)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;ReplaceMarkCalls:insertCall3:1&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;ReplaceMarkCalls:insertCall3:2&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;ReplaceMarkCalls:insertCall3:3&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;ReplaceMarkCalls:insertCall3:4&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;ReplaceMarkCalls:insertCall3:5&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;ReplaceMarkCalls:insertCall3:6&amp;quot;);"/>
				<param name="cp"/>
				<param name="instrs"/>
				<param name="methodRef"/>
				<param name="ip"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.ct.encode">
		<class name="/:sandmark.watermark.ct.encode.Graph2IR" intfc="n" abs="n" inn="n" sloc="228" jdoc="This class converts a sandmark.util.newgraph.MutableGraph into a program that builds this graph. The program is made up of intermedite code statements, taken from sandmark.watermark.ct.encode.ir. . &amp;lt;P&amp;gt; Call like this: &amp;lt;PRE&amp;gt; sandmark.util.newgraph.MutableGraph graph = ... sandmark.watermark.ct.encode.Split split = new sandmark.watermark.ct.encode.Split(graph,2); split.split(); sandmark.watermark.ct.encode.storage.GlobalStorage storage = ... sandmark.watermark.ct.encode.ir.Build B = sandmark.watermark.ct.encode.Graph2IR(graph, split.subGraphs, split.componentGraph, storage); &amp;lt; PRE&amp;gt; Each subgraph is turned into a Java method that when run, will build that subgraph. A set of fixup methods are also created which should be run to connect the subgraphs in order to create the complete graph.">
			<comm cntt="====================== Links ==========================="/>
			<comm cntt="====================== Creators ==========================="/>
			<comm cntt="====================== Fixups ==========================="/>
			<comm cntt="public static void main (String[] args) {"/>
			<comm cntt="System.out.println(&amp;quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&amp;quot;);"/>
			<comm cntt="System.out.println(&amp;quot;+++++++++++++++++++++ Testing Graph2IR ++++++++++++++++++++++&amp;quot;);"/>
			<comm cntt="System.out.println(&amp;quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&amp;quot;);"/>
			<comm cntt="sandmark.util.graph.Graph graph = new sandmark.util.graph.Graph();"/>
			<comm cntt="sandmark.util.graph.Node n1 = graph.addNode();"/>
			<comm cntt="sandmark.util.graph.Node n2 = graph.addNode();"/>
			<comm cntt="sandmark.util.graph.Node n3 = graph.addNode();"/>
			<comm cntt="sandmark.util.graph.Node n4 = graph.addNode();"/>
			<comm cntt="graph.setEdge(n4,n3,1);"/>
			<comm cntt="graph.setEdge(n4,n2,2);"/>
			<comm cntt="graph.setEdge(n3,n1,1);"/>
			<comm cntt="graph.setEdge(n3,n3,2);"/>
			<comm cntt="graph.setEdge(n2,n4,1);"/>
			<comm cntt="graph.setEdge(n2,n1,2);"/>
			<comm cntt="graph.setHeader(&amp;quot;graph, with 4 nodes and 6 edges.&amp;quot;);"/>
			<comm cntt="graph.process();"/>
			<comm cntt="sandmark.watermark.ct.encode.Split split = new Split(graph,2);"/>
			<comm cntt="split.split();"/>
			<comm cntt="sandmark.util.graph.Graph subGraphs[] = split.subGraphs;"/>
			<comm cntt="graph.print();"/>
			<comm cntt="subGraphs[0].print();"/>
			<comm cntt="subGraphs[1].print();"/>
			<comm cntt="System.out.println(&amp;quot;-----------------------------------&amp;quot;);"/>
			<comm cntt="sandmark.watermark.ct.encode.ir.List creators = genCreators(graph, subGraphs, true);"/>
			<comm cntt="System.out.println(creators.toString());"/>
			<comm cntt="System.out.println(&amp;quot;-----------------------------------&amp;quot;);"/>
			<comm cntt="sandmark.watermark.ct.encode.ir.List fixups = genFixups(graph, subGraphs);"/>
			<comm cntt="System.out.println(fixups.toString());"/>
			<comm cntt="System.out.println(&amp;quot;-----------------------------------&amp;quot;);"/>
			<comm cntt="}"/>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.gen(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[], sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.storage.GlobalStorage)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraphs"/>
				<param name="componentGraph"/>
				<param name="storage"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.addLinks(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node, java.util.Set, java.util.Set)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="node"/>
				<param name="createdNodes"/>
				<param name="addedEdges"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.findPath(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Graph, sandmark.util.newgraph.Node, sandmark.util.newgraph.Node, Path)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="dftree"/>
				<param name="root"/>
				<param name="node"/>
				<param name="currentPath"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.findPath(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node, sandmark.util.newgraph.Node)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="root"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.genCreator_addForwardLinks(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, java.util.Set)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="addedEdges"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.genCreator_addBackwardLinks(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, java.util.Set)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="addedEdges"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.genCreator(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, boolean)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="isCreator"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.genCreators(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[], boolean)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="components"/>
				<param name="isCreator"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.graph2links(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, Path)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="path"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.genFixup(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, java.util.HashSet)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="subGraph1"/>
				<param name="subGraph2"/>
				<param name="edges"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR.genFixups(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[])" access="priv" jdoc="">
				<param name="graph"/>
				<param name="subGraphs"/>
			</mth>
		<class name="/:sandmark.watermark.ct.encode.Graph2IR$Path" intfc="n" abs="n" inn="y" sloc="15" jdoc="">
			<field name="edges" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR$Path.Path()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR$Path.cons(sandmark.util.newgraph.Edge)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Graph2IR$Path.iterator()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.ct.encode.Encoder" intfc="n" abs="n" inn="n" sloc="128" jdoc="Main class for the encoder. Takes a sandmark.util.newgraph.MutableGraph as input and returns a Java class (&amp;apos;Watermark.java&amp;apos;) that builds this graph as output.">
			<field name="graph" access="priv" jdoc=""/>
			<field name="origGraph" access="priv" jdoc=""/>
			<field name="subGraphs" access="priv" jdoc=""/>
			<field name="componentGraph" access="priv" jdoc=""/>
			<field name="props" access="priv" jdoc=""/>
			<field name="ir" access="priv" jdoc=""/>
			<field name="code" access="priv" jdoc=""/>
			<field name="fieldsRequiringCasts" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.Encoder(sandmark.util.newgraph.MutableGraph, sandmark.util.ConfigProperties, java.util.Hashtable)" access="pub" jdoc="Called like this: &amp;lt;PRE&amp;gt; sandmark.watermark.ct.encode.Encoder encoder = new sandmark.watermark.ct.encode.Encoder(graph,props); encoder.encode(); String javaFile = encoder.getSource(); org.apache.bcel.generic.ClassGen byteCode = encoder.getByteCode(); try { String ClassName = props.getProperty(&amp;quot;DWM_CT_Encode_ClassName&amp;quot;); cg.getJavaClass().dump(ClassName + &amp;quot;.class&amp;quot;); } catch (Exception e) { } &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt; The following properties should be defined: &amp;lt;BR&amp;gt; Node Class - Name of the watermark class. &amp;lt;BR&amp;gt; DWM_CT_Encode_ParentClass - What the watermark class should inherit from. &amp;lt;BR&amp;gt; DWM_CT_Encode_ClassName - Name of the watermark class. &amp;lt;BR&amp;gt; DWM_CT_Encode_AvailableEdges - Colon-separated list of field names that we can use to encode graph edges. &amp;lt;BR&amp;gt; Storage Policy - Which nodes should we store in global variables? &amp;apos;root&amp;apos; (only sub-graph roots) or &amp;apos;all&amp;apos; (all nodes). &amp;lt;BR&amp;gt; Storage Method - Colon-separated list of &amp;apos;{vector,array,pointer,hash}&amp;apos; describing where we may store global sub-graph pointers. &amp;lt;BR&amp;gt; Protection Method - Colon-separated list of &amp;apos;{if,safe,try}&amp;apos; describing what methods we may use to protect against null pointers. &amp;lt;BR&amp;gt; Storage Location - Where should we store sub-graph pointers? This property is either &amp;apos;global&amp;apos; or &amp;apos;formal&amp;apos;. &amp;apos;Global&amp;apos; means that we&amp;apos;re storing pointers in some static global variables, &amp;apos;formal&amp;apos; means that these pointers get passed around from method to method as arguments to these methods. &amp;lt;BR&amp;gt; DWM_CT_Encode_IndividualFixups - &amp;quot;false&amp;quot; &amp;lt;BR&amp;gt; Graph Type - &amp;quot;radix&amp;quot; or &amp;quot;perm&amp;quot; &amp;lt;BR&amp;gt; Subgraph Count - Number of sub-graphs. &amp;lt;BR&amp;gt; Watermark - Value to be encoded &amp;lt;BR&amp;gt; DWM_CT_Encode_Package - Name of package in which the watermark class should be declared.">
				<param name="graph"/>
				<param name="props"/>
				<param name="fieldsRequiringCasts"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.encode()" access="pub" jdoc="Performs the actual encoding, by &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; splitting the graph in Subgraph Count number of components &amp;lt;LI&amp;gt; converting the components to intermediate code &amp;lt;LI&amp;gt; converting the intermediate code to Java bytecode. &amp;lt; OL&amp;gt;">
				<comm cntt="TamperProof.graph(origGraph, props);"/>
				<comm cntt="System.out.println(ir.toString());"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.getSource()" access="pub" jdoc="Return a string which is the source code of a Watermark.java class.">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.getByteCode(sandmark.program.Application)" access="pub" jdoc="Return the bytecode of the Watermark.java class.">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.getGraph()" access="pub" jdoc="Return the watermark graph.">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.getSubGraphs()" access="pub" jdoc="Return the watermark subgraphs.">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.getCreateMethods()" access="pub" jdoc="Return the names of the Create_graphX methods, in the order of which they should be called. We return an array of MethodID objects.">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.getCreateStorageMethods()" access="pub" jdoc="Return the names and types of the CreateStorage_X methods. We&amp;apos;re returning an array of String quadrupes &amp;lt;PRE&amp;gt; (methodName,returnType,localName, GLOBAL LOCAL). &amp;lt; PRE&amp;gt; methodName is the name of the method to call, returnType is the name of the storage type (&amp;quot;java.util.Vector&amp;quot;) it will return, localName is the name of the local variable into which the return value should be stored.">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.split()" access="priv" jdoc="Split the graph into Subgraph Count number of subgraphs. &amp;apos;componentGraph&amp;apos; encodes the dependencies between these subgraphs.">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.dumpIR(String)" access="pub" jdoc="">
				<param name="header"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.graph2IR(java.util.Hashtable)" access="priv" jdoc="Convert the graph to intermediate code. This is done in several steps: &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; generate &amp;apos;stright-forward&amp;apos; intermediate code, &amp;lt;LI&amp;gt; add code to save component root nodes in some global structure, &amp;lt;LI&amp;gt; add formal parameters, if necessary, &amp;lt;LI&amp;gt; add class fields to encode outgoing graph edges, &amp;lt;LI&amp;gt; inline fixup routines (methods that contain code that add edges between graph components), &amp;lt;LI&amp;gt; clean up the code by removing redundancies, &amp;lt;LI&amp;gt; construct &amp;quot;destructors&amp;quot; (methods that destroy the watermark graph), &amp;lt;LI&amp;gt; clean up the code by removing redundancies, &amp;lt;LI&amp;gt; add exception handlers and the like to protect against null pointer exceptions, &amp;lt;LI&amp;gt; add debugging code that prints out a run-time trace, &amp;lt;LI&amp;gt; build testing methods that call the component methods. &amp;lt; OL&amp;gt;">
				<param name="fieldsRequiringCasts"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Encoder.IR2Java()" access="priv" jdoc="Convert the intermediate code to Java.">
				<comm cntt="System.out.println(code);"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.Split" intfc="n" abs="n" inn="n" sloc="215" jdoc="This class is responsible for splitting a sandmark.util.newgraph.MutableGraph into an array of subgraphs. The splitting is done in such a way that each subgraph has a root, a special node from which all other nodes in the graph can be reached. This allows us to store only pointers to root nodes in global storage to prevent the garbage collector from collecting the subgraphs. &amp;lt;P&amp;gt; This class returns two pieces of data: &amp;lt;OL&amp;gt; &amp;lt;LI&amp;gt; an array of subgraphs, and &amp;lt;LI&amp;gt; a component graph. &amp;lt; OL&amp;gt; The component graph has the subgraphs as nodes, and the edges indicates the order in which the different subgraphs should be created. I.e. the componentGraph is a dependency graph whose topological order indicates to us how the subgraphs should be ordered. &amp;lt;P&amp;gt; Call like this: &amp;lt;PRE&amp;gt; sandmark.util.newgraph.MutableGraph graph = ... sandmark.watermark.ct.encode.Split split = new sandmark.watermark.ct.encode.Split(graph,2); split.split(); sandmark.util.newgraph.MutableGraph subGraphs[] = split.subGraphs; sandmark.util.newgraph.MutableGraph componentGraph = split.componentGraph; &amp;lt; PRE&amp;gt;">
			<comm cntt="====================== Weighting ==========================="/>
			<comm cntt="====================== Component ==========================="/>
			<comm cntt="====================== Extract ==========================="/>
			<comm cntt="====================== SubGraphSort ==========================="/>
			<comm cntt="====================== Test ==========================="/>
			<comm cntt="private static void trySplit ("/>
			<comm cntt="sandmark.util.newgraph.MutableGraph g,"/>
			<comm cntt="int components) {"/>
			<comm cntt="System.out.println(&amp;quot;-----------------------------------&amp;quot;);"/>
			<comm cntt="System.out.println(&amp;quot;g1, split into &amp;quot; + components + &amp;quot; component:&amp;quot;);"/>
			<comm cntt="sandmark.watermark.ct.encode.Split split = new sandmark.watermark.ct.encode.Split(g,components);"/>
			<comm cntt="split.split();"/>
			<comm cntt="split.componentGraph.print();"/>
			<comm cntt="for(int i=0; i&amp;lt;components; i++)"/>
			<comm cntt="split.subGraphs[i].print();"/>
			<comm cntt="}"/>
			<comm cntt="public static void main (String[] args) {"/>
			<comm cntt="System.out.println(&amp;quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&amp;quot;);"/>
			<comm cntt="System.out.println(&amp;quot;+++++++++++++++++++++++ Testing Split +++++++++++++++++++++++&amp;quot;);"/>
			<comm cntt="System.out.println(&amp;quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&amp;quot;);"/>
			<comm cntt="sandmark.util.graph.Graph g1 = new sandmark.util.graph.Graph();"/>
			<comm cntt="sandmark.util.graph.Node n1 = g1.addNode();"/>
			<comm cntt="sandmark.util.graph.Node n2 = g1.addNode();"/>
			<comm cntt="sandmark.util.graph.Node n3 = g1.addNode();"/>
			<comm cntt="sandmark.util.graph.Node n4 = g1.addNode();"/>
			<comm cntt="g1.setEdge(n4,n3,1);"/>
			<comm cntt="g1.setEdge(n4,n2,2);"/>
			<comm cntt="g1.setEdge(n3,n1,1);"/>
			<comm cntt="g1.setEdge(n3,n3,2);"/>
			<comm cntt="g1.setEdge(n2,n4,1);"/>
			<comm cntt="g1.setEdge(n2,n1,2);"/>
			<comm cntt="g1.setHeader(&amp;quot;g1, with 4 nodes and 6 edges.&amp;quot;);"/>
			<comm cntt="g1.process();"/>
			<comm cntt="g1.print();"/>
			<comm cntt="trySplit(g1,1);"/>
			<comm cntt="trySplit(g1,2);"/>
			<comm cntt="trySplit(g1,3);"/>
			<comm cntt="trySplit(g1,4);"/>
			<comm cntt="g1.setHeader(&amp;quot;g1, after splitting.&amp;quot;);"/>
			<comm cntt="g1.print();"/>
			<comm cntt="System.out.println(&amp;quot;-----------------------------------&amp;quot;);"/>
			<comm cntt="}"/>
			<field name="subGraphs" access="pub" jdoc=""/>
			<field name="componentGraph" access="pub" jdoc=""/>
			<field name="components" access="pub" jdoc=""/>
			<field name="graph" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.Split.Split(sandmark.util.newgraph.MutableGraph, int)" access="pub" jdoc="Create a new Split object. @param graph the graph to be split @param components the number of components to break the graph into.">
				<param name="graph"/>
				<param name="components"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.split()" access="pub" jdoc="Perform the split. Results are returned in the two public fields subGraphs and componentGraph.">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.setRoot()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.KunduMisra()" access="priv" jdoc="This method implements the Kundu-Misra graph splitting algorithm.">
				<comm cntt="graph.process();"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.labelNodes(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Graph, java.lang.Object, java.util.Hashtable)" access="priv" jdoc="Label the tree subgraph of &amp;apos;graph&amp;apos; such that the weight of leaves is =1 and the weight of an internal node is the sum of the children&amp;apos;s weight.">
				<param name="graph"/>
				<param name="dftree"/>
				<param name="node"/>
				<param name="weights"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.weighGraph(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Graph)" access="priv" jdoc="">
				<param name="graph"/>
				<param name="dftree"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.printWeights(java.util.Hashtable)" access="priv" jdoc="">
				<param name="weights"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.findComponentRoot(sandmark.util.newgraph.MutableGraph, java.util.Hashtable, int)" access="priv" jdoc="Find the root of the component whose weight is closest to &amp;apos;componentSize&amp;apos;">
				<param name="graph"/>
				<param name="weights"/>
				<param name="componentSize"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.findComponent(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Graph, java.lang.Object)" access="priv" jdoc="Return the list of nodes reachable through tree edges from &amp;apos;node&amp;apos;.">
				<param name="graph"/>
				<param name="dftree"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.extractComponent(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Graph, java.lang.Object)" access="priv" jdoc="Return the subgraph of &amp;apos;graph&amp;apos; whose node-set contains the nodes reachable through tree edges from &amp;apos;componentRoot&amp;apos;">
				<comm cntt="subGraph.process();"/>
				<param name="graph"/>
				<param name="dftree"/>
				<param name="componentRoot"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.buildComponentGraph(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[])" access="priv" jdoc="Build the dependency-graph component-graph for the subgraphs. The data element in each node of the dependency graph is the subgraph itself. &amp;apos;node2component&amp;apos; is a hash table that maps each node of every subgraph into the corresponding node of the dependency-graph. This is built in the Phase 1. In Phase 2 we look at each node of &amp;apos;graph&amp;apos; and its outgoing edges. If there&amp;apos;s an edge from-&amp;gt;to in &amp;apos;graph&amp;apos; and &amp;apos;from&amp;apos; is in component &amp;apos;C1&amp;apos; and &amp;apos;to&amp;apos; is in component &amp;apos;C2&amp;apos;, then we add an edge C1-&amp;gt;C2 to the component-graph if a) the edge is not present already, and b) C1 != C2.">
				<comm cntt="Phase 1."/>
				<comm cntt="Phase 2."/>
				<comm cntt="g.process();"/>
				<param name="graph"/>
				<param name="subGraphs"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.rootSubGraph(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[])" access="priv" jdoc="Return the subgraph that contains the global root node.">
				<param name="graph"/>
				<param name="subGraphs"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split.sortSubGraphs(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[], sandmark.util.newgraph.MutableGraph)" access="priv" jdoc="Toplogically sort &amp;apos;componentGraph&amp;apos;, returning a list of the subgraphs of &amp;apos;graph&amp;apos;, in the order in which they will eventually be created. Treat the &amp;apos;root subgraph&amp;apos; (the subgraph that contains the root node of &amp;apos;graph&amp;apos;) specially: it should always be created last. This is a bit of a hack. It would be cleaner to fix the &amp;apos;componentGraph&amp;apos; to indicate that the root graph is always the last one to be created, but this seems easier to implement.">
				<param name="graph"/>
				<param name="subGraphs"/>
				<param name="componentGraph"/>
			</mth>
		<class name="/:sandmark.watermark.ct.encode.Split$SplitException" intfc="n" abs="n" inn="y" sloc="4" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.Split$SplitException.SplitException()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.Split$SplitException.SplitException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.ct.encode.ir">
		<class name="/:sandmark.watermark.ct.encode.ir.Destroy" intfc="n" abs="n" inn="n" sloc="38" jdoc="">
			<field name="subGraph" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.Destroy.Destroy(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="ops"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Destroy.Destroy(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="ops"/>
				<param name="formals"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Destroy.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Destroy.name()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Destroy.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Build" intfc="n" abs="n" inn="n" sloc="159" jdoc="">
			<comm cntt="====================== Methods ==========================="/>
			<comm cntt="====================== Fields ==========================="/>
			<comm cntt="======================================================================"/>
			<comm cntt="====================== Build ==========================="/>
			<comm cntt="======================================================================"/>
			<field name="subGraphs" access="pub" jdoc=""/>
			<field name="componentGraph" access="pub" jdoc=""/>
			<field name="init" access="pub" jdoc=""/>
			<field name="creators" access="pub" jdoc=""/>
			<field name="fixups" access="pub" jdoc=""/>
			<field name="destructors" access="pub" jdoc=""/>
			<field name="construct" access="pub" jdoc=""/>
			<field name="destruct" access="pub" jdoc=""/>
			<field name="staticFields" access="pub" jdoc=""/>
			<field name="storageCreators" access="pub" jdoc=""/>
			<field name="storageBuilder" access="pub" jdoc=""/>
			<field name="storage" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.Build(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[], sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.storage.GlobalStorage)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraphs"/>
				<param name="componentGraph"/>
				<param name="init"/>
				<param name="creators"/>
				<param name="fixups"/>
				<param name="destructors"/>
				<param name="storage"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.methodsToJava(sandmark.util.ConfigProperties, sandmark.watermark.ct.encode.ir.List, sandmark.util.javagen.List)" access="pub" jdoc="">
				<param name="props"/>
				<param name="proc"/>
				<param name="res"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.genMethods(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="These are not needed anymore."/>
				<comm cntt="methods.cons(construct.toJava(props));"/>
				<comm cntt="methods.cons(destruct.toJava(props));"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.genNodeFields(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="Horrible hack, assuming that field names with"/>
				<comm cntt="&amp;apos;$&amp;apos;s in them are the ones that need to be declared."/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.genStaticFields(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.genFields(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.genHeader(sandmark.util.newgraph.MutableGraph, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="H += &amp;quot;\n&amp;quot; + sandmark.util.newgraph.Graphs.toDot(origGraph) + &amp;quot;\n\n&amp;quot;;"/>
				<comm cntt="if (origGraph != graph)"/>
				<comm cntt="H += sandmark.util.newgraph.Graphs.toDot(graph) + &amp;quot;\n\n&amp;quot; ;"/>
				<comm cntt="H += sandmark.util.newgraph.Graphs.toDot(componentGraph) + &amp;quot;\n\n&amp;quot; ;"/>
				<param name="origGraph"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.genRootMethod(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Build.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="Should be origGraph."/>
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Construct" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir.Construct.Construct(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="ops"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Construct.Construct(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="ops"/>
				<param name="formals"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Construct.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Construct.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Construct.name()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Fixup" intfc="n" abs="n" inn="n" sloc="43" jdoc="">
			<field name="subGraph1" access="pub" jdoc=""/>
			<field name="subGraph2" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.Fixup.Fixup(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph1"/>
				<param name="subGraph2"/>
				<param name="ops"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Fixup.Fixup(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph1"/>
				<param name="subGraph2"/>
				<param name="ops"/>
				<param name="formals"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Fixup.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Fixup.name()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Fixup.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.PrintGraph" intfc="n" abs="n" inn="n" sloc="15" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir.PrintGraph.PrintGraph(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.PrintGraph.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.PrintGraph.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.PrintGraph.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="String S = graph.toString(&amp;quot; &amp;quot;);"/>
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Destruct" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir.Destruct.Destruct(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="ops"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Destruct.Destruct(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="ops"/>
				<param name="formals"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Destruct.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Destruct.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Destruct.name()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Method" intfc="n" abs="y" inn="n" sloc="45" jdoc="">
			<comm cntt="public String signature() { String[] argv = new String[formals.size()]; int i = 0; java.util.Iterator fiter = formals.iterator(); while (fiter.hasNext()) { sandmark.watermark.ct.encode.ir.Formal f = (sandmark.watermark.ct.encode.ir.Formal) fiter.next(); argv[i++] = org.apache.bcel.classfile.Utility.getSignature(f.type); } String sig = &amp;quot;&amp;quot;; try { sig = org.apache.bcel.classfile.Utility.methodTypeToSignature(returnType, argv); } catch (Exception e) { sandmark.util.Log.message( sandmark.util.Log.INTERNAL_EXCEPTION, &amp;quot;Exception caught and ignored:&amp;quot; + e ); } return sig; }"/>
			<field name="ops" access="pub" jdoc=""/>
			<field name="formals" access="pub" jdoc=""/>
			<field name="returnType" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.Method.Method()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Method.name()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Method.setFormals(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="formals"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Method.getFormals()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Method.signature()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Method.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.SaveNode" intfc="n" abs="n" inn="n" sloc="24" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir.SaveNode.SaveNode(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node, sandmark.watermark.ct.encode.storage.NodeStorage)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="node"/>
				<param name="location"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.SaveNode.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.SaveNode.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.SaveNode.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.LoadNode" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir.LoadNode.LoadNode(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node, sandmark.watermark.ct.encode.storage.NodeStorage)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="node"/>
				<param name="location"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.LoadNode.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.LoadNode.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.LoadNode.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Create" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<field name="subGraph" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.Create.Create(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="ops"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Create.Create(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="ops"/>
				<param name="formals"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Create.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Create.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Create.name()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.AddEdge" intfc="n" abs="n" inn="n" sloc="54" jdoc="">
			<field name="subGraph1" access="pub" jdoc=""/>
			<field name="subGraph2" access="pub" jdoc=""/>
			<field name="edge" access="pub" jdoc=""/>
			<field name="protection" access="pub" jdoc=""/>
			<field name="mFieldType" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.AddEdge.AddEdge(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.LabeledEdge, String)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph1"/>
				<param name="subGraph2"/>
				<param name="edge"/>
				<param name="protection"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.AddEdge.setFieldType(String)" access="pub" jdoc="">
				<param name="fieldType"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.AddEdge.getFieldName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.AddEdge.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.AddEdge.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.AddEdge.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.IR" intfc="n" abs="n" inn="n" sloc="42" jdoc="Base-class for intermediate code statements. Each class has a &amp;apos;toJava&amp;apos; method that converts the IR statement to a sandmark.util.javagen. object.">
			<field name="graph" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.IR.renderListSeparate(sandmark.watermark.ct.encode.ir.List, String, String)" access="prot" jdoc="">
				<param name="L"/>
				<param name="separator"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.IR.renderOps(sandmark.watermark.ct.encode.ir.List, String)" access="pub" jdoc="">
				<param name="L"/>
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.IR.copy()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.IR.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.IR.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.IR.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Field" intfc="n" abs="n" inn="n" sloc="35" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="Static" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.Field.Field(String, String, boolean)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
				<param name="Static"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Field.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Field.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Field.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Field.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.FollowLink" intfc="n" abs="n" inn="n" sloc="74" jdoc="">
			<field name="subGraph" access="pub" jdoc=""/>
			<field name="node" access="pub" jdoc=""/>
			<field name="edge" access="pub" jdoc=""/>
			<field name="protection" access="pub" jdoc=""/>
			<field name="mCastTo" access="pub" jdoc=""/>
			<field name="mFieldType" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.FollowLink.FollowLink(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node, sandmark.util.newgraph.LabeledEdge, String)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="node"/>
				<param name="edge"/>
				<param name="protection"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.FollowLink.castTo(String)" access="pub" jdoc="">
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.FollowLink.setFieldType(String)" access="pub" jdoc="">
				<param name="fieldType"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.FollowLink.getFieldName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.FollowLink.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.FollowLink.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.FollowLink.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Formal" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.Formal.Formal(String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Formal.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Formal.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Formal.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Formal.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.NodeStorage" intfc="n" abs="n" inn="n" sloc="14" jdoc="">
			<field name="subGraph" access="pub" jdoc=""/>
			<field name="node" access="pub" jdoc=""/>
			<field name="location" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.NodeStorage.NodeStorage(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node, sandmark.watermark.ct.encode.storage.NodeStorage)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="node"/>
				<param name="location"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.ProtectRegion" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="ops" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.ProtectRegion.ProtectRegion(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="ops"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.ProtectRegion.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.ProtectRegion.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.ProtectRegion.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="stat.setComment(toString());"/>
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Init" intfc="n" abs="n" inn="n" sloc="32" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir.Init.Init(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="ops"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Init.Init(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.ir.List, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="ops"/>
				<param name="formals"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Init.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Init.name()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Init.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.CreateNode" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<field name="subGraph" access="pub" jdoc=""/>
			<field name="node" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateNode.CreateNode(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraph"/>
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateNode.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateNode.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateNode.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.Debug" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<field name="msg" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.Debug.Debug(sandmark.util.newgraph.MutableGraph, String)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="msg"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Debug.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Debug.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.Debug.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.StaticCall" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<field name="Class" access="pub" jdoc=""/>
			<field name="name" access="pub" jdoc=""/>
			<field name="type" access="pub" jdoc=""/>
			<field name="args" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.StaticCall.StaticCall(String, String, String, sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="Class"/>
				<param name="name"/>
				<param name="type"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.StaticCall.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.StaticCall.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="java.util.Iterator iter = args.iterator();"/>
				<comm cntt="while (iter.hasNext()) {"/>
				<comm cntt="sandmark.util.javagen.Expression s = (sandmark.util.javagen.Expression) iter.next();"/>
				<comm cntt="};"/>
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.FieldAccessor" intfc="y" abs="n" inn="n" sloc="4" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir.FieldAccessor.setFieldType(String)" access="pub" jdoc="">
				<param name="fieldType"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.FieldAccessor.getFieldName()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.CreateStorage" intfc="n" abs="n" inn="n" sloc="57" jdoc="">
			<field name="storageClass" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateStorage.CreateStorage(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.encode.storage.StorageClass, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="storageClass"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateStorage.name()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateStorage.type()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateStorage.varName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateStorage.isGlobal()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateStorage.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateStorage.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.CreateStorage.toJava(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir.List" intfc="n" abs="n" inn="n" sloc="106" jdoc="">
			<field name="list" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.List()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.List(sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.List(sandmark.watermark.ct.encode.ir.IR, sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.List(sandmark.watermark.ct.encode.ir.IR, sandmark.watermark.ct.encode.ir.IR, sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
				<param name="r3"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.List(sandmark.watermark.ct.encode.ir.IR, sandmark.watermark.ct.encode.ir.IR, sandmark.watermark.ct.encode.ir.IR, sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
				<param name="r3"/>
				<param name="r4"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.cons(sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="r1"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.snoc(sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="r1"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.cons(sandmark.watermark.ct.encode.ir.IR, sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.cons(sandmark.watermark.ct.encode.ir.IR, sandmark.watermark.ct.encode.ir.IR, sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="r1"/>
				<param name="r2"/>
				<param name="r3"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.cons(List)" access="pub" jdoc="">
				<param name="l1"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.cons(List, List)" access="pub" jdoc="">
				<param name="l1"/>
				<param name="l2"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.cons(List, List, List)" access="pub" jdoc="">
				<param name="l1"/>
				<param name="l2"/>
				<param name="l3"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.size()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.iterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.backwards()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List.toString()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.watermark.ct.encode.ir.List$Backwards" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<field name="iter" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir.List$Backwards.Backwards()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List$Backwards.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List$Backwards.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir.List$Backwards.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.ct.encode.ir2ir">
		<class name="/:sandmark.watermark.ct.encode.ir2ir.Destructors" intfc="n" abs="n" inn="n" sloc="71" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Destructors.Destructors(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="p"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Destructors.mutate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Destructors.rndElmt(java.util.LinkedList)" access="pub" jdoc="">
				<param name="L"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Destructors.destroy(sandmark.watermark.ct.encode.ir.Destroy)" access="pub" jdoc="">
				<comm cntt="int edgeClass = a.edge.edgeClass();"/>
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Destructors.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp" intfc="n" abs="n" inn="n" sloc="100" jdoc="">
			<comm cntt="================= Remove redundant loads ====================="/>
			<field name="storage" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp.CleanUp(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="p"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp.getNode(sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp.getEdge(sandmark.watermark.ct.encode.ir.IR)" access="pub" jdoc="">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp.removeUnused(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp.removeMultipleA(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp.removeMultipleB(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp.removeMultiple(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp.clean(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="M"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.CleanUp.mutate()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.AddCasts" intfc="n" abs="n" inn="n" sloc="56" jdoc="">
			<field name="needCasts" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddCasts.AddCasts(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties, java.util.Hashtable)" access="pub" jdoc="">
				<param name="orig"/>
				<param name="props"/>
				<param name="needCasts"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddCasts.mutate()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.Protect" intfc="n" abs="n" inn="n" sloc="108" jdoc="">
			<field name="protectionMethods" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Protect.Protect(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="p"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Protect.protectionKinds(String)" access="pub" jdoc="">
				<param name="protectionMethods"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Protect.pickRandomProtection()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Protect.findUnsafe(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Protect.protectRegion(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Protect.addProtection(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Protect.mutate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Protect.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.Builder" intfc="n" abs="n" inn="n" sloc="38" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Builder.Builder(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="p"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Builder.mutate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Builder.genBuildCalls(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="methods"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Builder.genConstructMethod()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Builder.genDestructMethod()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.AddFields" intfc="n" abs="n" inn="n" sloc="75" jdoc="">
			<comm cntt="For every generated method add the appropriate &amp;quot;Formal&amp;quot;-instructions."/>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddFields.AddFields(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="p"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddFields.addStaticFields()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddFields.addStorageCreators()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddFields.mutate()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.Transformer" intfc="n" abs="y" inn="n" sloc="11" jdoc="sandmark.watermark.ct.encode.ir2ir.Transformer is the base-class for various classes that transform intermediate code, i.e. sandmark.watermark.ct.encode.ir.">
			<field name="orig" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Transformer.Transformer(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="orig"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Transformer.mutate()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.AddFormals" intfc="n" abs="n" inn="n" sloc="65" jdoc="">
			<comm cntt="Run through the list of intermediate code instructions, looking for &amp;quot;SaveNode&amp;quot;- and &amp;quot;LoadNode&amp;quot;-instructions. Return the appropriate list of &amp;quot;Formal&amp;quot;-instructions."/>
			<comm cntt="For every generated method add the appropriate &amp;quot;Formal&amp;quot;-instructions."/>
			<field name="storageCreators" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddFormals.AddFormals(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties, String[][])" access="pub" jdoc="">
				<param name="p"/>
				<param name="props"/>
				<param name="storageCreators"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddFormals.findFormals(sandmark.watermark.ct.encode.ir.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;AddFormals.addFormals:0:formal=&amp;apos;&amp;quot; +f+&amp;quot;&amp;apos;&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;AddFormals.addFormals:1:formal=&amp;apos;&amp;quot; +formal+&amp;quot;&amp;apos;&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;AddFormals.addFormals:2:seen=&amp;apos;&amp;quot; +seen+&amp;quot;&amp;apos;&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;AddFormals.addFormals:3:P=&amp;apos;&amp;quot; +P+&amp;quot;&amp;apos;&amp;quot;);"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddFormals.findFormals(sandmark.watermark.ct.encode.ir.Method, String[][])" access="pub" jdoc="This method returns the list of formal parameters to add to the CreateGraph methods. It is less precise than the previous one in that every method gets the complete set of formals (one per generated storage creator), rather than the minimal set of formals that it actually needs. @param method the CreateGraph Fixup method. @param storageCreators[][] an array of quadruples: {methodName, returnType, localName, GLOBAL FORMAL} for example: {&amp;quot;CreateStorage_sm$hash&amp;quot;, &amp;quot;java.util.Hashtable&amp;quot;, &amp;quot;sm$hash&amp;quot;, &amp;quot;FORMAL&amp;quot;}">
				<param name="method"/>
				<param name="storageCreators"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.AddFormals.mutate()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.SaveNodes" intfc="n" abs="n" inn="n" sloc="98" jdoc="">
			<comm cntt="Run through the list of intermediate code instructions, looking for &amp;quot;CreateNode&amp;quot;-instructions. If this node needs to be stored in global storage, add a &amp;quot;SaveNode&amp;quot;-instruction."/>
			<comm cntt="If we haven&amp;apos;t already loaded &amp;apos;node&amp;apos; from global storage (and this node is, in fact, stored in a global) add a &amp;apos;LoadNode&amp;apos;-instruction to do so. &amp;apos;seen&amp;apos; is updated to indicate that this node has now been loaded."/>
			<comm cntt="Run through the list of intermediate code instructions, looking for &amp;quot;AddEdge&amp;quot;- or &amp;quot;FollowLink&amp;quot;-instructions. These instructions both need access to a node pointer. For each such pointer add a &amp;quot;LoadNode&amp;quot;-instruction so that the node is loaded from global storage."/>
			<comm cntt="For every generated method add StoreNode and LoadNode instructions that make sure that the nodes that need to be loaded or saved to global storage in fact are."/>
			<comm cntt="--------------------------------------------------------------"/>
			<field name="storage" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.SaveNodes.SaveNodes(sandmark.watermark.ct.encode.ir.Build, sandmark.watermark.ct.encode.storage.GlobalStorage, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="p"/>
				<param name="storage"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.SaveNodes.storeNode(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="ops"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.SaveNodes.load(sandmark.watermark.ct.encode.ir.IR, sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node, java.util.HashSet)" access="pub" jdoc="">
				<param name="f"/>
				<param name="subGraph"/>
				<param name="node"/>
				<param name="seen"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.SaveNodes.loadUsed(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="ops"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.SaveNodes.mutate()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.SaveNodes.printStorage(sandmark.watermark.ct.encode.storage.GlobalStorage, String, sandmark.util.newgraph.Node)" access="pub" jdoc="">
				<param name="storage"/>
				<param name="nodeName"/>
				<param name="node"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.Debug" intfc="n" abs="n" inn="n" sloc="21" jdoc="">
			<comm cntt="Run through every generated method adding a &amp;apos;Debug&amp;apos; instruction. This instruction will print out a message when the method is executed."/>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Debug.Debug(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="p"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Debug.debug(sandmark.watermark.ct.encode.ir.List)" access="pub" jdoc="">
				<param name="M"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.Debug.mutate()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.ir2ir.InlineFixups" intfc="n" abs="n" inn="n" sloc="44" jdoc="">
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.InlineFixups.InlineFixups(sandmark.watermark.ct.encode.ir.Build, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="p"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.InlineFixups.subGraphIndex(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[])" access="pub" jdoc="">
				<param name="subGraph"/>
				<param name="subGraphs"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.InlineFixups.inline(sandmark.watermark.ct.encode.ir.Fixup, sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="">
				<param name="fixup"/>
				<param name="subGraph"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.ir2ir.InlineFixups.mutate()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.ct.encode.storage">
		<class name="/:sandmark.watermark.ct.encode.storage.Hash" intfc="n" abs="n" inn="n" sloc="83" jdoc="">
			<const name="hashName" access="pub" jdoc=""/>
			<const name="storageType" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.Hash(int)" access="pub" jdoc="">
				<param name="storeLocation"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.typeName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.variableName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.getContainer(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.toJavaStore(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.toJavaLoad(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.toJavaCreate(sandmark.util.newgraph.MutableGraph, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Hash.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.storage.StorageClass" intfc="n" abs="y" inn="n" sloc="37" jdoc="sandmark.watermark.ct.encode.storage.Array, sandmark.watermark.ct.encode.storage.Hash, sandmark.watermark.ct.encode.storage.Pointer, sandmark.watermark.ct.encode.storage.Vector are classes that deal with how we keep track of graph nodes in the watermarked program. In order to make sure that the garbage collector does not do away with the subgraphs we&amp;apos;ve built, we must store (at least) the root pointer of each subgraph in some kind of global storage. There are four possibilities right now: we can store in a global Array, HashTable, individual Pointers, or in a java Vector. &amp;lt;P&amp;gt; sandmark.watermark.ct.encode.storage.Storage is the base-class for these storage methods. &amp;lt;P&amp;gt; sandmark.watermark.ct.encode.storage.GlobalStorage decides which nodes should be stored where.">
			<field name="storeLocation" access="pub" jdoc=""/>
			<const name="GLOBAL" access="pub" jdoc=""/>
			<const name="FORMAL" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.StorageClass()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.getStoreLocation()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.locationToString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.toJavaStore(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.toJavaLoad(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.typeName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.variableName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.toJavaCreate(sandmark.util.newgraph.MutableGraph, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.StorageClass.toJavaFormal(sandmark.util.newgraph.MutableGraph, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.storage.Array" intfc="n" abs="n" inn="n" sloc="67" jdoc="">
			<const name="arrayName" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.Array(int)" access="pub" jdoc="">
				<param name="storeLocation"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.typeName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.variableName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.getContainer(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.toJavaStore(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.toJavaLoad(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.toJavaCreate(sandmark.util.newgraph.MutableGraph, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Array.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.storage.GlobalStorage" intfc="n" abs="n" inn="n" sloc="101" jdoc="This class decides which nodes should be stored in what type of storage.">
			<comm cntt="==================== Save some nodes in globals ======================="/>
			<comm cntt="globalStoreKinds is a list of &amp;apos;arr&amp;apos;, &amp;apos;ptr&amp;apos;, &amp;apos;vec&amp;apos;, &amp;apos;hash&amp;apos;. storeWhat is &amp;apos;all&amp;apos;, &amp;apos;root&amp;apos;, or &amp;apos;none&amp;apos;. storeLocation is &amp;apos;global&amp;apos;, or &amp;apos;formal&amp;apos;."/>
			<comm cntt="--------------------------------------------------------------"/>
			<comm cntt="--------------------------------------------------------------"/>
			<field name="store" access="pub" jdoc=""/>
			<field name="storageClasses" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.storage.GlobalStorage.GlobalStorage(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[], sandmark.util.ConfigProperties)" access="pub" jdoc="Call it like this: &amp;lt;PRE&amp;gt; sandmark.watermark.ct.encode.storage.GlobalStorage storage = new sandmark.watermark.ct.encode.storage.GlobalStorage (graph,subGraphs,props); &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt; The following properties should be defined: &amp;lt;BR&amp;gt; Storage Policy: Which nodes should we store in global variables? &amp;apos;root&amp;apos; (only sub-graph roots) or &amp;apos;all&amp;apos; (all nodes). &amp;lt;BR&amp;gt; Storage Method: In what type of structure should we store nodes? This property is a colon-separated list of &amp;apos;{vector,array,pointer,hash}&amp;apos; describing where we may store global sub-graph pointers. &amp;lt;BR&amp;gt; Storage Location: Where should we store sub-graph pointers? This property is either &amp;apos;global&amp;apos; or &amp;apos;formal&amp;apos;. &amp;apos;Global&amp;apos; means that we&amp;apos;re storing pointers in some static global variables, &amp;apos;formal&amp;apos; means that these pointers get passed around from method to method as arguments to these methods.">
				<param name="graph"/>
				<param name="subGraphs"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.GlobalStorage.lookup(sandmark.util.newgraph.Node)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.GlobalStorage.getStorageClasses()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.GlobalStorage.storageKinds(String)" access="pub" jdoc="">
				<param name="globalStoreKinds"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.GlobalStorage.pickRandomStorage(String[], sandmark.util.newgraph.Node, int)" access="pub" jdoc="">
				<param name="kinds"/>
				<param name="node"/>
				<param name="location"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.GlobalStorage.selectStorage(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.MutableGraph[], String, String, String)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="subGraphs"/>
				<param name="storeWhat"/>
				<param name="globalStoreKinds"/>
				<param name="storeLocation"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.GlobalStorage.toString(String)" access="pub" jdoc="">
				<param name="indent"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.GlobalStorage.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.GlobalStorage.printStorage(sandmark.watermark.ct.encode.storage.GlobalStorage, String, sandmark.util.newgraph.Node)" access="pub" jdoc="">
				<param name="storage"/>
				<param name="nodeName"/>
				<param name="node"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.storage.NodeStorage" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<field name="node" access="pub" jdoc=""/>
			<field name="storage" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.storage.NodeStorage.NodeStorage(sandmark.util.newgraph.Node, sandmark.watermark.ct.encode.storage.StorageClass)" access="pub" jdoc="">
				<param name="node"/>
				<param name="storage"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.NodeStorage.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.NodeStorage.getStorageClass()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.NodeStorage.toJavaStore(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.NodeStorage.toJavaLoad(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.storage.Pointer" intfc="n" abs="n" inn="n" sloc="72" jdoc="">
			<comm cntt="Doesn&amp;apos;t work since Java doesn&amp;apos;t have reference parameters."/>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.Pointer(int)" access="pub" jdoc="">
				<param name="storeLocation"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.globalName(sandmark.util.newgraph.Node)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.typeName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.variableName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.toJavaStore(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<comm cntt="&amp;quot;n&amp;quot; + nodeNumber"/>
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.toJavaLoad(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.toJavaCreate(sandmark.util.newgraph.MutableGraph, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.toJavaField(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Pointer.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.encode.storage.Vector" intfc="n" abs="n" inn="n" sloc="101" jdoc="">
			<const name="vectorName" access="pub" jdoc=""/>
			<const name="storageType" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.Vector(int)" access="pub" jdoc="">
				<param name="storeLocation"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.typeName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.variableName(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.getContainer(sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.toJavaStore(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.toJavaLoad(sandmark.util.newgraph.Node, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="node"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.toJavaCreate(sandmark.util.newgraph.MutableGraph, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.toJavaInit(sandmark.util.newgraph.MutableGraph, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.encode.storage.Vector.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.ct.recognize">
		<class name="/:sandmark.watermark.ct.recognize.Recognizer" intfc="n" abs="n" inn="n" sloc="25" jdoc="The sandmark.watermark.ct.recognize.Recognizer class contains methods for recognizing dynamically built watermarks in a running program.">
			<comm cntt="----------------------------------------------------------"/>
			<comm cntt="Returns a sequence of &amp;apos;sandmark.watermark.ct.recognize.RecognizeData&amp;apos; objects. These represent the watermarks that were extracted from the heap."/>
			<comm cntt="-------------------------------------------------------"/>
			<comm cntt="Returns a sequence of &amp;apos;DecodedGraph&amp;apos; objects describing graphs that were extracted and decoded from the heap. The graphs are generated in the reverse order of root-node allocation, i.e. the graph whose root node is youngest is generated first."/>
			<field name="buffer" access="pub" jdoc=""/>
			<const name="BUFFER_SIZE" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="myWatermarks" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer.Recognizer(sandmark.watermark.DynamicRecognizeParameters, sandmark.util.ConfigProperties)" access="pub" jdoc="Runs a program and looks for watermarks. @param props global property list &amp;lt;P&amp;gt; Reads properties: &amp;lt;BR&amp;gt; Input File: the watermarked program &amp;lt;BR&amp;gt; Class Path: path to search for class-files &amp;lt;BR&amp;gt; Main Class: main class, if not set in Jar file &amp;lt;BR&amp;gt; Arguments: program arguments, if any &amp;lt;P&amp;gt; Call it like this: &amp;lt;PRE&amp;gt; sandmark.watermark.ct.recognize.Recognizer recognizer = new sandmark.watermark.ct.recognize.Recognizer(props); recognizer.run(); java.util.Iterator iter = recognizer.iterator(); while (iter.hasNext()) { sandmark.watermark.ct.recognize.RecognizeData res = (sandmark.watermark.ct.recognize.RecognizeData) iter.next(); System.out.println(res.toString()); } recognizer.waitToComplete(); &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt; The RecognizeData-object that the recognizer returns contains information about which graph was found, what watermark was extracted from this graph, and which encoding was used.">
				<param name="params"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer.onProgramExit(com.sun.jdi.VirtualMachine)" access="prot" jdoc="">
				<param name="vm"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer.onDisconnect()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer.watermarks()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.watermark.ct.recognize.Recognizer$InitBreakpoint" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$InitBreakpoint.InitBreakpoint()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$InitBreakpoint.Action(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.recognize.Recognizer$Watermarks" intfc="n" abs="n" inn="y" sloc="101" jdoc="">
			<field name="mProps" access="pub" jdoc=""/>
			<field name="nextObject" access="pub" jdoc=""/>
			<field name="graphs" access="pub" jdoc=""/>
			<field name="codecIt" access="pub" jdoc=""/>
			<field name="combinations" access="pub" jdoc=""/>
			<field name="codecs" access="pub" jdoc=""/>
			<field name="currentGraph" access="pub" jdoc=""/>
			<field name="currentCodec" access="pub" jdoc=""/>
			<field name="currentCombination" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Watermarks.Watermarks(sandmark.util.CircularBuffer, com.sun.jdi.VirtualMachine, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="buffer"/>
				<param name="vm"/>
				<param name="cp"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Watermarks.getNextTriple()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Watermarks.get()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Watermarks.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Watermarks.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Watermarks.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Watermarks.getCodecs()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Watermarks.decode(Long, sandmark.util.newgraph.Graph, sandmark.util.newgraph.codec.GraphCodec, sandmark.util.ConfigProperties)" access="priv" jdoc="Attempts to decode the graph theGraph into a watermark using the graph decoder &amp;apos;decoder&amp;apos;, and mapping kidnames according to &amp;apos;kidmap&amp;apos;. If decoding doesn&amp;apos;t work (for whatever reason), an exception is thrown.">
				<param name="root"/>
				<param name="g"/>
				<param name="gc"/>
				<param name="cp"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.recognize.Recognizer$DecodedGraph" intfc="n" abs="n" inn="y" sloc="9" jdoc="">
			<field name="graph" access="priv" jdoc=""/>
			<field name="root" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$DecodedGraph.DecodedGraph(sandmark.util.newgraph.Graph, Long)" access="pub" jdoc="">
				<param name="graph"/>
				<param name="root"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.recognize.Recognizer$Graphs" intfc="n" abs="n" inn="y" sloc="47" jdoc="">
			<field name="nextObject" access="pub" jdoc=""/>
			<field name="seen" access="pub" jdoc=""/>
			<field name="rootIt" access="pub" jdoc=""/>
			<field name="graph" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Graphs.Graphs(sandmark.util.CircularBuffer, com.sun.jdi.VirtualMachine)" access="pub" jdoc="">
				<param name="buffer"/>
				<param name="vm"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Graphs.get()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Graphs.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Graphs.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Recognizer$Graphs.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.ct.recognize.RecognizeData" intfc="n" abs="n" inn="n" sloc="49" jdoc="">
			<comm cntt="public int kidMap[];"/>
			<field name="codec" access="priv" jdoc="The encoding (radix, permutation-graph,...) that the watermark was encoded with."/>
			<field name="graph" access="priv" jdoc="The graph that was found on the heap."/>
			<field name="wm" access="priv" jdoc="The decoded watermark."/>
			<field name="wm_String" access="priv" jdoc="The watermark, decoded as a string."/>
			<field name="root" access="priv" jdoc="The &amp;apos;pointer&amp;apos; (uniqueID) of the root in the heap graph."/>
			<field name="graphCounter" access="priv" jdoc=""/>
			<field name="graphNum" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.recognize.RecognizeData.RecognizeData(sandmark.util.newgraph.codec.GraphCodec, sandmark.util.newgraph.Graph, java.math.BigInteger, String, Long)" access="pub" jdoc="RecognizeData-objects are returned by the Recognizer. They contain information about the watermarks that have been found. Fields are public and should be treated as read-only.">
				<param name="codec"/>
				<param name="graph"/>
				<param name="wm"/>
				<param name="wm_String"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.RecognizeData.formatSet(int[])" access="priv" jdoc="">
				<param name="set"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.RecognizeData.toString()" access="pub" jdoc="Format a RecognizeData-object.">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.RecognizeData.saveGraph()" access="pub" jdoc="Write the dot file for the watermark class.">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.RecognizeData.toShortString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.RecognizeData.addToGraphViewer()" access="pub" jdoc="Add all graphs to the graph viewer.">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.recognize.Heap2Graph" intfc="n" abs="n" inn="n" sloc="32" jdoc="Walks the object graph starting at a particular root node and builds the corresponding sandmark.util.newgraph.Graph.">
			<mth name="/:sandmark.watermark.ct.recognize.Heap2Graph.unpack(com.sun.jdi.VirtualMachine)" access="pub" jdoc="Walks the object graph starting at the root node. Construct and return the corresponding sandmark.util.newgraph.Graph.">
				<param name="vm"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Heap2Graph.unpack(com.sun.jdi.VirtualMachine, com.sun.jdi.ObjectReference)" access="pub" jdoc="">
				<param name="vm"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Heap2Graph.unpack(com.sun.jdi.VirtualMachine, java.util.List)" access="pub" jdoc="">
				<param name="vm"/>
				<param name="roots"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.recognize.Heap2Graph.unpack(sandmark.util.exec.Heap)" access="priv" jdoc="">
				<param name="heap"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.ct.trace">
		<class name="/:sandmark.watermark.ct.trace.TracePoint" intfc="n" abs="n" inn="n" sloc="58" jdoc="This class represents the location of an annotation point in the code. &amp;lt;P&amp;gt; All fields are public, but should be treated as read-only.">
			<comm cntt="public static TracePoint parse(String input) { java.util.StringTokenizer tok = new java.util.StringTokenizer(input); String value = tok.nextToken(); String remaining = &amp;quot;&amp;quot;; while(tok.hasMoreTokens()) remaining += &amp;quot;\t&amp;quot; + tok.nextToken(); sandmark.util.ByteCodeLocation location = sandmark.util.ByteCodeLocation.parse(remaining); return new TracePoint(value, location); }"/>
			<comm cntt="public static sandmark.watermark.ct.trace.TracePoint[] read ( String traceFile) throws Exception { java.io.BufferedReader in = new java.io.BufferedReader(new java.io.FileReader(traceFile)); java.util.Vector vec = new java.util.Vector(500); String line; while ((line = in.readLine()) != null) { sandmark.watermark.ct.trace.TracePoint d = sandmark.watermark.ct.trace.TracePoint.parse(line); vec.add(d); } sandmark.watermark.ct.trace.TracePoint[] arr = (sandmark.watermark.ct.trace.TracePoint[])vec.toArray(new sandmark.watermark.ct.trace.TracePoint[0]); return arr; }"/>
			<field name="value" access="pub" jdoc="The argument (if any) found in a Annotate.mark(Arg) call."/>
			<field name="location" access="pub" jdoc="The source location of a Annotate.mark(Arg) call."/>
			<field name="stack" access="pub" jdoc="The call stack at this annotation point."/>
			<mth name="/:sandmark.watermark.ct.trace.TracePoint.TracePoint(String, sandmark.util.ByteCodeLocation)" access="pub" jdoc="">
				<param name="value"/>
				<param name="location"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.TracePoint.TracePoint(String, sandmark.util.ByteCodeLocation, sandmark.util.StackFrame[])" access="pub" jdoc="">
				<param name="value"/>
				<param name="location"/>
				<param name="stack"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.TracePoint.equals(Object)" access="pub" jdoc="Compare for equality. @param b object to compare to">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.TracePoint.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.TracePoint.toString()" access="pub" jdoc="Format the data in an easy to parse form.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.TracePoint.toString(TracePoint[])" access="pub" jdoc="Format the data for easy reading.">
				<param name="pts"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.TracePoint.write(java.io.File, TracePoint[])" access="pub" jdoc="Write an array of trace point data to file.">
				<comm cntt="public static void write( String traceFileName, TracePoint[] tracePoints) throws Exception { java.io.PrintWriter writer = new java.io.PrintWriter( new java.io.FileWriter(traceFileName)); for(int i=0; i&amp;lt;tracePoints.length; i++) writer.println(tracePoints[i].toString()); writer.close(); }"/>
				<param name="traceFile"/>
				<param name="tracePoints"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.TracePoint.read(java.io.File)" access="pub" jdoc="">
				<param name="traceFile"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.Tracer" intfc="n" abs="n" inn="n" sloc="35" jdoc="">
			<comm cntt="----------------------------------------------------------"/>
			<comm cntt="----------------------------------------------------------"/>
			<comm cntt="Stop tracing the program, by user request."/>
			<field name="annotatorClass" access="priv" jdoc="The sandmark.watermark.ct.trace.Tracer class contains methods for running a program and detecting annotation points. @param p global property list &amp;lt;P&amp;gt; Reads properties: @param Class Path path to search for class-files @param Main Class main class, if not set in Jar file @param Arguments program arguments, if any @param DWM_CT_AnnotatorClass where Annotator.java lives, if not sandmark.watermark.ct.trace.Annotator @param DWM_MaxTracePoints max number of annotation points we will accept &amp;lt;P&amp;gt;"/>
			<field name="list" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.Tracer.Tracer(String, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="cmdLine"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Tracer.getTracePoints()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Tracer.getMarkValue()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Tracer.STOP()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.watermark.ct.trace.Tracer$Breakpoint" intfc="n" abs="n" inn="y" sloc="31" jdoc="">
			<mth name="/:sandmark.watermark.ct.trace.Tracer$Breakpoint.Breakpoint(String, String)" access="pub" jdoc="">
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Tracer$Breakpoint.Action(sandmark.util.exec.MethodCallData)" access="pub" jdoc="">
				<param name="data"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.ct.trace.Preprocessor" intfc="n" abs="n" inn="n" sloc="71" jdoc="">
			<field name="app" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<const name="STACKID" access="pub" jdoc="Name of the local variable stored in each method to record the unique ID of that call frame."/>
			<const name="FRAMECOUNTER" access="pub" jdoc="Name of static variable in sandmark.watermark.ct.trace.Annotator that holds the current stack ID count."/>
			<const name="ADDEDCODESIZE" access="pub" jdoc="The amount of code we&amp;apos;re adding to each method. Use this to compute the actual offset of a mark() call within the unprocessed (original) source. We&amp;apos;re adding the following code, whose size adds up to 11: &amp;lt;PRE&amp;gt; GETSTATIC X 3 DUP2 1 LCONST_1 1 LADD 1 GETSTATIC X 3 LSTORE_1 X (or LSTORE) 1 (or 2) (NOP) 0 (or 1) &amp;lt; PRE&amp;gt;"/>
			<mth name="/:sandmark.watermark.ct.trace.Preprocessor.Preprocessor(sandmark.program.Application, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="app"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Preprocessor.preprocess()" access="pub" jdoc="Go through every method in every class of the program and add the code &amp;lt;PRE&amp;gt; long sm$stackID = sandmark.watermark.ct.trace.Annotator.stackFrameNumber++; &amp;lt; PRE&amp;gt; to the very beginning of the method. This will give every stackframe a unique ID.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Preprocessor.insertAnnotatorClass()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Preprocessor.save(java.io.File)" access="pub" jdoc="Save the edited classfiles under a new name.">
				<param name="appFile"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Preprocessor.preprocessClass(sandmark.program.Class)" access="pub" jdoc="Make the modifications to every method of the class. @param ec the class to be edited">
				<param name="ec"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Preprocessor.preprocessMethod(sandmark.program.Class, sandmark.program.Method)" access="pub" jdoc="Create a local variable to hold the stack ID. @param ec the class to be edited @param mg the method to be edited Example: &amp;lt;PRE&amp;gt; void P() { ... } &amp;lt; PRE&amp;gt; The resulting method would look something like this: &amp;lt;PRE&amp;gt; void P() { long sm$stackID = sandmark.watermark.ct.trace.Annotator.stackFrameNumber++; ... } &amp;lt; PRE&amp;gt; Or, in bytecode: &amp;lt;PRE&amp;gt; GETSTATIC sandmark.watermark.ct.trace.Annotator.stackFrameNumber DUP2 LCONST_1 LADD GETSTATIC sandmark.watermark.ct.trace.Annotator.stackFrameNumber LSTORE sm$stackID-index &amp;lt; PRE&amp;gt; One complication: &amp;lt;PRE&amp;gt; LSTORE &amp;lt; PRE&amp;gt; could either be &amp;lt;PRE&amp;gt; LSTORE_1 &amp;lt; PRE&amp;gt; or &amp;lt;PRE&amp;gt; LSTORE 5 &amp;lt; PRE&amp;gt; In the former case the instruction is 1 byte, in the latter, 2. We want all code sequences we insert to be the same length, so that when mark() is called in the preprocessed bytecode, we can figure out what its &amp;quot;real&amp;quot; offset is (the offset in the unprocessed code). Therefore we add an extra NOP in the case of LSTORE_1.">
				<param name="ec"/>
				<param name="mg"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.Annotator" intfc="n" abs="n" inn="n" sloc="24" jdoc="The &amp;lt;CODE&amp;gt;Annotator&amp;lt; Code&amp;gt; class contains static methods that are called to identify insertion points for watermarking code. First, annotation calls are added to the subject program, and the program is run to produce a log. Then, the watermarker marks the program by replacing the annotation calls with generated code. &amp;lt;P&amp;gt; NOTE: this class &amp;lt;b&amp;gt;must&amp;lt; b&amp;gt; be compiled with with -g in order for the local variable tables to be intact. If not, we can&amp;apos;t get stack-frame information for the mark() calls during tracing. &amp;lt;P&amp;gt; 13-dec-2000 cc 30-sep-1999 gmt 10-feb-2000 gmt">
			<comm cntt="This is the method we set a breakpoint on during tracing. When execution reaches this point sandmark.watermark.ct.trace.VALUE contains whatever data was passed to the last mark() call. If no data was passed then VALUE=&amp;quot;----&amp;quot;. If a string was passed then VALUE= &amp;quot;\&amp;quot;the string\&amp;quot;&amp;quot;. If a long was passed then VALUE= &amp;quot;the value&amp;quot;. MARK() doesn&amp;apos;t have a sm$stackID variable. The reason is that we set the breakpoint at the beginning of MARK at which time sm$stackID wouldn&amp;apos;t exist anyway. It doesn&amp;apos;t matter, we don&amp;apos;t need a unique stack frame ID for MARK anyway."/>
			<comm cntt="Marks an unparameterized annotation point."/>
			<comm cntt="Marks an annotation point controlled by a string value."/>
			<comm cntt="Marks an annotation point controlled by an integral value."/>
			<field name="VALUE" access="pub" jdoc=""/>
			<field name="stackFrameNumber" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.Annotator.MARK()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Annotator.sm$mark()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Annotator.sm$mark(String)" access="pub" jdoc="">
				<param name="s"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Annotator.sm$mark(long)" access="pub" jdoc="">
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.Annotator.clear()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.ct.trace.callforest">
		<class name="/:sandmark.watermark.ct.trace.callforest.CallFrame" intfc="n" abs="n" inn="n" sloc="23" jdoc="">
			<field name="method" access="pub" jdoc=""/>
			<field name="threadID" access="pub" jdoc=""/>
			<field name="frameID" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.CallFrame.CallFrame(sandmark.util.MethodID, long, long)" access="pub" jdoc="">
				<param name="method"/>
				<param name="threadID"/>
				<param name="frameID"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.CallFrame.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.CallFrame.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.CallFrame.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.Build" intfc="n" abs="n" inn="n" sloc="154" jdoc="">
			<field name="annotationPoints" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="annotatorClass" access="pub" jdoc=""/>
			<field name="classHierarchy" access="pub" jdoc=""/>
			<field name="storageClasses" access="pub" jdoc=""/>
			<field name="forest" access="pub" jdoc=""/>
			<field name="root2Graph" access="pub" jdoc=""/>
			<const name="DEFAULT_WEIGHT" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build.Build(sandmark.watermark.ct.trace.TracePoint, sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="annotationPoints"/>
				<param name="classHierarchy"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build.build()" access="pub" jdoc="Build the information flow graph. Add the following edges to the graph: callerEntryNode -&amp;gt; callerCallNode callerCallNode -&amp;gt; calleeEntryNode calleeExitNode -&amp;gt; callerReturnNode callerReturnNode -&amp;gt; callerExitNode calleeEnterNode -&amp;gt; calleeExitNode The top of the stack is in stack[0]. This holds the sm$mark()-call. The array of stacks looks like this: &amp;lt;PRE&amp;gt; j==0 j==1 ============================================================= +-------+ 0 |sm$mark| &amp;lt;--- topFrame +-------+ +-------+ ^^ 0 |sm$mark| 1 | | || +-------+ +-------+ || 1 | | 2 |callee | &amp;lt;--- calleeFrame &amp;lt;-- i || +-------+ +-------+ || 2 | | 3 |caller | &amp;lt;--- callerFrame || +-------+ +-------+ || 3 | | 4 | | || +-------+ +-------+ 4 | main | 5 | main | &amp;lt;-- bottomFrame +-------+ +-------+ lastStack currentStack &amp;lt; PRE&amp;gt; Note that, for some retarded reason, sm$mark is at the bottom of the stack, not the top. In other words, stacks grow from high indices to low. This means that the lastStack and the currentStack are indexed differently. &amp;lt;P&amp;gt; &amp;lt;code&amp;gt;lastStackCurrentFrameIndex&amp;lt; code&amp;gt; holds the index of the frame in the last stack corresponding to the current frame in the current stack. &amp;lt;P&amp;gt; &amp;lt;code&amp;gt;data&amp;lt; code&amp;gt; is a matrix that holds data for each stack frame. data[j][i] holds the nodes created for frame i in stack j.">
				<comm cntt="System.out.println(&amp;quot;CALLEE: &amp;quot; + calleeFrameData.toString());"/>
				<comm cntt="System.out.println(&amp;quot;CALLER: &amp;quot; + callerFrameData.toString());"/>
				<comm cntt="System.out.println(&amp;quot;lastCallerReturnNode: &amp;quot; +"/>
				<comm cntt="((lastCallerReturnNode!=null)?&amp;quot;&amp;quot;+lastCallerReturnNode.nodeNumber():&amp;quot;null&amp;quot;));"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build.newGraph(sandmark.util.StackFrame)" access="pub" jdoc="Create a new graph (if necessary) corresponding to the bottom (root) stack frame of a thread. @param root The first (bottom) call frame of a thread">
				<comm cntt="System.out.println( &amp;quot;Cached newGraph: &amp;quot;+cf );"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build.isMarkMethod(sandmark.util.MethodID)" access="pub" jdoc="Return true if method is one of the mark()-methods in the annotator class. @param method the method">
				<comm cntt="&amp;&amp; method.sourceName.equals(annotatorClass);"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build.addNode(sandmark.util.newgraph.MutableGraph, sandmark.util.StackFrame, int)" access="priv" jdoc="Add a node to the call graph. @param graph the call graph @param data the information to be added to the node @param kind the kind of node to create sandmark.watermark.ct.trace.callforest.Node lists the possible node kinds.">
				<param name="graph"/>
				<param name="frame"/>
				<param name="kind"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build.addEdge(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.trace.callforest.Node, sandmark.watermark.ct.trace.callforest.Node)" access="priv" jdoc="Add an edge of a particular weight to the call graph. @param graph the call graph @param from the source node @param to the sink node sandmark.watermark.ct.trace.callforest.Node lists the possible node kinds.">
				<comm cntt="System.out.println(&amp;quot;Adding edge: &amp;quot; + from.nodeNumber() + &amp;quot;--&amp;gt;&amp;quot; + to.nodeNumber());"/>
				<param name="graph"/>
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build.okToAddStorageArgument(sandmark.util.MethodID)" access="pub" jdoc="Return true if it OK to add a storage argument to this method. At this point we don&amp;apos;t know exactly which type of storage we are going to use, so we&amp;apos;ll try all of them. @param method the method">
				<comm cntt="System.out.println(&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; methodRenameOK(&amp;quot; + method + &amp;quot;,&amp;quot; + newMethod + &amp;quot;)&amp;quot; );"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build.addArgumentLast(String, String)" access="pub" jdoc="">
				<param name="signature"/>
				<param name="newType"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build.sameStackFrame(sandmark.util.StackFrame, sandmark.util.StackFrame)" access="pub" jdoc="">
				<param name="s1"/>
				<param name="s2"/>
			</mth>
		<class name="/:sandmark.watermark.ct.trace.callforest.Build$Data" intfc="n" abs="n" inn="y" sloc="25" jdoc="">
			<field name="graph" access="pub" jdoc=""/>
			<field name="enterNode" access="pub" jdoc=""/>
			<field name="exitNode" access="pub" jdoc=""/>
			<field name="callNode" access="pub" jdoc=""/>
			<field name="returnNode" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build$Data.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Build$Data.createDataArray(sandmark.watermark.ct.trace.TracePoint)" access="pub" jdoc="">
				<param name="annotationPoints"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.Path" intfc="n" abs="n" inn="n" sloc="138" jdoc="">
			<comm cntt="calculates the weight of a path in the forest(including the edge weights)"/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.Path()" access="pub" jdoc="Construct an empty path.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.Path(sandmark.util.newgraph.Path)" access="pub" jdoc="Construct a copy of the path &amp;lt;code&amp;gt;P&amp;lt; code&amp;gt;.">
				<param name="P"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.toString()" access="pub" jdoc="Generate a string representation of this paths.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.pathWeight()" access="pub" jdoc="Return the weight of this path(sum of the weights of the node in the path).">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.getWeight(sandmark.watermark.ct.trace.callforest.Path, sandmark.watermark.ct.trace.callforest.Forest)" access="pub" jdoc="">
				<comm cntt="return path.pathWeight();"/>
				<param name="path"/>
				<param name="forest"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.numberOfMarkNodes()" access="pub" jdoc="Return the number of sm$mark() ENTER-nodes in the path.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.equals(java.lang.Object)" access="pub" jdoc="Return true if &amp;lt;code&amp;gt;path2&amp;lt; code&amp;gt; is equal to this path.">
				<param name="path2"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.compareTo(java.lang.Object)" access="pub" jdoc="Return (-1,0,1), the result of comparing &amp;lt;em&amp;gt;the weight&amp;lt; em&amp;gt; of this path to that of &amp;lt;code&amp;gt;p2&amp;lt; code&amp;gt;. &amp;lt;p&amp;gt; Note: this class has a natural ordering that is inconsistent with equals. &amp;lt;p&amp;gt; Two paths are equal if they contain the same nodes in the same order. &amp;lt;code&amp;gt;p1.compareTo(p2)&amp;lt; code&amp;gt; will return 0, however, if the two paths have the same weight.">
				<param name="p2"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.mkNode(int, int)" access="pub" jdoc="">
				<param name="number"/>
				<param name="weight"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.testA()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Path.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.Node" intfc="n" abs="n" inn="n" sloc="150" jdoc="">
			<comm cntt="Returns a new copy of this node"/>
			<const name="MISSING_int" access="pub" jdoc=""/>
			<const name="MISSING_kind" access="pub" jdoc=""/>
			<const name="ENTER" access="pub" jdoc=""/>
			<const name="EXIT" access="pub" jdoc=""/>
			<const name="CALL" access="pub" jdoc=""/>
			<const name="RETURN" access="pub" jdoc=""/>
			<field name="kind" access="priv" jdoc=""/>
			<field name="weight" access="priv" jdoc=""/>
			<field name="frame" access="priv" jdoc=""/>
			<field name="isMark" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.Node(sandmark.util.ByteCodeLocation, long, long, int, int, boolean)" access="pub" jdoc="">
				<param name="location"/>
				<param name="threadID"/>
				<param name="frameID"/>
				<param name="weight"/>
				<param name="kind"/>
				<param name="isMark"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.Node(int, sandmark.util.StackFrame, int, int)" access="pub" jdoc="">
				<param name="number"/>
				<param name="frame"/>
				<param name="weight"/>
				<param name="kind"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.Node(sandmark.util.ByteCodeLocation, long, long, int)" access="pub" jdoc="">
				<param name="location"/>
				<param name="threadID"/>
				<param name="frameID"/>
				<param name="weight"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.Node(sandmark.util.ByteCodeLocation, long)" access="pub" jdoc="">
				<param name="location"/>
				<param name="threadID"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.Node(sandmark.util.ByteCodeLocation, long, long)" access="pub" jdoc="">
				<param name="location"/>
				<param name="threadID"/>
				<param name="frameID"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.copy()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.toString()" access="pub" jdoc="Format the data in an easy to parse form.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.toStringShortFormat()" access="pub" jdoc="Format the data in a compact form.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.toStringDotFormat()" access="pub" jdoc="Format the data in a format suitable for dot.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.kind2String(int)" access="pub" jdoc="">
				<param name="kind"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.kind2StringSmall(int)" access="pub" jdoc="">
				<param name="kind"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.getMethod()" access="pub" jdoc="Return the method represented by this node.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.frameID()" access="pub" jdoc="Return the ID number of the frame represented by this node.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.isMarkNode()" access="pub" jdoc="Return true if this node represents one of the mark()-methods in the annotator class.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.getWeight()" access="pub" jdoc="Return the weight of this node.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.setWeight(int)" access="pub" jdoc="Set the weight of this node.">
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.getKind()" access="pub" jdoc="Get the weight of this node.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.isEnterNode()" access="pub" jdoc="Return true is this is an ENTER node.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.isExitNode()" access="pub" jdoc="Return true is this is an EXIT node.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.isCallNode()" access="pub" jdoc="Return true is this is an CALL node.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.isReturnNode()" access="pub" jdoc="Return true is this is an RETURN node.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.getFrame()" access="pub" jdoc="Get the stack frame corresponding to this node.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Node.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.Edge" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<const name="MISSING_weight" access="pub" jdoc=""/>
			<field name="weight" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Edge.Edge(sandmark.watermark.ct.trace.callforest.Node, sandmark.watermark.ct.trace.callforest.Node, String, int)" access="pub" jdoc="">
				<param name="from"/>
				<param name="to"/>
				<param name="label"/>
				<param name="weight"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Edge.toString()" access="pub" jdoc="Format the data in an easy to parse form.">
				<comm cntt="theEdgeNumber + &amp;quot;,&amp;quot; +"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Edge.getWeight()" access="prot" jdoc="Return the weight of this edge.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Edge.setWeight(int)" access="prot" jdoc="Set the weight of this edge.">
				<param name="weight"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.Decorate" intfc="n" abs="n" inn="n" sloc="240" jdoc="">
			<field name="classHierarchy" access="pub" jdoc=""/>
			<field name="nstatistics" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="annotatorClass" access="pub" jdoc=""/>
			<field name="storageClasses" access="pub" jdoc=""/>
			<field name="forest" access="pub" jdoc=""/>
			<const name="EDGE_WEIGHT" access="pub" jdoc=""/>
			<const name="EDGE_CALL_WEIGHT" access="pub" jdoc=""/>
			<const name="ADD_PARAM_STEALTHY_WEIGHT" access="pub" jdoc=""/>
			<const name="ADD_RETURN_STEALTHY_WEIGHT" access="pub" jdoc=""/>
			<const name="NODE_MARK_WEIGHT" access="pub" jdoc=""/>
			<const name="NODE_STEALTHY_WEIGHT" access="pub" jdoc=""/>
			<const name="NODE_UNSTEALTHY_WEIGHT" access="pub" jdoc=""/>
			<const name="NODE_JAVA_WEIGHT" access="pub" jdoc=""/>
			<const name="NODE_CANTMODIFY_WEIGHT" access="pub" jdoc=""/>
			<const name="TREE_ORDER_WEIGHT" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.Decorate(java.util.Vector, sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.newstatistics.Stats, sandmark.util.ConfigProperties)" access="pub" jdoc="">
				<param name="forest"/>
				<param name="classHierarchy"/>
				<param name="stats"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.decorate()" access="pub" jdoc="Add node and edge weights to the information flow graph.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.decorateNodes()" access="pub" jdoc="Add weights to all the nodes in all the call graphs.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.decorateNode(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.trace.callforest.Node, long, long)" access="pub" jdoc="Construct the weight of this node. A mark node gets the weight NODE_MARK_WEIGHT. A node that calls a mark node represents a method into which we may embed the watermark. If the watermark code fits in, the node&amp;apos;s weight will be NODE_STEALTHY_WEIGHT P, where 0&amp;lt;=P&amp;lt;=1 is a measure of how stealthy the method is. @param graph the call graph @param node the node">
				<comm cntt="weight+=NODE_STEALTHY_WEIGHT;"/>
				<comm cntt="weight = (int)((double)weight java.lang.Math.pow((double)treeNumber,TREE_ORDER_WEIGHT));"/>
				<param name="graph"/>
				<param name="node"/>
				<param name="minID"/>
				<param name="maxID"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.stealthyToHoldWatermark(sandmark.util.MethodID)" access="pub" jdoc="Return a number that is a measure of how stealthy it would be to insert watermarking code in this method. @param method the method @return a number between 0.0 and 1.0 where 1.0 is a perfect fit. &amp;lt;p&amp;gt; The bytecodes we insert have approximately this distribution: &amp;lt;PRE&amp;gt; bytecode percent -------------------- aload 29 putfield 10 astore 8 new 7 invokespecial 7 dup 7 getstatic 6 invokevirtual 6 iconst |ldc 5 ifnull 3 pop 2 return 2 getfield 2 checkcast 1 goto 1 &amp;lt; PRE&amp;gt;">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.addStats(String[], int, double, java.util.Hashtable)" access="pub" jdoc="Compute the similarity of a set of bytecodes in a method to the type of code we insert. @param ops a set of bytecodes @param numberOfBytecodes total number of bytecodes in this method @param wm_percent frequency of these bytecodes in the code we insert @param usage bytecode counts for this method. @return the ratio. &amp;lt;p&amp;gt; @return a number between 0.0 and 1.0 where 1.0 is a perfect fit.">
				<param name="ops"/>
				<param name="numberOfBytecodes"/>
				<param name="wm_percent"/>
				<param name="usage"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.okToAddStorageArgument(sandmark.util.MethodID)" access="pub" jdoc="Return true if it OK to add a storage argument to this method. At this point we don&amp;apos;t know exactly which type of storage we are going to use, so we&amp;apos;ll try all of them. @param method the method">
				<comm cntt="System.out.println(&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; methodRenameOK(&amp;quot; + method + &amp;quot;,&amp;quot; + newMethod + &amp;quot;)&amp;quot; );"/>
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.addArgumentLast(String, String)" access="pub" jdoc="">
				<param name="signature"/>
				<param name="newType"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.stealthyToAddStorageArgument(sandmark.util.MethodID)" access="pub" jdoc="Return true if it would be stealthy to add a storage argument to this method. The stealthiness of adding an argument depends on &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; the number of arguments the method has, &amp;lt;LI&amp;gt; the types of these arguments. &amp;lt; UL&amp;gt; In general, adding yet another argument to a method that already has several should be good. Also, since we&amp;apos;re adding a reference argument it&amp;apos;s probably stealthy if the method already has one or more reference parameters. @param method the method @return a number between 0.0 and 1.0 describing how stealthy it would be to add another reference formal parameter.">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.stealthyToAddReturnValue(sandmark.util.MethodID)" access="pub" jdoc="Return 1.0 if it would be stealthy to add a return value to this method. @param method the method @return a number between 0.0 and 1.0 describing how stealthy it would be to add a return value.">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.decorateEdges()" access="pub" jdoc="Add weights to all the edges in all the call graphs.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Decorate.decorateEdge(sandmark.util.newgraph.MutableGraph, sandmark.watermark.ct.trace.callforest.Edge)" access="pub" jdoc="Construct the weight of this edge. @param graph the call graph @param edge the edge">
				<param name="graph"/>
				<param name="edge"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.Forest" intfc="n" abs="n" inn="n" sloc="73" jdoc="">
			<comm cntt="Return a dot representation of the forest."/>
			<field name="annotationPoints" access="pub" jdoc=""/>
			<field name="classHierarchy" access="pub" jdoc=""/>
			<field name="nstatistics" access="pub" jdoc=""/>
			<field name="props" access="pub" jdoc=""/>
			<field name="forest" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Forest.Forest(sandmark.watermark.ct.trace.TracePoint, sandmark.analysis.classhierarchy.ClassHierarchy, sandmark.newstatistics.Stats, sandmark.util.ConfigProperties)" access="pub" jdoc="Construct a forest of call graphs from a set of annotation points. Each call graph is rooted in a &amp;apos;unique entry point.&amp;apos; A unique entry point is an application call frame generated by Java runtime system. For example, there will be one call graph rooted in the call frame for &amp;quot;main&amp;quot;. There may be other call graphs rooted in &amp;quot;action&amp;quot;-methods, for example methods invoked by the run-time system in response to a button click by the user. Consider the following program: &amp;lt;PRE&amp;gt; 1: P() { 2: sm$mark(); 3: } 4: 5: Q() { 6: sm$mark(); 7: P(); 8: } 9: 10: main() { 11: Q(); 12: Q(); 13: } &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt; We get the call graph below. &amp;quot;Q:2 6&amp;quot; means &amp;quot;call frame #2 for method Q, line number 6&amp;quot;. &amp;lt;PRE&amp;gt; mark:5 mark:9 ^ ^ | | | | V V mark:3 P:4 7 mark:7 P:8 7 ^ ^ ^ ^ | | | | | | | | V V V V Q:2 6----&amp;gt;Q:2 Q:6 6----&amp;gt;Q:6 ^ ^ | | | | V V main:1 11 ----------------&amp;gt; main:1 12 ^ | root &amp;lt; PRE&amp;gt; The nodes of the graphs are stack frames. The root of each call graph is the frame of whatever run() or main() method started the thread. The leaves are stack frames of sm$mark() method calls. The edge Q:2 6----&amp;gt;Q:2 above indicates that there is a way to pass information from mark:3 to mark:5, but not the other way. Each interior node is labeled by the stack frame (a sandmark.util.StackFrame object) it corresponds to. Each leaf represents a sm$mark() call and is labeled with the sm$mark(...) value given at that location. @param annotationPoints the set of locations found during tracing. @param classHierarchy the class hierarchy @param stats static statistics about the program @param props properties">
				<param name="annotationPoints"/>
				<param name="classHierarchy"/>
				<param name="stats"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Forest.construct()" access="pub" jdoc="Build the information flow graph.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Forest.getFlowPath(sandmark.util.StackFrame, sandmark.util.MethodID)" access="pub" jdoc="Given two stack frames, returns an array of method ids which require an additional parameter to pass information from the first to the second. @param from the source stack frame @param to the sink method">
				<param name="from"/>
				<param name="to"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Forest.toString()" access="pub" jdoc="">
				<comm cntt="Return a string representation of the forest."/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Forest.toDot()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Forest.addToGraphViewer()" access="pub" jdoc="View a graphical representation of the forest">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Forest.getForest()" access="pub" jdoc="Return a vector of call graphs. Each node in the graph has a sandmark.util.StackFrame as its data.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Forest.size()" access="pub" jdoc="Return the number of graphs in the forest.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Forest.getCallGraph(int)" access="pub" jdoc="Return the i:th graph in the forest.">
				<param name="i"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.PathGenerator" intfc="n" abs="n" inn="n" sloc="45" jdoc="">
			<field name="orderedIterator" access="pub" jdoc=""/>
			<field name="orderedPaths" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.PathGenerator.PathGenerator(java.util.Vector, int)" access="pub" jdoc="This class generates paths between sm$mark()-nodes in the call forest. We generate the paths in order of goodness, with the best one first.">
				<param name="forest"/>
				<param name="maxPaths"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.PathGenerator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.PathGenerator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.PathGenerator.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.PathGenerator.toString()" access="pub" jdoc="Generate a string representation of all the paths.">
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator" intfc="n" abs="n" inn="n" sloc="57" jdoc="">
			<field name="forest" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator.AllPathsIterator(java.util.Vector)" access="pub" jdoc="This class generates paths between sm$mark()-nodes in the call forest. &amp;lt;P&amp;gt; &amp;lt;PRE&amp;gt; for every graph g in the forest (in reverse order) do { for every mark-node n in g do { for every path p starting in n and ending in another mark-node m do { yield p; } } } &amp;lt; PRE&amp;gt;">
				<param name="forest"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator.start(int, java.lang.Object[])" access="pub" jdoc="Start enumerator number k. elmts[0..k-1] hold the current generated values for the first k enumerators.">
				<comm cntt="if (k==2)"/>
				<param name="k"/>
				<param name="elmts"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator.create(java.lang.Object[])" access="pub" jdoc="Create the object to be returned by the enumerator. Throws an exception if no element could be generated.">
				<param name="elmts"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator.count()" access="pub" jdoc="Return the number of iterators.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator.markNodes(sandmark.util.newgraph.MutableGraph)" access="pub" jdoc="Generate all the mark ENTER-nodes in the graph.">
				<param name="graph"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator.toString()" access="pub" jdoc="Generate a string representation of all the paths.">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator.dominatingNode(sandmark.watermark.ct.trace.callforest.Node, sandmark.watermark.ct.trace.callforest.Node)" access="pub" jdoc="Return the lowest dominating node of &amp;lt;code&amp;gt;markNode1&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;markNode2&amp;lt; code&amp;gt;.">
				<param name="markNode1"/>
				<param name="markNode2"/>
			</mth>
		<class name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator$Afs" intfc="n" abs="n" inn="y" sloc="27" jdoc="">
			<mth name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator$Afs.Afs(sandmark.util.newgraph.MutableGraph, sandmark.util.newgraph.Node)" access="pub" jdoc="Same as sandmark.util.newgraph.Afs except we trim off parts of paths that follow the last mark()-node, and we return a sandmark.watermark.ct.trace.callforest.Path rather than a sandmark.util.newgraph.Path.">
				<param name="graph"/>
				<param name="root"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.AllPathsIterator$Afs.next()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.Test" intfc="n" abs="n" inn="n" sloc="271" jdoc="">
			<comm cntt="Test 1"/>
			<comm cntt="Test 2"/>
			<comm cntt="Test 3"/>
			<comm cntt="Test 4"/>
			<comm cntt="Main"/>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test.mkFrame(String, String, String, long, long, long, long)" access="pub" jdoc="">
				<param name="name"/>
				<param name="sig"/>
				<param name="className"/>
				<param name="lineNumber"/>
				<param name="codeIndex"/>
				<param name="threadID"/>
				<param name="frameID"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test.mkTracePoint(String, String, String, String, long, long, sandmark.util.StackFrame[])" access="pub" jdoc="">
				<param name="data"/>
				<param name="name"/>
				<param name="sig"/>
				<param name="className"/>
				<param name="lineNumber"/>
				<param name="codeIndex"/>
				<param name="frames"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test.test1(ClassHierarchy, Stats, sandmark.util.ConfigProperties)" access="pub" jdoc="Build the dynamic call-graph for this simple method: &amp;lt;PRE&amp;gt; public class Simple1 { static void P() { sandmark.watermark.ct.trace.Annotator.sm$mark(); } public static void main(String args[]) { P(); } } &amp;lt; PRE&amp;gt;">
				<comm cntt="f.view();"/>
				<param name="classHierarchy"/>
				<param name="stats"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test.test2(ClassHierarchy, Stats, sandmark.util.ConfigProperties, boolean)" access="pub" jdoc="Build the dynamic call-graph for this simple method: &amp;lt;PRE&amp;gt; public class Simple6 { static void P() { sandmark.watermark.ct.trace.Annotator.sm$mark(); } static void Q() { sandmark.watermark.ct.trace.Annotator.sm$mark(); } public static void main(String args[]) { P(); Q(); } } &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt; @param classHierarchy the class hierarchy @param stats statistics @param props properties @param okToAddParam &amp;apos;false&amp;apos; if we should name one of the methods &amp;quot;Q&amp;quot;, meaning that its argument list cannot be changed.">
				<comm cntt="System.out.println(f);"/>
				<param name="classHierarchy"/>
				<param name="stats"/>
				<param name="props"/>
				<param name="okToAddParam"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test.test3(ClassHierarchy, Stats, sandmark.util.ConfigProperties)" access="pub" jdoc="Build the dynamic call-graph for this simple class: &amp;lt;PRE&amp;gt; class TTTApplication { void mark() { sm$mark(); } void move() { sm$mark(); mark(); } void actionPerformed () { move() } } &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt; These are the stack frames: &amp;lt;PRE&amp;gt; TRACEPT[1,LOCATION[METHOD[move,(I)V,TTTApplication], LINE=98, BC=36]] FRAME[LOCATION[METHOD[sm$mark,(J)V,sandmark.watermark.ct.trace.Annotator], LINE=59, BC=6], ID=78] FRAME[LOCATION[METHOD[move,(I)V,TTTApplication], LINE=98, BC=36], ID=67] FRAME[LOCATION[METHOD[actionPerformed,(Ljava awt event ActionEvent;)V,TTTApplication$1], LINE=32, BC=20], ID=66] TRACEPT[8,LOCATION[METHOD[mark,(I)V,TTTApplication], LINE=131, BC=49]] FRAME[LOCATION[METHOD[sm$mark,(J)V,sandmark.watermark.ct.trace.Annotator], LINE=59, BC=6], ID=80] FRAME[LOCATION[METHOD[mark,(I)V,TTTApplication], LINE=131, BC=49], ID=79] FRAME[LOCATION[METHOD[move,(I)V,TTTApplication], LINE=99, BC=41], ID=67] FRAME[LOCATION[METHOD[actionPerformed,(Ljava awt event ActionEvent;)V,TTTApplication$1], LINE=32, BC=20], ID=66] &amp;lt; PRE&amp;gt;">
				<param name="classHierarchy"/>
				<param name="stats"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test.test4(ClassHierarchy, Stats, sandmark.util.ConfigProperties)" access="pub" jdoc="Build the dynamic call-graph for this simple class: &amp;lt;PRE&amp;gt; public class SimpleE { static void K() { sandmark.watermark.ct.trace.Annotator.sm$mark(); } static void L() { sandmark.watermark.ct.trace.Annotator.sm$mark(); } static void M() { sandmark.watermark.ct.trace.Annotator.sm$mark(); } static void N() { sandmark.watermark.ct.trace.Annotator.sm$mark(); } static void O() { sandmark.watermark.ct.trace.Annotator.sm$mark(); N(); } static void P() { sandmark.watermark.ct.trace.Annotator.sm$mark(); O(); } static void W() { L(); sandmark.watermark.ct.trace.Annotator.sm$mark(); M(); } static void R() { K(); } static void S() { P(); W(); R(); } public static void main(String args[]) { S(); } } &amp;lt; PRE&amp;gt; &amp;lt;P&amp;gt; These are the stack frames: &amp;lt;PRE&amp;gt; TRACEPT[----,LOCATION[METHOD[P,()V,SimpleE,dynamic], LINE=25, BC=0]] FRAME[LOCATION[METHOD[sm$mark,()V,sandmark.watermark.ct.trace.Annotator,dynamic], LINE=45, BC=4], THRD=1, ID=3] FRAME[LOCATION[METHOD[P,()V,SimpleE,dynamic], LINE=25, BC=0], THRD=1, ID=2] FRAME[LOCATION[METHOD[S,()V,SimpleE,dynamic], LINE=40, BC=0], THRD=1, ID=1] FRAME[LOCATION[METHOD[main,([Ljava lang String;)V,SimpleE,dynamic], LINE=46, BC=0], THRD=1, ID=0] TRACEPT[----,LOCATION[METHOD[O,()V,SimpleE,dynamic], LINE=20, BC=0]] FRAME[LOCATION[METHOD[sm$mark,()V,sandmark.watermark.ct.trace.Annotator,dynamic], LINE=45, BC=4], THRD=1, ID=5] FRAME[LOCATION[METHOD[O,()V,SimpleE,dynamic], LINE=20, BC=0], THRD=1, ID=4] FRAME[LOCATION[METHOD[P,()V,SimpleE,dynamic], LINE=26, BC=3], THRD=1, ID=2] FRAME[LOCATION[METHOD[S,()V,SimpleE,dynamic], LINE=40, BC=0], THRD=1, ID=1] FRAME[LOCATION[METHOD[main,([Ljava lang String;)V,SimpleE,dynamic], LINE=46, BC=0], THRD=1, ID=0] TRACEPT[----,LOCATION[METHOD[N,()V,SimpleE,dynamic], LINE=16, BC=0]] FRAME[LOCATION[METHOD[sm$mark,()V,sandmark.watermark.ct.trace.Annotator,dynamic], LINE=45, BC=4], THRD=1, ID=7] FRAME[LOCATION[METHOD[N,()V,SimpleE,dynamic], LINE=16, BC=0], THRD=1, ID=6] FRAME[LOCATION[METHOD[O,()V,SimpleE,dynamic], LINE=21, BC=3], THRD=1, ID=4] FRAME[LOCATION[METHOD[P,()V,SimpleE,dynamic], LINE=26, BC=3], THRD=1, ID=2] FRAME[LOCATION[METHOD[S,()V,SimpleE,dynamic], LINE=40, BC=0], THRD=1, ID=1] FRAME[LOCATION[METHOD[main,([Ljava lang String;)V,SimpleE,dynamic], LINE=46, BC=0], THRD=1, ID=0] TRACEPT[----,LOCATION[METHOD[L,()V,SimpleE,dynamic], LINE=8, BC=0]] FRAME[LOCATION[METHOD[sm$mark,()V,sandmark.watermark.ct.trace.Annotator,dynamic], LINE=45, BC=4], THRD=1, ID=10] FRAME[LOCATION[METHOD[L,()V,SimpleE,dynamic], LINE=8, BC=0], THRD=1, ID=9] FRAME[LOCATION[METHOD[W,()V,SimpleE,dynamic], LINE=30, BC=0], THRD=1, ID=8] FRAME[LOCATION[METHOD[S,()V,SimpleE,dynamic], LINE=41, BC=3], THRD=1, ID=1] FRAME[LOCATION[METHOD[main,([Ljava lang String;)V,SimpleE,dynamic], LINE=46, BC=0], THRD=1, ID=0] TRACEPT[----,LOCATION[METHOD[W,()V,SimpleE,dynamic], LINE=31, BC=3]] FRAME[LOCATION[METHOD[sm$mark,()V,sandmark.watermark.ct.trace.Annotator,dynamic], LINE=45, BC=4], THRD=1, ID=11] FRAME[LOCATION[METHOD[W,()V,SimpleE,dynamic], LINE=31, BC=3], THRD=1, ID=8] FRAME[LOCATION[METHOD[S,()V,SimpleE,dynamic], LINE=41, BC=3], THRD=1, ID=1] FRAME[LOCATION[METHOD[main,([Ljava lang String;)V,SimpleE,dynamic], LINE=46, BC=0], THRD=1, ID=0] TRACEPT[----,LOCATION[METHOD[M,()V,SimpleE,dynamic], LINE=12, BC=0]] FRAME[LOCATION[METHOD[sm$mark,()V,sandmark.watermark.ct.trace.Annotator,dynamic], LINE=45, BC=4], THRD=1, ID=13] FRAME[LOCATION[METHOD[M,()V,SimpleE,dynamic], LINE=12, BC=0], THRD=1, ID=12] FRAME[LOCATION[METHOD[W,()V,SimpleE,dynamic], LINE=32, BC=6], THRD=1, ID=8] FRAME[LOCATION[METHOD[S,()V,SimpleE,dynamic], LINE=41, BC=3], THRD=1, ID=1] FRAME[LOCATION[METHOD[main,([Ljava lang String;)V,SimpleE,dynamic], LINE=46, BC=0], THRD=1, ID=0] TRACEPT[----,LOCATION[METHOD[K,()V,SimpleE,dynamic], LINE=4, BC=0]] FRAME[LOCATION[METHOD[sm$mark,()V,sandmark.watermark.ct.trace.Annotator,dynamic], LINE=45, BC=4], THRD=1, ID=16] FRAME[LOCATION[METHOD[K,()V,SimpleE,dynamic], LINE=4, BC=0], THRD=1, ID=15] FRAME[LOCATION[METHOD[R,()V,SimpleE,dynamic], LINE=36, BC=0], THRD=1, ID=14] FRAME[LOCATION[METHOD[S,()V,SimpleE,dynamic], LINE=42, BC=6], THRD=1, ID=1] FRAME[LOCATION[METHOD[main,([Ljava lang String;)V,SimpleE,dynamic], LINE=46, BC=0], THRD=1, ID=0] &amp;lt; PRE&amp;gt;">
				<param name="classHierarchy"/>
				<param name="stats"/>
				<param name="props"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test.main(String)" access="pub" jdoc="Build the dynamic call-graph for methods test1, test2, test3, test4. Call by &amp;lt;PRE&amp;gt; java -classpath .:.. smextern3 BCEL.jar:.. smextern bloat-1.0.jar \ sandmark.watermark.ct.trace.callforest.Test &amp;lt; PRE&amp;gt;">
				<param name="args"/>
			</mth>
		<class name="/:sandmark.watermark.ct.trace.callforest.Test$Stats" intfc="n" abs="n" inn="y" sloc="38" jdoc="">
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test$Stats.Stats()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test$Stats.getByteCodeUsage(String, String)" access="pub" jdoc="">
				<param name="className"/>
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test$Stats.getByteCode(String, String)" access="pub" jdoc="">
				<param name="className"/>
				<param name="methodName"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.ct.trace.callforest.Test$ClassHierarchy" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test$ClassHierarchy.ClassHierarchy()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.ct.trace.callforest.Test$ClassHierarchy.methodRenameOK(sandmark.util.MethodID, sandmark.util.MethodID)" access="pub" jdoc="">
				<param name="origMethod"/>
				<param name="newMethod"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.dm">
		<class name="/:sandmark.watermark.dm.DM" intfc="n" abs="n" inn="n" sloc="282" jdoc="Author: Zachary Heidepriem">
			<comm cntt="Get the HTML codes of the About page."/>
			<comm cntt="Get the URL of the Help page"/>
			<comm cntt="Generate and embed a signature value into the program. The props argument holds a watermark and possibly a key &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Watermark: The watermark to encode. &amp;lt;LI&amp;gt; Key: The key with which to recover the watermark &amp;lt; UL&amp;gt;"/>
			<comm cntt="embed"/>
			<comm cntt="Gets a permutation for the watermark contained in props"/>
			<comm cntt="encode perIndex into the corresponding permutation"/>
			<comm cntt="PRE2: 0 &amp;lt;= perIndex &amp;lt; factorial(perLength)"/>
			<comm cntt="POST1: perIndex = 0"/>
			<comm cntt="decode a permutation per, returning its corresponding perIndex"/>
			<comm cntt="PRE2: per[0..perLength-1] is a permutation of 0..perLength-1"/>
			<comm cntt="POST1: 0 &amp;lt;= perIndex &amp;lt; factorial(n)"/>
			<comm cntt="POST2: per[i] = i forall i in 0..perLength-1"/>
			<comm cntt="Gets a string for the permutation in perm"/>
			<comm cntt="Returns a vector that contains instruction handles of"/>
			<comm cntt="first instructions of every block"/>
			<comm cntt="the last entry in the table is the first instruction in the method"/>
			<comm cntt="A vector to store the watermarks found in the program."/>
			<comm cntt="class BlockRecognizer"/>
			<comm cntt="class Relinker"/>
			<comm cntt="MethodChooser"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<const name="MAGIC_START" access="priv" jdoc=""/>
			<const name="MAGIC_END" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.dm.DM.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getShortName()" access="pub" jdoc="Returns this watermarker&amp;apos;s short name.">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getLongName()" access="pub" jdoc="Returns this watermarker&amp;apos;s long name.">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.vertexCount(java.math.BigInteger)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.swap(java.util.Vector, long, long)" access="pub" jdoc="">
				<param name="V"/>
				<param name="i"/>
				<param name="j"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.createVector(long)" access="pub" jdoc="">
				<param name="length"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.index2perm(long, java.math.BigInteger)" access="pub" jdoc="">
				<comm cntt="we&amp;apos;re reducing perIndex to 0"/>
				<param name="perLength"/>
				<param name="perIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.perm2index(long, java.util.Vector)" access="pub" jdoc="">
				<comm cntt="search for s: per[s] == r-1"/>
				<param name="perLength"/>
				<param name="per"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getPermutation(String)" access="priv" jdoc="">
				<param name="wmstring"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.getString(java.util.Vector)" access="priv" jdoc="">
				<param name="perm"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.watermark(sandmark.program.Method, java.util.Vector)" access="priv" jdoc="">
				<comm cntt="cfg.printCFG();"/>
				<comm cntt="for(int i=0;i&amp;lt;blocks.length;i++) System.out.println(blocks[i]);"/>
				<comm cntt="System.out.println(watermark);"/>
				<param name="method"/>
				<param name="watermark"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.makeTable(sandmark.analysis.controlflowgraph.MethodCFG)" access="priv" jdoc="">
				<comm cntt="last element in v is link to first"/>
				<param name="cfg"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.buildMethod(sandmark.program.Method, org.apache.bcel.generic.InstructionList)" access="priv" jdoc="">
				<param name="mg"/>
				<param name="allInstrs"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.unique(int, sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="">
				<param name="n"/>
				<param name="blocks"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.reorder(sandmark.analysis.controlflowgraph.MethodCFG, java.util.Vector)" access="priv" jdoc="">
				<comm cntt="Reorder the blocks in the cfg to match watermark"/>
				<comm cntt="The new watermark accounts for non-unique blocks"/>
				<comm cntt="ctr is the current index of blocks"/>
				<comm cntt="wm_index is the index in the original wm"/>
				<comm cntt="skip to first unique block"/>
				<comm cntt="if(DEBUG) System.out.println(ctr);"/>
				<comm cntt="n is the current value in the old watermark"/>
				<comm cntt="Get the &amp;quot;nth&amp;quot; unique block,"/>
				<comm cntt="and all the non-unique blocks that follow it"/>
				<comm cntt="ctr2 is an index in the old blocks"/>
				<comm cntt="if(DEBUG) System.out.println(&amp;quot;The &amp;quot; + n + &amp;quot;th unique block is: &amp;quot; + orig_blocks[ctr2-1]);"/>
				<comm cntt="have reordered the first watermark unique blocks"/>
				<comm cntt="so just copy the old blocks over"/>
				<comm cntt="while(it.hasNext()){ b = (sandmark.analysis.controlflowgraph.BasicBlock)it.next(); b must be unique if(ctr &amp;lt; watermark.size()){ int relativeIndex = watermark.indexOf(new Long(ctr)); int absoluteIndex = getAbsoluteIndex(relativeIndex, blocks, cfg); blocks[absoluteIndex] = b; b = (sandmark.analysis.controlflowgraph.BasicBlock)it.next(); while(notUnique(b)){ blocks[absoluteIndex++] = b; b = (sandmark.analysis.controlflowgraph.BasicBlock)it.next(); } } else blocks[ctr] = b; rest of blocks are in same order ctr++; } return blocks;"/>
				<param name="cfg"/>
				<param name="watermark"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM.main(String[])" access="pub" jdoc="">
				<comm cntt="String in = &amp;quot;.. smtest3 tests hard fft test_wm.jar&amp;quot;;"/>
				<param name="args"/>
			</mth>
		<class name="/:sandmark.watermark.dm.DM$BlockRecognizer" intfc="n" abs="n" inn="y" sloc="235" jdoc="">
			<comm cntt="Reverse the process of reordering"/>
			<comm cntt="e.g. if the indices in wm cfg is [1,2,0],"/>
			<comm cntt="the encoded permutation was [2,0,1]"/>
			<comm cntt="v is a vector of Long vectors."/>
			<comm cntt="returns all unique Long vectors w st w[i] is a member of v[i]"/>
			<comm cntt="Given a basic block, find all occurences of it in cfg"/>
			<comm cntt="using the compareBlocks method. If it does not occur,"/>
			<comm cntt="or occurs more than once and is not a goto block, return null"/>
			<comm cntt="a is an original block, b is wm"/>
			<mth name="/:sandmark.watermark.dm.DM$BlockRecognizer.BlockRecognizer(sandmark.program.Application, sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="Put all the methods into a vector"/>
				<comm cntt="for both apps"/>
				<comm cntt="For all pairs of methods, build CFGs and try to get watermarks"/>
				<comm cntt="if(DEBUG) System.out.println(i + &amp;quot; &amp;quot; + orig_methods.size());"/>
				<param name="orig_app"/>
				<param name="wm_app"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$BlockRecognizer.getWatermarks(sandmark.analysis.controlflowgraph.MethodCFG, sandmark.analysis.controlflowgraph.MethodCFG)" access="priv" jdoc="">
				<comm cntt="wm_cfg.printCFG();"/>
				<comm cntt="System.out.println(&amp;quot;\n\noriginal: &amp;quot;);"/>
				<comm cntt="orig_cfg.printCFG();"/>
				<comm cntt="Put all the orig blocks into a list"/>
				<comm cntt="Find locations of corresponding blocks in wm cfg"/>
				<comm cntt="couldn&amp;apos;t match all blocks"/>
				<comm cntt="Since we skipped some non-unique blocks, the"/>
				<comm cntt="indices arent consecutive. So we have to reduce."/>
				<comm cntt="e.g. [2,5,3] becomes [1,3,2]"/>
				<comm cntt="Renumber the orderings and add perms for trailing numbers"/>
				<comm cntt="An ordering like [2,1,3] could really be [2,1] so"/>
				<comm cntt="put both into a new vector"/>
				<comm cntt="Decode all the permutations. If decoded string"/>
				<comm cntt="has magic number, we can add it to &amp;apos;this&amp;apos;"/>
				<param name="wm_cfg"/>
				<param name="orig_cfg"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$BlockRecognizer.getPerms(java.util.Vector)" access="priv" jdoc="">
				<comm cntt="Perms 2 are the extra perms we need for"/>
				<comm cntt="consecutive trailing numbers"/>
				<param name="ordering"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$BlockRecognizer.reduce(java.util.Vector)" access="priv" jdoc="">
				<param name="ordering"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$BlockRecognizer.getPossibleOrderings(java.util.Vector)" access="priv" jdoc="">
				<comm cntt="base case"/>
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$BlockRecognizer.getLocations(sandmark.analysis.controlflowgraph.BasicBlock, java.util.Iterator)" access="priv" jdoc="">
				<comm cntt="There should only be 1 location in wm cfg for"/>
				<comm cntt="the given block, unless the block is a GOTO block"/>
				<param name="block"/>
				<param name="it"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$BlockRecognizer.compareInstList(java.util.ArrayList, java.util.ArrayList)" access="priv" jdoc="">
				<param name="alist"/>
				<param name="blist"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$BlockRecognizer.compareBlocks(sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="">
				<comm cntt="ignoring empty blocks"/>
				<comm cntt="ignoring empty blocks"/>
				<param name="ablock"/>
				<param name="bblock"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.dm.DM$Relinker" intfc="n" abs="n" inn="y" sloc="90" jdoc="">
			<comm cntt="public final static boolean DEBUG = false;"/>
			<comm cntt="method Relink"/>
			<comm cntt="IHPair"/>
			<field name="blocks" access="pub" jdoc=""/>
			<field name="table" access="pub" jdoc=""/>
			<field name="watermark" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.dm.DM$Relinker.Relinker(sandmark.analysis.controlflowgraph.BasicBlock[], java.util.Vector, java.util.Vector)" access="pub" jdoc="">
				<param name="blocks"/>
				<param name="table"/>
				<param name="watermark"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$Relinker.relink()" access="pub" jdoc="">
				<comm cntt="deal with the first instruction"/>
				<comm cntt="deal with middle instructions"/>
				<comm cntt="now deal with last instruction"/>
				<comm cntt="first instruction, set startLink"/>
				<comm cntt="need to change existing branch"/>
				<comm cntt="some non-branching instruction"/>
				<comm cntt="insert new branch instruction (to fix fall throughs)"/>
				<comm cntt="first instruction, set startLink"/>
				<comm cntt="if(DEBUG) for(int i=0; i &amp;lt; newTable.size(); i++) System.out.println(newTable.get(i));"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$Relinker.setTargets(org.apache.bcel.generic.InstructionList, java.util.Vector, java.util.Vector)" access="priv" jdoc="">
				<comm cntt="if (DEBUG) System.out.println(&amp;quot;replacing &amp;quot; + pair.getA() + &amp;quot; with &amp;quot; + pair.getB());"/>
				<param name="il"/>
				<param name="t"/>
				<param name="watermark"/>
			</mth>
		<class name="/:sandmark.watermark.dm.DM$Relinker$IHPair" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<field name="a" access="pub" jdoc=""/>
			<field name="b" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.dm.DM$Relinker$IHPair.IHPair(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="a"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$Relinker$IHPair.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$Relinker$IHPair.getA()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$Relinker$IHPair.getB()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.dm.DM$MethodChooser" intfc="n" abs="n" inn="y" sloc="103" jdoc="">
			<comm cntt="private org.apache.bcel.classfile.Method method;"/>
			<comm cntt="private org.apache.bcel.classfile.JavaClass jc;"/>
			<comm cntt="public static final boolean DEBUG = false;"/>
			<field name="method" access="priv" jdoc=""/>
			<const name="DEFAULT_KEY" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.dm.DM$MethodChooser.MethodChooser(sandmark.program.Application, String, int)" access="pub" jdoc="">
				<param name="app"/>
				<param name="key"/>
				<param name="minSize"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$MethodChooser.getMethod()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$MethodChooser.setMethod(int, int, sandmark.program.Application)" access="priv" jdoc="">
				<param name="n"/>
				<param name="method2mark"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$MethodChooser.uniqueBlockCount(sandmark.analysis.controlflowgraph.MethodCFG)" access="priv" jdoc="">
				<param name="cfg"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$MethodChooser.numPossibles(sandmark.program.Application, int)" access="priv" jdoc="">
				<comm cntt="return 0;"/>
				<comm cntt="int size = cfg.size()-2; source and sink, i think?"/>
				<comm cntt="if(DEBUG) System.out.println(size);"/>
				<param name="app"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.watermark.dm.DM$MethodChooser.getMethod2Mark(String, int)" access="priv" jdoc="">
				<param name="keystring"/>
				<param name="n"/>
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.execpath">
		<class name="/:sandmark.watermark.execpath.VarValue" intfc="n" abs="n" inn="n" sloc="101" jdoc="This class contains a snapshot of a variable and its value at a particular point in time. The &amp;quot;value&amp;quot; will be an Integer wrapper around the hashcode of the object if it is a ReferenceType. Alternatively, if the object was null at this point, the value will be null. For a BasicType, the value will be the appropriate wrapper class around the given value. For a local variable, the name of the variable will be &amp;quot;L[i]&amp;quot; where i is the local index. If a VarValue represents a local variable, then the getLocalIndex() method returns the index (i).">
			<comm cntt="static type name=value"/>
			<comm cntt="this type name=value"/>
			<comm cntt="type L[i]=value"/>
			<const name="NONNULL" access="pub" jdoc=""/>
			<const name="STATIC" access="pub" jdoc=""/>
			<const name="INSTANCE" access="pub" jdoc=""/>
			<const name="LOCAL" access="pub" jdoc=""/>
			<field name="type" access="priv" jdoc=""/>
			<field name="name" access="priv" jdoc=""/>
			<field name="value" access="priv" jdoc=""/>
			<field name="localIndex" access="priv" jdoc=""/>
			<field name="kind" access="priv" jdoc=""/>
			<field name="typeCache" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.VarValue.VarValue(String)" access="prot" jdoc="">
				<param name="line"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.valueIsHashCode()" access="pub" jdoc="Returns true iff getValue() will be an Integer around the hashcode of this variable">
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.getName()" access="pub" jdoc="Returns the name of this variable. Locals are named &amp;quot;L[i]&amp;quot; where i is the local index.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.getKind()" access="pub" jdoc="Returns a flag int determining what kind of variable this is. One of STATIC, INSTANCE, or LOCAL.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.isNonnullUnhashable()" access="pub" jdoc="Returns true iff this value came from an object that has an unsafe hashCode method, but is nonnull.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.isNull()" access="pub" jdoc="Returns true iff the value is a null reference.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.getType()" access="pub" jdoc="Returns a Type class for this variable.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.getLocalIndex()" access="pub" jdoc="Returns the index of the local variable if this VarValue represents a local variable. If not, it returns -1.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.getValue()" access="pub" jdoc="Returns the value of this variable at this particular trace point. For BasicTypes, this will be the appropriate wrapper class around the given value. For ReferenceTypes, this will be an Integer wrapper around the hashcode of the object at this particular tracepoint (or possibly null).">
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.equals(Object)" access="pub" jdoc="Returns true iff the given VarValue refers to the same variable as this one (compares name, type, and kind).">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.VarValue.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.SMLinkedList" intfc="n" abs="n" inn="n" sloc="9" jdoc="">
			<field name="next" access="pub" jdoc=""/>
			<field name="data" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.SMLinkedList.SMLinkedList(SMLinkedList, String)" access="pub" jdoc="">
				<param name="l"/>
				<param name="d"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.SandmarkListHolder" intfc="n" abs="n" inn="n" sloc="98" jdoc="">
			<field name="thread2str" access="priv" jdoc=""/>
			<field name="mutex" access="pub" jdoc=""/>
			<field name="head" access="pub" jdoc=""/>
			<field name="tail" access="pub" jdoc=""/>
			<field name="count" access="pub" jdoc=""/>
			<field name="filename" access="pub" jdoc=""/>
			<field name="writer" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.SandmarkListHolder.start(String)" access="pub" jdoc="">
				<param name="init"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.SandmarkListHolder.finish()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.SandmarkListHolder.run()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.SandmarkListHolder.concat(String, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.SandmarkListHolder.concat(String, long)" access="pub" jdoc="">
				<param name="name"/>
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.SandmarkListHolder.concat(String, float)" access="pub" jdoc="">
				<param name="name"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.SandmarkListHolder.concat(String, double)" access="pub" jdoc="">
				<param name="name"/>
				<param name="d"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.SandmarkListHolder.concat(String, Object)" access="pub" jdoc="">
				<param name="name"/>
				<param name="obj"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.ContextCodeGen" intfc="n" abs="n" inn="n" sloc="126" jdoc="">
			<field name="mCondGen" access="prot" jdoc=""/>
			<field name="mGens" access="prot" jdoc=""/>
			<field name="isLengthOne" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.ContextCodeGen.ContextCodeGen(sandmark.program.Application, java.util.Iterator)" access="pub" jdoc="">
				<param name="app"/>
				<param name="nodes"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ContextCodeGen.insert(String)" access="pub" jdoc="">
				<param name="bits"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.RecognitionIterator" intfc="n" abs="n" inn="n" sloc="36" jdoc="">
			<field name="f" access="pub" jdoc=""/>
			<field name="nextNode" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.RecognitionIterator.RecognitionIterator(java.io.File)" access="pub" jdoc="">
				<param name="file"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.RecognitionIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.RecognitionIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.RecognitionIterator.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.RecognitionIterator.getNext()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.TraceGetter" intfc="n" abs="n" inn="n" sloc="161" jdoc="">
			<field name="mVM" access="priv" jdoc=""/>
			<field name="exited" access="priv" jdoc=""/>
			<field name="error" access="priv" jdoc=""/>
			<field name="outputFile" access="priv" jdoc=""/>
			<field name="didSetFileName" access="priv" jdoc=""/>
			<field name="exitEvent" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.TraceGetter(String, java.io.File)" access="pub" jdoc="">
				<comm cntt="suspend.setValue(&amp;quot;&amp;quot;);"/>
				<comm cntt="vm.setDebugTraceMode(~0);"/>
				<param name="cmdLine"/>
				<param name="outputFile"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.startTracing()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.run()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.setFileName(com.sun.jdi.ClassType)" access="priv" jdoc="">
				<param name="classType"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.kill()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.exited(boolean)" access="priv" jdoc="">
				<param name="err"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.waitForExit()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.dumpTrace()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.getTrace()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceGetter.main(String)" access="pub" jdoc="">
				<comm cntt="new LoopCodeGen(app,new TraceNode[] {"/>
				<comm cntt="new TraceNode(null,null), XXXash need a valid line"/>
				<comm cntt="}).insert(wm);"/>
				<comm cntt="XXXash fixme: Analyzer.getBitSequence(nodes);"/>
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.ConditionGenerator" intfc="n" abs="n" inn="n" sloc="1086" jdoc="">
			<const name="ISUNIQUESOFAR" access="priv" jdoc=""/>
			<const name="ISEVEN" access="priv" jdoc=""/>
			<const name="ISGTZERO" access="priv" jdoc=""/>
			<const name="ISLTZERO" access="priv" jdoc=""/>
			<const name="ISNAN" access="priv" jdoc=""/>
			<const name="ISPOSINF" access="priv" jdoc=""/>
			<const name="ISNEGINF" access="priv" jdoc=""/>
			<const name="ISNULL" access="priv" jdoc=""/>
			<const name="ISLOWERCASE" access="priv" jdoc=""/>
			<const name="ISUPPERCASE" access="priv" jdoc=""/>
			<const name="ISDIGIT" access="priv" jdoc=""/>
			<const name="ISNONNULLUNHASHABLE" access="priv" jdoc=""/>
			<const name="MASK" access="priv" jdoc=""/>
			<field name="types" access="priv" jdoc=""/>
			<field name="traceNodes" access="priv" jdoc=""/>
			<field name="storedTraceNodes" access="priv" jdoc=""/>
			<field name="application" access="priv" jdoc=""/>
			<field name="clazz" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.ConditionGenerator(java.util.Iterator, sandmark.program.Application)" access="pub" jdoc="">
				<param name="nodes"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.getConditions(int, boolean)" access="pub" jdoc="This method returns an iterator of InstructionLists that all end in an IfInstruction branch that may be taken if you were to insert these instructions right before the nth occurrence of the tracepoint specified in the constructor. The IfInstructions will all target themselves to start with, and must be reset.">
				<comm cntt="compute single-var info"/>
				<comm cntt="compute variable pair info"/>
				<comm cntt="if equal basic types"/>
				<comm cntt="if types are ReferenceTypes but not UninitializedObjectTypes"/>
				<comm cntt="get instruction lists"/>
				<comm cntt="compute all pairs"/>
				<comm cntt="compute all triples"/>
				<param name="nth"/>
				<param name="taken"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generatePAIRSEQUAL(java.util.Hashtable, VarValue[], int, org.apache.bcel.generic.Instruction[][], boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<comm cntt="first true, look for several false falses (two unhashables that may be equal)"/>
				<comm cntt="first false"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="int, char, byte, short, boolean"/>
				<comm cntt="puts a 1 0"/>
				<param name="areequal"/>
				<param name="vars"/>
				<param name="nth"/>
				<param name="fetch"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.getFeatures(long[], long[], long[], int)" access="priv" jdoc="">
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="nth"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.printFeatures(long)" access="priv" jdoc="">
				<param name="features"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISUNIQUESOFAR(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<comm cntt="exclude this case"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="int, short, byte, char, boolean"/>
				<comm cntt="((b-a)&amp;gt;&amp;gt;31 | (a-b)&amp;gt;&amp;gt;31) ^ 1"/>
				<comm cntt="puts a 1 0"/>
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISEVEN(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<comm cntt="do nothing"/>
				<comm cntt="which==true"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="int, short, byte, char, boolean"/>
				<comm cntt="which==true"/>
				<comm cntt="puts a 1 0"/>
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISGTZERO(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<comm cntt="do nothing"/>
				<comm cntt="which==false"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="which==false"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="which==false"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="int, byte, short, boolean, char"/>
				<comm cntt="puts a 1 0"/>
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISLTZERO(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<comm cntt="do nothing"/>
				<comm cntt="which==false"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="which==false"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="which==false"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="int, byte, short, boolean, char"/>
				<comm cntt="which==false"/>
				<comm cntt="puts a 1 0"/>
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISPOSINF(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<comm cntt="which==true"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="which==true"/>
				<comm cntt="puts a 1 0"/>
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISNEGINF(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<comm cntt="which==true"/>
				<comm cntt="puts a 1 0"/>
				<comm cntt="which==true"/>
				<comm cntt="puts a 1 0"/>
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISNULL(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISINTINRANGE(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List, boolean, int, int)" access="priv" jdoc="">
				<comm cntt="on stack: isUpperCase, isLowerCase"/>
				<comm cntt="which==false"/>
				<comm cntt="puts a 1 0"/>
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
				<param name="which"/>
				<param name="min"/>
				<param name="max"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISLOWERCASE(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISUPPERCASE(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateISDIGIT(long[], long[], long[], VarValue[], int, org.apache.bcel.generic.Instruction[], org.apache.bcel.generic.ConstantPoolGen, boolean, java.util.List, java.util.List)" access="priv" jdoc="">
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="vars"/>
				<param name="i"/>
				<param name="fetch"/>
				<param name="cpg"/>
				<param name="taken"/>
				<param name="combinable"/>
				<param name="standalone"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.generateInstructionLists(long[], long[], long[], int, java.util.Hashtable, boolean)" access="priv" jdoc="">
				<param name="nthfeatures"/>
				<param name="firsttrue"/>
				<param name="firstfalse"/>
				<param name="nth"/>
				<param name="areequal"/>
				<param name="taken"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.getFetch(VarValue)" access="priv" jdoc="">
				<comm cntt="int, char, bool, short, byte"/>
				<param name="var"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.getBasicTypeFeatures(int, VarValue, int)" access="priv" jdoc="">
				<comm cntt="var is the VarValue for the desired variable and stage"/>
				<comm cntt="test ISUNIQUESOFAR"/>
				<comm cntt="get the value and turn it into a double (safe?)"/>
				<comm cntt="test ISGTZERO"/>
				<comm cntt="test ISLTZERO"/>
				<comm cntt="test ISNAN"/>
				<comm cntt="test ISPOSINF"/>
				<comm cntt="test ISNEGINF"/>
				<comm cntt="get the value and turn it into a long"/>
				<comm cntt="Long"/>
				<param name="stage"/>
				<param name="var"/>
				<param name="varindex"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.integralFeatures(long, boolean)" access="priv" jdoc="">
				<comm cntt="test ISEVEN"/>
				<comm cntt="test ISGTZERO"/>
				<comm cntt="test ISLTZERO"/>
				<comm cntt="test ISLOWERCASE"/>
				<comm cntt="test ISUPPERCASE"/>
				<comm cntt="test ISDIGIT"/>
				<param name="value"/>
				<param name="isSmallIntegral"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.getObjectTypeFeatures(int, VarValue, int)" access="priv" jdoc="">
				<comm cntt="test for ISUNIQUESOFAR"/>
				<comm cntt="nonnull hashable object"/>
				<param name="stage"/>
				<param name="var"/>
				<param name="varindex"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.ConditionGenerator.main(String)" access="pub" jdoc="">
				<comm cntt="XXXash need to use TraceIndexer"/>
				<comm cntt="XXXash need an iterator"/>
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.Tracer" intfc="n" abs="n" inn="n" sloc="600" jdoc="This class modifies an Application to produce an execution trace of itself at runtime. To do this, we add a new class to the application that has a single static Vector in it, and at the beginning of every basic block throughout the rest of the application, code is inserted to add a string into this static vector that contains information about the current state of the program. This is the first phase of the execution path watermarker.">
			<comm cntt="the name of the class holding the static vector"/>
			<comm cntt="the Class object for the class holding the static vector"/>
			<comm cntt="the Field object for the static vector itself"/>
			<const name="typehash" access="priv" jdoc=""/>
			<const name="UNPRINTABLE" access="priv" jdoc=""/>
			<const name="BASIC" access="priv" jdoc=""/>
			<const name="OBJECT" access="priv" jdoc=""/>
			<field name="application" access="priv" jdoc=""/>
			<field name="listHolderClassName" access="priv" jdoc=""/>
			<field name="listHolderClass" access="priv" jdoc=""/>
			<field name="listfield" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.Tracer.Tracer(sandmark.program.Application, boolean)" access="pub" jdoc="Modifies the given application to contain trace code.">
				<comm cntt="for each class"/>
				<comm cntt="for each method"/>
				<comm cntt="REMOVE THIS LATER!!!!!"/>
				<comm cntt="hashes strings to basic blocks"/>
				<comm cntt="hashes original BBs to pairs of BB[2]{last, subroutine}, where subroutine may be null"/>
				<comm cntt="for each basic block"/>
				<comm cntt="determine how to print each local var"/>
				<comm cntt="and which subroutine to jump to"/>
				<comm cntt="hacky test to see if I&amp;apos;m preceeded by the first half"/>
				<comm cntt="of a long or double"/>
				<comm cntt="get stack info"/>
				<comm cntt="this BB will have either a JSR or an inlined subroutine."/>
				<comm cntt="it goes right before the current BB"/>
				<comm cntt="no subroutine, make it"/>
				<comm cntt="inline the subroutine"/>
				<comm cntt="subroutine already exists, put in a jump to it"/>
				<comm cntt="not tracing variables"/>
				<comm cntt="now that I&amp;apos;ve made all the subroutines and last blocks, add them to the cfg with edges"/>
				<comm cntt="add last"/>
				<comm cntt="add subroutine"/>
				<comm cntt="reset all branches that target the beginning of bb to the beginning of last"/>
				<comm cntt="DO NOT REPLACE THIS WITH ilist.redirectExceptionHandlers!!!!"/>
				<comm cntt="fix CFG edges"/>
				<comm cntt="getByteCode() might throw an exception if the method gets"/>
				<comm cntt="too big, or if the branches get spaced too far away"/>
				<comm cntt="so that the offsets are &amp;gt;32k"/>
				<param name="app"/>
				<param name="traceVars"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Tracer.getTraceCode(sandmark.analysis.controlflowgraph.BasicBlock, sandmark.program.Method, String, org.apache.bcel.generic.ConstantPoolGen, sandmark.analysis.controlflowgraph.MethodCFG, org.apache.bcel.generic.InstructionFactory)" access="priv" jdoc="">
				<param name="bb"/>
				<param name="method"/>
				<param name="classname"/>
				<param name="cpg"/>
				<param name="cfg"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Tracer.getSubroutine(int[], sandmark.analysis.defuse.ReachingDefs, org.apache.bcel.generic.ConstantPoolGen, sandmark.analysis.controlflowgraph.MethodCFG, org.apache.bcel.generic.InstructionFactory, String, sandmark.program.Method, sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="">
				<param name="localtypes"/>
				<param name="localdefs"/>
				<param name="cpg"/>
				<param name="cfg"/>
				<param name="factory"/>
				<param name="classname"/>
				<param name="method"/>
				<param name="bb"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Tracer.setupListHolderClass()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.Tracer.hasMultipleTypes(java.util.Set)" access="priv" jdoc="">
				<param name="defs"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Tracer.isPrintable(org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="vartype"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Tracer.makePrinter(sandmark.program.Class, boolean, org.apache.bcel.generic.InstructionFactory)" access="priv" jdoc="">
				<comm cntt="&amp;quot;{if}:&amp;quot;"/>
				<comm cntt="&amp;quot;{if}:thread&amp;quot;"/>
				<comm cntt="&amp;quot;{if}:thread:class:&amp;quot;"/>
				<comm cntt="&amp;quot;{if}:thread:class:method&amp;quot;"/>
				<comm cntt="&amp;quot;{if}:thread:class:method:&amp;quot;"/>
				<comm cntt="&amp;quot;{if}:thread:class:method:offset&amp;quot;"/>
				<comm cntt="&amp;quot;{if}:thread:class:method:offset:&amp;quot;"/>
				<comm cntt="on stack: &amp;quot;{if}:thread:method:offset:numsuccs&amp;quot;"/>
				<comm cntt="on stack: &amp;quot;{if}:thread:method:offset:numsuccs::&amp;quot;"/>
				<comm cntt="now do the fields"/>
				<comm cntt="must separate out the static fields from the instance fields"/>
				<comm cntt="print out static fields"/>
				<comm cntt="end for each static field"/>
				<comm cntt="stack: out, &amp;quot;thread:method:numsuccs:num:S var1=___:S var2=___&amp;quot;"/>
				<comm cntt="set up a branch to skip the instance fields, if no instance is supplied"/>
				<comm cntt="this target must be changed later!!"/>
				<comm cntt="print out instance fields"/>
				<comm cntt="end for each instance field"/>
				<comm cntt="not tracing vars"/>
				<param name="clazz"/>
				<param name="traceVars"/>
				<param name="factory"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Tracer.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.LoopCodeGen" intfc="n" abs="n" inn="n" sloc="93" jdoc="">
			<mth name="/:sandmark.watermark.execpath.LoopCodeGen.LoopCodeGen(sandmark.program.Application, java.util.Iterator)" access="pub" jdoc="">
				<param name="app"/>
				<param name="nodes"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.LoopCodeGen.insert(String)" access="pub" jdoc="">
				<param name="bits"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.Analyzer" intfc="n" abs="n" inn="n" sloc="175" jdoc="This class can do some analysis on the trace list made by a program that has run through Tracer.">
			<field name="threadInfo" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.Analyzer.Analyzer(java.util.Iterator)" access="pub" jdoc="">
				<param name="output"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer.getTrace(String)" access="pub" jdoc="">
				<param name="threadName"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer.getBitSequence(TraceIndexer, String, java.util.Iterator)" access="pub" jdoc="Returns the bit sequence represented by the given list of TraceNodes. The output of getTrace is the preferred input to this method.">
				<param name="index"/>
				<param name="mainThread"/>
				<param name="it"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer.getLocationOccurrences(TraceNode, TraceNode)" access="pub" jdoc="">
				<param name="node"/>
				<param name="nodes"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer.parse(java.util.Iterator)" access="priv" jdoc="Takes in a raw trace list and the name of the thread to trace and produces a list of TraceNodes that characterize the program execution. @param output the static list variable generated by a Traced program. @param thread the name of the thread to trace (i.e. &amp;quot;main&amp;quot;)">
				<param name="output"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer.pad(int, String)" access="priv" jdoc="">
				<param name="numsuccs"/>
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer.getThreadNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer.main(String)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;\n&amp;quot;+nodes == null ? null : getBitSequence(nodes));"/>
				<param name="args"/>
			</mth>
		<class name="/:sandmark.watermark.execpath.Analyzer$Method" intfc="n" abs="n" inn="y" sloc="19" jdoc="">
			<field name="methodName" access="pub" jdoc=""/>
			<field name="className" access="pub" jdoc=""/>
			<field name="methodSig" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.Analyzer$Method.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer$Method.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer$Method.Method(String, String, String)" access="pub" jdoc="">
				<param name="m"/>
				<param name="s"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.Analyzer$Instruction" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<field name="offset" access="pub" jdoc=""/>
			<field name="method" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.Analyzer$Instruction.Instruction(String, String, String, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="s"/>
				<param name="c"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer$Instruction.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.Analyzer$Instruction.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.Analyzer$InstructionInfo" intfc="n" abs="n" inn="y" sloc="9" jdoc="">
			<field name="count" access="pub" jdoc=""/>
			<field name="numsuccs" access="pub" jdoc=""/>
			<field name="isIfSwitch" access="pub" jdoc=""/>
			<field name="succs" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.Analyzer$InstructionInfo.InstructionInfo(int, boolean)" access="pub" jdoc="">
				<param name="succs"/>
				<param name="iis"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.Analyzer$ThreadInfo" intfc="n" abs="n" inn="y" sloc="9" jdoc="">
			<field name="instructionInfo" access="pub" jdoc=""/>
			<field name="lastInstruction" access="pub" jdoc=""/>
			<field name="lastInstructionInfo" access="pub" jdoc=""/>
			<field name="threadName" access="pub" jdoc=""/>
			<field name="nodeList" access="pub" jdoc=""/>
			<field name="nodes" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.Analyzer$ThreadInfo.ThreadInfo(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.execpath.NodeIterator" intfc="n" abs="n" inn="n" sloc="26" jdoc="">
			<field name="file" access="priv" jdoc=""/>
			<field name="current" access="priv" jdoc=""/>
			<field name="offsetList" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.NodeIterator.NodeIterator(java.util.List, java.io.File)" access="pub" jdoc="">
				<param name="offsets"/>
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.NodeIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.NodeIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.NodeIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.EPW" intfc="n" abs="n" inn="n" sloc="331" jdoc="">
			<const name="METHOD_LENGTH_LIMIT" access="priv" jdoc=""/>
			<const name="LOOP_WM_RATIO" access="priv" jdoc=""/>
			<field name="mTG" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<field name="mTraceFile" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.EPW.startTracing(sandmark.watermark.DynamicTraceParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.endTracing()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.stopTracing()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.embed(sandmark.watermark.DynamicEmbedParameters)" access="pub" jdoc="">
				<comm cntt="System.out.println(ins.list);"/>
				<comm cntt="System.out.println(&amp;quot;inserted into &amp;quot; + ins.codeGen.mMethod + &amp;quot; at &amp;quot; +"/>
				<comm cntt="ins.codeGen.mIH);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.startRecognition(sandmark.watermark.DynamicRecognizeParameters)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;tracing&amp;quot;);"/>
				<comm cntt="System.out.println(&amp;quot;done&amp;quot;);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.watermarks()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.stopRecognition()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.waitForProgramExit()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getStrs(java.math.BigInteger)" access="priv" jdoc="">
				<comm cntt="System.out.println(parts[i]);"/>
				<comm cntt="System.out.println(&amp;quot;part &amp;quot; + parts[i].toString(2));"/>
				<comm cntt="System.out.println(strs[i]);"/>
				<param name="parts"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getInt(String)" access="pub" jdoc="">
				<param name="str"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.EPW.main(String)" access="pub" jdoc="">
				<comm cntt="sandmark.program.Application app = new sandmark.program.Application(inputFile); sandmark.program.Class cls = (sandmark.program.Class)app.classes().next(); sandmark.program.Method method = cls.getMethod(&amp;quot;main&amp;quot;,&amp;quot;([Ljava lang String;)V&amp;quot;); java.util.LinkedList list = new java.util.LinkedList(); list.add(new TraceNode(&amp;quot;{}:234:&amp;quot; + cls.getName() + &amp;quot;:&amp;quot; + method.getName() + method.getSignature() + &amp;quot;:0:1:::&amp;quot;,null)); new LoopCodeGen(app,list.iterator()).insert(&amp;quot;010110111011111011111111&amp;quot;); app.save(&amp;quot;foo.jar&amp;quot;);"/>
				<param name="argv"/>
			</mth>
		<class name="/:sandmark.watermark.execpath.EPW$Insertion" intfc="n" abs="n" inn="y" sloc="5" jdoc="">
			<field name="codeGen" access="pub" jdoc=""/>
			<field name="bits" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.EPW$Insertion.Insertion(WMCodeGen, String)" access="pub" jdoc="">
				<param name="c"/>
				<param name="b"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.execpath.TraceIndexer" intfc="n" abs="n" inn="n" sloc="62" jdoc="">
			<field name="file" access="priv" jdoc=""/>
			<field name="bb2OffsetList" access="priv" jdoc=""/>
			<field name="threadToLength" access="priv" jdoc=""/>
			<field name="traceLength" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer.TraceIndexer(java.io.File)" access="pub" jdoc="">
				<param name="traceFile"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer.getThreadLengths()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer.getTraceLength()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer.getTracePoints(String)" access="pub" jdoc="">
				<param name="threadName"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer.getOffsetList(TracePoint)" access="pub" jdoc="">
				<param name="t"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		<class name="/:sandmark.watermark.execpath.TraceIndexer$TracePoint" intfc="n" abs="n" inn="y" sloc="31" jdoc="">
			<field name="threadname" access="pub" jdoc=""/>
			<field name="classname" access="pub" jdoc=""/>
			<field name="methodname" access="pub" jdoc=""/>
			<field name="offset" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer$TracePoint.TracePoint(String, String, String, int)" access="pub" jdoc="">
				<param name="thread"/>
				<param name="clazz"/>
				<param name="method"/>
				<param name="off"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer$TracePoint.TracePoint(TraceNode)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer$TracePoint.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer$TracePoint.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceIndexer$TracePoint.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.execpath.StreamPump" intfc="n" abs="n" inn="n" sloc="16" jdoc="">
			<field name="mStream" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.StreamPump.StreamPump(java.io.InputStream)" access="pub" jdoc="">
				<param name="is"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.StreamPump.run()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.TraceReader" intfc="n" abs="n" inn="n" sloc="18" jdoc="">
			<field name="nextLine" access="pub" jdoc=""/>
			<field name="reader" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.TraceReader.TraceReader(java.io.File)" access="pub" jdoc="">
				<param name="tf"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceReader.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceReader.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceReader.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.TraceNode" intfc="n" abs="n" inn="n" sloc="74" jdoc="This class contains the trace info at the start of one particular basic block. Trace info includes static instance local variable values, offset of the starting instruction of the BB, number of successors of the BB, class method method signature containing the BB, and the bits (if any) generated by running this basic block, and also whether these bits appear in the final bit sequence string.">
			<const name="TYPE_IF" access="pub" jdoc=""/>
			<const name="TYPE_SWITCH" access="pub" jdoc=""/>
			<const name="TYPE_OTHER" access="pub" jdoc=""/>
			<field name="varvalues" access="priv" jdoc=""/>
			<field name="offset" access="priv" jdoc=""/>
			<field name="numSuccessors" access="priv" jdoc=""/>
			<field name="threadName" access="priv" jdoc=""/>
			<field name="className" access="priv" jdoc=""/>
			<field name="methodName" access="priv" jdoc=""/>
			<field name="methodSignature" access="priv" jdoc=""/>
			<field name="bits" access="priv" jdoc=""/>
			<field name="nodeType" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.TraceNode.TraceNode(String, String)" access="prot" jdoc="">
				<param name="line"/>
				<param name="bit"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.getNodeType()" access="pub" jdoc="Returns an int indicating the type of bb this is (one of TYPE_IF, TYPE_SWITCH, or TYPE_OTHER).">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.getBits()" access="pub" jdoc="Returns the piece of the bit string generated at this point in the trace (may be &amp;quot;&amp;quot;).">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.getOffset()" access="pub" jdoc="Returns the offset of the first instruction in this BB.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.getNumSuccessors()" access="pub" jdoc="Returns the number of successors of this BB.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.getThreadName()" access="pub" jdoc="Returns the name of the current thread in this trace.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.getClassName()" access="pub" jdoc="Returns the name of the class whose method contains this trace point.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.getMethodName()" access="pub" jdoc="Returns the method in which this trace point exists.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.getMethodSignature()" access="pub" jdoc="The signature of getMethodName()">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.getVarValues()" access="pub" jdoc="Returns a list of static instance local variables along with their values at this trace point.">
			</mth>
			<mth name="/:sandmark.watermark.execpath.TraceNode.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.WMCodeGen" intfc="n" abs="n" inn="n" sloc="136" jdoc="">
			<field name="mMethod" access="prot" jdoc=""/>
			<field name="mIH" access="prot" jdoc=""/>
			<field name="mNodes" access="prot" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen.WMCodeGen(sandmark.program.Application, java.util.Iterator)" access="pub" jdoc="">
				<param name="app"/>
				<param name="nodes"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen.insert(String)" access="pub" jdoc="">
				<param name="bits"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen.updateTargeters(org.apache.bcel.generic.InstructionHandle, org.apache.bcel.generic.InstructionHandle)" access="prot" jdoc="">
				<param name="orig"/>
				<param name="newH"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen.incrementLocals(org.apache.bcel.generic.InstructionList, int)" access="priv" jdoc="">
				<param name="list"/>
				<param name="inc"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen.main(String)" access="pub" jdoc="">
				<comm cntt="XXXash need a valid line"/>
				<comm cntt="new WMCodeGen(app,new TraceNode[] {node}).insert(&amp;quot;011001&amp;quot;);"/>
				<param name="argv"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen.findLiveInt()" access="prot" jdoc="">
			</mth>
		<class name="/:sandmark.watermark.execpath.WMCodeGen$CodeGenException" intfc="n" abs="n" inn="y" sloc="3" jdoc="">
			<mth name="/:sandmark.watermark.execpath.WMCodeGen$CodeGenException.CodeGenException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.execpath.WMCodeGen$PushBackIterator" intfc="n" abs="n" inn="y" sloc="22" jdoc="">
			<field name="lastItem" access="pub" jdoc=""/>
			<field name="pushedBack" access="pub" jdoc=""/>
			<field name="it" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen$PushBackIterator.PushBackIterator(java.util.Iterator)" access="pub" jdoc="">
				<param name="it"/>
			</mth>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen$PushBackIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen$PushBackIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen$PushBackIterator.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.execpath.WMCodeGen$PushBackIterator.pushBack()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.gtw">
		<class name="/:sandmark.watermark.gtw.ClusterGraph" intfc="n" abs="y" inn="n" sloc="58" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="APP" access="pub" jdoc=""/>
			<field name="WMARK" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.ClusterGraph.randomlyWalkAddingEdges(java.util.ArrayList, java.util.ArrayList, int)" access="pub" jdoc="">
				<param name="appNodes"/>
				<param name="wmarkNodes"/>
				<param name="crossEdgeCount"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.ClusterGraph.containsDisconnectedNode(java.util.ArrayList)" access="priv" jdoc="">
				<param name="nodes"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.ClusterGraph.synthesizeEdge(Object, int, Object, int)" access="prot" jdoc="">
				<param name="node1"/>
				<param name="node1Type"/>
				<param name="node2"/>
				<param name="node2Type"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.ClusterGraph.isLegalEdge(Object, int, Object, int)" access="prot" jdoc="">
				<param name="node1"/>
				<param name="node1Type"/>
				<param name="node2"/>
				<param name="node2Type"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.CFGComparator" intfc="n" abs="n" inn="n" sloc="11" jdoc="">
			<mth name="/:sandmark.watermark.gtw.CFGComparator.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.GTWRecognizer" intfc="n" abs="n" inn="n" sloc="153" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="mMarkedMethods" access="priv" jdoc=""/>
			<field name="mHasNext" access="priv" jdoc=""/>
			<field name="mDumpDot" access="priv" jdoc=""/>
			<field name="useCRT" access="priv" jdoc=""/>
			<field name="configProperties" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.GTWRecognizer.GTWRecognizer(sandmark.program.Application, sandmark.util.ConfigProperties, java.math.BigInteger)" access="pub" jdoc="">
				<param name="app"/>
				<param name="props"/>
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTWRecognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTWRecognizer.isLastMark()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTWRecognizer.next()" access="pub" jdoc="">
				<comm cntt="System.out.println(cfg.toDot());"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTWRecognizer.setNextPermutation()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTWRecognizer.remove()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.watermark.gtw.GTWRecognizer$MarkedMethod" intfc="n" abs="n" inn="y" sloc="12" jdoc="">
			<field name="name" access="pub" jdoc=""/>
			<field name="value" access="pub" jdoc=""/>
			<field name="index" access="pub" jdoc=""/>
			<field name="marks" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.GTWRecognizer$MarkedMethod.MarkedMethod(String, java.math.BigInteger, int, java.math.BigInteger)" access="pub" jdoc="">
				<param name="nm"/>
				<param name="m"/>
				<param name="n"/>
				<param name="mks"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.gtw.FunctionClusterGraph" intfc="n" abs="n" inn="n" sloc="222" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<const name="WM_METHOD_REAL_CALL_THRESHHOLD" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.FunctionClusterGraph.FunctionClusterGraph(sandmark.analysis.controlflowgraph.ProgramCFG)" access="pub" jdoc="">
				<param name="pCFG"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.FunctionClusterGraph.buildClusters(sandmark.analysis.controlflowgraph.ProgramCFG)" access="priv" jdoc="">
				<param name="pcfg"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.FunctionClusterGraph.buildClusterEdges(sandmark.analysis.controlflowgraph.ProgramCFG)" access="priv" jdoc="">
				<param name="pcfg"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.FunctionClusterGraph.synthesizeEdge(Object, int, Object, int)" access="prot" jdoc="">
				<comm cntt="Choose a random edge contained in the origin cluster"/>
				<param name="node1"/>
				<param name="node1Type"/>
				<param name="node2"/>
				<param name="node2Type"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.FunctionClusterGraph.getRandomEdge(sandmark.analysis.controlflowgraph.MethodCFG, int)" access="priv" jdoc="">
				<param name="methodCFG"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.FunctionClusterGraph.isLegalEdge(Object, int, Object, int)" access="prot" jdoc="">
				<param name="node1"/>
				<param name="node1Type"/>
				<param name="node2"/>
				<param name="node2Type"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.FunctionClusterGraph.hasSplitableEdge(sandmark.analysis.controlflowgraph.MethodCFG, int)" access="prot" jdoc="">
				<param name="cfg"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.FunctionClusterGraph.isSplitableEdge(sandmark.analysis.controlflowgraph.MethodCFG, sandmark.analysis.controlflowgraph.BasicBlock, sandmark.analysis.controlflowgraph.BasicBlock, int)" access="prot" jdoc="">
				<param name="cfg"/>
				<param name="src"/>
				<param name="dest"/>
				<param name="type"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.FunctionClusterGraph.nodeName(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.GTW" intfc="n" abs="n" inn="n" sloc="343" jdoc="">
			<field name="DEBUG" access="pub" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.GTW.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getConfigProperties()" access="pub" jdoc="">
				<comm cntt="{&amp;quot;GTW_GRAPHCODEC&amp;quot;,&amp;quot;PermutationGraph&amp;quot;, &amp;quot;What graph codec to use to go from &amp;quot; + &amp;quot;watermark number to CFG and back&amp;quot;, &amp;quot;true&amp;quot;,&amp;quot;S&amp;quot;,}, {&amp;quot;GTW_CFS&amp;quot;,&amp;quot;ControlFlowSynthesizer&amp;quot;, &amp;quot;What CFS to use&amp;quot;,&amp;quot;true&amp;quot;,&amp;quot;S&amp;quot;,}, {&amp;quot;GTW_BBM&amp;quot;,&amp;quot;ParityBlockMarker&amp;quot;, &amp;quot;What block marker to use&amp;quot;,&amp;quot;true&amp;quot;,&amp;quot;S&amp;quot;,}, {&amp;quot;GTW_VALUESPLITTER&amp;quot;,&amp;quot;Scientific Notation&amp;quot;, &amp;quot;What value splitter to use&amp;quot;,&amp;quot;true&amp;quot;,&amp;quot;S&amp;quot;,},"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<comm cntt=".getProperty(&amp;quot;Dump Dot Graphs&amp;quot;).equals(&amp;quot;true&amp;quot;),"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.main(String)" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.GTW.getNumberOfEdgesToAdd(ClusterGraph, java.util.ArrayList, java.util.ArrayList, java.util.Random)" access="priv" jdoc="">
				<param name="cg"/>
				<param name="programCFGs"/>
				<param name="wmCFGs"/>
				<param name="rnd"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.gtw.eigen">
		<class name="/:sandmark.watermark.gtw.eigen.Graph" intfc="n" abs="n" inn="n" sloc="37" jdoc="">
			<field name="vertices" access="priv" jdoc=""/>
			<field name="adjacencyLists" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.Graph.Graph(int)" access="pub" jdoc="">
				<param name="_vertices"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.Graph.checkRange(int)" access="priv" jdoc="">
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.Graph.addEdge(int, int)" access="pub" jdoc="">
				<param name="v1"/>
				<param name="v2"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.Graph.containsEdge(int, int)" access="pub" jdoc="">
				<param name="v1"/>
				<param name="v2"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.Graph.degree(int)" access="pub" jdoc="">
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.Graph.numVertices()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.watermark.gtw.eigen.Graph$Edge" intfc="n" abs="n" inn="y" sloc="19" jdoc="">
			<field name="v1" access="priv" jdoc=""/>
			<field name="v2" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.Graph$Edge.Edge(int, int)" access="pub" jdoc="">
				<param name="_v1"/>
				<param name="_v2"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.Graph$Edge.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.Graph$Edge.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.GraphEigenvalues" intfc="n" abs="n" inn="n" sloc="25" jdoc="">
			<field name="r" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphEigenvalues.GraphEigenvalues(int)" access="pub" jdoc="">
				<param name="vertices"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphEigenvalues.main(String[])" access="pub" jdoc="">
				<param name="argv"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.SumsPanel" intfc="n" abs="n" inn="n" sloc="38" jdoc="">
			<field name="model" access="priv" jdoc=""/>
			<const name="BORDER" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.SumsPanel.SumsPanel(SumData)" access="pub" jdoc="">
				<param name="_model"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumsPanel.getCoord(double)" access="priv" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumsPanel.drawSet(Graphics, Color, int, int)" access="priv" jdoc="">
				<param name="g"/>
				<param name="c"/>
				<param name="set"/>
				<param name="y"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumsPanel.paintComponent(Graphics)" access="prot" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.EigenData" intfc="n" abs="n" inn="n" sloc="10" jdoc="">
			<field name="e" access="pub" jdoc=""/>
			<field name="a" access="pub" jdoc=""/>
			<field name="b" access="pub" jdoc=""/>
			<field name="sum" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.EigenData.EigenData(DoubleMatrix1D, double, double, double)" access="pub" jdoc="">
				<param name="_e"/>
				<param name="_a"/>
				<param name="_b"/>
				<param name="_sum"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.SumData" intfc="n" abs="n" inn="n" sloc="55" jdoc="">
			<field name="data" access="priv" jdoc=""/>
			<field name="numSets" access="priv" jdoc=""/>
			<field name="listeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData.SumData()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData.SumData(int)" access="pub" jdoc="">
				<param name="capacity"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData.getListener()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData.addListener(BasicListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData.signalChange()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData.increaseCapacity()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData.numSets()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData.setSize(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData.setElement(int, int)" access="pub" jdoc="">
				<param name="set"/>
				<param name="element"/>
			</mth>
		<class name="/:sandmark.watermark.gtw.eigen.SumData$DataSet" intfc="n" abs="n" inn="y" sloc="30" jdoc="">
			<field name="num" access="pub" jdoc=""/>
			<field name="data" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData$DataSet.DataSet(int)" access="pub" jdoc="">
				<param name="capacity"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData$DataSet.addElement(double)" access="pub" jdoc="">
				<param name="d"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData$DataSet.numElements()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData$DataSet.getElement(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData$DataSet.increaseCapacity()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.SumData$SumListener" intfc="n" abs="n" inn="y" sloc="12" jdoc="">
			<field name="dataSet" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData$SumListener.SumListener(int)" access="pub" jdoc="">
				<param name="_dataSet"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.SumData$SumListener.graphChanged(Graph, DoubleMatrix1D, double, double, double)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
				<param name="a"/>
				<param name="b"/>
				<param name="sum"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.GraphListener" intfc="y" abs="n" inn="n" sloc="4" jdoc="">
			<mth name="/:sandmark.watermark.gtw.eigen.GraphListener.graphChanged(Graph, DoubleMatrix1D, double, double, double)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
				<param name="a"/>
				<param name="b"/>
				<param name="sum"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.KPartiteGraphData" intfc="n" abs="n" inn="n" sloc="27" jdoc="">
			<field name="parts" access="priv" jdoc=""/>
			<field name="n" access="priv" jdoc=""/>
			<field name="p" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.KPartiteGraphData.KPartiteGraphData(int, int, double, GraphListener)" access="pub" jdoc="">
				<param name="_parts"/>
				<param name="_n"/>
				<param name="_p"/>
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.KPartiteGraphData.generateGraph(int, int, double)" access="priv" jdoc="">
				<param name="parts"/>
				<param name="n"/>
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.KPartiteGraphData.run()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.RandomGraphData" intfc="n" abs="n" inn="n" sloc="24" jdoc="">
			<field name="n" access="priv" jdoc=""/>
			<field name="p" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.RandomGraphData.RandomGraphData(int, double, GraphListener)" access="pub" jdoc="">
				<param name="_n"/>
				<param name="_p"/>
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.RandomGraphData.generateGraph(int, double)" access="priv" jdoc="">
				<param name="n"/>
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.RandomGraphData.run()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.EigenPanel" intfc="n" abs="n" inn="n" sloc="55" jdoc="">
			<field name="model" access="priv" jdoc=""/>
			<const name="BORDER" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.EigenPanel.EigenPanel(GraphData)" access="pub" jdoc="">
				<param name="_model"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.EigenPanel.getCoords(double, double, double)" access="priv" jdoc="">
				<param name="x"/>
				<param name="y"/>
				<param name="maxx"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.EigenPanel.drawTransformedLine(Graphics, double, double, double, double, double)" access="priv" jdoc="">
				<param name="g"/>
				<param name="x1"/>
				<param name="y1"/>
				<param name="x2"/>
				<param name="y2"/>
				<param name="maxx"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.EigenPanel.paintComponent(Graphics)" access="prot" jdoc="">
				<param name="g"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.RepaintingListener" intfc="n" abs="n" inn="n" sloc="22" jdoc="">
			<field name="c" access="priv" jdoc=""/>
			<field name="lastRepaint" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.RepaintingListener.RepaintingListener(JComponent)" access="pub" jdoc="">
				<comm cntt="There will be a repaint when the component is first shown."/>
				<param name="_c"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.RepaintingListener.action()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.RepaintingListener.somethingChanged()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.RepaintingListener.graphChanged(Graph, DoubleMatrix1D, double, double, double)" access="pub" jdoc="">
				<param name="g"/>
				<param name="e"/>
				<param name="a"/>
				<param name="b"/>
				<param name="sum"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.GraphPanel" intfc="n" abs="n" inn="n" sloc="31" jdoc="">
			<field name="model" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphPanel.GraphPanel(GraphData)" access="pub" jdoc="">
				<param name="_model"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphPanel.paintComponent(Graphics)" access="prot" jdoc="">
				<comm cntt="compute angle per vertex"/>
				<comm cntt="compute radius"/>
				<comm cntt="set color to black"/>
				<comm cntt="compute center"/>
				<comm cntt="draw vertices"/>
				<comm cntt="draw edges"/>
				<param name="gr"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.GraphData" intfc="n" abs="n" inn="n" sloc="73" jdoc="">
			<field name="g" access="priv" jdoc=""/>
			<field name="e" access="priv" jdoc=""/>
			<field name="a" access="priv" jdoc=""/>
			<field name="b" access="priv" jdoc=""/>
			<field name="sum" access="priv" jdoc=""/>
			<field name="listeners" access="priv" jdoc=""/>
			<const name="params" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphData.setGraph(Graph)" access="pub" jdoc="">
				<param name="g"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphData.GraphData(Graph, GraphListener)" access="pub" jdoc="">
				<param name="g"/>
				<param name="gl"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphData.addListener(GraphListener)" access="pub" jdoc="">
				<param name="gl"/>
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphData.getGraph()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphData.getEigenData()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.watermark.gtw.eigen.GraphData$BestFitParams" intfc="n" abs="n" inn="y" sloc="17" jdoc="">
			<field name="a11" access="pub" jdoc=""/>
			<field name="a12" access="pub" jdoc=""/>
			<field name="a21" access="pub" jdoc=""/>
			<field name="a22" access="pub" jdoc=""/>
			<field name="u" access="pub" jdoc=""/>
			<field name="v" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.gtw.eigen.GraphData$BestFitParams.BestFitParams(int)" access="pub" jdoc="">
				<param name="n"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.gtw.eigen.BasicListener" intfc="y" abs="n" inn="n" sloc="3" jdoc="">
			<mth name="/:sandmark.watermark.gtw.eigen.BasicListener.somethingChanged()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.hattrick">
		<class name="/:sandmark.watermark.hattrick.HatTrick" intfc="n" abs="n" inn="n" sloc="184" jdoc="">
			<comm cntt="Returns the base-10 digit mapped to the passed-in signature Each signature maps to a single base-10 digit."/>
			<comm cntt="changed java.io.InputStream to java.lang.Byte"/>
			<comm cntt="changed java.io.ObjectInputStream to java.lang.Number"/>
			<comm cntt="changed java.io.ObjectOutputStream to java.lang.StrictMath"/>
			<comm cntt="Returns this watermarker&amp;apos;s short name."/>
			<comm cntt="Returns this watermarker&amp;apos;s long name."/>
			<comm cntt="Get the HTML codes of the About page."/>
			<comm cntt="Get the URL of the Help page"/>
			<comm cntt="Embedding"/>
			<comm cntt="Recognition"/>
			<comm cntt="Return an iterator which generates the watermarks found in the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt; UL&amp;gt;"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<const name="SECRET_NAME" access="priv" jdoc=""/>
			<field name="classHash" access="priv" jdoc=""/>
			<field name="numHash" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getDigitFromSig(String)" access="pub" jdoc="">
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.getClassFromSig(String)" access="priv" jdoc="">
				<param name="signature"/>
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="Break down the watermark value into digits"/>
				<comm cntt="changed il.insert(newIl) to il.append(newIl)"/>
				<comm cntt="Add a &amp;quot;public static final String&amp;quot; field to the class to mark which method the watermark is in"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		<class name="/:sandmark.watermark.hattrick.HatTrick$Recognizer" intfc="n" abs="n" inn="y" sloc="71" jdoc="">
			<comm cntt="An iterator which generates the watermarks found in the program."/>
			<field name="result" access="pub" jdoc=""/>
			<field name="current" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.hattrick.HatTrick$Recognizer.Recognizer(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick$Recognizer.generate(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<comm cntt="Find the class and the method where the bogus variables are using the special field marker"/>
				<comm cntt="found the method, extract the name"/>
				<comm cntt="If this class had the method containing the watermark then extract the method&amp;apos;s local variable table and recover WM"/>
				<comm cntt="System.out.println(&amp;quot;currentBigInteger: &amp;quot; + currentBigInteger);"/>
				<comm cntt="System.out.println(&amp;quot;current wmInteger: &amp;quot; + wmInteger);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick$Recognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick$Recognizer.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.hattrick.HatTrick$Recognizer.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.mondenwmark">
		<class name="/:sandmark.watermark.mondenwmark.MondenWmark" intfc="n" abs="n" inn="n" sloc="384" jdoc="MondenWmark Watermarking @author Armand Navabi @version 1.0">
			<comm cntt="Embedding"/>
			<comm cntt="For testing and evaluation (script) purposes"/>
			<comm cntt="prefix to prevent false watermarks"/>
			<const name="PREFIX" access="pub" jdoc=""/>
			<field name="watermarkTest" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.numInstructions(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="while((watermarkCode.length() % 3) != 0) watermarkCode += &amp;quot;1&amp;quot;; because we use 3 bit codes"/>
				<comm cntt="System.out.println(&amp;quot;Random Key: &amp;quot; + randKey);"/>
				<comm cntt="Embed watermark in method with the most number of arithmetic ops."/>
				<comm cntt="Add instructions so that mg can encode the given watermark"/>
				<comm cntt="instrsAdded += methodCopy.getInstructionList().size();"/>
				<comm cntt="Now change the name of the dummyMethod, and add it so it becomes part of the class"/>
				<comm cntt="System.out.println(&amp;quot;WATERMARK CODE ENCODING: &amp;quot; + watermarkCode + &amp;quot; length of &amp;quot; + watermarkCode.length());"/>
				<comm cntt="encode watermarkCode"/>
				<comm cntt="System.out.println(watermarkCode.substring(startSub, endSub) + &amp;quot;: &amp;quot; + numericalValue);"/>
				<comm cntt="System.out.println(&amp;quot;numerical value: &amp;quot; + numericalValue);"/>
				<comm cntt="System.out.println(&amp;quot;tableKey: &amp;quot; + tableKey);"/>
				<comm cntt="System.out.println(&amp;quot;encoding opcode: &amp;quot; + tableKey);"/>
				<comm cntt="System.out.println(&amp;quot;Instruction Size: &amp;quot; + methodCopy.getInstructionList().size());"/>
				<comm cntt="instrsHandle = il.getInstructionHandles();"/>
				<comm cntt="for(int i = 4; i &amp;gt; 0; i--) System.out.println(instrsHandle[instrsHandle.length - i]);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.makeKey(String)" access="priv" jdoc="">
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.makeKey(int)" access="priv" jdoc="">
				<comm cntt="get random ordering"/>
				<comm cntt="now sort key array"/>
				<comm cntt="for(int k = 0; k &amp;lt; 8; k++) System.out.println(randomArray[k]);"/>
				<param name="randomSeed"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getOpIndex(char)" access="priv" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.buildCodeTable(String)" access="priv" jdoc="">
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.addInstrs(sandmark.program.Method, int)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot;METHOD: &amp;quot; + method);"/>
				<comm cntt="org.apache.bcel.generic.InstructionHandle[] ihs = il.getInstructionHandles();"/>
				<comm cntt="int moreOps = (wmarkLength - (getNumOps(method) 3)) 3;"/>
				<comm cntt="make sure there are at least on instruction to encode"/>
				<param name="method"/>
				<param name="wmarkLength"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getEncodeSize(sandmark.program.Method)" access="priv" jdoc="">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.isIArithmeticInstr(org.apache.bcel.generic.Instruction)" access="priv" jdoc="">
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.isNumericalInstr(org.apache.bcel.generic.Instruction)" access="priv" jdoc="">
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Random Key: &amp;quot; + randKey);"/>
				<comm cntt="if not instruction list, go to next method."/>
				<comm cntt="System.out.println(&amp;quot;Instruction: &amp;quot; + instructions[j]);"/>
				<comm cntt="System.out.println(currentWMark);"/>
				<comm cntt="System.out.println(&amp;quot;current wmark: &amp;quot; + currentWMark + &amp;quot; length: &amp;quot; + currentWMark.length());"/>
				<comm cntt="System.out.println(&amp;quot;decoded wmark: &amp;quot; + decodedWmark);"/>
				<comm cntt="if(recognizedWmark.equals(watermarkTest)) System.out.println(&amp;quot;WATERMARK RECOGNIZED!&amp;quot;);"/>
				<comm cntt="else System.out.println(recognizedWmark + &amp;quot; does not equal &amp;quot; + watermarkTest);"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.getWmarkValue(String)" access="priv" jdoc="">
				<param name="wmarkCode"/>
			</mth>
			<mth name="/:sandmark.watermark.mondenwmark.MondenWmark.buildDeCodeTable(String)" access="priv" jdoc="">
				<param name="key"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.objectwm">
		<class name="/:sandmark.watermark.objectwm.Profiler" intfc="n" abs="n" inn="n" sloc="159" jdoc="">
			<comm cntt="Gets the bytecode usage in terms of profile length and prints the information"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="masterTable" access="pub" jdoc=""/>
			<field name="maxProfileLength" access="pub" jdoc=""/>
			<field name="myApp" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.Profiler.Profiler(String, int)" access="pub" jdoc="">
				<param name="jarInput"/>
				<param name="length"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Profiler.merge(java.util.Hashtable, java.util.Hashtable)" access="priv" jdoc="">
				<param name="childTable"/>
				<param name="parentTable"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Profiler.getProfiles(int)" access="priv" jdoc="">
				<param name="profileLength"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Profiler.printHashTable(java.util.Hashtable, String, int, int)" access="pub" jdoc="">
				<param name="hTable"/>
				<param name="mesg"/>
				<param name="profLength"/>
				<param name="printThreshold"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Profiler.containsKey(java.util.Hashtable, Object)" access="pub" jdoc="">
				<param name="hTable"/>
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Profiler.getCommonTable(Profiler[], int, int)" access="pub" jdoc="">
				<param name="p"/>
				<param name="prLength"/>
				<param name="prThresh"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Profiler.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.ObjectWatermark" intfc="n" abs="n" inn="n" sloc="181" jdoc="Implementing Stern&amp;apos;s Algorithm for Robust Object Watermarking">
			<comm cntt="Constructs a watermarker"/>
			<comm cntt="Returns this watermarker&amp;apos;s short name."/>
			<comm cntt="Returns this watermarker&amp;apos;s long name."/>
			<comm cntt="Returns this watermark&amp;apos;s configuration properties."/>
			<comm cntt="Get the HTML codes of the About page for ConstantString"/>
			<comm cntt="Get the URL of the Help page for ConstantString"/>
			<comm cntt="Specifies the author of this algorithm."/>
			<comm cntt="Specifies the author&amp;apos;s email address."/>
			<comm cntt="Specifies what this algorithm does."/>
			<comm cntt="Embed a watermark value into the program. The props argument holds at least the following properties: &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt;LI&amp;gt; Output File: The name of the jar file to be constructed. &amp;lt; UL&amp;gt;"/>
			<comm cntt="Recognition procedure begins ... IMPORTANT NOTE: # The &amp;apos;result&amp;apos; vector contains the watermark retrieved in the first index position. The second index of the &amp;apos;result&amp;apos; vector contains 1 or 0 depeding on whether the watermark was found or not. # Currently, the watermarked code is passed as parameter, and the watermark ( to be recognized ) is passed in the &amp;apos;Key&amp;apos; field A strict assumption is made that if the watermarked code is of the form &amp;lt;A_wm.jar&amp;gt;, then the original code is of the form &amp;lt;A.jar&amp;gt;"/>
			<comm cntt="Return an vector which contains the watermarks found in the program. &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; Input File: The name of the file to be watermarked. &amp;lt;LI&amp;gt; Original File: The name of the original jar file before watermaking. &amp;lt; UL&amp;gt;"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="config" access="priv" jdoc=""/>
			<field name="helper" access="priv" jdoc=""/>
			<field name="vecExtract" access="priv" jdoc=""/>
			<field name="myApp" access="pub" jdoc=""/>
			<field name="inputJarFile" access="pub" jdoc=""/>
			<field name="outputJarFile" access="pub" jdoc=""/>
			<field name="wmBigInteger" access="priv" jdoc=""/>
			<field name="wmString" access="priv" jdoc=""/>
			<field name="myWatermark" access="priv" jdoc=""/>
			<field name="origJarFile" access="priv" jdoc=""/>
			<field name="mConfigProps" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.ObjectWatermark()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getShortName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getConfigProperties()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getPostprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getPostrequisities()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getPostsuggestions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getPreprohibited()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getPrerequisities()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getPresuggestions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.getReferences()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="&amp;lt;config.origVector&amp;gt; now contains the initial vector frequencies"/>
				<comm cntt="Parsing input to get the wmVector"/>
				<comm cntt="obtained from commmand line"/>
				<comm cntt="trim to size -&amp;gt; codeBook.numVectorGroups"/>
				<comm cntt="After extracting into the wmVector --&amp;gt; this is to be embedded"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
		<class name="/:sandmark.watermark.objectwm.ObjectWatermark$Recognizer" intfc="n" abs="n" inn="y" sloc="166" jdoc="">
			<field name="result" access="pub" jdoc=""/>
			<field name="jarInput" access="pub" jdoc=""/>
			<field name="current" access="pub" jdoc=""/>
			<field name="tempVal" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark$Recognizer.Recognizer(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark$Recognizer.correlate(String, String)" access="priv" jdoc="">
				<comm cntt="System.out.println(&amp;quot; Error: wmark length mismatch : check code&amp;quot;);"/>
				<comm cntt="System.exit(1);"/>
				<comm cntt="wmark2[k] = (double)Integer.parseInt(newWmark.substring(k,k+1));"/>
				<param name="oldWmark"/>
				<param name="newWmark"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark$Recognizer.generate(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<comm cntt="initialize original vector"/>
				<comm cntt="initialize origVector"/>
				<comm cntt="Get &amp;apos;wmString&amp;apos; from &amp;apos;Key&amp;apos;"/>
				<comm cntt="obtained from &amp;apos;Key&amp;apos;"/>
				<comm cntt="trim to size -&amp;gt; codeBook.numVectorGroups"/>
				<comm cntt="Vector &amp;apos;result&amp;apos; contains the code+watermark vector Vector &amp;apos;origVector&amp;apos; contains the original code vector result - origVector should give the wmString (ie. watermark vector), incase the watermark is not destroyed"/>
				<comm cntt="ensuring threshold on either side of the actual value"/>
				<comm cntt="Calculate the normalized correlation function"/>
				<comm cntt="the &amp;quot;result&amp;quot; vector is returned"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark$Recognizer.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark$Recognizer.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectWatermark$Recognizer.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.objectwm.VectorExtraction" intfc="n" abs="n" inn="n" sloc="66" jdoc="">
			<comm cntt="Constructor"/>
			<comm cntt="Extracts the frequency vector from the @classFile"/>
			<comm cntt="for test purpose ... public static void main( String args[] ) throws java.io.IOException { extractVector(args[0], 10); int vIndex = 0; System.out.println(&amp;quot;Extracted vector:\n&amp;quot;); while( vIndex &amp;lt; origVector.size() ) { System.out.print( (Integer)origVector.elementAt(vIndex) ); vIndex++; } System.out.println(); return; }"/>
			<field name="config" access="pub" jdoc=""/>
			<field name="helper" access="pub" jdoc=""/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.VectorExtraction.VectorExtraction()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorExtraction.extractVector(sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="else lookup for instructions that matches with codeBook codes"/>
				<comm cntt="call codeBook to create vector from the VectorGrp"/>
				<comm cntt="compareTo"/>
				<comm cntt="code found; add to vector"/>
				<comm cntt="increment once for the group. even for multiple set matches"/>
				<param name="classObj"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.CodeBook" intfc="n" abs="n" inn="n" sloc="348" jdoc="">
			<comm cntt="Constructor"/>
			<comm cntt="Returns &amp;apos;true&amp;apos; if its a branch nullify instruction group; else returns &amp;apos;false&amp;apos;"/>
			<comm cntt="This method implements ..."/>
			<comm cntt="This method implements ..."/>
			<comm cntt="Main interface to the codeBook"/>
			<field name="wmarkLength" access="pub" jdoc=""/>
			<field name="numGroups" access="pub" jdoc=""/>
			<field name="numSets" access="pub" jdoc=""/>
			<field name="numInInstr" access="pub" jdoc=""/>
			<field name="numOutInstr" access="pub" jdoc=""/>
			<field name="numEmbedInstr" access="pub" jdoc=""/>
			<field name="numNullifyInstr" access="pub" jdoc=""/>
			<field name="inInstr" access="pub" jdoc=""/>
			<field name="outInstr" access="pub" jdoc=""/>
			<field name="embedInstr" access="pub" jdoc=""/>
			<field name="nullifyInstr" access="pub" jdoc=""/>
			<field name="codeVector" access="pub" jdoc=""/>
			<field name="vectorGrp" access="pub" jdoc=""/>
			<field name="numVectorGroups" access="pub" jdoc=""/>
			<field name="elemsVectorGrp" access="pub" jdoc=""/>
			<field name="numDep" access="pub" jdoc=""/>
			<field name="instrDep" access="pub" jdoc=""/>
			<field name="nullifyEffect" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.CodeBook.CodeBook()" access="pub" jdoc="">
				<comm cntt="start with a 8 bit watermark embedding"/>
				<comm cntt="start with a 8 group multiple instructions set CodeBook"/>
				<comm cntt="... group0"/>
				<comm cntt="... group1"/>
				<comm cntt="... group2"/>
				<comm cntt="... group3"/>
				<comm cntt="... group4"/>
				<comm cntt="... group5"/>
				<comm cntt="... group6"/>
				<comm cntt="... group7"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.CodeBook.isBranchEmbed(int)" access="pub" jdoc="">
				<param name="vectorIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.CodeBook.getParams(String, int)" access="priv" jdoc="">
				<comm cntt="Store parameters if any"/>
				<param name="iLSet"/>
				<param name="numInstr"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.CodeBook.putParams(String, int, String[][])" access="priv" jdoc="">
				<comm cntt="Store parameters if any"/>
				<comm cntt="1 operand"/>
				<comm cntt="for 2 operands"/>
				<param name="iSet"/>
				<param name="numInstr"/>
				<param name="newParams"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.CodeBook.getInstructionFromCodeBook(String[], int, int, int, String)" access="pub" jdoc="">
				<comm cntt="get the actual values from the input instr set"/>
				<comm cntt="get the groupNum of the instruction group corresponding to the given vectorGrp"/>
				<comm cntt="fill the result set"/>
				<param name="instrSet"/>
				<param name="instrSetLength"/>
				<param name="groupNum"/>
				<param name="setNum"/>
				<param name="resultSet"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.VectorUpdateCtrl" intfc="n" abs="n" inn="n" sloc="101" jdoc="">
			<comm cntt="Constructor"/>
			<field name="vecfreq" access="priv" jdoc=""/>
			<field name="mark" access="priv" jdoc=""/>
			<field name="zeroFreqFlag" access="priv" jdoc=""/>
			<field name="vectUpdatesRem" access="priv" jdoc=""/>
			<field name="substSearch" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.VectorUpdateCtrl(java.util.Vector)" access="pub" jdoc="">
				<param name="wmVector"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.setSubstSearch(int)" access="pub" jdoc="">
				<param name="vIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.unsetSubstSearch(int)" access="pub" jdoc="">
				<param name="vIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.getSubstSearch(int)" access="pub" jdoc="">
				<param name="vIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.getElementAt(int)" access="pub" jdoc="">
				<param name="vIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.setFreqCounterToZero(int)" access="pub" jdoc="">
				<param name="vIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.zerofreqState(int)" access="pub" jdoc="">
				<comm cntt="zeroFreqFlag = 2 =&amp;gt; update over &amp; noted down; = 1 =&amp;gt; initially the vector index was zero;"/>
				<param name="vIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.markState(int)" access="pub" jdoc="">
				<comm cntt="this vector element update completed"/>
				<param name="vIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.updateFrequencyCounter(int)" access="pub" jdoc="">
				<param name="vIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.allUpdatesDone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.updateFrequencyCounterInThreshold(int, int)" access="pub" jdoc="">
				<param name="vIndex"/>
				<param name="updateVal"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.VectorUpdateCtrl.displayVectorFreq(String)" access="pub" jdoc="">
				<param name="headerMessage"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.MethodCopyUtil" intfc="n" abs="n" inn="n" sloc="780" jdoc="">
			<comm cntt="This method checks that the sideEffects of overloading a method is within a particular threshold limit"/>
			<comm cntt="Changes the local access index of the deleted parameter to the index of the new parameter which replicates it"/>
			<comm cntt="Third approach of overloading method, deleting a parameter and then creating a new variable to replicate the deleted parameter."/>
			<comm cntt="Second approach of overloading method, deleting a parameter and then removing all the instructions that access the deleted parameter."/>
			<comm cntt="Creates an intial copy of an existing method which is to be overloaded and returns the sandmark.program.Method object of the created method"/>
			<comm cntt="Re-initializes the parameters of the newly created method"/>
			<comm cntt="First approach of overloading method, inserting a new parameter"/>
			<comm cntt="Checks if the method is already overloaded more that a &amp;apos;threshold&amp;apos; number of times"/>
			<comm cntt="Checks whether the name and signature of the method created conflicts with any of the existing methods&amp;apos; name and signature"/>
			<comm cntt="Deletes the instructions within 2 consecutive targeters in which the instruction referenced by &amp;apos;index&amp;apos; lies"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="util" access="pub" jdoc=""/>
			<field name="helper" access="pub" jdoc=""/>
			<field name="config" access="pub" jdoc=""/>
			<field name="copyMethodOption0" access="pub" jdoc=""/>
			<field name="copyMethodOption1" access="pub" jdoc=""/>
			<field name="copyMethodOption2" access="pub" jdoc=""/>
			<field name="methodInvocationCount" access="pub" jdoc=""/>
			<field name="parameterSuffix" access="priv" jdoc=""/>
			<field name="targetsObj" access="priv" jdoc=""/>
			<field name="mcopy_arg_types" access="priv" jdoc=""/>
			<field name="mcopy_arg_names" access="priv" jdoc=""/>
			<field name="mcopy_instrList" access="priv" jdoc=""/>
			<field name="mcopy_instrHandles" access="priv" jdoc=""/>
			<field name="deleteVartype" access="pub" jdoc=""/>
			<field name="randomDelete" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.MethodCopyUtil(ObjectUtil)" access="pub" jdoc="">
				<param name="objUtil"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.remVecfreqUpdatesInThreshold(int, int, VectorUpdateCtrl, org.apache.bcel.generic.InstructionList)" access="priv" jdoc="">
				<comm cntt="get the instructions corresponding to this vector"/>
				<comm cntt="to ensure we dont touch util.cpObj right now, we use &amp;apos;getOpcodeFromInstr&amp;apos;"/>
				<comm cntt="break from the while if vecOccur exceeds the &amp;quot;threshold&amp;quot;"/>
				<comm cntt="Cannot proceed with the update; threshold update &amp;quot; + &amp;quot; exceeded for a vector .."/>
				<comm cntt="At this point the vecOccur[] contains the no. of sideeffects for the entire vector elements groups; store it; need not be recalculated"/>
				<param name="numVectors"/>
				<param name="currVecIndex"/>
				<param name="vecObj"/>
				<param name="instrList"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.createInitLocalVar(org.apache.bcel.generic.Type, sandmark.program.Method)" access="priv" jdoc="Creates a local Var and initializes it; used while deleting a paramter from the method and replicating it">
				<param name="deleteVartype"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.changeLocalAccessIndex(sandmark.program.Method, int, int)" access="priv" jdoc="">
				<comm cntt="added : verify"/>
				<param name="mg"/>
				<param name="oldVarIndex"/>
				<param name="newVarIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.deleteMethodParameter2(sandmark.program.Method)" access="pub" jdoc="">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.deleteMethodParameter1(sandmark.program.Method)" access="pub" jdoc="">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.createCloneMethod(sandmark.program.Method, int, int, int, VectorUpdateCtrl)" access="pub" jdoc="">
				<comm cntt="test_purpose:"/>
				<comm cntt="we are modifying option 1 and doing check later ( since we have to delete some targeter ranges"/>
				<comm cntt="check TBD: change made ..."/>
				<comm cntt="util.classObj.setConstantPool(util.classObj.getFinalConstantPool());"/>
				<comm cntt="create &amp; initialize a local Var depending on the type deleted"/>
				<comm cntt="change all accesses to localVar &amp;apos;randomDelete&amp;apos; to &amp;apos;newlocalIndex&amp;apos;"/>
				<comm cntt="TBD : TBchecked ...+1"/>
				<comm cntt="TBD : TBchecked ...+1"/>
				<param name="mg"/>
				<param name="selectModifyOption"/>
				<param name="numVectors"/>
				<param name="currVecIndex"/>
				<param name="vecObj"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.reInitializeParameters(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="for long and double"/>
				<comm cntt="TBD: instead of inserting the initialization code at the beginining of code, we can insert in anywhere prior to its use; to be safe, at targeter points"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.insertMethodParameter(sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="Insertion of new parameter"/>
				<comm cntt="util.classObj.setConstantPool(util.classObj.getFinalConstantPool());"/>
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.methodAlreadyOverloaded(String)" access="priv" jdoc="">
				<param name="methodName"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.methodNameSigConflict(String, org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<comm cntt="&amp;lt;methodNameSig conflict&amp;gt;"/>
				<param name="methodName"/>
				<param name="newArgTypes"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.deleteTargeterRange(sandmark.program.Method, org.apache.bcel.generic.InstructionList, int)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;TargetLostException caught HERE: &amp;quot; + e);"/>
				<comm cntt="System.exit(1);"/>
				<comm cntt="end of catch block"/>
				<param name="mg"/>
				<param name="instrList"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.createMethodInvocation(sandmark.program.Method, org.apache.bcel.generic.Type, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="pick method at the &amp;apos;iterClasses.next()&amp;apos; class"/>
				<comm cntt="TBD: config.getMethodEmbedThreshold()) .. check threshold"/>
				<comm cntt="----- at this point, all objects &amp;apos;obj&amp;apos; are populated to do the insertion ------------"/>
				<comm cntt="NOTE: method always public;"/>
				<comm cntt="initialize parameters and return var( if any )"/>
				<comm cntt="get random Insertion point"/>
				<comm cntt="insert trivial &amp;apos;opaque&amp;apos; jump across the invocation"/>
				<comm cntt="get Constructor parameters, and initialize parameter if any"/>
				<comm cntt="create &amp;apos;invoke object&amp;apos; depending on whether the fn. is &amp;apos;static&amp;apos; or &amp;apos;virtual&amp;apos;"/>
				<comm cntt="load localVars created into the stack"/>
				<comm cntt="insert invoke instructions; save to return localVar( if necessary )"/>
				<param name="mg"/>
				<param name="consArgTypes"/>
				<param name="consmg"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.insertMethodInvoke(org.apache.bcel.generic.InstructionHandle, sandmark.program.Method, int, org.apache.bcel.generic.Type, int)" access="priv" jdoc="">
				<comm cntt="System.exit(1);"/>
				<comm cntt="if(objectIndex != -1) util.instrListObj.insert(ih, new org.apache.bcel.generic.ALOAD(objectIndex));"/>
				<param name="ih"/>
				<param name="mg"/>
				<param name="returnLocalIndex"/>
				<param name="returnType"/>
				<param name="objectIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.createInvokeObject(org.apache.bcel.generic.InstructionHandle, int, org.apache.bcel.generic.Type, sandmark.program.Method, org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="ih"/>
				<param name="localIndices"/>
				<param name="argTypes"/>
				<param name="mg"/>
				<param name="returnType"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.loadLocalVarInstr(org.apache.bcel.generic.InstructionHandle, int, org.apache.bcel.generic.Type[], org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<param name="ih"/>
				<param name="localIndices"/>
				<param name="argTypes"/>
				<param name="returnType"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.MethodCopyUtil.initializeParameters(org.apache.bcel.generic.Type, org.apache.bcel.generic.Type)" access="priv" jdoc="">
				<comm cntt="not required, i suppose"/>
				<comm cntt="TBD: object return support ..."/>
				<comm cntt="NOTE: inserted in opposite order"/>
				<param name="argTypes"/>
				<param name="returnType"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.ObjectHelper" intfc="n" abs="n" inn="n" sloc="131" jdoc="">
			<comm cntt="Constructor"/>
			<comm cntt="Returns a random value within specified boundary; taking values from low to high-1"/>
			<comm cntt="Compares two instruction opcode in string format"/>
			<comm cntt="Displays watermark vector information"/>
			<comm cntt="Extracts the short className from the full classFile name"/>
			<comm cntt="Extract the opcode from a verbose instruction"/>
			<comm cntt="Extracts the opcode from the instruction"/>
			<comm cntt="Returns true if the String is a branch statement, else returns false"/>
			<comm cntt="Overloaded from previous method"/>
			<comm cntt="Returns &amp;apos;true&amp;apos; if the @instr is an access tyoe instruction, else returns &amp;apos;false&amp;apos;"/>
			<comm cntt="Extracts the argument val in the instruction"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.ObjectHelper()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.getRandomValue(int, int)" access="pub" jdoc="">
				<param name="low"/>
				<param name="high"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.codeMatch(String, String, int)" access="pub" jdoc="">
				<param name="str1"/>
				<param name="str2"/>
				<param name="numInstr"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.display_VectorInfo(java.util.Vector, String)" access="pub" jdoc="">
				<param name="vec"/>
				<param name="mesg"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.extractShortFileName(String)" access="pub" jdoc="">
				<param name="classFile"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.getOpcodeFromInstr(String)" access="pub" jdoc="">
				<param name="instrCode"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.getOpcode(String)" access="pub" jdoc="">
				<param name="instrCode"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.isOfTypeBranch(String)" access="pub" jdoc="">
				<param name="opcode"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.isOfTypeBranch(org.apache.bcel.generic.Instruction)" access="pub" jdoc="">
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.isOfTypeAccess(String)" access="priv" jdoc="">
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectHelper.getArgumentValInInstruction(String)" access="pub" jdoc="">
				<param name="instr"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.SubstitutionUtil" intfc="n" abs="n" inn="n" sloc="130" jdoc="This class implements all the code substitution embedding features">
			<comm cntt="Constructor"/>
			<comm cntt="This method is the first procedure for vector increment. Pure code substitution is done in this ie. we find match of codegroup instruction and substitute it by equivalent set of instructions; @param insertih contains the point where the insertion is to be done. (remember, the old instructions are already deleted!) @param subInstr contains the instructions obtained from codeBook along with the parameters of the old instructions @param numInstr contains the number of instructions that are being substituted"/>
			<comm cntt="This method retrieves the point where code is to be substituted, provided we found the codebook instruction group in the app. code, else null is returned; @param instrGrp @param numInstr -&amp;gt; input parameters @param origCodeStr -&amp;gt; output parameter"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="util" access="priv" jdoc=""/>
			<field name="helper" access="priv" jdoc=""/>
			<field name="targetsObj" access="pub" jdoc=""/>
			<field name="updateTargetersFlag" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.SubstitutionUtil.SubstitutionUtil(ObjectUtil)" access="pub" jdoc="">
				<param name="objUtil"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.SubstitutionUtil.substituteCode(org.apache.bcel.generic.InstructionHandle, String, int)" access="pub" jdoc="">
				<comm cntt="we save the target to redirect all the targeters of the deleted point to the first subst instruction embedded"/>
				<comm cntt="util.instrListObj.setPositions();"/>
				<comm cntt="needed for one vector group !"/>
				<param name="insertih"/>
				<param name="subInstr"/>
				<param name="numInstr"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.SubstitutionUtil.getCodeSubstPoint(String, int, String)" access="pub" jdoc="">
				<comm cntt="NOTE: here we are assuming we have max. one branch instruction in the codeBook code; we always have max. one !"/>
				<comm cntt="did not found a code match; look in the next method"/>
				<comm cntt="saving the matched instructions into origCodeStr[] for later substitution"/>
				<comm cntt="instrList.setPositions();"/>
				<comm cntt="util.methodObj.setInstructionList(instrList);"/>
				<param name="instrGrp"/>
				<param name="numInstr"/>
				<param name="origCodeStr"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.Insertion" intfc="n" abs="n" inn="n" sloc="291" jdoc="">
			<comm cntt="Constructor"/>
			<comm cntt="This method inserts previously non-existing codes; new code inserted to increase the vector frequency; @substInstr --&amp;gt; &amp;apos;raw&amp;apos; instructions fom codeBook @numInstr --&amp;gt; number of instructions to be embedded @codeBookembedIndex --&amp;gt; group number from which the nullify instructions are to be taken Returns &amp;apos;true&amp;apos; on success, else returns &amp;apos;false&amp;apos;"/>
			<comm cntt="method copied to increase the vector frequency of the vector groups present in that method. @instrGrpInstr -&amp;gt; the vector instruction group which is to be incremented @numInstr -&amp;gt; number of instructions in this group @numVectors -&amp;gt; ie. the watermark length @currVecIndex -&amp;gt; the present vector index which is being incremented; Returns the number of &amp;apos;vecOccurence&amp;apos; of the vector &amp;apos;vIndex&amp;apos; on succes, else returns -1"/>
			<comm cntt="Displays the current vector frequencies in the application"/>
			<comm cntt="This method is the first procedure for vector increment. Pure code substitution is done in this ie. we find match of codegroup instruction and substitute it by equivalent set of instructions; @vIndex contains the vector group whose frequency is to be incremented; Returns 1 on success, else returns -1"/>
			<comm cntt="Entry procedure for this &amp;apos;Insertion&amp;apos; class."/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="util" access="priv" jdoc=""/>
			<field name="helper" access="priv" jdoc=""/>
			<field name="vecObj" access="priv" jdoc=""/>
			<field name="config" access="priv" jdoc=""/>
			<field name="substUtil" access="priv" jdoc=""/>
			<field name="instrEmbedUtil" access="priv" jdoc=""/>
			<field name="methodcopyUtil" access="priv" jdoc=""/>
			<field name="numClasses" access="priv" jdoc=""/>
			<field name="numMethods" access="priv" jdoc=""/>
			<field name="numInstr" access="priv" jdoc=""/>
			<field name="numberOfSubstitutions" access="priv" jdoc=""/>
			<field name="numberOfNewInstructionEmbed" access="priv" jdoc=""/>
			<field name="numberOfMethodCopying" access="priv" jdoc=""/>
			<field name="methodOverloadOption" access="priv" jdoc=""/>
			<field name="feasibleCounter" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.Insertion.Insertion()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Insertion.newInstructionEmbed(String, int, int)" access="priv" jdoc="">
				<comm cntt="insert code at the &amp;apos;iterClasses.next()&amp;apos; class"/>
				<comm cntt="skip &amp;lt;constructor&amp;gt; and &amp;lt;static&amp;gt; method"/>
				<comm cntt="IMPORTANT NOTE: &amp;apos;instrEmbedUtil.newInstrIndexObj&amp;apos; is the point where we are going to insert the new instructions: initially it is set to 0 ie. First instruction in the method"/>
				<param name="substInstr"/>
				<param name="numInstr"/>
				<param name="codeBookembedIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Insertion.copyMethodEmbed(String, int, int, int)" access="priv" jdoc="">
				<comm cntt="Storing the constructor method information for this class; this is used by the dummy invokation of the copy method, specifically when we need to create the object for this class"/>
				<comm cntt="check if argument type is not of desired type"/>
				<comm cntt="only insertion of parameter possible"/>
				<comm cntt="[ Done Along with createCloneMethod now (due to this rewrite) .. see above ] Next step is to insert an additional parameter delete one parameter; INSERTION: create a new parameter; can be anything; initialize the parameter; introduce some bogus codes that accesses this parameter at some targeter point in the clone method ; this bogusCode can also be the vectorInstruction group, but keep track of the freqency update too; do we need to be careful abt the local reuse ?? since this method maynot be ever invoked; DELETION: delete all the accesses to this parameter in the method; for each access we have to delete all the instructions till the either side of closest targeters; check for vector frequency difference; if it decreases a measure then abort, else keep it."/>
				<comm cntt="int numInstructions = util.getNumberOfInstructionsInMethod(copymg); if((numInstructions &amp;lt; config.getMethodCopyLowerThreshold()) || (numInstructions &amp;gt; config.getMethodCopyUpperThreshold())) continue; TBD: in createCloneMethod"/>
				<comm cntt="util.classObj.setConstantPool((util.classObj.getConstantPool()).getFinalConstantPool());"/>
				<comm cntt="Create an invocation to this method; bypass the invocation thru an opaque predicate step1 : get the method parameters and the return parameter( if any ) step2 : select class method insertion point step3 : create new locals based on requirement step4 : create opaque constructs step5 : do final invocation code insertion"/>
				<param name="instrGrpInstr"/>
				<param name="numInstr"/>
				<param name="numVectors"/>
				<param name="currVecIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Insertion.displayCurrentVectorFrequency()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Insertion.codeSubstitution(int)" access="priv" jdoc="">
				<comm cntt="get corresponding CodeGroup from the VectorGroup"/>
				<comm cntt="&amp;apos;subInstr&amp;apos; has the set of instructions to be substituted"/>
				<param name="vIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Insertion.modifyCode(java.util.Vector)" access="pub" jdoc="">
				<comm cntt="ITERATE TILL ALL THE DESIRED FREQUENCY HAS BEEN REACHED"/>
				<comm cntt="if there is scope for substitution, do it"/>
				<comm cntt="set the &amp;apos;substSearch&amp;apos; marker to 0, ie. no more searching for substitution unless it is set to 1 by some other substitution; again a dependency sort of matrix is created and stored for reference"/>
				<comm cntt="Else, choose an instruction embedding techinque from the pool"/>
				<comm cntt="for each vector element"/>
				<comm cntt="freq iteration.(while)"/>
				<param name="wmVector"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.InstructionEmbedUtil" intfc="n" abs="n" inn="n" sloc="704" jdoc="">
			<comm cntt="Constructor"/>
			<comm cntt="Checks if there is a integer variable &amp; returns true false; it also stores the first assignment to the local variable in an array &amp;apos;localInitArray[]&amp;apos;"/>
			<comm cntt="This function checks whether the &amp;apos;localInitPoint&amp;apos; dominates the &amp;apos;embedPoint&amp;apos;"/>
			<comm cntt="This function computes and returns the point in the method code where the local variable with index &amp;apos;varIndex&amp;apos; is initialized (or first used); Incase it is not initialized, -1 is returned"/>
			<comm cntt="Checks in the &amp;apos;localtable&amp;apos; if the local variable is already there along with its corresponding index; localtable is of the form --&amp;gt; X12 ; Returns &amp;apos;true&amp;apos; on occurence, else returns &amp;apos;false&amp;apos;"/>
			<comm cntt="This functions extracts a reusuable local variable; incase no local variables in the method can be reused, it creates a new local variable at returns its index; methodsInvoked: localAlreadyUsed(), varTypeIsInt(int)"/>
			<comm cntt="Converts the received code to the actual code to be inserted by placing appropriate local variable indices etc etc; methodsInvoked: inLocalTable(String)"/>
			<comm cntt="This method checks whether the code to be inserted splits any existing vector groups; returns &amp;apos;true&amp;apos; if splits, else returns &amp;apos;false&amp;apos;"/>
			<comm cntt="This function checks the place after &amp;apos;newInstrIndexObj&amp;apos; till the end of the code where the localVar ( which has index &amp;apos;localIndex&amp;apos; ) is next used; it then selects a safe random point in between this range &amp; returns it; incase the local is not reused anymore, it returns -1 ; Also, make sure that the return index is before any jump into this range!!"/>
			<comm cntt="This method computes and returns the point in the method code where the branch nullify instruction is to be inserted ; note this is different from finding out the insertion point for the normal nullify instructions methodsInvoked: util.getTargeterPointsInRange()"/>
			<comm cntt="Checks whether there is any assignment within the instruction indices &amp;apos;src&amp;apos; and &amp;apos;dest&amp;apos;"/>
			<comm cntt="Used while finding the basic blocks in the method"/>
			<comm cntt="This method returns the end point of the basic block where the reference &amp;apos;index&amp;apos; instruction lies; @param index is the position where the bogus new Vector instruction is embedded methodsInvoked: inLeaderGroup()"/>
			<comm cntt="displaying leader information of the method cfg"/>
			<comm cntt="returns the local variable index if it is in localtable, else returns -1"/>
			<comm cntt="displays the current local table"/>
			<comm cntt="Fetches the last initialization point of the local variables reused created for embedding instructions"/>
			<comm cntt="This function evaluates and returns the point to embed the new instruction group; returns -1 if no possible point exists"/>
			<comm cntt="This method is invoked from the newCode Insertion option in modifyCode(): @param substInstr --&amp;gt; &amp;apos;raw&amp;apos; instructions fom codeBook @param numInstr --&amp;gt; number of instructions to be embedded @param codeBookembedIndex --&amp;gt; group number from which the nullify instructions are to be taken; same as &amp;apos;vIndex&amp;apos; in Insertion.class"/>
			<comm cntt="Removes all elements from the local table"/>
			<comm cntt="This method inserts the nullifying code at the point &amp;apos;nullifyEmbedPoint&amp;apos; methodsInvoked: addFromLocalTable(), util.extractInstrType(), codeBook.isBranchEmbed()"/>
			<comm cntt="Extracts the local index from the &amp;apos;localtable&amp;apos; and returns the newly formed string"/>
			<comm cntt="Fetches the local variable value allocated; creates the instruction string and returns it"/>
			<field name="DEBUG" access="priv" jdoc=""/>
			<field name="util" access="pub" jdoc=""/>
			<field name="helper" access="pub" jdoc=""/>
			<field name="ihNewInstrEmbedObj" access="pub" jdoc=""/>
			<field name="newInstrIndexObj" access="pub" jdoc=""/>
			<field name="putstaticObj" access="priv" jdoc=""/>
			<field name="getstaticObj" access="priv" jdoc=""/>
			<field name="naObj" access="priv" jdoc=""/>
			<field name="bipushObj" access="priv" jdoc=""/>
			<field name="nullifyEmbedObj" access="priv" jdoc=""/>
			<field name="nullifyBranchObj" access="priv" jdoc=""/>
			<field name="localtable" access="priv" jdoc=""/>
			<field name="methodNameSuffix" access="priv" jdoc=""/>
			<field name="statVarSuffix" access="priv" jdoc=""/>
			<field name="localInitArray" access="priv" jdoc=""/>
			<field name="branchNullifyAbort" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.InstructionEmbedUtil(ObjectUtil)" access="pub" jdoc="">
				<param name="objUtil"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.varTypeIsInt(int)" access="priv" jdoc="">
				<comm cntt="test_purpose:"/>
				<param name="varIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.localIndexReuse(int)" access="priv" jdoc="">
				<param name="localIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.checkInitPointDominates(int, int)" access="priv" jdoc="">
				<comm cntt="&amp;&amp;(k&amp;lt;embedPoint))"/>
				<comm cntt="continue; TBVerified:"/>
				<comm cntt="localInitPoint doesnot dominate the embedPoint"/>
				<comm cntt="test for backward jumps into the local-embed range ; maintain a &amp;apos;worklist to analyze the loops recursively"/>
				<param name="localInitPoint"/>
				<param name="embedPoint"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.getLocalVarInitPoint(int)" access="priv" jdoc="">
				<param name="varIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.localAlreadyUsed(int)" access="priv" jdoc="">
				<param name="localIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.getLocalVarIndex_CreateIndex(int)" access="priv" jdoc="">
				<comm cntt="this is to ensure that 2 different &amp;apos;raw&amp;apos; variables are not assigned the same actual local no.; creates problem during nullifying"/>
				<comm cntt="call a function to return true if local &amp;apos;localIndex&amp;apos; is int, else return false"/>
				<comm cntt="Else create a new local variable; return its index"/>
				<comm cntt="not required, i suppose"/>
				<comm cntt="shift the rest of inits in localInitArray[] by 2 to accomodate this new initialization instructions at the beginning of the code"/>
				<comm cntt="IMP: TBD: recheck: takes care of next use local problem ; so that this included instructions are not considered for next use"/>
				<param name="instrEmbedIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.transformCode(String, String)" access="pub" jdoc="">
				<comm cntt="add this to local table"/>
				<comm cntt="util.classObj.addField(f); cgObj"/>
				<comm cntt="we have bipushObj, naObj &amp; putstaticObj to be inserted"/>
				<param name="subInstr"/>
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.checkSplitVectorGrp(int, org.apache.bcel.generic.InstructionHandle[])" access="pub" jdoc="">
				<comm cntt="checking nullifyInstr split now ..."/>
				<param name="instrIndex"/>
				<param name="instrHandles"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.getNullifyInsertPoint()" access="priv" jdoc="">
				<comm cntt="TBD: anymore opcodes possible that change the local value?"/>
				<comm cntt="takes care of basic block problem"/>
				<comm cntt="make the upper range the one which is closest ie. end of the basicblock in which the new instruction is embedded, or the point of next use of the local"/>
				<comm cntt="takes care of virtual machine stack problem"/>
				<comm cntt="if no targeters, then select a random point b w &amp;apos;newInstrIndexObj&amp;apos; &amp; &amp;apos;upperRange&amp;apos;, else, take a random targeter point and make that the point for insertion of the nullifying code TBD: recheck consequences"/>
				<comm cntt="No targeters in between embedPoint and nextSafeNullifyPoint:"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.getBranchNullifyInsertPoint()" access="priv" jdoc="">
				<comm cntt="Returning prematurely from fn. getBranchNullifyInsertPoint val"/>
				<comm cntt="now select the targeters that do not conflict"/>
				<comm cntt="loop around and fetch next &amp;apos;selectTargeter&amp;apos; point"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.checkAssignmentInRange(int, int)" access="priv" jdoc="">
				<param name="src"/>
				<param name="dest"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.inLeaderGroup(int, int, int)" access="priv" jdoc="">
				<param name="index"/>
				<param name="numleaders"/>
				<param name="leaders"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.getBlockEndPoint(int)" access="priv" jdoc="">
				<comm cntt="sort leaders"/>
				<param name="index"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.displayLeaders(int, int)" access="pub" jdoc="">
				<param name="numleaders"/>
				<param name="leaders"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.inLocalTable(String)" access="priv" jdoc="">
				<param name="localchar"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.printlocalTable()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.getLastLocalInitPosition()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.getNewEmbedPoint()" access="priv" jdoc="">
				<comm cntt="IMPORTANT NOTE: get a new instruction insert point ie. &amp;apos;newInstrIndexObj&amp;apos;"/>
				<comm cntt="no targeters in Range ( fn. getNewEmbedPoint ) :"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.substituteNewCode(String, int, int, VectorUpdateCtrl)" access="pub" jdoc="">
				<comm cntt="First step: transform each instruction; insert local variable values in it"/>
				<comm cntt="NOTE: &amp;apos;ihNewInstrEmbedObj&amp;apos; will change depending on the localVar available"/>
				<comm cntt="init"/>
				<comm cntt="Already assigned a local val( new old ), skip"/>
				<comm cntt="this.printlocalTable();"/>
				<comm cntt="At this point we have selected the local vars to be reused created"/>
				<comm cntt="Index location where we&amp;apos;ll be inserting the &amp;apos;nullifying&amp;apos; code"/>
				<comm cntt="Abort overridden for branch target"/>
				<comm cntt="Couldnt get a possible &amp;apos;nullifyEmbedPoint&amp;apos;:"/>
				<comm cntt="have to create a new static each time ... CHECK THIS !! TBD:"/>
				<comm cntt="pick a random targeter point from targetIndices"/>
				<comm cntt="the rest of the code insertion is done at &amp;apos;ihNewInstrEmbedObj&amp;apos;"/>
				<comm cntt="if not embed branch reqd., then return"/>
				<comm cntt="store the insert embed poition to jump back from the &amp;apos;nullify&amp;apos; code"/>
				<param name="subInstr"/>
				<param name="numInstr"/>
				<param name="codeBookembedIndex"/>
				<param name="vecObj"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.clearLocalTable()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.insertNullifyCode(int, int)" access="priv" jdoc="">
				<comm cntt="else insert the instruction at nullifyEmbedPoint"/>
				<comm cntt="addFromLocalTable performs almost the same function as &amp;apos;transformCode&amp;apos;"/>
				<comm cntt="nullifyInstr now contains the final instructions with appropriate locals to be substituted at &amp;apos;nullifyEmbedPoint&amp;apos;"/>
				<comm cntt="DEBUGGING : checking final insert point"/>
				<param name="codeBookembedIndex"/>
				<param name="nullifyEmbedPoint"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.addFromLocalTable(int)" access="priv" jdoc="">
				<param name="embedIndex"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.InstructionEmbedUtil.insertlocalValFromTable(String)" access="priv" jdoc="">
				<param name="str"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.ObjectUtil" intfc="n" abs="n" inn="n" sloc="356" jdoc="This class implements all the APIs required by the main insertion methods">
			<comm cntt="This method takes the opcode of the instruction as a String and returns the corresponding &amp;apos;Instruction&amp;apos; object which is to be then used for insertion; &amp;apos;instr&amp;apos; is complete ie. contains all the actual end parameters"/>
			<comm cntt="skips the method whose parameter type is outside the range of types implemented"/>
			<comm cntt="Returns the number of instances of a group of instrcutions in a particular method"/>
			<comm cntt="Returns the targeter indices within a given range of indices"/>
			<comm cntt="Retrieves the index of a given instructionHandle"/>
			<comm cntt="This method returns the current targeter points in the code above the lowerIndexLimit point ; returns the number of points, and the indices are stored in the output parameter &amp;apos;targetIndices&amp;apos;"/>
			<comm cntt="Returns the number of instructions in the method"/>
			<comm cntt="Committing the final changes into the jar file"/>
			<field name="myTargetClassName" access="priv" jdoc=""/>
			<field name="classObj" access="pub" jdoc=""/>
			<field name="methodObj" access="pub" jdoc=""/>
			<field name="instrListObj" access="pub" jdoc=""/>
			<field name="targetHandleObj" access="pub" jdoc=""/>
			<field name="helper" access="priv" jdoc=""/>
			<field name="config" access="priv" jdoc=""/>
			<field name="codeBook" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.ObjectUtil()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.setTargetClassName(String)" access="pub" jdoc="">
				<param name="className"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.setTargetClassObject(sandmark.program.Class)" access="pub" jdoc="">
				<param name="cObj"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.getTargetClassName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.extractInstrType(String)" access="pub" jdoc="">
				<comm cntt="NOTE: more cases to be added as &amp; when instructions are updated in the codeBook"/>
				<comm cntt="if( opcode.equals( &amp;quot;lconst_0&amp;quot;)) incn = org.apache.bcel.generic.InstructionConstants.LCONST_0; if( opcode.equals( &amp;quot;lconst_1&amp;quot;)) incn = org.apache.bcel.generic.InstructionConstants.LCONST_1; if( opcode.equals( &amp;quot;fconst_0&amp;quot;)) incn = org.apache.bcel.generic.InstructionConstants.FCONST_0; if( opcode.equals( &amp;quot;fconst_1&amp;quot;)) incn = org.apache.bcel.generic.InstructionConstants.FCONST_1; if( opcode.equals( &amp;quot;fconst_2&amp;quot;)) incn = org.apache.bcel.generic.InstructionConstants.FCONST_2; if( opcode.equals( &amp;quot;dconst_0&amp;quot;)) incn = org.apache.bcel.generic.InstructionConstants.DCONST_0; if( opcode.equals( &amp;quot;dconst_1&amp;quot;)) incn = org.apache.bcel.generic.InstructionConstants.DCONST_1;"/>
				<param name="instr"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.skipMethod(sandmark.program.Method)" access="pub" jdoc="">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.getNumberOfInstanceOfGroup(sandmark.program.Method, String, int)" access="pub" jdoc="">
				<comm cntt="to ensure we dont touch cpObj right now, we use &amp;apos;getOpcodeFromInstr&amp;apos;"/>
				<comm cntt="helper.getOpcodeFromInstr( instr.toString() );"/>
				<comm cntt="org.apache.bcel.generic.InstructionHandle posHandle = instrHandles[i+offset+1];"/>
				<param name="mg"/>
				<param name="instrStrGrp"/>
				<param name="numInstr"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.getTargeterPointsInRange(int, int, org.apache.bcel.generic.InstructionList)" access="pub" jdoc="">
				<param name="low"/>
				<param name="high"/>
				<param name="instrList"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.getIndexOfHandle(org.apache.bcel.generic.InstructionHandle)" access="pub" jdoc="">
				<param name="instrHandle"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.getTargerterIndices(int, int)" access="pub" jdoc="">
				<comm cntt="we only take targeters till the insert point of the &amp;apos;getStatic&amp;apos;"/>
				<param name="lowerIndexLimit"/>
				<param name="targetIndices"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.getNumberOfInstructionsInMethod(sandmark.program.Method)" access="pub" jdoc="">
				<param name="mg"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.getNumberOfClasses(sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="getting the number of classes in the .jar file"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.ObjectUtil.updateJarFileInfo()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.watermark.objectwm.Config" intfc="n" abs="n" inn="n" sloc="76" jdoc="">
			<comm cntt="Constructor"/>
			<field name="myNumberOfEmbeddingOptions" access="priv" jdoc=""/>
			<field name="myMaxCodeInstructions" access="priv" jdoc=""/>
			<field name="myWatermarkValue" access="priv" jdoc=""/>
			<field name="myRecognitionThreshold" access="priv" jdoc=""/>
			<field name="myMethodEmbedThreshold" access="priv" jdoc=""/>
			<field name="myMethodCopyLowerThreshold" access="priv" jdoc=""/>
			<field name="myMethodCopyUpperThreshold" access="priv" jdoc=""/>
			<field name="myMaxMethodOverloads" access="priv" jdoc=""/>
			<field name="myMaxSelectTry" access="priv" jdoc=""/>
			<field name="myBranchNullifyAbortThreshold" access="priv" jdoc=""/>
			<field name="myEmbedEffortCount" access="priv" jdoc=""/>
			<field name="origVector" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.objectwm.Config.Config()" access="pub" jdoc="">
				<comm cntt="number of new code embedding options, leaving aside substitution"/>
				<comm cntt="generally used during taking number of substitution Instructions"/>
				<comm cntt="correlation threshold for recognizer to output watermark &amp;quot; marked&amp;quot;"/>
				<comm cntt="threshold for new instruction embed"/>
				<comm cntt="lower threshold for method length to overload it"/>
				<comm cntt="upper threshold for method length to overload it"/>
				<comm cntt="used to reduce the execution time"/>
				<comm cntt="max number of random selects while picking a method class"/>
				<comm cntt="max number of branch nullify embed point selct aborts before we try to direct the branch to the next instruction"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getBranchNullifyAbortThreshold()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getMaxTry()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getMaxMethodOverloads()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getMethodEmbedThreshold()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getMethodCopyLowerThreshold()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getMethodCopyUpperThreshold()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getRecognitionThreshold()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.setWatermarkValue(String)" access="pub" jdoc="">
				<param name="watermark"/>
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getWatermarkValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getNumberOfEmbeddingOptions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getMaxCodeInstructions()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.objectwm.Config.getEmbedEffortCount()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.steganography">
		<class name="/:sandmark.watermark.steganography.Steganography" intfc="n" abs="n" inn="n" sloc="255" jdoc="Given an application and a (watermark,key) pair, Steganography hides (watermark,key) in a PNG image of the application. To prevent the image from being removed, byte codes from some class of the application are also hidden in the image. A class loader is installed in the application to load hidden class from the image when the application is started. @author Srinivas Visvanathan">
			<comm cntt="does the actual embedding"/>
			<comm cntt="renames .class to .cls. Cheap hack to ensure that our loader"/>
			<comm cntt="(StegLoader) is used to load all the class files in the application"/>
			<comm cntt="adds the class loader (available at STEGLOADER_PATH) to the application."/>
			<comm cntt="add initializations of clsName, mainClsName and imgName in the static"/>
			<comm cntt="initialization code of jc"/>
			<comm cntt="looks through the files of the app and returns name of PNG with largest"/>
			<comm cntt="capacity. Throws an exception of no PNGs are found"/>
			<comm cntt="looks through the classes of the app and returns the name of the class"/>
			<comm cntt="with smallest size. Throws an exception of no classes are found"/>
			<comm cntt="XOR the bytes of buff with bytes of key"/>
			<comm cntt="Instance of this class is returned by recognize"/>
			<comm cntt="class StegIterator"/>
			<field name="app" access="priv" jdoc=""/>
			<field name="wmark" access="priv" jdoc=""/>
			<field name="key" access="priv" jdoc=""/>
			<field name="clsName" access="priv" jdoc=""/>
			<field name="imgName" access="priv" jdoc=""/>
			<field name="mainClsName" access="priv" jdoc=""/>
			<const name="HDR_SIZE" access="priv" jdoc=""/>
			<const name="STEGLOADER_PATH" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.steganography.Steganography.embed(sandmark.watermark.StaticEmbedParameters)" access="pub" jdoc="">
				<comm cntt="get watermark bytes"/>
				<comm cntt="get key"/>
				<comm cntt="select smallest class as class to hide"/>
				<comm cntt="use PNG with largest capacity for hiding"/>
				<comm cntt="identify main class, if present"/>
				<comm cntt="embed stuff"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.doEmbedding()" access="priv" jdoc="">
				<comm cntt="read in png"/>
				<comm cntt="make and hide payload"/>
				<comm cntt="save png back"/>
				<comm cntt="install loader to extract hidden class on startup"/>
				<comm cntt="change class extensions to &amp;quot;.cls&amp;quot; in the jar"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.renameClassFiles()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.constructPayload(java.awt.image.BufferedImage)" access="priv" jdoc="">
				<comm cntt="ensure there&amp;apos;s enough space to hide everything"/>
				<comm cntt="construct payload"/>
				<comm cntt="encode class length"/>
				<comm cntt="next comes class data"/>
				<comm cntt="encode watermark length"/>
				<comm cntt="TODO: XOR with key"/>
				<comm cntt="next comes watermark"/>
				<comm cntt="remove the class being hidden"/>
				<param name="bi"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.installLoader()" access="priv" jdoc="">
				<comm cntt="get steg loader class"/>
				<comm cntt="fix static init code"/>
				<comm cntt="add stegloader to the jar and set it as main class"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.fixStaticInit(org.apache.bcel.classfile.JavaClass)" access="priv" jdoc="">
				<comm cntt="delete all instructions"/>
				<comm cntt="add initialization for clsName"/>
				<comm cntt="add initialization for imgName"/>
				<comm cntt="add initialization for mainClsName"/>
				<param name="jc"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.selectLargestPNG(sandmark.program.Application)" access="priv" jdoc="">
				<comm cntt="bad PNG, skip it"/>
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.selectSmallestClass(sandmark.program.Application)" access="priv" jdoc="">
				<param name="app"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.recognize(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.keyXOR(byte[], long)" access="priv" jdoc="">
				<param name="buff"/>
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.getAlgHTML()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.getAlgURL()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.getAuthor()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.getAuthorEmail()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.getDescription()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.getLongName()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.getMutations()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography.getShortName()" access="pub" jdoc="">
			</mth>
		<class name="/:sandmark.watermark.steganography.Steganography$StegIterator" intfc="n" abs="n" inn="y" sloc="62" jdoc="">
			<field name="key" access="priv" jdoc=""/>
			<field name="wmarks" access="pub" jdoc=""/>
			<field name="curr" access="pub" jdoc=""/>
			<mth name="/:sandmark.watermark.steganography.Steganography$StegIterator.StegIterator(sandmark.watermark.StaticRecognizeParameters)" access="pub" jdoc="">
				<comm cntt="scan thru PNG&amp;apos;s of app, and extract any watermarks they contain into a"/>
				<comm cntt="list"/>
				<param name="params"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography$StegIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography$StegIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography$StegIterator.remove()" access="pub" jdoc="">
				<comm cntt="does nothing"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.Steganography$StegIterator.getWatermark(sandmark.program.File, long)" access="priv" jdoc="">
				<comm cntt="read in the png"/>
				<comm cntt="new java.io.File(&amp;quot;out.png&amp;quot;));"/>
				<comm cntt="extract hidden payload if any"/>
				<comm cntt="extract class length"/>
				<comm cntt="get watermark length"/>
				<comm cntt="extract watermark"/>
				<param name="pngFile"/>
				<param name="key"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.steganography.ImageHider" intfc="n" abs="n" inn="n" sloc="56" jdoc="Utility class that can be used to hide arbitrary data in images. Data hiding is achieved by storing 2 bits of data in the lower 2 significant bits of the alpha, red, green and blue channels of pixels. The class operates on the generic BufferedImage (@see java.awt.image.BufferedImage) image object that&amp;apos;s provided as part of the standard Java library. However Steganography saves and loads images from PNG files only since (a) its one of the formats supported by the standard java library (others are JPEG and GIF; as of j2se 1.4) (b) PNG supports lossless compression (unlike JPEG, which is typically lossy) (c) PNG does not impose any restrictions on the nature of the image (GIF supports at most 256 colors and any image with more colors would be reduced to 256 colors while saving). PNG also faithfully stores transparency (alpha) info.">
			<comm cntt="argb - ARGB value of a single pixel, 8 bits used per channel b - byte to hide 2 bits are hidden in each channel of the pixel by replacing the least significant 2 bits with 2 bits of data Returns the pixel with the data hidden in it"/>
			<comm cntt="Extracts the byte hidden in a pixel by reading out the 2 bits hidden in the ARGB channels"/>
			<const name="HDR_SIZE" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.steganography.ImageHider.hide(java.awt.image.BufferedImage, byte)" access="pub" jdoc="Tries to hide the given data bytes in the given image. @param bi image to hide data in @param payload array of bytes to hide @return If the image has enough capacity, a new image with the data hidden in it is returned. If there wasn&amp;apos;t enough space, null is returned.">
				<comm cntt="not enough space"/>
				<comm cntt="get RGBA info"/>
				<comm cntt="encode payload length"/>
				<comm cntt="construct result image"/>
				<param name="bi"/>
				<param name="payload"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.ImageHider.recover(java.awt.image.BufferedImage)" access="pub" jdoc="Tries to extract any data that may be hidden in the given image. @param bi Image to recover data from @return a byte array if a valid data payload was found in the image or null if no valid data payload was found.">
				<comm cntt="get RGBA info"/>
				<comm cntt="read payload size field and check if its valid"/>
				<comm cntt="read out hidden stuff"/>
				<param name="bi"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.ImageHider.hideByte(int, byte)" access="priv" jdoc="">
				<param name="argb"/>
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.ImageHider.recoverByte(int)" access="priv" jdoc="">
				<param name="argb"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.ImageHider.getCapacity(java.awt.image.BufferedImage)" access="pub" jdoc="Returns the number of bytes of data that can be hidden in a given image. @param bi image @return no. of bytes of data that can be hidden in bi">
				<param name="bi"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.steganography.StegLoader" intfc="n" abs="n" inn="n" sloc="105" jdoc="">
			<comm cntt="name of hidden class"/>
			<comm cntt="name of main class"/>
			<comm cntt="name of image in which class was hidden"/>
			<comm cntt="the code for &amp;lt;clinit&amp;gt; will be replaced by Steganography with valid"/>
			<comm cntt="initializations"/>
			<field name="clsName" access="priv" jdoc=""/>
			<field name="mainClsName" access="priv" jdoc=""/>
			<field name="imgName" access="priv" jdoc=""/>
			<const name="HDR_SIZE" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.steganography.StegLoader.findClass(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.StegLoader.loadClassFromCls(String)" access="priv" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.StegLoader.loadClassFromImage(String)" access="priv" jdoc="">
				<comm cntt="read in png"/>
				<comm cntt="extract hidden payload if any"/>
				<comm cntt="extract class length"/>
				<comm cntt="extract class data"/>
				<param name="name"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.StegLoader.recover(java.awt.image.BufferedImage)" access="pub" jdoc="">
				<comm cntt="get RGBA info"/>
				<comm cntt="read payload size field and check if its valid"/>
				<comm cntt="read out hidden stuff"/>
				<param name="bi"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.StegLoader.recoverByte(int)" access="priv" jdoc="">
				<param name="argb"/>
			</mth>
			<mth name="/:sandmark.watermark.steganography.StegLoader.main(String)" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.watermark.util">
		<class name="/:sandmark.watermark.util.MD5Marker" intfc="n" abs="n" inn="n" sloc="200" jdoc="">
			<field name="dummyFieldName" access="priv" jdoc=""/>
			<field name="dummyClass" access="priv" jdoc=""/>
			<field name="instanceFields" access="priv" jdoc=""/>
			<field name="k" access="priv" jdoc=""/>
			<field name="d" access="priv" jdoc=""/>
			<field name="key" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.util.MD5Marker.MD5Marker(sandmark.program.Class, int, java.math.BigInteger)" access="pub" jdoc="">
				<param name="clazz"/>
				<param name="bits"/>
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.MD5Marker(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.embed(sandmark.analysis.controlflowgraph.BasicBlock, java.math.BigInteger)" access="pub" jdoc="">
				<param name="b"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.recognize(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.capacityIsConstant()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.findMethod(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.insert(org.apache.bcel.generic.Instruction, org.apache.bcel.generic.InstructionList, java.util.ArrayList, org.apache.bcel.generic.InstructionHandle)" access="priv" jdoc="">
				<param name="insn"/>
				<param name="il"/>
				<param name="l"/>
				<param name="last"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.mark(sandmark.analysis.controlflowgraph.BasicBlock, int)" access="priv" jdoc="">
				<param name="b"/>
				<param name="desiredValue"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.pushconst(int)" access="priv" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.addNumber(java.lang.Number)" access="priv" jdoc="">
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.read(java.util.ArrayList)" access="priv" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.addField(sandmark.program.Class, boolean)" access="priv" jdoc="">
				<param name="clazz"/>
				<param name="staticField"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker.addFieldref(sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="">
				<param name="b"/>
			</mth>
		<class name="/:sandmark.watermark.util.MD5Marker$TrivialIterator" intfc="n" abs="n" inn="y" sloc="20" jdoc="">
			<field name="value" access="priv" jdoc=""/>
			<field name="alreadyReturned" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.util.MD5Marker$TrivialIterator.TrivialIterator(int)" access="pub" jdoc="">
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker$TrivialIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker$TrivialIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.util.MD5Marker$TrivialIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.util.StaticWriteParityMarker" intfc="n" abs="y" inn="n" sloc="112" jdoc="This class encodes one-bit values in basic blocks. It does so using parity which can be toggled by inserting one of the following instruction sequences into the basic block:&amp;lt;br&amp;gt; &amp;lt;pre&amp;gt; getstatic &amp;lt;i&amp;gt;dummyfield&amp;lt; i&amp;gt; ineg putstatic &amp;lt;i&amp;gt;dummyfield&amp;lt; i&amp;gt; &amp;lt; pre&amp;gt; or &amp;lt;pre&amp;gt; getstatic &amp;lt;i&amp;gt;dummyfield&amp;lt; i&amp;gt; iconst_1 iadd putstatic &amp;lt;i&amp;gt;dummyfield&amp;lt; i&amp;gt; &amp;lt; pre&amp;gt; where &amp;lt;i&amp;gt;dummyfield&amp;lt; i&amp;gt; is a field added to the program during marking, and is hence not used anywhere by the program. For blocks from instance methods, an instance field is used, so the first and last instructions would be getfield and putfield, respectively.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; Note that this approach will only work if getstatic, putstatic, getfield, and putfield instructions do not end basic blocks. Because of that, classed derived from this one should only be used to mark basic blocks from a {@link sandmark.analysis.controlflowgraph.MethodCFG}where the possibility of a thrown exception does not end a basic block.">
			<field name="dummyFieldName" access="priv" jdoc=""/>
			<field name="dummyClass" access="priv" jdoc=""/>
			<field name="instanceFields" access="priv" jdoc=""/>
			<field name="increment" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.StaticWriteParityMarker(sandmark.program.Class, boolean)" access="prot" jdoc="Constructs a new marker which will create a new static field in the given class if necessary. The field is not added until an attempt is made to mark a basic block from a static method. When a basic block from an instance method is marked, an instance field is added to the class the basic block came from instead. @param clazz class to create a new dummy static field in @param _increment If this argument is true, each added piece of code will increment a new field by 1. If it is false, each piece will negate the new field. Note that the negating instruction sequence consists of 3 instructions, while the incrementing instruction sequence consists of 4.">
				<param name="clazz"/>
				<param name="_increment"/>
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.getParity(sandmark.analysis.controlflowgraph.BasicBlock)" access="prot" jdoc="Returns either 0 or 1, based on what the parity of the given basic block currently is. How exactly that parity is computed is determined by each subclass">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.embed(sandmark.analysis.controlflowgraph.BasicBlock, java.math.BigInteger)" access="pub" jdoc="Attempts to encode the given value in the given basic block. The basic block is modified in place. If the given value is something other than 0 or 1, an {@link IllegalArgumentException} will be thrown. @param b basic block to encode data in @param value data to encode @throws IllegalArgumentException if value is neither 0 nor 1 @see #getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)">
				<param name="b"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.recognize(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="Returns an {@link java.util.Iterator Iterator} over all values found to be embedded in the given basic block. Only values embedded using the marking scheme used by this marker will be reported.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; The {@link java.util.Iterator} will iterate over exactly one value, and that value will be either 0 or 1. @param b basic block to search for a mark in">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="Returns the number of bits that can be encoded into the given basic block. This method always returns 1. @param b basic block to report the bit capacity of @see #embed(sandmark.analysis.controlflowgraph.BasicBlock,java.math.BigInteger) @see #embed(sandmark.analysis.controlflowgraph.BasicBlock,long)">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.capacityIsConstant()" access="pub" jdoc="Returns true if this class returns the same capacity for any basic block, including null. Since the capacity of each basic block under this marker is exactly one bit, this method returns true. @see #getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)">
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.findMethod(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.mark(sandmark.analysis.controlflowgraph.BasicBlock, int)" access="priv" jdoc="">
				<param name="b"/>
				<param name="desiredParity"/>
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.addField(sandmark.program.Class, boolean)" access="priv" jdoc="">
				<param name="clazz"/>
				<param name="staticField"/>
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker.addFieldref(sandmark.analysis.controlflowgraph.BasicBlock)" access="priv" jdoc="">
				<param name="b"/>
			</mth>
		<class name="/:sandmark.watermark.util.StaticWriteParityMarker$TrivialIterator" intfc="n" abs="n" inn="y" sloc="20" jdoc="">
			<field name="value" access="priv" jdoc=""/>
			<field name="alreadyReturned" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker$TrivialIterator.TrivialIterator(int)" access="pub" jdoc="">
				<param name="_value"/>
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker$TrivialIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker$TrivialIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.watermark.util.StaticWriteParityMarker$TrivialIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.util.MethodMarker" intfc="n" abs="y" inn="n" sloc="10" jdoc="Subclasses of this class are used to encode integral values in methods. @see sandmark.analysis.controlflowgraph.MethodCFG">
			<mth name="/:sandmark.watermark.util.MethodMarker.embed(sandmark.program.Method, java.math.BigInteger)" access="pub" jdoc="Attempts to encode the given value in the given method. The method is modified in place. If the number of bits in the given value exceeds that of the value returned by{@link #getCapacity(sandmark.program.Method)}, an {@link java.lang.IllegalArgumentException}will be thrown. @param method method to encode data in @param value data to encode @throws java.lang.IllegalArgumentException if value has too many bits @see #getCapacity(sandmark.program.Method)">
				<param name="method"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MethodMarker.embed(sandmark.program.Method, long)" access="pub" jdoc="Attempts to encode the given value in the given method. The method is modified in place. If the number of bits in the given value exceeds that of the value returned by{@link #getCapacity(sandmark.program.Method)}, an {@link IllegalArgumentException}will be thrown.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; This method is implemented with a call to{@link #embed(sandmark.program.Method,java.math.BigInteger)}. @param method method to encode data in @param value data to encode @throws java.lang.IllegalArgumentException if value has too many bits @see #getCapacity(sandmark.program.Method)">
				<param name="method"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MethodMarker.recognize(sandmark.program.Method)" access="pub" jdoc="Returns an {@link java.util.Iterator} over all values found to be embedded in the given method. Only values embedded using the marking scheme used by this marker will be reported. @param method method to search for marks in">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.util.MethodMarker.getCapacity(sandmark.program.Method)" access="pub" jdoc="Returns the number of bits that can be encoded into the given method. @param method method to report the bit capacity of @see #embed(sandmark.program.Method,java.math.BigInteger) @see #embed(sandmark.program.Method,long)">
				<param name="method"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.util.EveryBlockMarker" intfc="n" abs="n" inn="n" sloc="63" jdoc="This implementation of MethodMarker takes a BasicBlockMarker and uses it to mark each basic block in a method. The BasicBlockMarker is also used to recognize embedded values from each basic block in the method.">
			<field name="marker" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.util.EveryBlockMarker.EveryBlockMarker(BasicBlockMarker)" access="pub" jdoc="Constructs a marker that marks basic blocks using the given {@link BasicBlockMarker}. @param _marker used to embed and recognize values in each basic block of a method">
				<param name="_marker"/>
			</mth>
			<mth name="/:sandmark.watermark.util.EveryBlockMarker.embed(sandmark.program.Method, java.math.BigInteger)" access="pub" jdoc="Attempts to encode the given value in the given method. The method is modified in place. If the number of bits in the given value exceeds that of the value returned by {@link #getCapacity(sandmark.program.Method)}, an {@link IllegalArgumentException} will be thrown.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; Each basic block in the method will be marked with the given value. @param method method to encode data in @param value data to encode @throws java.lang.IllegalArgumentException if value has too many bits @see #getCapacity(sandmark.program.Method)">
				<param name="method"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.watermark.util.EveryBlockMarker.recognize(sandmark.program.Method)" access="pub" jdoc="Returns an {@link java.util.Iterator} over all values found to be embedded in the given method. The returned{@link java.util.Iterator} will iterate over all values found in at least one basic block of the method, sorted in descending order according to how many basic blocks each value was found in. @param method method to search for marks in">
				<param name="method"/>
			</mth>
			<mth name="/:sandmark.watermark.util.EveryBlockMarker.getCapacity(sandmark.program.Method)" access="pub" jdoc="Returns the number of bits that can be encoded into the given method. This is calculated to be the smallest capacity among the basic blocks of the method, as returned by the underlying{@link BasicBlockMarker}. @param method method to report the bit capacity of @see #embed(sandmark.program.Method,java.math.BigInteger) @see #embed(sandmark.program.Method,long) @see BasicBlockMarker#getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)">
				<param name="method"/>
			</mth>
		<class name="/:sandmark.watermark.util.EveryBlockMarker$CountOrderer" intfc="n" abs="n" inn="y" sloc="23" jdoc="">
			<field name="counts" access="priv" jdoc=""/>
			<mth name="/:sandmark.watermark.util.EveryBlockMarker$CountOrderer.CountOrderer(java.util.HashMap)" access="pub" jdoc="">
				<param name="_counts"/>
			</mth>
			<mth name="/:sandmark.watermark.util.EveryBlockMarker$CountOrderer.getCount(Object)" access="priv" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.watermark.util.EveryBlockMarker$CountOrderer.compare(Object, Object)" access="pub" jdoc="">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.watermark.util.InsnCountMarker" intfc="n" abs="n" inn="n" sloc="8" jdoc="This class marks basic blocks with a one-bit value by manipulating the number of instructions in the block. An even number of instructions corresponds to 0; an odd number corresponds to 1. @see PutstaticCountMarker">
			<mth name="/:sandmark.watermark.util.InsnCountMarker.InsnCountMarker(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.watermark.util.InsnCountMarker.getParity(sandmark.analysis.controlflowgraph.BasicBlock)" access="prot" jdoc="Returns either 0 or 1, based on whether the number of instructions in the given basic block is odd or even.">
				<param name="b"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.util.PutstaticCountMarker" intfc="n" abs="n" inn="n" sloc="24" jdoc="This class embeds a one-bit value in a basic block by manipulating the number of distinct static fields written by the basic block. An even number of distinct fields corresponds to 0; an odd number corresponds to 1. Basic blocks can be marked with this class without destroying previous marks made by an{@link InsnCountMarker InsnCountMarker}.">
			<mth name="/:sandmark.watermark.util.PutstaticCountMarker.PutstaticCountMarker(sandmark.program.Class)" access="pub" jdoc="">
				<param name="clazz"/>
			</mth>
			<mth name="/:sandmark.watermark.util.PutstaticCountMarker.getParity(sandmark.analysis.controlflowgraph.BasicBlock)" access="prot" jdoc="Returns either 0 or 1, based on whether the number of unique static fields written to in the given basic block is odd or even.">
				<param name="b"/>
			</mth>
		</class>
		<class name="/:sandmark.watermark.util.BasicBlockMarker" intfc="n" abs="y" inn="n" sloc="13" jdoc="Subclasses of this class are used to encode integral values in basic blocks. @see sandmark.analysis.controlflowgraph.BasicBlock">
			<mth name="/:sandmark.watermark.util.BasicBlockMarker.embed(sandmark.analysis.controlflowgraph.BasicBlock, java.math.BigInteger)" access="pub" jdoc="Attempts to encode the given value in the given basic block. The basic block is modified in place. If the number of bits in the given value exceeds that of the value returned by {@link #getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)}, an {@link IllegalArgumentException} will be thrown. @param b basic block to encode data in @param value data to encode @throws IllegalArgumentException if value has too many bits @see #getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)">
				<param name="b"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.watermark.util.BasicBlockMarker.embed(sandmark.analysis.controlflowgraph.BasicBlock, long)" access="pub" jdoc="Attempts to encode the given value in the given basic block. The basic block is modified in place. If the number of bits in the given value exceeds that of the value returned by {@link #getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)}, an {@link IllegalArgumentException} will be thrown. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt; This method is implemented with a call to{@link #embed(sandmark.analysis.controlflowgraph.BasicBlock,java.math.BigInteger)}. @param b basic block to encode data in @param value data to encode @throws IllegalArgumentException if value has too many bits @see #getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)">
				<param name="b"/>
				<param name="value"/>
			</mth>
			<mth name="/:sandmark.watermark.util.BasicBlockMarker.recognize(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="Returns an {@link java.util.Iterator} over all values found to be embedded in the given basic block. Only values embedded using the marking scheme used by this marker will be reported. @param b basic block to search for marks in">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.util.BasicBlockMarker.getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)" access="pub" jdoc="Returns the number of bits that can be encoded into the given basic block. @param b basic block to report the bit capacity of @see #embed(sandmark.analysis.controlflowgraph.BasicBlock,java.math.BigInteger) @see #embed(sandmark.analysis.controlflowgraph.BasicBlock,long)">
				<param name="b"/>
			</mth>
			<mth name="/:sandmark.watermark.util.BasicBlockMarker.capacityIsConstant()" access="pub" jdoc="Returns true if this class returns the same capacity for any basic block, including null. @see #getCapacity(sandmark.analysis.controlflowgraph.BasicBlock)">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard">
		<class name="/:sandmark.wizard.AppProvider" intfc="n" abs="n" inn="n" sloc="7" jdoc="DefaultObjectProvider that provides sandmark Applications.">
			<mth name="/:sandmark.wizard.AppProvider.addObject(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.DefaultAlgorithmProvider" intfc="n" abs="n" inn="n" sloc="27" jdoc="@author ash AlgorithmProvider that provides sandmark Algorithms that are not dynamic watermarks or birthmarks (i.e. obfuscations, static watermarks, etc.)">
			<field name="sAlgs" access="prot" jdoc=""/>
			<field name="mAlgs" access="priv" jdoc=""/>
			<field name="mCursor" access="pub" jdoc=""/>
			<mth name="/:sandmark.wizard.DefaultAlgorithmProvider.getAlgorithms()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.DefaultAlgorithmProvider.reset()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.DefaultAlgorithmProvider.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.DefaultAlgorithmProvider.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.DefaultAlgorithmProvider.remove()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.DefaultObjectProvider" intfc="n" abs="n" inn="n" sloc="25" jdoc="@author ash ObjectProvider that provides sandmark Objects and allows adding, removing, etc.">
			<field name="mObjects" access="prot" jdoc=""/>
			<field name="mCursor" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.DefaultObjectProvider.addObject(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.DefaultObjectProvider.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.DefaultObjectProvider.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.DefaultObjectProvider.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.DefaultObjectProvider.reset()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.DefaultObjectProvider.getObjects()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.DefaultObjectProvider.removeObject(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.StaticWatermarkProvider" intfc="n" abs="n" inn="n" sloc="12" jdoc="@author ash AlgorithmProvider that provides sandmark static watmerking algorithms only.">
		</class>
		<class name="/:sandmark.wizard.AlgorithmProvider" intfc="y" abs="n" inn="n" sloc="4" jdoc="">
			<mth name="/:sandmark.wizard.AlgorithmProvider.getAlgorithms()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.AlgorithmProvider.reset()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.ChoiceRunner" intfc="n" abs="n" inn="n" sloc="40" jdoc="@author ash Runs Choice c">
			<field name="mListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.ChoiceRunner.run(sandmark.wizard.modeling.Choice)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.wizard.ChoiceRunner.addRunListener(ChoiceRunListener)" access="pub" jdoc="">
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.wizard.ChoiceRunner.removeRunListener(ChoiceRunListener)" access="pub" jdoc="">
				<param name="r"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.Wizard" intfc="n" abs="y" inn="n" sloc="30" jdoc="A Wizard object encapsulates code for performing multiple obfuscations and or watermarking algorithms. @author Kelly Heffner @version 1.0 11 17 2003">
			<mth name="/:sandmark.wizard.Wizard.step()" access="pub" jdoc="Performs another iteration of the algorithm, returning false if the algorithm is done. Ideally this allows for the user of the wizard to setup a system with &amp;lt;code&amp;gt;while(wizard.step())&amp;lt; code&amp;gt;.">
			</mth>
			<mth name="/:sandmark.wizard.Wizard.getLastChoice()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.Wizard.runChoice(sandmark.wizard.modeling.Choice)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.wizard.Wizard.getConfigProperties()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.ChoiceRunListener" intfc="y" abs="n" inn="n" sloc="3" jdoc="@author ash Listens for choice run.">
			<mth name="/:sandmark.wizard.ChoiceRunListener.ranChoice(sandmark.wizard.modeling.Choice)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.ObjectProvider" intfc="y" abs="n" inn="n" sloc="6" jdoc="@author ash Provides sandmark Objects for wizard">
			<mth name="/:sandmark.wizard.ObjectProvider.addObject(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.ObjectProvider.getObjects()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.ObjectProvider.reset()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.ObjectProvider.removeObject(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.decision">
		<class name="/:sandmark.wizard.decision.Strategy" intfc="y" abs="n" inn="n" sloc="6" jdoc="Interface that encapsulates the code that makes decisions of what choices to run, in what order, and runs choices.">
			<mth name="/:sandmark.wizard.decision.Strategy.step()" access="pub" jdoc="Called multiple times to run algorithms. Returns whether Strategy has finished or not.">
			</mth>
			<mth name="/:sandmark.wizard.decision.Strategy.init(sandmark.wizard.modeling.Model, sandmark.wizard.evaluation.Evaluator, sandmark.wizard.ChoiceRunner)" access="pub" jdoc="">
				<param name="m"/>
				<param name="e"/>
				<param name="r"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.decision.AllAlgsOnce" intfc="n" abs="n" inn="n" sloc="21" jdoc="@author ash AllAlgsOnce is a Strategery that runs each algorithm provided by the AlgorithmProvider one time by iterating over algorithms.">
			<comm cntt="(non-Javadoc) @see sandmark.wizard.decision.Strategy#step()"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.decision.Strategy#init(sandmark.wizard.modeling.Model, sandmark.wizard.evaluation.Evaluator, sandmark.wizard.ChoiceRunner)"/>
			<field name="mModel" access="priv" jdoc=""/>
			<field name="mRunner" access="priv" jdoc=""/>
			<field name="mUsedAlgs" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.decision.AllAlgsOnce.step()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.decision.AllAlgsOnce.init(Model, Evaluator, ChoiceRunner)" access="pub" jdoc="">
				<param name="m"/>
				<param name="e"/>
				<param name="r"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.decision.priority">
		<class name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy" intfc="n" abs="n" inn="n" sloc="80" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<comm cntt="we want high priority near the front"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.decision.Strategy#step()"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.decision.Strategy#init(sandmark.wizard.modeling.Model, sandmark.wizard.evaluation.Evaluator, sandmark.wizard.ChoiceRunner)"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.modeling.ModelChangeListener#modelChanged()"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.modeling.ModelChangeListener#choicesAdded(sandmark.wizard.modeling.Choice[])"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.modeling.ModelChangeListener#choicesRemoved(sandmark.wizard.modeling.Choice[])"/>
			<const name="DELTA" access="prot" jdoc=""/>
			<field name="mChoicePQ" access="prot" jdoc=""/>
			<field name="mEvaluator" access="priv" jdoc=""/>
			<field name="mModel" access="prot" jdoc=""/>
			<field name="mRunner" access="prot" jdoc=""/>
			<field name="mPQComparator" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy.valueUpdated(sandmark.program.Object, float, float)" access="pub" jdoc="">
				<param name="object"/>
				<param name="obfLevel"/>
				<param name="perfLevel"/>
			</mth>
			<mth name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy.getWeightForChoice(sandmark.wizard.modeling.Choice, float, float)" access="priv" jdoc="">
				<comm cntt="XXXash: need to get alg potency here"/>
				<param name="c"/>
				<param name="obfLevel"/>
				<param name="perfLevel"/>
			</mth>
			<mth name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy.step()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy.init(sandmark.wizard.modeling.Model, sandmark.wizard.evaluation.Evaluator, sandmark.wizard.ChoiceRunner)" access="pub" jdoc="">
				<param name="m"/>
				<param name="e"/>
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy.modelChanged()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy.choicesAdded(sandmark.wizard.modeling.Choice[])" access="pub" jdoc="">
				<param name="choices"/>
			</mth>
			<mth name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy.choicesRemoved(sandmark.wizard.modeling.Choice[])" access="pub" jdoc="">
				<param name="choices"/>
			</mth>
		<class name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy$ChoiceWrapper" intfc="n" abs="n" inn="y" sloc="10" jdoc="">
			<field name="value" access="pub" jdoc=""/>
			<mth name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy$ChoiceWrapper.ChoiceWrapper(sandmark.wizard.modeling.Choice, float)" access="pub" jdoc="">
				<param name="c"/>
				<param name="v"/>
			</mth>
			<mth name="/:sandmark.wizard.decision.priority.MaxPriorityStrategy$ChoiceWrapper.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.decision.random">
		<class name="/:sandmark.wizard.decision.random.Random" intfc="n" abs="n" inn="n" sloc="22" jdoc="Strategy that randomly chooses sandmark algorithms to run for each step.">
			<mth name="/:sandmark.wizard.decision.random.Random.step()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.evaluation">
		<class name="/:sandmark.wizard.evaluation.Evaluator" intfc="y" abs="n" inn="n" sloc="7" jdoc="Class that encapsulates evaluation for obfuscation level and performance level for sandmark objects.">
			<mth name="/:sandmark.wizard.evaluation.Evaluator.addEvaluationListener(EvaluationListener)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.Evaluator.removeEvaluationListener(EvaluationListener)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.Evaluator.evaluateObfuscationLevel(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.Evaluator.evaluatePerformanceLevel(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.Evaluator.init(sandmark.wizard.modeling.Model, sandmark.wizard.ChoiceRunner)" access="pub" jdoc="">
				<param name="m"/>
				<param name="r"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.evaluation.FixedChange" intfc="n" abs="n" inn="n" sloc="33" jdoc="">
			<const name="OBF_START" access="priv" jdoc=""/>
			<const name="PERF_START" access="priv" jdoc=""/>
			<field name="change" access="priv" jdoc=""/>
			<field name="mObjectToRunCount" access="priv" jdoc=""/>
			<field name="mListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.evaluation.FixedChange.FixedChange(float)" access="pub" jdoc="">
				<param name="f"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.FixedChange.FixedChange()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.evaluation.FixedChange.init(sandmark.wizard.modeling.Model, sandmark.wizard.ChoiceRunner)" access="pub" jdoc="">
				<param name="m"/>
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.FixedChange.addEvaluationListener(EvaluationListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.FixedChange.removeEvaluationListener(EvaluationListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.FixedChange.evaluatePerformanceLevel(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.FixedChange.evaluateObfuscationLevel(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.FixedChange.ranChoice(sandmark.wizard.modeling.Choice)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.evaluation.EvaluationListener" intfc="y" abs="n" inn="n" sloc="3" jdoc="@author ash Interface for classes that listen for value of obfuscation level and performance level update for sandmark objects being protected using quick protect wizard.">
			<mth name="/:sandmark.wizard.evaluation.EvaluationListener.valueUpdated(sandmark.program.Object, float, float)" access="pub" jdoc="">
				<param name="o"/>
				<param name="obfLevel"/>
				<param name="perfLevel"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.evaluation.hprof">
		<class name="/:sandmark.wizard.evaluation.hprof.Hprof" intfc="n" abs="n" inn="n" sloc="131" jdoc="Hprof objects are an abstraction of information contained in the output file from the Java profiler (hprof). At the present, this file assumes that hprof was run with the options &amp;lt;code&amp;gt;cpu=times,heap=sites&amp;lt; code&amp;gt;. At the time this code was written, no known implementation of an abstraction for hprof data existed. The hprof output format is defined, but not finalized; changes to the output format should be reflected in this code. @author Kelly Heffner @since 3.3.0">
			<comm cntt="Hash on method --&amp;gt; data, data is sortable by rank"/>
			<comm cntt="sample format"/>
			<comm cntt="rank self accum count trace method"/>
			<comm cntt="1 33.44% 33.44% 1 305 Matrix.matinv"/>
			<comm cntt="2 24.41% 57.86% 24157828 303 Matrix.get_elem"/>
			<comm cntt="3 15.72% 73.58% 16000000 301 Matrix.get_elem"/>
			<comm cntt="4 14.38% 87.96% 1 304 Matrix.matmul"/>
			<comm cntt="5 12.04% 100.00% 12177828 302 Matrix.set_elem"/>
			<comm cntt="rank percent_in_trace cummulative count_in_trace method_of_trace"/>
			<const name="CPU_TIME_START" access="priv" jdoc=""/>
			<const name="CPU_TIME_END" access="priv" jdoc=""/>
			<const name="CPU_TIME_START2" access="priv" jdoc=""/>
			<const name="CPU_TIME_END2" access="priv" jdoc=""/>
			<field name="mCPUInfo" access="priv" jdoc=""/>
			<field name="mJavaArgs" access="priv" jdoc=""/>
			<field name="mListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.Hprof(String)" access="pub" jdoc="Creates an Hprof object out of the given output file.">
				<param name="javaArgs"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.evaluatePerformanceLevel(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.evaluateObfuscationLevel(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.ranChoice(sandmark.wizard.modeling.Choice)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.init(sandmark.wizard.modeling.Model, sandmark.wizard.ChoiceRunner)" access="pub" jdoc="">
				<param name="model"/>
				<param name="runner"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.addEvaluationListener(sandmark.wizard.evaluation.EvaluationListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.removeEvaluationListener(sandmark.wizard.evaluation.EvaluationListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.getProfileData()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.parse(java.io.File)" access="priv" jdoc="">
				<comm cntt="skip over all of the file until the CPU usage information is found"/>
				<comm cntt="and read it in"/>
				<comm cntt="System.out.println(&amp;quot;##&amp;quot;+currLine);"/>
				<param name="hprofOutput"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.parseCPU(java.util.HashMap, java.io.BufferedReader)" access="priv" jdoc="">
				<comm cntt="read the table header and eat it"/>
				<comm cntt="all done"/>
				<comm cntt="rank, percent, cummulative, count, trace number, methodname"/>
				<comm cntt="int rank = Integer.parseInt("/>
				<comm cntt="eat cummulative"/>
				<comm cntt="there are multiple entries per method (from different call"/>
				<comm cntt="locations) - add the percent usage, count,"/>
				<comm cntt="keep method"/>
				<param name="cpuInfo"/>
				<param name="inFile"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.getCpuUsage(java.util.HashMap, sandmark.program.Object)" access="pub" jdoc="">
				<param name="cpuInfo"/>
				<param name="object"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.getCpuUsage(java.util.HashMap, sandmark.program.Method)" access="pub" jdoc="">
				<comm cntt="System.out.println(key);"/>
				<param name="cpuInfo"/>
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.getCpuUsage(java.util.HashMap, sandmark.program.Class)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;getting for class: &amp;quot; + c);"/>
				<param name="cpuInfo"/>
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.getCpuUsage(java.util.HashMap, sandmark.program.Application)" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;getting for app&amp;quot;);"/>
				<param name="cpuInfo"/>
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof.doProfile(String)" access="priv" jdoc="">
				<param name="javaArgs"/>
			</mth>
		<class name="/:sandmark.wizard.evaluation.hprof.Hprof$CPU_Data" intfc="n" abs="n" inn="y" sloc="22" jdoc="">
			<comm cntt="public int rank;"/>
			<comm cntt="ideally if needed later, a bunch of Comparators could be provided"/>
			<comm cntt="if you wanted to sort the data differently"/>
			<field name="percent" access="pub" jdoc=""/>
			<field name="count" access="pub" jdoc=""/>
			<field name="traceNumbers" access="pub" jdoc=""/>
			<field name="method" access="pub" jdoc=""/>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof$CPU_Data.CPU_Data(float, int, int, String)" access="pub" jdoc="">
				<param name="p"/>
				<param name="c"/>
				<param name="t"/>
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof$CPU_Data.compareTo(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.hprof.Hprof$CPU_Data.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.evaluation.swmetric">
		<class name="/:sandmark.wizard.evaluation.swmetric.Metrics" intfc="n" abs="n" inn="n" sloc="22" jdoc="Metrics is a simple wrapper class that bundles together all of the data collected from the different statistics.">
			<field name="measures" access="pub" jdoc=""/>
			<mth name="/:sandmark.wizard.evaluation.swmetric.Metrics.Metrics(float[])" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.Metrics.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.Metrics.length()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.evaluation.swmetric.MetricSummary" intfc="n" abs="y" inn="n" sloc="41" jdoc="">
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricSummary.main(String[])" access="pub" jdoc="">
				<comm cntt="java.util.ArrayList appMetrics = new java.util.ArrayList();"/>
				<comm cntt="java.util.ArrayList classMetrics = new java.util.ArrayList();"/>
				<comm cntt="java.util.ArrayList methodMetrics = new java.util.ArrayList();"/>
				<comm cntt="open up each application and collect the stats"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricSummary.doBoundries(Metrics[], String[])" access="priv" jdoc="">
				<param name="am"/>
				<param name="names"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricSummary.printArray(Metrics[], java.io.PrintStream)" access="priv" jdoc="">
				<param name="m"/>
				<param name="file"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.evaluation.swmetric.MetricChange" intfc="n" abs="n" inn="n" sloc="219" jdoc="">
			<field name="mListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.addEvaluationListener(sandmark.wizard.evaluation.EvaluationListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.removeEvaluationListener(sandmark.wizard.evaluation.EvaluationListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.init(sandmark.wizard.modeling.Model, sandmark.wizard.ChoiceRunner)" access="pub" jdoc="">
				<param name="m"/>
				<param name="r"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.ranChoice(sandmark.wizard.modeling.Choice)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.getMetrics(sandmark.program.Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.getMetrics(sandmark.program.Application, boolean)" access="pub" jdoc="">
				<comm cntt="am.evaluateMetric();"/>
				<param name="app"/>
				<param name="normalize"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.getMetrics(sandmark.program.Method, boolean)" access="pub" jdoc="">
				<comm cntt="sandmark.newstatistics.Stats stats = m.getApplication().getStatistics();"/>
				<comm cntt="java.util.Iterator classes = app.classes();"/>
				<comm cntt="mm.evaluateMetric();"/>
				<param name="m"/>
				<param name="normalize"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.getMetrics(sandmark.program.Class, boolean)" access="pub" jdoc="">
				<comm cntt="sandmark.newstatistics.Stats stats = cls.getApplication().getStatistics();"/>
				<comm cntt="cm.evaluateMetric();"/>
				<param name="cls"/>
				<param name="normalize"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.getAppMetrics(sandmark.program.Application, boolean)" access="pub" jdoc="">
				<param name="app"/>
				<param name="norm"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.getClassMetrics(sandmark.program.Application, boolean)" access="pub" jdoc="">
				<param name="app"/>
				<param name="norm"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.getMethodMetrics(sandmark.program.Application, boolean)" access="pub" jdoc="">
				<param name="app"/>
				<param name="norm"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.getAverage(sandmark.wizard.evaluation.swmetric.Metrics)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.getSum(sandmark.wizard.evaluation.swmetric.Metrics)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.evaluateObfuscationLevel(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.evaluatePerformanceLevel(sandmark.program.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.computeChange(sandmark.wizard.evaluation.swmetric.Metrics, sandmark.wizard.evaluation.swmetric.Metrics)" access="pub" jdoc="">
				<comm cntt="fix this when the metric scaling gets fixed!"/>
				<param name="met1"/>
				<param name="met2"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.foldMean(sandmark.wizard.evaluation.swmetric.Metrics[])" access="pub" jdoc="">
				<param name="metrics"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.foldMax(sandmark.wizard.evaluation.swmetric.Metrics[])" access="pub" jdoc="">
				<param name="metrics"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.foldStdDev(sandmark.wizard.evaluation.swmetric.Metrics[])" access="pub" jdoc="">
				<comm cntt="one value from a method is metrics[m].measures[i]"/>
				<param name="metrics"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.foldMin(sandmark.wizard.evaluation.swmetric.Metrics[])" access="pub" jdoc="">
				<param name="metrics"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.MetricChange.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.evaluation.swmetric.StatisticsPrimer" intfc="n" abs="n" inn="n" sloc="56" jdoc="">
			<mth name="/:sandmark.wizard.evaluation.swmetric.StatisticsPrimer.main(String[])" access="pub" jdoc="">
				<comm cntt="open up each application and collect the stats"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.StatisticsPrimer.doBoundries(Metrics[], String[])" access="priv" jdoc="">
				<param name="am"/>
				<param name="names"/>
			</mth>
			<mth name="/:sandmark.wizard.evaluation.swmetric.StatisticsPrimer.printArray(Metrics[], java.io.PrintStream)" access="priv" jdoc="">
				<param name="m"/>
				<param name="file"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.executive">
		<class name="/:sandmark.wizard.executive.DAGWatermark" intfc="n" abs="n" inn="n" sloc="85" jdoc="">
			<field name="app" access="priv" jdoc=""/>
			<field name="watermarks" access="priv" jdoc=""/>
			<field name="key" access="priv" jdoc=""/>
			<field name="params" access="priv" jdoc=""/>
			<field name="appliedWM" access="priv" jdoc=""/>
			<field name="watermarkers" access="priv" jdoc=""/>
			<field name="dag" access="priv" jdoc=""/>
			<field name="myLastChoice" access="priv" jdoc=""/>
			<field name="watermarkChoice" access="priv" jdoc=""/>
			<field name="index" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.executive.DAGWatermark.DAGWatermark(sandmark.program.Application, String[], String)" access="pub" jdoc="">
				<param name="app"/>
				<param name="watermarks"/>
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.wizard.executive.DAGWatermark.step()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.executive.DAGWatermark.getLastChoice()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.executive.DAGWatermark.getAppliedWatermarkers()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.executive.DAGWatermark.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.executive.RandomWatermark" intfc="n" abs="n" inn="n" sloc="104" jdoc="">
			<field name="app" access="priv" jdoc=""/>
			<field name="watermarks" access="priv" jdoc=""/>
			<field name="key" access="priv" jdoc=""/>
			<field name="params" access="priv" jdoc=""/>
			<field name="myRandom" access="priv" jdoc=""/>
			<field name="myPostProhibits" access="priv" jdoc=""/>
			<field name="appliedWM" access="priv" jdoc=""/>
			<field name="watermarkers" access="priv" jdoc=""/>
			<field name="myLastChoice" access="priv" jdoc=""/>
			<field name="watermarkChoice" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.executive.RandomWatermark.RandomWatermark(sandmark.program.Application, String[], String)" access="pub" jdoc="">
				<param name="app"/>
				<param name="watermarks"/>
				<param name="key"/>
			</mth>
			<mth name="/:sandmark.wizard.executive.RandomWatermark.step()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.executive.RandomWatermark.getLastChoice()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.executive.RandomWatermark.getAppliedWatermarkers()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.executive.RandomWatermark.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.modeling">
		<class name="/:sandmark.wizard.modeling.CorruptStateException" intfc="n" abs="n" inn="n" sloc="5" jdoc="">
			<mth name="/:sandmark.wizard.modeling.CorruptStateException.CorruptStateException()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.CorruptStateException.CorruptStateException(String)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.Choice" intfc="n" abs="n" inn="n" sloc="18" jdoc="">
			<const name="DONE" access="pub" jdoc=""/>
			<const name="COMPLETE" access="pub" jdoc=""/>
			<field name="myAlg" access="priv" jdoc=""/>
			<field name="myTarget" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.Choice.Choice(sandmark.Algorithm, sandmark.program.Object)" access="pub" jdoc="">
				<param name="alg"/>
				<param name="targ"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Choice.getAlg()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Choice.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Choice.getTarget()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.Model" intfc="y" abs="n" inn="n" sloc="21" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.wizard.modeling.Model.init(sandmark.wizard.evaluation.Evaluator, sandmark.wizard.ChoiceRunner, sandmark.wizard.ObjectProvider, sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="e"/>
				<param name="r"/>
				<param name="op"/>
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.getChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.getChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.getChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.choices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.getTerminationChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.getTerminationChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.getTerminationChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.terminationChoices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.addModelChangeListener(ModelChangeListener)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.removeModelChangeListener(ModelChangeListener)" access="pub" jdoc="">
				<param name="m"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.isTerminationPoint()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.hasChoices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.getVisualization()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.filter(sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Model.filter(sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.Util" intfc="n" abs="n" inn="n" sloc="337" jdoc="The Util class specifies convience methods for determining the dependencies between obfuscations, watermarkers, etc (any &amp;lt;code&amp;gt;sandmark.Algorithm&amp;lt; code&amp;gt; algorithm). @author Kelly Heffner @since 3.4.0 11 18 03">
			<comm cntt="mapping from sandmark.config.RequisiteProperty"/>
			<comm cntt="to a list of algorithms that prohibit require it"/>
			<comm cntt="mapping from sandmark.config.RequisiteProperty"/>
			<comm cntt="to a list of algorithms that have that property"/>
			<const name="PRE_REQUIRE" access="pub" jdoc=""/>
			<const name="POST_REQUIRE" access="pub" jdoc=""/>
			<const name="PRE_PROHIBIT" access="pub" jdoc=""/>
			<const name="POST_PROHIBIT" access="pub" jdoc=""/>
			<const name="PRE_SUGGEST" access="pub" jdoc=""/>
			<const name="POST_SUGGEST" access="pub" jdoc=""/>
			<field name="allAlgorithms" access="priv" jdoc=""/>
			<field name="obfs" access="priv" jdoc=""/>
			<field name="dynSwm" access="priv" jdoc=""/>
			<field name="stcSwm" access="priv" jdoc=""/>
			<field name="algDependencies" access="priv" jdoc=""/>
			<field name="propToPreprohibit" access="priv" jdoc=""/>
			<field name="propToPostprohibit" access="priv" jdoc=""/>
			<field name="propToPrerequisite" access="priv" jdoc=""/>
			<field name="propToPostrequisite" access="priv" jdoc=""/>
			<field name="propToAlgorithms" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.Util.getObfuscators()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getDynamicWatermarkers()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getStaticWatermarkers()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getXers(sandmark.Algorithm, int)" access="pub" jdoc="Returns a list of all algorithms that Xs the given algorithm, where X is one of the given dependency relationships. @param alg the target algorithm @param relation a dependency relationship">
				<param name="alg"/>
				<param name="relation"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getXed(sandmark.Algorithm, int)" access="pub" jdoc="Returns a list of all algorithms that the given algorithm Xs, where X is one of the given dependency relationships. @param alg the source algorithm @param relation a dependency relationship @return a list of algorithms that &amp;lt;code&amp;gt;alg&amp;lt; code&amp;gt; Xs">
				<param name="alg"/>
				<param name="relation"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getPrerequisiters(sandmark.config.RequisiteProperty)" access="pub" jdoc="Returns a list of all algorithms which prerequire the property in question.">
				<comm cntt="System.exit(0);"/>
				<param name="prop"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getPostrequisiters(sandmark.config.RequisiteProperty)" access="pub" jdoc="Returns a list of all algorithms which postrequire the property in question.">
				<param name="prop"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getPreprohibitors(sandmark.config.RequisiteProperty)" access="pub" jdoc="Returns a list of all algorithms which preprohibit the property in question.">
				<param name="prop"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getPostprohibitors(sandmark.config.RequisiteProperty)" access="pub" jdoc="Returns a list of all algorithms which postprohibit the property in question.">
				<param name="prop"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getAlgsForProp(sandmark.config.RequisiteProperty)" access="pub" jdoc="Returns a list of all algorithms which have the property in question.">
				<comm cntt="change this to an array? the list never changes..."/>
				<param name="prop"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getMutationProps(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.main(String[])" access="pub" jdoc="">
				<comm cntt="font size"/>
				<comm cntt="labeled nodes"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getSpecifiers(sandmark.config.RequisiteProperty, java.util.HashMap, java.lang.reflect.Method)" access="priv" jdoc="Returns a list of all algorithms which are related to the property in question via the supplied relation.">
				<comm cntt="IllegalAccessException, IllegalArgumentException, InvocationTargetException"/>
				<param name="prop"/>
				<param name="propToSpecifier"/>
				<param name="getSpecifys"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.setIntersect(java.util.List, java.util.List)" access="pub" jdoc="Takes the intersection of two Lists. @param l1 one list @param l2 a second list @return the intersection of l1 and l2">
				<param name="l1"/>
				<param name="l2"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.initializeAlgs()" access="priv" jdoc="">
				<comm cntt="no obfuscators returns null list"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.initializeGraph()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.isTargetOf(sandmark.program.Object, sandmark.Algorithm)" access="pub" jdoc="">
				<param name="o"/>
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.getAlgsForTarget(sandmark.program.Object, sandmark.Algorithm[])" access="pub" jdoc="">
				<param name="o"/>
				<param name="algs"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util.isAncestorOf(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="child"/>
				<param name="parent"/>
			</mth>
		<class name="/:sandmark.wizard.modeling.Util$DependencyEdge" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<comm cntt="private sandmark.Algorithm from;"/>
			<comm cntt="private sandmark.Algorithm to;"/>
			<comm cntt="public java.lang.Object sinkNode(){"/>
			<comm cntt="return to;"/>
			<comm cntt="}"/>
			<comm cntt="public java.lang.Object sourceNode(){"/>
			<comm cntt="return from;"/>
			<comm cntt="}"/>
			<field name="type" access="priv" jdoc=""/>
			<const name="LABELS" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.Util$DependencyEdge.DependencyEdge(sandmark.Algorithm, sandmark.Algorithm, int)" access="pub" jdoc="">
				<param name="a"/>
				<param name="b"/>
				<param name="relation"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.Util$DependencyEdge.getType()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.wizard.modeling.ModelChangeListener" intfc="y" abs="n" inn="n" sloc="5" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.wizard.modeling.ModelChangeListener.modelChanged()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.ModelChangeListener.choicesAdded(Choice[])" access="pub" jdoc="">
				<param name="choices"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.ModelChangeListener.choicesRemoved(Choice[])" access="pub" jdoc="">
				<param name="choices"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.modeling.dfa">
		<class name="/:sandmark.wizard.modeling.dfa.WeightMap" intfc="n" abs="n" inn="n" sloc="44" jdoc="">
			<comm cntt="file has format ShortName:number"/>
			<comm cntt="System.out.println(entry + &amp;quot; &amp;quot; + breakPt + &amp;quot; &amp;quot; + breakPt2);"/>
			<field name="myWeights" access="priv" jdoc=""/>
			<field name="myDegrade" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.dfa.WeightMap.getWeightForAlg(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="obf"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.WeightMap.getDegradationForAlg(sandmark.Algorithm)" access="pub" jdoc="">
				<param name="obf"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.WeightPrimer" intfc="n" abs="n" inn="n" sloc="169" jdoc="This class performs the computations to decide the algorithm strength, and aids in computing performance degradation.">
			<comm cntt="private static float getClassMetrics(sandmark.program.Application app) { sandmark.newstatistics.Stats stats = app.getStatistics(); java.util.Iterator classes = app.classes(); float count = 0; float sum = 0; while(classes.hasNext()){ sandmark.program.Class cls = (sandmark.program.Class)classes.next(); sandmark.metric.Metric [] classMetrics = stats.getClassMetrics(cls); for(int i = 0; i &amp;lt; classMetrics.length; i++){ sandmark.metric.Metric cm = classMetrics[i]; cm.evaluateMetric(); sum += cm.getNormalizedMeasure(cm.getMeasure()); count++; } } if(count == 0) return 0; else return sum count; } private static float getMethodMetrics(sandmark.program.Application app) { sandmark.newstatistics.Stats stats = app.getStatistics(); java.util.Iterator classes = app.classes(); float count = 0; float sum = 0; while(classes.hasNext()){ sandmark.program.Class cls = (sandmark.program.Class)classes.next(); java.util.Iterator methods = cls.methods(); while(methods.hasNext()){ sandmark.program.Method m = (sandmark.program.Method)methods.next(); sandmark.metric.Metric [] metrics = stats.getMethodMetrics(m); for(int i = 0; i &amp;lt; metrics.length; i++){ sandmark.metric.MethodMetric mm = (sandmark.metric.MethodMetric) metrics[i]; mm.evaluateMetric(); sum += mm.getNormalizedMeasure(mm.getMeasure()); count++; } } } if(count == 0) return 0; return sum count; }"/>
			<mth name="/:sandmark.wizard.modeling.dfa.WeightPrimer.main(String[])" access="pub" jdoc="">
				<comm cntt="String [] obfuscatorNames = sandmark.obfuscate.Obfuscator.getAllObfuscatorNames();"/>
				<comm cntt="args[1] contains obfuscator to use"/>
				<comm cntt="args contains jar files to prime on"/>
				<comm cntt="now run the obfuscators"/>
				<comm cntt="calculate the difference and stick it in goodness"/>
				<comm cntt="normalize"/>
				<param name="args"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.WeightPrimer.getTiming(sandmark.obfuscate.GeneralObfuscator[], String, String[])" access="priv" jdoc="">
				<comm cntt="make sure that any caching done by runtime isnt recorded"/>
				<comm cntt="p.getInputStream();"/>
				<comm cntt="System.out.println(&amp;quot;Raw timing: &amp;quot; + timing[i]);"/>
				<param name="obfuscators"/>
				<param name="jar1"/>
				<param name="jar2"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.DFA" intfc="n" abs="n" inn="n" sloc="382" jdoc="">
			<comm cntt="mapping of application object A to an arraylist of application objects in A&amp;apos;s range"/>
			<comm cntt="used for dfa intersection"/>
			<comm cntt="remove all useless states from the graph"/>
			<comm cntt="trims the dfa to the dfa containing only those nodes"/>
			<const name="DEBUG" access="priv" jdoc=""/>
			<field name="myStartState" access="prot" jdoc=""/>
			<field name="rangeMap" access="prot" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.DFA(java.util.HashMap)" access="priv" jdoc="">
				<param name="rangeMap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.DFA(java.util.HashMap, sandmark.Algorithm, sandmark.config.RequisiteProperty, sandmark.Algorithm[], sandmark.program.Object[], boolean)" access="prot" jdoc="Constructs common structure between every dfa type. Initializes the set of states to be the powerset of the set of all application objects that are a target of alg1. @param alg1 the algorithm that is involved in the dependency @param accept initial value of every state&amp;apos;s accept field">
				<comm cntt="The set of states is composed of the powerset of all application objects that are"/>
				<comm cntt="a target of alg1"/>
				<comm cntt="build the nodes"/>
				<comm cntt="build the edges"/>
				<comm cntt="then \lambda(q, (a,t))= q"/>
				<param name="rangeMap"/>
				<param name="alg1"/>
				<param name="prop"/>
				<param name="allAlgs"/>
				<param name="allObjects"/>
				<param name="accept"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.createDFA(sandmark.Algorithm[], sandmark.program.Object[])" access="pub" jdoc="Creates a DFA for algs and objects by finding dependencies of algorithms.">
				<comm cntt="get range of all objects"/>
				<comm cntt="getUniversalDFA(algs, objects); if there were no restrictions, this would be it!"/>
				<comm cntt="for each algorithm find postprohibits, preprohibits, prerequisites and postprohibits"/>
				<comm cntt="build DFA by intersecting restriction DFA&amp;apos;s."/>
				<param name="algs"/>
				<param name="objects"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.trim()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.getStartState()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.toDot()" access="pub" jdoc="">
				<comm cntt="+ &amp;quot;, label= &amp;quot; + &amp;quot;\&amp;quot;&amp;quot; + node.getLabel()"/>
				<comm cntt="if(edge.getSource() == edge.getDestination())"/>
				<comm cntt="label = &amp;quot;&amp;quot;;"/>
				<comm cntt="else"/>
				<comm cntt="if(edge.getSource() != edge.getDestination()){"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.dotInFile(String)" access="pub" jdoc="">
				<param name="filename"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.buildRangeMap(sandmark.program.Object[])" access="prot" jdoc="For each object o, if t is a subobject of o or vice versa then o is in r(t)">
				<comm cntt="for each object o, if t is a subobject of o or vice versa"/>
				<comm cntt="then o is in r(t)."/>
				<param name="objects"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.isSubobjectOf(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="child"/>
				<param name="parent"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.getAlphabet(sandmark.Algorithm[], sandmark.program.Object[])" access="prot" jdoc="Returns a list of tuples (algorithm, target) of valid algorithm to target pairs.">
				<param name="allAlgs"/>
				<param name="allObjs"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.isTargetOf(sandmark.program.Object, sandmark.Algorithm)" access="pub" jdoc="">
				<param name="obj"/>
				<param name="alg"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.getPowerset(Object[])" access="prot" jdoc="Returns an array of arrays, that is the powerset of a given set. @param set the given set @return the P(set)">
				<comm cntt="hopefully a faster way to do this:"/>
				<comm cntt="- enumerate all of the binary numbers from 0 to 2^n"/>
				<comm cntt="- each number denotes a subset of set, create that"/>
				<comm cntt="array and add it to the powerset"/>
				<comm cntt="System.out.println(&amp;quot;Generating powerset of size: &amp;quot; + numPowersets);"/>
				<comm cntt="System.out.println(&amp;quot;Array created&amp;quot;);"/>
				<param name="set"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.trimUnreachable()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.trimDeadStates()" access="prot" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.trim(java.util.ArrayList)" access="priv" jdoc="">
				<param name="newNodes"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.getBFSPathFrom(java.util.ArrayList, boolean)" access="priv" jdoc="">
				<param name="startNodes"/>
				<param name="forward"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.getNodeRangeMap(sandmark.program.Object[], java.util.ArrayList)" access="prot" jdoc="">
				<param name="allObjs"/>
				<param name="targetSet"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.hasProp(sandmark.Algorithm, sandmark.config.RequisiteProperty)" access="prot" jdoc="">
				<comm cntt="if a either has the property p, or is the alg for prop p"/>
				<param name="a"/>
				<param name="prop"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.intersect(DFA, DFA)" access="priv" jdoc="Takes two DFA&amp;apos;s and returns the DFA that is the intersection of the two languages.">
				<comm cntt="nested hashtable first is keyed on state from dfa1,"/>
				<comm cntt="which is mapped to a hashtable keyed on state from dfa2,"/>
				<comm cntt="which is mapped to the new state for s1xs2"/>
				<comm cntt="new set of states are d1.myStates x d2.myStates"/>
				<comm cntt="now fill in the edge table"/>
				<comm cntt="put an edge from state1xstate2 to dest1xdest2"/>
				<comm cntt="change edge weight here"/>
				<param name="d1"/>
				<param name="d2"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.getEdgeArray(java.util.Iterator)" access="priv" jdoc="">
				<param name="edges"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFA.getCharMap(DFAEdge[])" access="priv" jdoc="">
				<param name="edges"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.DFANode" intfc="n" abs="n" inn="n" sloc="25" jdoc="A DFANode represents a node in a deterministic finite automata which models the dependency relationships between program transformations and how they affect the order in which the transformations can be applied to different application objects. @author Kelly Heffner">
			<field name="myLabel" access="priv" jdoc=""/>
			<field name="myAccept" access="priv" jdoc=""/>
			<field name="tempLabel" access="pub" jdoc=""/>
			<field name="allLabels" access="pub" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.dfa.DFANode.DFANode(String, boolean)" access="pub" jdoc="Constructs a DFA Node with a given label (used for the DOT graph representation)">
				<param name="label"/>
				<param name="accept"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFANode.isAccept()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFANode.setAccept(boolean)" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFANode.getLabel()" access="pub" jdoc="">
				<comm cntt="&amp;quot;&amp;quot;+tempLabel;"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.DFAEdge" intfc="n" abs="n" inn="n" sloc="43" jdoc="">
			<field name="mySource" access="priv" jdoc=""/>
			<field name="myDest" access="priv" jdoc=""/>
			<field name="myAlg" access="priv" jdoc=""/>
			<field name="myTarget" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAEdge.DFAEdge(DFANode, DFANode, sandmark.Algorithm, sandmark.program.Object)" access="pub" jdoc="">
				<param name="source"/>
				<param name="dest"/>
				<param name="alg"/>
				<param name="targ"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAEdge.sourceNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAEdge.sinkNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAEdge.clone(Object, Object)" access="pub" jdoc="">
				<param name="source"/>
				<param name="Sink"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAEdge.getSource()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAEdge.getDestination()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAEdge.getAlg()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAEdge.getTarget()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAEdge.getCharKey()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.IntermediateDFA" intfc="y" abs="n" inn="n" sloc="14" jdoc="">
			<mth name="/:sandmark.wizard.modeling.dfa.IntermediateDFA.isNonLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="s_qp"/>
				<param name="r_t"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.IntermediateDFA.isLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="r_t"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.PostreqDFA" intfc="n" abs="n" inn="n" sloc="71" jdoc="PostreqDFA.java Created: Fri Sep 13 10:11:39 2002 @author Kelly T Heffner">
			<mth name="/:sandmark.wizard.modeling.dfa.PostreqDFA.PostreqDFA(java.util.HashMap, sandmark.Algorithm, sandmark.config.RequisiteProperty, sandmark.Algorithm[], sandmark.program.Object[])" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges before trim&amp;quot; + myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges after trim unreachable&amp;quot; + myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges after trim dead&amp;quot; + myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<param name="rangeMap"/>
				<param name="alg1"/>
				<param name="prop"/>
				<param name="allAlgs"/>
				<param name="allObjects"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.PostreqDFA.isNonLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<comm cntt="\lambda(q, (a,t)) = q^\prime if a = A and"/>
				<comm cntt="s(q) + r(t) = s(q^\prime)"/>
				<comm cntt="s(q) - r(t) = s(q&amp;apos;)"/>
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="s_qp"/>
				<param name="r_t"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.PostreqDFA.isLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<comm cntt="r(t) subset of s(q)"/>
				<comm cntt="r(t) intersect s(q) is empty"/>
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="r_t"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.DFAModel" intfc="n" abs="n" inn="n" sloc="155" jdoc="@author ash The DFAModel uses a deterministic finite automata to model the protection of the sandmark objects, with the start state being the unprotected program and each edge representing a Choice representing algorithms to run next. At each step of the Model tells the Strategy the Choices and the Strategy then runs a Choice (using a ChoiceRunner object).">
			<comm cntt="(non-Javadoc) @see sandmark.wizard.modeling.Strategy#getChoices()"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.modeling.Strategy#getVisualization()"/>
			<field name="mDFA" access="priv" jdoc=""/>
			<field name="mCurrentNode" access="priv" jdoc=""/>
			<field name="mCurrentChoices" access="priv" jdoc=""/>
			<field name="mTerminationChoice" access="priv" jdoc=""/>
			<field name="mListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.deletingObject(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="Deletes object from DFA.">
				<comm cntt="Delete all edges connected to the object to delete"/>
				<comm cntt="Tell listeners that model has changed."/>
				<param name="parent"/>
				<param name="child"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.addedObject(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="child"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.copiedObject(sandmark.program.Object, sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="orig"/>
				<param name="copy"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.init(sandmark.wizard.evaluation.Evaluator, sandmark.wizard.ChoiceRunner, sandmark.wizard.ObjectProvider, sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="Initializes DFAModel and registers listeners. Builds a DFA model based on the objects and algorithms from the ObjectProvider and AlgorithmProveder.">
				<param name="e"/>
				<param name="r"/>
				<param name="op"/>
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.registerMemberChangeListener(sandmark.wizard.ObjectProvider)" access="priv" jdoc="Registers listeners for objects in ObjectProvider">
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.addModelChangeListener(sandmark.wizard.modeling.ModelChangeListener)" access="pub" jdoc="Adds a model change listener to the list of listeners">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.removeModelChangeListener(sandmark.wizard.modeling.ModelChangeListener)" access="pub" jdoc="Removes a model change listener to the list of listeners">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.ranChoice(sandmark.wizard.modeling.Choice)" access="pub" jdoc="Called after choice has been run. Changes DFA current state to reflect model after choice has been run. Also fires a model changed for ModelChangeListeners.">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.isTerminationPoint()" access="pub" jdoc="Returns if model is at a termination point (i.e. current node in DFA is an accept state).">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.terminationChoices()" access="pub" jdoc="Returns a sandmark.util.SingleObjectIterator with the EdgeChoice that is a termination choice (i.e. leads to accept state in DFA). The termination choice is found with a BFS starting at the current node in the DFA.">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.getTerminationChoiceCount()" access="pub" jdoc="Returns 0 if the current node is an accept state or 1 otherwise.">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.getTerminationChoiceAt(int)" access="pub" jdoc="Returns the choice that leads to an accept state. Choice is found using BFS search starting at current node in DFA leading to accept state.">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.getTerminationChoicesAt(int, int)" access="pub" jdoc="Returns the choice that leads to an accept state in a Choice[] of length 1. Choice is found using BFS search starting at current node in DFA leading to accept state.">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.hasChoices()" access="pub" jdoc="Returns whether or not there are any choices from current node of DFA.">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.getChoiceCount()" access="pub" jdoc="Returns the number of choices from the current state in the DFA.">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.getChoiceAt(int)" access="pub" jdoc="Returns the ith choice from the choices reachable from current state in DFA.">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.getChoicesAt(int, int)" access="pub" jdoc="Returns a list of choice from the mth choice to the nth choice from the choices reachable from current state in DFA.">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.choices()" access="pub" jdoc="Returns Iterator of choices reachable from current state in DFA.">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.getObjects(sandmark.wizard.ObjectProvider)" access="prot" jdoc="Returns ArrayList of objects provided by ObjectProvider.">
				<param name="object"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.buildChoiceList()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.findTerminationChoice()" access="priv" jdoc="Finds termination choice reachable form current state in DFA. Uses a breadth first search, starting at current state, which can not be an accept state, to find the EdgeChoice that is the edge taken to the accept state.">
				<comm cntt="this only affects the case where state == mCurrentNode"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.getVisualization()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.getCurrentNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.filter(sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel.filter(sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
		<class name="/:sandmark.wizard.modeling.dfa.DFAModel$EdgeChoice" intfc="n" abs="n" inn="y" sloc="7" jdoc="">
			<field name="mEdge" access="pub" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel$EdgeChoice.EdgeChoice(DFAEdge)" access="pub" jdoc="">
				<param name="edge"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.DFAModel$ChoiceList" intfc="n" abs="n" inn="y" sloc="32" jdoc="">
			<field name="mEdgeIterator" access="priv" jdoc=""/>
			<field name="mChoices" access="priv" jdoc=""/>
			<field name="next" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel$ChoiceList.ChoiceList(java.util.Iterator)" access="pub" jdoc="">
				<param name="edgeIterator"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel$ChoiceList.getChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel$ChoiceList.getChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel$ChoiceList.getChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel$ChoiceList.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel$ChoiceList.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.DFAModel$ChoiceList.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.PostprohibitDFA" intfc="n" abs="n" inn="n" sloc="54" jdoc="">
			<mth name="/:sandmark.wizard.modeling.dfa.PostprohibitDFA.PostprohibitDFA(java.util.HashMap, sandmark.Algorithm, sandmark.config.RequisiteProperty, sandmark.Algorithm[], sandmark.program.Object[])" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges before trim&amp;quot; +"/>
				<comm cntt="myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges after trim unreachable&amp;quot; +"/>
				<comm cntt="myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges after trim dead&amp;quot; +"/>
				<comm cntt="myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<param name="rangeMap"/>
				<param name="alg1"/>
				<param name="prop"/>
				<param name="allAlgs"/>
				<param name="allObjects"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.PostprohibitDFA.isNonLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<comm cntt="\lambda(q, (a,t)) = q^\prime if a = A and"/>
				<comm cntt="s(q) + r(t) = s(q^\prime)"/>
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="s_qp"/>
				<param name="r_t"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.PostprohibitDFA.isLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<comm cntt="r(t) intersect s(q) is empty"/>
				<comm cntt="t is an element of s_q and a does not have property p"/>
				<comm cntt="(!a.equals(alg1))"/>
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="r_t"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.PrereqDFA" intfc="n" abs="n" inn="n" sloc="48" jdoc="PrereqDFA.java Created: Mon Sep 9 14:13:30 2002 @author Kelly T Heffner">
			<mth name="/:sandmark.wizard.modeling.dfa.PrereqDFA.PrereqDFA(java.util.HashMap, sandmark.Algorithm, sandmark.config.RequisiteProperty, sandmark.Algorithm[], sandmark.program.Object[])" access="pub" jdoc="Creates a DFA modeling alg1 prerequiring property prop. @param alg1 the algorithm with a prerequisite @param prop the property that alg1 prerequires @param allAlgs all of the obfuscation algorithms @param allObjects all of the application objects">
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges before trim&amp;quot; + myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges after trim unreachable&amp;quot; + myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges after trim dead&amp;quot; + myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<param name="rangeMap"/>
				<param name="alg1"/>
				<param name="prop"/>
				<param name="allAlgs"/>
				<param name="allObjects"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.PrereqDFA.isNonLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<comm cntt="\lambda(q, (a,t)) = q^\prime if a has the property p and"/>
				<comm cntt="s(q) + r(t) = s(q^\prime)"/>
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="s_qp"/>
				<param name="r_t"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.PrereqDFA.isLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<comm cntt="if a=alg1 and t \in s(q)"/>
				<comm cntt="or a has p and r(t) \subseteq s(q)"/>
				<comm cntt="or a \neq alg1 and does not have p"/>
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="r_t"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.dfa.PreprohibitDFA" intfc="n" abs="n" inn="n" sloc="59" jdoc="Preprohibit.java Created: Fri Sep 20 14:07:18 2002 @author Kelly T Heffner">
			<mth name="/:sandmark.wizard.modeling.dfa.PreprohibitDFA.PreprohibitDFA(java.util.HashMap, sandmark.Algorithm, sandmark.config.RequisiteProperty, sandmark.Algorithm[], sandmark.program.Object[])" access="pub" jdoc="">
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges before trim&amp;quot; + myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges after trim unreachable&amp;quot; + myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<comm cntt="System.out.println(&amp;quot;Number of states &amp; edges after trim dead&amp;quot; + myStates.length + &amp;quot;, &amp;quot; + myEdges.length);"/>
				<param name="rangeMap"/>
				<param name="alg1"/>
				<param name="prop"/>
				<param name="allAlgs"/>
				<param name="allObjects"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.PreprohibitDFA.isNonLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<comm cntt="\lambda(q, (a,t)) = q^\prime if a has property p and:"/>
				<comm cntt="s(q) + r(t) = s(q^\prime)"/>
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="s_qp"/>
				<param name="r_t"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.dfa.PreprohibitDFA.isLoopEdge(sandmark.Algorithm, sandmark.Algorithm, sandmark.program.Object, sandmark.config.RequisiteProperty, java.util.ArrayList, java.util.ArrayList)" access="pub" jdoc="">
				<comm cntt="r(t) subset of s(q)"/>
				<comm cntt="r(t) intersect s(q) is empty"/>
				<comm cntt="(!a.equals(alg1))"/>
				<param name="alg1"/>
				<param name="a"/>
				<param name="t"/>
				<param name="prop"/>
				<param name="s_q"/>
				<param name="r_t"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.modeling.lazydfa">
		<class name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel" intfc="n" abs="n" inn="n" sloc="109" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<comm cntt="(non-Javadoc) @see sandmark.wizard.modeling.Strategy#getChoices()"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.modeling.Strategy#update(sandmark.wizard.modeling.Choice)"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.modeling.Strategy#getVisualization()"/>
			<field name="mDFA" access="priv" jdoc=""/>
			<field name="mCurrentNode" access="priv" jdoc=""/>
			<field name="mListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.init(sandmark.wizard.evaluation.Evaluator, sandmark.wizard.ChoiceRunner, sandmark.wizard.ObjectProvider, sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="e"/>
				<param name="r"/>
				<param name="op"/>
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.registerMemberChangeListener(sandmark.wizard.ObjectProvider)" access="priv" jdoc="">
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.addedObject(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="child"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.copiedObject(sandmark.program.Object, sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="orig"/>
				<param name="child"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.deletingObject(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="child"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.isTerminationPoint()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.hasChoices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.getChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.getChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.getChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.getTerminationChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.getTerminationChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.getTerminationChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.choices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.terminationChoices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.addModelChangeListener(sandmark.wizard.modeling.ModelChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.removeModelChangeListener(sandmark.wizard.modeling.ModelChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.getObjects(sandmark.wizard.ObjectProvider)" access="prot" jdoc="">
				<param name="object"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.getChoices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.ranChoice(sandmark.wizard.modeling.Choice)" access="pub" jdoc="">
				<param name="choice"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.getVisualization()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.filter(sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel.filter(sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
		<class name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel$EdgeChoice" intfc="n" abs="n" inn="y" sloc="7" jdoc="">
			<field name="mEdge" access="pub" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel$EdgeChoice.EdgeChoice(LazyDFAEdge)" access="pub" jdoc="">
				<param name="edge"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel$DFAEdgeIterator" intfc="n" abs="n" inn="y" sloc="14" jdoc="">
			<field name="mEdges" access="priv" jdoc=""/>
			<field name="i" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel$DFAEdgeIterator.DFAEdgeIterator(LazyDFAEdge)" access="pub" jdoc="">
				<param name="edges"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel$DFAEdgeIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel$DFAEdgeIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAModel$DFAEdgeIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.wizard.modeling.lazydfa.LazyDFAEdge" intfc="n" abs="n" inn="n" sloc="39" jdoc="">
			<comm cntt="package"/>
			<comm cntt="package"/>
			<field name="myAlg" access="priv" jdoc=""/>
			<field name="myTarget" access="priv" jdoc=""/>
			<field name="mySource" access="priv" jdoc=""/>
			<field name="myLazilyComputedSink" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAEdge.LazyDFAEdge(sandmark.Algorithm, sandmark.program.Object, LazyDFANode)" access="pub" jdoc="">
				<param name="alg"/>
				<param name="target"/>
				<param name="source"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAEdge.getLazilyComputedSink()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAEdge.setLazilyComputedSink(LazyDFANode)" access="pub" jdoc="">
				<param name="sink"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAEdge.getSource()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAEdge.getAlg()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAEdge.getTarget()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFAEdge.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode" intfc="n" abs="n" inn="n" sloc="114" jdoc="">
			<comm cntt="package"/>
			<comm cntt="package"/>
			<comm cntt="package"/>
			<comm cntt="package"/>
			<comm cntt="package"/>
			<comm cntt="package"/>
			<field name="ranList" access="priv" jdoc=""/>
			<field name="prohibList" access="priv" jdoc=""/>
			<field name="reqList" access="priv" jdoc=""/>
			<field name="myEdges" access="priv" jdoc=""/>
			<field name="mRangeMap" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.LazyDFANode(java.util.HashMap)" access="pub" jdoc="Creates a LazyDFANode with empty mappings (ie a start state).">
				<param name="rangeMap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.LazyDFANode(java.util.HashMap, LazyDFANode)" access="pub" jdoc="Creates a LazyDFANode from another LazyDFANode, copying the entries in each list.">
				<comm cntt="package"/>
				<param name="rangeMap"/>
				<param name="toCopy"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.getOutgoingEdges(LazyDFA)" access="pub" jdoc="">
				<param name="dfa"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.getCurrentEdgeSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.setEdgeSet(LazyDFAEdge[])" access="pub" jdoc="">
				<param name="edges"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.ranListContains(sandmark.config.RequisiteProperty, sandmark.program.Object)" access="pub" jdoc="">
				<param name="p"/>
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.prohibListContains(sandmark.config.RequisiteProperty, sandmark.program.Object)" access="pub" jdoc="">
				<param name="p"/>
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.isAccept()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.addRan(sandmark.config.RequisiteProperty, sandmark.program.Object)" access="pub" jdoc="">
				<param name="p"/>
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.addProhib(sandmark.config.RequisiteProperty, sandmark.program.Object)" access="pub" jdoc="">
				<param name="p"/>
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.addReq(sandmark.config.RequisiteProperty, sandmark.program.Object)" access="pub" jdoc="">
				<param name="p"/>
				<param name="obj"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode.removeReq(sandmark.config.RequisiteProperty, sandmark.program.Object)" access="pub" jdoc="">
				<param name="p"/>
				<param name="obj"/>
			</mth>
		<class name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode$Tuple" intfc="n" abs="n" inn="y" sloc="16" jdoc="">
			<field name="prop" access="pub" jdoc=""/>
			<field name="targ" access="pub" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode$Tuple.Tuple(sandmark.config.RequisiteProperty, sandmark.program.Object)" access="pub" jdoc="">
				<param name="p"/>
				<param name="x"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFANode$Tuple.equals(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		</class>
		<class name="/:sandmark.wizard.modeling.lazydfa.LazyDFA" intfc="n" abs="n" inn="n" sloc="151" jdoc="">
			<comm cntt="package"/>
			<field name="myStartState" access="priv" jdoc=""/>
			<field name="myStates" access="priv" jdoc=""/>
			<field name="mAlgProvider" access="priv" jdoc=""/>
			<field name="mObjProvider" access="pub" jdoc=""/>
			<field name="myRangeMap" access="priv" jdoc=""/>
			<field name="DEBUG" access="pub" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFA.LazyDFA(sandmark.wizard.AlgorithmProvider, sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="ap"/>
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFA.getStartState()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFA.getDestination(LazyDFAEdge)" access="pub" jdoc="">
				<comm cntt="the destination node does not change since its based"/>
				<comm cntt="on properties"/>
				<comm cntt="otherwise, we need to compute it :D"/>
				<param name="edge"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFA.buildEdges(LazyDFANode)" access="pub" jdoc="">
				<comm cntt="degenerate case, we stripped out our edges to the accept state"/>
				<comm cntt="if(!source.isAccept() &amp;&amp; deadCount == tempEdgeList.size() &amp;&amp;"/>
				<comm cntt="source.getCurrentEdgeSet() == null){"/>
				<comm cntt="source.setEdgeSet((LazyDFAEdge[])"/>
				<comm cntt="tempEdgeList.toArray"/>
				<comm cntt="(new LazyDFAEdge[tempEdgeList.size()]));"/>
				<comm cntt="return;"/>
				<comm cntt="}"/>
				<param name="source"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFA.getEdgeList(LazyDFANode)" access="priv" jdoc="">
				<comm cntt="this edge list may already be computed - if so, we know that this"/>
				<comm cntt="edge set is a superset of the edges that can come out now"/>
				<comm cntt="(properties are still the same, only weights change) so skip"/>
				<comm cntt="the reevaluation of the edges"/>
				<comm cntt="now go through each element of the alphabet and determine if it"/>
				<comm cntt="can be on an edge out of this node. for all (T,x)"/>
				<comm cntt="if T has a prereq property p, that property must be fulfilled"/>
				<comm cntt="ie that x is in the ran list mapping keyed on p"/>
				<comm cntt="if T has a preprohibit property p, then that property must be"/>
				<comm cntt="unfulfilled ie that x is not in the ran list mapping keyed on p"/>
				<comm cntt="no postprohibitions have banned T, ie for all mutation properties"/>
				<comm cntt="p that T has, x cannot be in the prohibit list keyed on p"/>
				<comm cntt="dont forget to check the algorithm property for alg!"/>
				<comm cntt="otherwise good to go!"/>
				<param name="source"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFA.buildRangeMap(sandmark.wizard.ObjectProvider)" access="prot" jdoc="">
				<comm cntt="for each object o, if t is a subobject of o or vice versa"/>
				<comm cntt="then o is in r(t)."/>
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.lazydfa.LazyDFA.getRange(java.util.HashMap, sandmark.program.Object)" access="pub" jdoc="">
				<param name="rangeMap"/>
				<param name="obj"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.modeling.set">
		<class name="/:sandmark.wizard.modeling.set.PriorityQueue" intfc="n" abs="n" inn="n" sloc="65" jdoc="A small modification of a LinkedList to make a priority queue. The priorities are defined by the compareTo method (in Comparable), but duplicates are allowed. @author Kelly Heffner">
			<field name="myList" access="priv" jdoc=""/>
			<field name="myComparer" access="priv" jdoc=""/>
			<field name="myGraph" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.set.PriorityQueue.PriorityQueue(java.util.Comparator)" access="pub" jdoc="Constructs a PriorityQueue given the means to determine priority.">
				<param name="comp"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.PriorityQueue.add(Object)" access="pub" jdoc="Adds an object to the queue, behind the last object with priority greater than or equal to its priority. (things with lower priority numbers are closer to the back of the list) @param o the object to add - must be a type that the Comparator can compare">
				<comm cntt="System.out.println(&amp;quot;adding &amp;quot; + o + &amp;quot; &amp;quot; + ((sandmark.program.Object)o).getUserConstraints().obfuscationLevel);"/>
				<comm cntt="yes, I mean size(), not size()-1, I want the iterator after the last"/>
				<comm cntt="element"/>
				<comm cntt="System.out.println(myList);"/>
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.PriorityQueue.getVisualization()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.PriorityQueue.remove(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.PriorityQueue.dequeue()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.PriorityQueue.removeNode(Object)" access="priv" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.PriorityQueue.getFront()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.PriorityQueue.isEmpty()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.set.SetModel" intfc="n" abs="n" inn="n" sloc="251" jdoc="">
			<field name="objectToSet" access="priv" jdoc="sandmark.program.Object ==&amp;gt; sandmark.wizard.modeling.set.CandidateSet"/>
			<field name="mObjects" access="priv" jdoc=""/>
			<field name="mChoiceList" access="priv" jdoc=""/>
			<field name="mAlgProvider" access="priv" jdoc=""/>
			<field name="mListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.init(sandmark.wizard.evaluation.Evaluator, sandmark.wizard.ChoiceRunner, sandmark.wizard.ObjectProvider, sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="Initializes a SetModel given a list of algorithms and an application. allAlgs is a list of{@link sandmark.Algorithm} objects (which is cloned anywhere it would be stored). app is the root sandmark.program.Object for what objects you want to run algorithms on (normally a sandmark.program.Application.">
				<param name="e"/>
				<param name="r"/>
				<param name="op"/>
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.deletingObject(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="child"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.addedObject(sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="child"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.copiedObject(sandmark.program.Object, sandmark.program.Object, sandmark.program.Object)" access="pub" jdoc="">
				<param name="parent"/>
				<param name="orig"/>
				<param name="copy"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.registerMemberChangeListener(sandmark.wizard.ObjectProvider)" access="priv" jdoc="">
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.buildChoiceList()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.choices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.terminationChoices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.getVisualization()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.getChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.hasChoices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.getTerminationChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.getTerminationChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.getTerminationChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.isTerminationPoint()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.getChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.getChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.addModelChangeListener(sandmark.wizard.modeling.ModelChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.removeModelChangeListener(sandmark.wizard.modeling.ModelChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.ranChoice(sandmark.wizard.modeling.Choice)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.initObject(java.util.HashMap, sandmark.program.Object, sandmark.Algorithm)" access="priv" jdoc="">
				<param name="hints"/>
				<param name="obj"/>
				<param name="allAlgs"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.initObjects(java.util.HashMap, sandmark.wizard.ObjectProvider, sandmark.wizard.AlgorithmProvider)" access="priv" jdoc="">
				<param name="hints"/>
				<param name="op"/>
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.removeFromCandidateSet(java.util.Collection, sandmark.wizard.modeling.set.CandidateSet)" access="priv" jdoc="">
				<comm cntt="two rules for removal:"/>
				<comm cntt="i. once a property has been removed from the candidate pool"/>
				<comm cntt="all algorithms that have that property as a prereq"/>
				<comm cntt="(and the prereq has not been filled) must be removed"/>
				<comm cntt="as well"/>
				<comm cntt="ii. once a property has been removed from the candidate pool"/>
				<comm cntt="all algorithms that postreq that property must"/>
				<comm cntt="be removed as well"/>
				<comm cntt="get the list of properties that have been affected (the mutations"/>
				<comm cntt="for all the algorithms being removed)"/>
				<comm cntt="for each prop, see if it was the last of its kind"/>
				<comm cntt="check each algorithm to see if it has that property"/>
				<comm cntt="we just need one"/>
				<comm cntt="now we have extinct, the list of properties that have been"/>
				<comm cntt="completely removed from the list"/>
				<comm cntt="rule i. unfilled prereqs"/>
				<comm cntt="rule ii."/>
				<param name="toRemove"/>
				<param name="candidateSet"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.computeNewCandidates(sandmark.Algorithm, sandmark.program.Object)" access="pub" jdoc="Performs the dependency computations on the candidate sets necessary when an algorithm is run. @param candidate the algorithm run @param target the object that the target was run on">
				<comm cntt="adjust the main candidate pool accordingly"/>
				<comm cntt="add all properties for this algorithm to the run props list"/>
				<comm cntt="add all post requirements for this algorithm to the post"/>
				<comm cntt="req list"/>
				<comm cntt="add all post suggestions for this algorithm to the post"/>
				<comm cntt="suggest list"/>
				<comm cntt="once an allgorithm has been run, all algorithms that"/>
				<comm cntt="preprohibit it must be removed from the candidate pool"/>
				<comm cntt="the above line replaced:"/>
				<comm cntt="while(propItr.hasNext()){"/>
				<comm cntt="sandmark.config.RequisiteProperty prop ="/>
				<comm cntt="(sandmark.config.RequisiteProperty)propItr.next();"/>
				<comm cntt="java.util.ArrayList toRemove = getPreprohibitors(prop);"/>
				<comm cntt="removeFromAlgList(toRemove, candidatePool, runProperties);"/>
				<comm cntt="}"/>
				<comm cntt="once an algorithm has been run, all algorithms that it"/>
				<comm cntt="postprohibits must be removed from the candidate pool"/>
				<comm cntt="the above line replaced:"/>
				<comm cntt="sandmark.config.RequisiteProperty [] postProhibited ="/>
				<comm cntt="candidate.getPostprohibited();"/>
				<comm cntt="if(postProhibited != null){"/>
				<comm cntt="for(int p = 0; p &amp;lt; postProhibited.length; p++){"/>
				<comm cntt="java.util.ArrayList toRemove ="/>
				<comm cntt="getAlgsForProp(postProhibited[p]);"/>
				<comm cntt="removeFromAlgList(toRemove, candidatePool, runProperties);"/>
				<comm cntt="}"/>
				<comm cntt="}"/>
				<param name="candidate"/>
				<param name="target"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.getCurrentIterationPool(sandmark.wizard.modeling.set.CandidateSet)" access="pub" jdoc="Narrows the list of algorithm candidates for an object to a list of algorithms that can be run on this iteration. @param candidateSet the object to narrow the candidates for">
				<comm cntt="rules for determining what can be run in the current"/>
				<comm cntt="iteration:"/>
				<comm cntt="i. Anything that post-prohibits a req&amp;apos;d property"/>
				<comm cntt="should be removed from the candidate list"/>
				<comm cntt="ii. Anything with unfufilled prereq&amp;apos;s should be"/>
				<comm cntt="removed from the candidate list"/>
				<comm cntt="iii.For all req&amp;apos;d properties, remove any algorithm"/>
				<comm cntt="that would be pre-prohibited by all alg&amp;apos;s that"/>
				<comm cntt="fufill that property."/>
				<comm cntt="i. Anything that post-prohibits a req&amp;apos;d property"/>
				<comm cntt="should be removed from the candidate list"/>
				<comm cntt="ii. Anything with unfufilled prereq&amp;apos;s should be"/>
				<comm cntt="removed from the candidate list"/>
				<comm cntt="just need one"/>
				<comm cntt="iii.For all req&amp;apos;d properties, remove any algorithm"/>
				<comm cntt="that would be pre-prohibited by all alg&amp;apos;s that"/>
				<comm cntt="fufill that property."/>
				<comm cntt="for all req&amp;apos;d properties p, if t_p pre-prohibits x"/>
				<comm cntt="for all t_p, remove x"/>
				<comm cntt="take the set intersection of toRemove and"/>
				<comm cntt="the pre-prohibit list for this algorithm"/>
				<comm cntt="this will remove any algorithm that is not"/>
				<comm cntt="prehibited by the possible req filler"/>
				<comm cntt="iv. if all alg&amp;apos;s that fufill a required property"/>
				<comm cntt="are removed - backtrack?"/>
				<param name="candidateSet"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.filter(sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel.filter(sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
		<class name="/:sandmark.wizard.modeling.set.SetModel$ChoiceList" intfc="n" abs="n" inn="y" sloc="53" jdoc="">
			<field name="mObjectIterator" access="priv" jdoc=""/>
			<field name="mChoices" access="priv" jdoc=""/>
			<field name="mCurrentIterator" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$ChoiceList.ChoiceList()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$ChoiceList.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$ChoiceList.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$ChoiceList.remove()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$ChoiceList.setCurrentIterator()" access="priv" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$ChoiceList.getChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$ChoiceList.getChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$ChoiceList.getChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.set.SetModel$SetModelIterator" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<field name="myTarg" access="priv" jdoc=""/>
			<field name="algItr" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$SetModelIterator.SetModelIterator(sandmark.wizard.modeling.set.CandidateSet, sandmark.program.Object)" access="pub" jdoc="">
				<param name="algs"/>
				<param name="targ"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$SetModelIterator.hasNext()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$SetModelIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.SetModel$SetModelIterator.remove()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:sandmark.wizard.modeling.set.CandidateSet" intfc="n" abs="n" inn="n" sloc="85" jdoc="CandidateSet objects contain information about the algorithms run on a specific object.">
			<field name="unfilledPostreqs" access="priv" jdoc="List of sandmark.config.RequisiteProperty"/>
			<field name="unfilledPostsuggs" access="priv" jdoc="List of sandmark.config.RequisiteProperty"/>
			<field name="runProperties" access="priv" jdoc="List of sandmark.config.RequisiteProperty"/>
			<field name="runnableAlgorithms" access="priv" jdoc="List of sandmark.Algorithm -- algorithms not banned forever"/>
			<field name="myConst" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.CandidateSet(java.util.List, sandmark.program.UserObjectConstraints)" access="pub" jdoc="">
				<param name="targetAlgorithms"/>
				<param name="consts"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.clone()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.getConstraints()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.getAlgorithms()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.numAlgorithms()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.getAlgorithmList()" access="pub" jdoc="Returns a shallow copy of the algorithm list.">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.hasRun(sandmark.config.RequisiteProperty)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.run(sandmark.config.RequisiteProperty)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.run(java.util.Collection)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.addPostreqs(sandmark.config.RequisiteProperty)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.addPostreqs(sandmark.config.RequisiteProperty[])" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.addPostreqs(java.util.Collection)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.postReqs()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.removeAlgorithms(java.util.Collection)" access="pub" jdoc="">
				<param name="toRemove"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.addPostsuggs(sandmark.config.RequisiteProperty)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.addPostsuggs(sandmark.config.RequisiteProperty[])" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.addPostsuggs(java.util.Collection)" access="pub" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.set.CandidateSet.verify()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.modeling.wmdag">
		<class name="/:sandmark.wizard.modeling.wmdag.WMDAGNode" intfc="n" abs="n" inn="n" sloc="29" jdoc="A WMDAGNode represents a node in a directed acyclic graph which models the dependency relationships between program transformations and how they affect the order in which the transformations can be applied. @author Ginger Myles">
			<field name="myAlg" access="priv" jdoc=""/>
			<field name="myLevel" access="priv" jdoc=""/>
			<field name="currentPostprohibits" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAGNode.WMDAGNode(sandmark.Algorithm, int, java.util.ArrayList)" access="pub" jdoc="Constructs a WM DAG Node with a given label, level, and set of post prohibitions.">
				<param name="alg"/>
				<param name="level"/>
				<param name="postProhibits"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAGNode.getAlg()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAGNode.getLevel()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAGNode.getPostprohibits()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAGNode.equals(java.lang.Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAGNode.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.modeling.wmdag.WMDAG" intfc="n" abs="n" inn="n" sloc="247" jdoc="">
			<field name="myGraph" access="pub" jdoc=""/>
			<field name="seq" access="pub" jdoc=""/>
			<field name="curpos" access="pub" jdoc=""/>
			<field name="app" access="pub" jdoc=""/>
			<field name="mListeners" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.init(sandmark.wizard.evaluation.Evaluator, sandmark.wizard.ChoiceRunner, sandmark.wizard.ObjectProvider, sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="e"/>
				<param name="r"/>
				<param name="op"/>
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.constructGraph(sandmark.Algorithm)" access="priv" jdoc="">
				<param name="algs"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.findLongestPath(java.util.ArrayList, java.util.HashSet, int)" access="priv" jdoc="">
				<param name="path"/>
				<param name="postProhibs"/>
				<param name="longestPathLength"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.addModelChangeListener(sandmark.wizard.modeling.ModelChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.removeModelChangeListener(sandmark.wizard.modeling.ModelChangeListener)" access="pub" jdoc="">
				<param name="l"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.hasChoices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.isTerminationPoint()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.getChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.getTerminationChoiceCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.getChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.getTerminationChoiceAt(int)" access="pub" jdoc="">
				<param name="i"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.getChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.getTerminationChoicesAt(int, int)" access="pub" jdoc="">
				<param name="m"/>
				<param name="n"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.ranChoice(sandmark.wizard.modeling.Choice)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.choices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.terminationChoices()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.getVisualization()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.getSequence()" access="pub" jdoc="">
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.filter(sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.filter(sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.findLongestSeq(sandmark.Algorithm)" access="priv" jdoc="">
				<comm cntt="java.util.Iterator leaves = myGraph.reverseRoots();"/>
				<comm cntt="System.out.println(&amp;quot;num nodes in graph: &amp;quot; + myGraph.nodeCount());"/>
				<comm cntt="System.out.println(&amp;quot;leaf: &amp;quot; + leaf);"/>
				<param name="algs"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.construct(sandmark.wizard.modeling.wmdag.WMDAGNode, sandmark.Algorithm, java.util.Hashtable)" access="priv" jdoc="">
				<param name="currentNode"/>
				<param name="algs"/>
				<param name="postProhibs"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.findPossAlgs(java.util.ArrayList, sandmark.Algorithm)" access="priv" jdoc="">
				<param name="postProhibs"/>
				<param name="algs"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.buildPostprohibInfo(sandmark.Algorithm)" access="priv" jdoc="">
				<param name="algs"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.buildClassToAlgs(sandmark.Algorithm)" access="priv" jdoc="">
				<param name="algs"/>
			</mth>
			<mth name="/:sandmark.wizard.modeling.wmdag.WMDAG.buildPostprohibAlgs(sandmark.Algorithm)" access="priv" jdoc="">
				<param name="algs"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:sandmark.wizard.quickprotect">
		<class name="/:sandmark.wizard.quickprotect.QuickProtect" intfc="y" abs="n" inn="n" sloc="7" jdoc="Quick Protect algorithms are designed to be simple ways to combine sandmark.Algorithms for the Quick Protect pane on the GUI. @author Kelly Heffner @since 3.4.0 2003-12-10 Classes that extend QuickProtect contain a run method that takes an AlgorithmProvider and ObjectProvider. The AlgorithmProvider supplies the list of sandmark protection algorithms and the ObjectProvider supplies the sandmark objects to protect (i.e. applications, classes, methods).">
			<mth name="/:sandmark.wizard.quickprotect.QuickProtect.run(sandmark.wizard.AlgorithmProvider, sandmark.wizard.ObjectProvider)" access="pub" jdoc="The run method typically utilizes three classes. A Model, a Strategy and a Evaluator. The Strategy has a reference to a Model and a Evaluator. The Strategy then chooses how to protect the objects from the ObjectProvider using algorithms from the AlgorithmProvider and choosing from the choices provided by the model it is using. This is done in the step() method of the Strategy, which is typically called in the run method of the QuickProtect class. The Model also has a reference to the Evaluator.">
				<param name="ap"/>
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.QuickProtect.filter(sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.QuickProtect.filter(sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.QuickProtect.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.quickprotect.DefaultQuickProtect" intfc="n" abs="n" inn="n" sloc="20" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<mth name="/:sandmark.wizard.quickprotect.DefaultQuickProtect.run(sandmark.wizard.AlgorithmProvider, sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<comm cntt="new sandmark.wizard.modeling.dfa.DFAModel();"/>
				<param name="ap"/>
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.DefaultQuickProtect.filter(sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.DefaultQuickProtect.filter(sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.DefaultQuickProtect.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.quickprotect.CustomQuickProtect" intfc="n" abs="n" inn="n" sloc="36" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<comm cntt="(non-Javadoc) @see sandmark.wizard.quickprotect.QuickProtect#run(sandmark.wizard.AlgorithmProvider, sandmark.wizard.ObjectProvider)"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.quickprotect.QuickProtect#filter(sandmark.wizard.AlgorithmProvider)"/>
			<comm cntt="(non-Javadoc) @see sandmark.wizard.quickprotect.QuickProtect#filter(sandmark.wizard.ObjectProvider)"/>
			<field name="mModel" access="priv" jdoc=""/>
			<field name="mStrategy" access="priv" jdoc=""/>
			<field name="mEvaluator" access="priv" jdoc=""/>
			<field name="mRunner" access="priv" jdoc=""/>
			<mth name="/:sandmark.wizard.quickprotect.CustomQuickProtect.setModel(sandmark.wizard.modeling.Model)" access="pub" jdoc="">
				<param name="model"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.CustomQuickProtect.setDecision(sandmark.wizard.decision.Strategy)" access="pub" jdoc="">
				<param name="decision"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.CustomQuickProtect.setEvaluator(sandmark.wizard.evaluation.Evaluator)" access="pub" jdoc="">
				<param name="eval"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.CustomQuickProtect.run(AlgorithmProvider, ObjectProvider)" access="pub" jdoc="">
				<param name="ap"/>
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.CustomQuickProtect.filter(AlgorithmProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.CustomQuickProtect.filter(ObjectProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.CustomQuickProtect.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.quickprotect.StaticWatermark" intfc="n" abs="n" inn="n" sloc="26" jdoc="@author ash To change the template for this generated type comment go to Window - Preferences - Java - Code Generation - Code and Comments">
			<comm cntt="(non-Javadoc) @see sandmark.wizard.quickprotect.QuickProtect#run(sandmark.wizard.AlgorithmProvider, sandmark.wizard.ObjectProvider)"/>
			<mth name="/:sandmark.wizard.quickprotect.StaticWatermark.run(sandmark.wizard.AlgorithmProvider, sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="ap"/>
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.StaticWatermark.filter(sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.StaticWatermark.filter(sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.StaticWatermark.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:sandmark.wizard.quickprotect.AllAlgsOnce" intfc="n" abs="n" inn="n" sloc="20" jdoc="@author ash">
			<comm cntt="(non-Javadoc) @see sandmark.wizard.quickprotect.QuickProtect#run(sandmark.program.Application)"/>
			<mth name="/:sandmark.wizard.quickprotect.AllAlgsOnce.run(sandmark.wizard.AlgorithmProvider, sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<comm cntt="new sandmark.wizard.modeling.dfa.DFAModel();"/>
				<param name="ap"/>
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.AllAlgsOnce.filter(sandmark.wizard.AlgorithmProvider)" access="pub" jdoc="">
				<param name="ap"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.AllAlgsOnce.filter(sandmark.wizard.ObjectProvider)" access="pub" jdoc="">
				<param name="op"/>
			</mth>
			<mth name="/:sandmark.wizard.quickprotect.AllAlgsOnce.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
</java-project>